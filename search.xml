<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[算法-图]]></title>
      <url>/2018/01/11/%E7%AE%97%E6%B3%95-%E5%9B%BE/</url>
      <content type="html"><![CDATA[<p>大纲</p>
<ul>
<li>Graph<ul>
<li>Clone Graph</li>
<li>Topological Sorting 拓扑排序</li>
</ul>
</li>
<li>搜索<ul>
<li>DFS</li>
<li>BFS 两个场景<ul>
<li>图的遍历，Graph Traversal</li>
<li>简单图求最短路径，Shortest Path in Simple Graph</li>
</ul>
</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h1 id="例题1，Clone-Graph">1. 例题1，Clone Graph</h1><p>克隆图！</p>
<p><strong>方法——DFS</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> UndirectedGraphNode <span class="title">cloneGraph</span><span class="params">(UndirectedGraphNode node)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    Map&lt;UndirectedGraphNode, UndirectedGraphNode&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    <span class="keyword">return</span> dfs(node, map);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> UndirectedGraphNode <span class="title">dfs</span><span class="params">(UndirectedGraphNode node, Map&lt;UndirectedGraphNode, UndirectedGraphNode&gt; map)</span> </span>&#123;</div><div class="line">    <span class="comment">// 如果有这个节点了，就直接返回</span></div><div class="line">    <span class="keyword">if</span>(map.containsKey(node)) <span class="keyword">return</span> map.get(node);</div><div class="line">    <span class="comment">// 否则，克隆这个节点</span></div><div class="line">    UndirectedGraphNode newNode = <span class="keyword">new</span> UndirectedGraphNode(node.label);</div><div class="line">    map.put(node, newNode);</div><div class="line">    List&lt;UndirectedGraphNode&gt; newNeighbors = newNode.neighbors;</div><div class="line">    <span class="keyword">for</span>(UndirectedGraphNode neighbor: node.neighbors) &#123;</div><div class="line">        newNeighbors.add(dfs(neighbor, map));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> newNode;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>方法2——BFS + 队列</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> UndirectedGraphNode <span class="title">cloneGraph</span><span class="params">(UndirectedGraphNode startNode)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(startNode == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">  <span class="comment">//用BFS得到所有的节点</span></div><div class="line">  ArrayList&lt;UndirectedGraphNode&gt; nodes = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">  </div><div class="line">  <span class="comment">// 复制节点</span></div><div class="line">  HashMap&lt;UndirectedGraphNode, UndirectedGraphNode&gt; mapping = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">  <span class="keyword">for</span>(UndirectedGraphNode node : nodes)&#123;</div><div class="line">    UndirectedGraphNode newNode = <span class="keyword">new</span> UndirectedGraphNode(node.val);</div><div class="line">    mapping.put(node, newNode);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 复制邻居</span></div><div class="line">  <span class="keyword">for</span>(UndirectedGraphNode node: nodes)&#123;</div><div class="line">    UndirectedGraphNode newNode = mapping.get(node);</div><div class="line">    <span class="keyword">for</span>(UndirectedGraphNode neighbor : node.neighbors)&#123;</div><div class="line">      newNode.neighbors.add(mapping.get(neighbor));</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> mapping.get(startNode);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> ArrayList&lt;UndirectedGraphNode&gt; <span class="title">bfs</span><span class="params">(UndirectedGraphNode startNode)</span></span>&#123;</div><div class="line">  <span class="comment">// bfs  + 队列！ 宽度优先用队列！！！！</span></div><div class="line">  Queue&lt;UndirectedGraphNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">  <span class="comment">// 还需要判断这个点是否被访问过！</span></div><div class="line">  HashSet&lt;UndirectedGraphNode&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">  queue.offer(startNode);</div><div class="line">  visited.add(startNode);</div><div class="line">  <span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">    UndirectedGraphNode head = queue.poll();</div><div class="line">    <span class="keyword">for</span>(UndirectedGraphNode neibor : head.neighbors)&#123;</div><div class="line">      <span class="comment">// if 不正常的情况，就continue</span></div><div class="line">      <span class="keyword">if</span>(visited.contains(neibor))&#123; <span class="keyword">continue</span>; &#125;</div><div class="line">      queue.offer(neibor);</div><div class="line">      visited.add(neibor);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;UndirectedGraphNode&gt;(visited);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="拓扑排序">2. 拓扑排序</h1><p>下面这个图假设是一种上课顺序，比如上1之前必须上0。求这个图的任意一个拓扑排序（按照这个顺序上课则可以上完所有课）</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-11-13-57-33.png" alt=""> </p>
<p>拓扑排序很好的参考资料：<a href="http://www.stoimen.com/blog/2012/10/01/computer-algorithms-topological-sort-of-a-graph/" target="_blank" rel="external">Topological Sort of a Graph</a> </p>
<p>拓扑排序的思路如下：</p>
<ol>
<li>统计当前入度为0的点，加入队列</li>
<li>将当前所有入度为0的点删掉，并将这些点的下一点的连线删掉</li>
<li>重复1和2，直到所有的点都被删掉</li>
</ol>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-11-16-43-48.png" alt=""> </p>
<h2 id="例题2，Topological-Sorting">2.1. 例题2，Topological Sorting</h2><p>实现拓扑排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>. 把所有入度为<span class="number">0</span>的点放入队列</div><div class="line"><span class="number">2</span>. 将这个队列开始BFS</div><div class="line"><span class="number">3</span>. 每拿出一个点:例如拿出<span class="number">1</span>/<span class="number">2</span>/<span class="number">3</span>，每拿一个，要将每个的入度减一</div><div class="line"></div><div class="line"><span class="comment">// 队列维护当前入度为0的点</span></div><div class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;DirectedGraphNode&gt; <span class="title">topSort</span><span class="params">(ArrayList&lt;DirectedGraphNode&gt; graph)</span></span>&#123;</div><div class="line">	ArrayList&lt;DirectedGraphNode&gt; result = <span class="keyword">new</span> ArrayList&lt;DirectedGraphNode&gt;();</div><div class="line">	<span class="comment">// 统计所有点的入度</span></div><div class="line">	HashMap&lt;DirectedGraphNode, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    <span class="keyword">for</span>(DirectedGraphNode node : graph)&#123;</div><div class="line">      <span class="keyword">for</span>(DirectedGraphNode neibor : node.neighbors)&#123;</div><div class="line">          <span class="keyword">if</span>(map.containsKey(neibor)) map.put(neibor, map.get(neibor) + <span class="number">1</span>);</div><div class="line">          <span class="keyword">else</span> map.put(neibor, <span class="number">1</span>);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 将所有入度为0的节点入队列</span></div><div class="line">    Queue&lt;DirectedGraphNode&gt; q = <span class="keyword">new</span> LinkedList&lt;DirectedGraphNode&gt;();</div><div class="line">    <span class="keyword">for</span>(DirectedGraphNode node : graph)&#123;</div><div class="line">      <span class="keyword">if</span>(!map.containsKey(node))&#123;</div><div class="line">          q.offer(node);</div><div class="line">          result.add(node);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//BFS</span></div><div class="line">    <span class="keyword">while</span>(!q.isEmpty())&#123;</div><div class="line">    	DirectedGraphNode node = q.poll();</div><div class="line">        <span class="keyword">for</span>(DirectedGraphNode neibor : node.neighbors)&#123;</div><div class="line">        	q.put(neibor, q.get(neibor) - <span class="number">1</span>);</div><div class="line">            <span class="keyword">if</span>(q.get(neibor) == <span class="number">0</span>)&#123; <span class="comment">// 一旦入度为0，就放到队列里</span></div><div class="line">            	result.add(neibor);</div><div class="line">            	queue.offer(neibor);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Course-Schedule">2.2. Course Schedule</h2><p>给n门课，和课之间的先后上课顺序。求这些课能否正常依次上完。</p>
<p>思路：其实就是寻找课程之间有没有环路，如果存在环路，那就不行！</p>
<p><strong>方法1，BFS</strong></p>
<p>一个有向无环图，他一定至少有一个 入度为0的结点，一个出度为0的结点。所以，如果我们从入度入手：</p>
<ol>
<li>先把入度为0的结点删除了。</li>
<li>然后再把删除后重新成为入度为0的结点删除了。</li>
<li>依次循环，最后，<span style="border-bottom:2px dashed black;">如果，删除的结点个数不等于图总结点个数，那么，就是有环图<span style="border-bottom:2px dashed black;">。</span></span></li>
</ol>
<p>想用BFS，那就肯定得用队列了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] countIn(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)&#123;</div><div class="line">        <span class="keyword">int</span>[] Incounter = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] edges : prerequisites)&#123;</div><div class="line">            ++Incounter[edges[<span class="number">0</span>]];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> Incounter;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</div><div class="line">        <span class="comment">//拓扑排序</span></div><div class="line">        <span class="comment">// 统计每个点的入度</span></div><div class="line">        <span class="keyword">int</span>[] InCounter = countIn(numCourses, prerequisites);</div><div class="line">        <span class="comment">// 将所有入度为0的点放入队列</span></div><div class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i)&#123;</div><div class="line">            <span class="keyword">if</span>(InCounter[i] == <span class="number">0</span>) queue.add(i);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(queue.isEmpty()) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="comment">//BFS</span></div><div class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</div><div class="line">            <span class="keyword">int</span> preCourse = queue.poll();</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span>[] edage : prerequisites)&#123;</div><div class="line">                <span class="keyword">if</span>(edage[<span class="number">1</span>] != preCourse) <span class="keyword">continue</span>;</div><div class="line">                <span class="comment">// edage是从edage[1]出发到edage[0]的边</span></div><div class="line">                --InCounter[edage[<span class="number">0</span>]];</div><div class="line">                <span class="keyword">if</span>(InCounter[edage[<span class="number">0</span>]] == <span class="number">0</span>)&#123;</div><div class="line">                    queue.add(edage[<span class="number">0</span>]);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 如果当前节点还存在有入度的点，那么就不行</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : InCounter) <span class="keyword">if</span>(i != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>当然了，上面寻找每个点的邻居的方法太暴力了。我们再优化一下。 优化点：  </p>
<ol>
<li>记录每个点的邻居</li>
<li>在末尾记录入度为0的点的个数！</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</div><div class="line">       <span class="keyword">int</span> inCounter;</div><div class="line">       List&lt;Integer&gt; neighbors;</div><div class="line">       Node()&#123;</div><div class="line">           inCounter = <span class="number">0</span>;</div><div class="line">           neighbors = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">private</span> Node[] countIn(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)&#123;</div><div class="line">       Node[] Incounter = <span class="keyword">new</span> Node[numCourses];</div><div class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) Incounter[i] = <span class="keyword">new</span> Node();</div><div class="line">       <span class="keyword">for</span>(<span class="keyword">int</span>[] edges : prerequisites)&#123;</div><div class="line">           ++Incounter[edges[<span class="number">0</span>]].inCounter;</div><div class="line">           Incounter[edges[<span class="number">1</span>]].neighbors.add(edges[<span class="number">0</span>]);</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> Incounter;</div><div class="line">   &#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</div><div class="line">       <span class="comment">//拓扑排序</span></div><div class="line">       <span class="comment">// 统计每个点的入度</span></div><div class="line">       Node[] InCounter = countIn(numCourses, prerequisites);</div><div class="line"></div><div class="line">       <span class="comment">// 将所有入度为0的点放入队列</span></div><div class="line">       <span class="keyword">int</span> zeroIn = <span class="number">0</span>;</div><div class="line">       Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i)&#123;</div><div class="line">           <span class="keyword">if</span>(InCounter[i].inCounter == <span class="number">0</span>) &#123;queue.add(i); ++zeroIn;&#125;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span>(queue.isEmpty()) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">       <span class="comment">//BFS</span></div><div class="line">       </div><div class="line">       <span class="keyword">while</span> (!queue.isEmpty())&#123;</div><div class="line">           <span class="keyword">int</span> preCourse = queue.poll();</div><div class="line">           List&lt;Integer&gt; neibors = InCounter[preCourse].neighbors;</div><div class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> neibor : neibors) &#123;</div><div class="line">               --InCounter[neibor].inCounter;</div><div class="line">               <span class="keyword">if</span> (InCounter[neibor].inCounter == <span class="number">0</span>) &#123;</div><div class="line">                   queue.add(neibor);</div><div class="line">                   ++zeroIn;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// 如果当前节点还存在有入度的点，那么就不行</span></div><div class="line">       <span class="keyword">return</span> zeroIn == numCourses;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p><strong>方法2，DFS</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</div><div class="line">        List&lt;Integer&gt; neibors = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">private</span> Node[] shift(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)&#123;</div><div class="line">        Node[] nodes = <span class="keyword">new</span> Node[numCourses];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) nodes[i] = <span class="keyword">new</span> Node();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] edge : prerequisites)&#123;</div><div class="line">            nodes[edge[<span class="number">1</span>]].neibors.add(edge[<span class="number">0</span>]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> nodes;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">boolean</span>[] used;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(Node[] nodes, <span class="keyword">int</span> idx, <span class="keyword">boolean</span>[] visited)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(visited[idx]) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        visited[idx] = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> neibor : nodes[idx].neibors)&#123;</div><div class="line">            <span class="keyword">if</span>(!dfs(nodes, neibor, visited)) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        visited[idx] = <span class="keyword">false</span>;</div><div class="line">        used[idx] = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</div><div class="line">        <span class="comment">// 转化边邻关系、统计入度</span></div><div class="line"></div><div class="line">        Node[] nodes = shift(numCourses, prerequisites);</div><div class="line">        <span class="comment">// dfs</span></div><div class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</div><div class="line">        used = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</div><div class="line">        <span class="comment">// 从所有入度为0的节点开始</span></div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i)&#123;</div><div class="line">            <span class="keyword">if</span>(used[i]) <span class="keyword">continue</span>; <span class="comment">// 剪枝，否则会超时</span></div><div class="line">            <span class="keyword">if</span>(!dfs(nodes, i, visited)) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="Course-Schedule-II">2.3. Course Schedule II</h2><p>给一些课程关系。输出一个合理的上课顺序</p>
<p><strong>方法1，BFS</strong></p>
<p>一样的套路哇</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</div><div class="line">        List&lt;Integer&gt; neighbors = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> degrees;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">private</span> Node[] helper(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)&#123;</div><div class="line">        Node[] nodes = <span class="keyword">new</span> Node[numCourses];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) nodes[i] = <span class="keyword">new</span> Node();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] edge : prerequisites)&#123;</div><div class="line">            ++nodes[edge[<span class="number">0</span>]].degrees;</div><div class="line">            nodes[edge[<span class="number">1</span>]].neighbors.add(edge[<span class="number">0</span>]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> nodes;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites) &#123;</div><div class="line">        <span class="comment">// 确定每个节点的入度，和节点的邻居</span></div><div class="line">        Node[] nodes = helper(numCourses, prerequisites);</div><div class="line">        <span class="comment">// 将所有入度为0的节点入栈</span></div><div class="line">        Queue&lt;Integer&gt; zeroDegrees = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> zeroCounter = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span>[] order = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</div><div class="line">        <span class="keyword">int</span> filled = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i)&#123;</div><div class="line">            <span class="keyword">if</span>(nodes[i].degrees == <span class="number">0</span>)&#123;</div><div class="line">                order[filled++] = i;</div><div class="line">                zeroDegrees.add(i);</div><div class="line">                ++zeroCounter;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// bfs</span></div><div class="line">        <span class="keyword">while</span> (!zeroDegrees.isEmpty())&#123;</div><div class="line">            <span class="keyword">int</span> originIdx = zeroDegrees.poll();</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> destIdx : nodes[originIdx].neighbors)&#123;</div><div class="line">                --nodes[destIdx].degrees;</div><div class="line">                <span class="keyword">if</span>(nodes[destIdx].degrees == <span class="number">0</span>)&#123;</div><div class="line">                    order[filled++] = destIdx;</div><div class="line">                    zeroDegrees.add(destIdx);</div><div class="line">                    ++zeroCounter;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(zeroCounter == numCourses) <span class="keyword">return</span> order;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[算法-常见数据结构]]></title>
      <url>/2017/12/25/%E7%AE%97%E6%B3%95-%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<p><strong>大纲</strong></p>
<ul>
<li>线性<ul>
<li>队列 - Queue</li>
<li>栈 - Stack</li>
<li>哈希 - Hash</li>
</ul>
</li>
<li>树形<ul>
<li>堆/优先队列 - Heap / Priority Queue</li>
<li>TreeMap</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h1 id="Hash相关问题">1. Hash相关问题</h1><h2 id="Insert-Delete-GetRandom-O-1">1.1. Insert Delete GetRandom O(1)</h2><p>设计一个数据结构，支持插入、删除和随机取的复杂度都是$O(1)$</p>
<p>注意一些技巧，特别是remove时的技巧。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">HashMap&lt;Integer, Integer&gt; set;</div><div class="line">    ArrayList&lt;Integer&gt; nums;</div><div class="line">    <span class="comment">/**set的key是插入的数字，value是在nums中的idx**/</span></div><div class="line">    java.util.Random rand = <span class="keyword">new</span> java.util.Random();</div><div class="line">    <span class="comment">/** Initialize your data structure here. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RandomizedSet</span><span class="params">()</span> </span>&#123;</div><div class="line">        set = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        nums = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Inserts a value to the set. Returns true if the set did not already contain the specified element. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(set.containsKey(val)) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        set.put(val,nums.size());</div><div class="line">        nums.add(val);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Removes a value from the set. Returns true if the set contained the specified element. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(set.containsKey(val))&#123;</div><div class="line">            <span class="comment">// 为了保证序号正确，先让val与nums中的最后一个交换</span></div><div class="line">            <span class="keyword">int</span> idx = set.get(val);</div><div class="line">            <span class="keyword">int</span> lastVal = nums.get(nums.size() - <span class="number">1</span>);</div><div class="line">            set.replace(lastVal, idx);</div><div class="line">            nums.set(idx,lastVal);</div><div class="line">            set.remove(val);</div><div class="line">            nums.remove(nums.size() - <span class="number">1</span>);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;<span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Get a random element from the set. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//System.out.println(rand.nextInt(nums.size()));</span></div><div class="line">        <span class="keyword">return</span> nums.get(rand.nextInt(nums.size())); <span class="comment">// 注意这个用法</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="Insert-Delete-GetRandom-O-1-Duplicates-allowed">1.2. Insert Delete GetRandom O(1) - Duplicates allowed</h2><p>如果允许重复元素出现，那么怎么实现？</p>
<p>那就把idx变成idx列表！</p>
<p>（为什么不能直接计数呢？因为如果只计数的话，随机输出时，元素比例就不符合原来的比例了）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">HashMap&lt;Integer, ArrayList&lt;Integer&gt;&gt; set;</div><div class="line">ArrayList&lt;Integer&gt; nums;</div><div class="line">Random rand = <span class="keyword">new</span> Random();</div><div class="line"><span class="comment">/**key : 就是插入的值</span></div><div class="line"> * value :在nums中的idx **/</div><div class="line"><span class="comment">/** Initialize your data structure here. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">RandomizedCollection</span><span class="params">()</span> </span>&#123;</div><div class="line">    set = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    nums = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(set.containsKey(val))&#123;</div><div class="line">        set.get(val).add(nums.size());</div><div class="line">        nums.add(val);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        ArrayList idxs = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        idxs.add(nums.size());</div><div class="line">        set.put(val,idxs);</div><div class="line">        nums.add(val);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Removes a value from the collection. Returns true if the collection contained the specified element. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(set.containsKey(val))&#123;</div><div class="line">        <span class="comment">// 待删除元素的idxs列表</span></div><div class="line">        ArrayList&lt;Integer&gt; idxs = set.get(val);</div><div class="line">        <span class="comment">// idx = idxs.get(0)</span></div><div class="line">        <span class="comment">// 将nums最后一个挪过来</span></div><div class="line">        <span class="keyword">if</span>(idxs.get(<span class="number">0</span>) &lt; nums.size() - <span class="number">1</span>) &#123;</div><div class="line">            nums.set(idxs.get(<span class="number">0</span>), nums.get(nums.size() - <span class="number">1</span>));</div><div class="line">            <span class="comment">// 更新set中挪过来的idx</span></div><div class="line">            ArrayList&lt;Integer&gt; lastIdxs = set.get(nums.get(idxs.get(<span class="number">0</span>)));</div><div class="line">            <span class="keyword">int</span> deleted = <span class="number">0</span>;</div><div class="line">            <span class="keyword">while</span> (deleted &lt; lastIdxs.size()) &#123;</div><div class="line">                <span class="keyword">if</span> (lastIdxs.get(deleted) == nums.size() - <span class="number">1</span>) &#123;</div><div class="line">                    lastIdxs.remove(deleted);</div><div class="line">                &#125;</div><div class="line">                deleted += <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">            lastIdxs.add(idxs.get(<span class="number">0</span>));</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 删除</span></div><div class="line">        nums.remove(nums.size() - <span class="number">1</span>);</div><div class="line">        <span class="keyword">if</span>(idxs.size() == <span class="number">1</span>)&#123;set.remove(val);&#125;</div><div class="line">        <span class="keyword">else</span>&#123;idxs.remove(<span class="number">0</span>);&#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Get a random element from the collection. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(nums.size() == <span class="number">0</span>) <span class="keyword">return</span>  -<span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> nums.get(rand.nextInt(nums.size()));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="栈相关">2. 栈相关</h1><h2 id="Valid-Parentheses">2.1. Valid Parentheses</h2><p>给一个字符串，其中元素为<code>{},(),[]</code>。判断括号是否合法</p>
<p>思路：用栈！！！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(<span class="keyword">char</span> a, <span class="keyword">char</span> b)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> (a == <span class="string">'&#123;'</span> &amp;&amp; b == <span class="string">'&#125;'</span>) ||</div><div class="line">            (a == <span class="string">'['</span> &amp;&amp; b == <span class="string">']'</span>) ||</div><div class="line">            (a == <span class="string">'('</span> &amp;&amp; b == <span class="string">')'</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(s.length() &lt;= <span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i)&#123;</div><div class="line">        <span class="keyword">if</span>(s.charAt(i) == <span class="string">'['</span> || s.charAt(i) == <span class="string">'&#123;'</span> || s.charAt(i) == <span class="string">'('</span>)&#123;</div><div class="line">            stack.push(s.charAt(i));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">if</span>(stack.empty() || !isMatch(stack.pop(),s.charAt(i)))</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Longest-Valid-Parentheses">2.2. Longest Valid Parentheses</h2><p>给一个字符串，其中元素为<code>()</code> 。判断最长合法括号</p>
<p>思路：用栈。一开始想的太简单，但没那么简单。难点在于如何寻找合法串的开始。例如<code>(()</code> 这种，应该怎样记录呢？</p>
<p>但事实上应该换一个角度：</p>
<ol>
<li><code>stack</code>里面装的一直是“还没配好对的那些可怜的括号的index”</li>
<li>是<code>&#39;(‘</code>的时候<code>push</code></li>
<li>是<code>’)’</code>的时候，说明可能配对了；看<code>stack top</code>是不是左括号，不是的话，<code>push</code>当前的<code>’)’</code>（算是一种对之前<code>push</code>进去的所有东西的清除）</li>
<li>是的话，<code>pop</code>那个配对的左括号，然后<code>update res</code>：<code>i</code>和<code>top</code>的（最后一个配不成对的）<code>index</code>相减，就是<code>i</code>属于的这一段的当前最长。如果一<code>pop</code>就整个栈空了，说明前面全配好对了，那<code>res</code>就是最大<code>=i+1</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">    <span class="keyword">int</span> max = <span class="number">0</span>, curr = <span class="number">0</span>;</div><div class="line">    <span class="keyword">char</span>[] arr = s.toCharArray();</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; ++i)&#123;</div><div class="line">        <span class="keyword">if</span>(arr[i] == <span class="string">')'</span> &amp;&amp; !stack.empty() &amp;&amp; arr[stack.peek()] == <span class="string">'('</span>)&#123;</div><div class="line">            <span class="comment">// arr[i]与arr[stack.peek()]匹配成了一对括号</span></div><div class="line">            stack.pop();</div><div class="line">            <span class="keyword">if</span>(stack.empty())&#123;</div><div class="line">                max = i + <span class="number">1</span>;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                max = Math.max(max, i - stack.peek());</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            stack.push(i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> max;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[算法-回溯法]]></title>
      <url>/2017/12/21/%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%BA%AF%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>  回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。</p>
<p>   回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。</p>
<a id="more"></a>
<h1 id="八皇后问题">1. 八皇后问题</h1><p>在棋盘上放置8个皇后，使得它们互不攻击，此时每个皇后的攻击范围为同行同列和同<br>对角线，要求找出所有解，如图7-4所示。 </p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-21-22-15-31.png" alt=""> </p>
<p>暴力思路：</p>
<p>64选8，有$C_{64}^8$种方案。</p>
<p>优化：</p>
<p>因为恰好每行每列各放置一个皇后，那就是一个全排列问题。而0~7的排列一共只有$8! = 40320$个。如果枚举的话，也没多少个。</p>
<p>为了方便分析，我们先把问题简化为4皇后问题。</p>
<p>假如皇后现在的位置是<code>（0,2.*,*)</code></p>
<p>即：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> * * *</div><div class="line">* * <span class="number">1</span> *</div><div class="line">* * * *</div><div class="line">* * * *</div></pre></td></tr></table></figure>
<p>此时后面两个皇后无论放哪里，都会和前两行的皇后冲突。此时，递归函数将不再递归调用它自身，而是返回上一层。这个就叫回溯。</p>
<p>我们画出四皇后的解答树（每个元素代表第i个皇后放在第j列）：</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-22-18-16-28.png" alt=""> </p>
<p>因此，八皇后问题可以这么写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> counter = <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span>[] C = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>]; <span class="comment">// C[i]表示第i行的皇后放在了C[i]列</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> cur)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(cur == n)&#123; <span class="comment">// n个皇后都不冲突</span></div><div class="line">    ++counter;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</div><div class="line">    <span class="keyword">int</span> ok = <span class="number">1</span>;</div><div class="line">    <span class="comment">// 尝试把第cur行的皇后放在第i列</span></div><div class="line">    C[cur] = i;</div><div class="line">    <span class="comment">// 检查是否和前面皇后冲突</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cur; ++j)&#123;</div><div class="line">      <span class="keyword">if</span>(C[cur] == C[j]||</div><div class="line">        cur - C[cur] == j - C[j]||</div><div class="line">         CUR + C[cur] == j + C[j])&#123;</div><div class="line">        ok = <span class="number">0</span>;</div><div class="line">        <span class="keyword">break</span>; <span class="comment">// 如果冲突，就不再继续搜索</span></div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span>(ok) search(cur + <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>进一步优化：</p>
<p>骚操作：用二维数组<code>vis[3][]</code>判断当前尝试的皇后是否与其他皇后冲突。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">先看看这个：</div><div class="line"></div><div class="line">  <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></div><div class="line"><span class="number">0</span> <span class="number">1</span> * * *</div><div class="line"><span class="number">1</span> * <span class="number">1</span> * *</div><div class="line"><span class="number">2</span> * * <span class="number">1</span> *</div><div class="line"><span class="number">3</span> * * * <span class="number">1</span></div><div class="line"></div><div class="line">我们看看标<span class="number">1</span>的对角线上的i和j有什么关系：</div><div class="line"></div><div class="line">这个对角线i == j</div><div class="line"></div><div class="line">我们看下一个对角线：</div><div class="line"></div><div class="line"></div><div class="line">  <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></div><div class="line"><span class="number">0</span> * <span class="number">1</span> * *</div><div class="line"><span class="number">1</span> * * <span class="number">1</span> *</div><div class="line"><span class="number">2</span> * * * <span class="number">1</span></div><div class="line"><span class="number">3</span> * * * *</div><div class="line"></div><div class="line">这个对角线 i == j + <span class="number">1</span></div><div class="line">  </div><div class="line">其实，这个方向的对角线，只要在一个对角线上，那么 i - j 就是一个定值</div><div class="line"></div><div class="line">那么：</div><div class="line"></div><div class="line">vis[<span class="number">0</span>][i] :第i列是否已有皇后；</div><div class="line">vis[<span class="number">1</span>][j + i] : 第j行i列对应的对角线是否已经有皇后（因为同一个对角线上的i + j都是相等的）</div><div class="line">vis[<span class="number">2</span>][j - i + n] ： 第j行i列对角线是否已经有皇后 (同一对角线上 j - i 是一个定值 ， 但可能出现负数，因此加一个n)</div><div class="line">  </div><div class="line"><span class="keyword">boolean</span>[][] vis ;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> cur)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(cur == n)&#123; <span class="comment">// n个皇后都不冲突</span></div><div class="line">    ++counter;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</div><div class="line">    <span class="comment">// 尝试把第cur行的皇后放在第i列</span></div><div class="line">    C[cur] = i;</div><div class="line">    <span class="comment">// 检查是否和前面皇后冲突</span></div><div class="line">    <span class="keyword">if</span>(!vis[<span class="number">0</span>][i] &amp;&amp; !vis[<span class="number">1</span>][cur + i] &amp;&amp; !vis[<span class="number">2</span>][cur - i + n])&#123;</div><div class="line">      C[cur] = i;</div><div class="line">      vis[<span class="number">0</span>][i] = vis[<span class="number">1</span>][cur + i] = vis[<span class="number">2</span>][cur - i + n] = <span class="keyword">true</span>;</div><div class="line">      search(cur + <span class="number">1</span>);</div><div class="line">      vis[<span class="number">0</span>][i] = vis[<span class="number">1</span>][cur + i] = vis[<span class="number">2</span>][cur - i + n] = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="N-Queens">1.1. N-Queens</h2><p>N皇后问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">    <span class="keyword">boolean</span>[][] vis ;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * vis[0][i] : 第i列有没有皇后</div><div class="line">     * vis[1][i + j] : 第 i+j 对角线有无皇后</div><div class="line">     * vis[2][i - j + n] : 第 i-j 对角线有无皇后**/</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> row, List&lt;String&gt; pos, <span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(row == n)&#123;</div><div class="line">            List&lt;String&gt; one = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">            one.addAll(pos);</div><div class="line">            result.add(one);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 尝试将第row行的皇后放入第col列</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; ++ col)&#123;</div><div class="line">            <span class="keyword">if</span>(!vis[<span class="number">0</span>][col] &amp;&amp; !vis[<span class="number">1</span>][col + row] &amp;&amp; !vis[<span class="number">2</span>][col - row + n])&#123;</div><div class="line">                <span class="comment">// 构建第row行的皇后阵列</span></div><div class="line">                StringBuilder strBu = <span class="keyword">new</span> StringBuilder();</div><div class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">                <span class="keyword">while</span> (i &lt; n)&#123;</div><div class="line">                    <span class="keyword">if</span>(i == col) &#123;</div><div class="line">                        strBu.append(<span class="string">"Q"</span>);</div><div class="line">                    &#125;<span class="keyword">else</span>&#123;</div><div class="line">                        strBu.append(<span class="string">"."</span>);</div><div class="line">                    &#125;</div><div class="line">                    ++i;</div><div class="line">                &#125;</div><div class="line">                pos.add(strBu.toString());</div><div class="line">                vis[<span class="number">0</span>][col] = <span class="keyword">true</span>;</div><div class="line">                vis[<span class="number">1</span>][col + row] = <span class="keyword">true</span>;</div><div class="line">                vis[<span class="number">2</span>][col - row + n] = <span class="keyword">true</span>;</div><div class="line">                helper(row + <span class="number">1</span>, pos, n);</div><div class="line">                pos.remove(pos.size() - <span class="number">1</span>);</div><div class="line">                vis[<span class="number">0</span>][col] = <span class="keyword">false</span>;</div><div class="line">                vis[<span class="number">1</span>][col + row] = <span class="keyword">false</span>;</div><div class="line">                vis[<span class="number">2</span>][col - row + n] = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</div><div class="line">        vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">3</span>][<span class="number">2</span>*n];</div><div class="line">        helper(<span class="number">0</span>,<span class="keyword">new</span> LinkedList&lt;&gt;(), n);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="N-Queens-II">1.2. N-Queens II</h2><p>求N皇后的所有的可能排列数目</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">boolean</span>[][] vis ;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * vis[0][i] : 第i列有没有皇后</div><div class="line">     * vis[1][i + j] : 第 i+j 对角线有无皇后</div><div class="line">     * vis[2][i - j + n] : 第 i-j 对角线有无皇后**/</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(row == n)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> counter = <span class="number">0</span>;</div><div class="line">        <span class="comment">// 尝试将第row行的皇后放入第col列</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; ++ col)&#123;</div><div class="line">            <span class="keyword">if</span>(!vis[<span class="number">0</span>][col] &amp;&amp; !vis[<span class="number">1</span>][col + row] &amp;&amp; !vis[<span class="number">2</span>][col - row + n])&#123;</div><div class="line">                vis[<span class="number">0</span>][col] = <span class="keyword">true</span>;</div><div class="line">                vis[<span class="number">1</span>][col + row] = <span class="keyword">true</span>;</div><div class="line">                vis[<span class="number">2</span>][col - row + n] = <span class="keyword">true</span>;</div><div class="line">                counter += helper(row + <span class="number">1</span>, n);</div><div class="line">                vis[<span class="number">0</span>][col] = <span class="keyword">false</span>;</div><div class="line">                vis[<span class="number">1</span>][col + row] = <span class="keyword">false</span>;</div><div class="line">                vis[<span class="number">2</span>][col - row + n] = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> counter;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">3</span>][<span class="number">2</span>*n];</div><div class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>, n);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h1 id="全排列问题">2. 全排列问题</h1><p>全排列问题主要有以下几个知识点：</p>
<ul>
<li>暴力枚举、回溯</li>
<li>Heap’s Algorithm</li>
<li>固定-交换法</li>
<li>字典法</li>
<li>求第k个排列，计算法</li>
</ul>
<h2 id="Permutations">2.1. Permutations</h2><p>给一个无重数组，生成这个数组数字的全排列。</p>
<p><strong>暴力循环法</strong></p>
<p>一般最先想到的方法是暴力循环法，即对于每一位，遍历集合中可能的元素，如果在这一位之前出现过了该元素，跳过该元素。例如对于<code>123</code>，第一位可以是 1 或 2 或 3 。当第一位为 1时，第二位再遍历集合，发现 1 不行，因为前面已经出现 1 了，而 2 和 3 可以。当第二位为 2 时 ， 再遍历集合，发现 1 和 2都不行，3 可以。可以用递归或循环来实现，但是复杂度为 $O(n^n)$ 。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// 典型的回溯方法</span></div><div class="line"></div><div class="line">List&lt;List&lt;Integer&gt;&gt; result;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">boolean</span>[] used, List&lt;Integer&gt; preArr)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(preArr.size() == nums.length)&#123;</div><div class="line">            List&lt;Integer&gt; one = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">            one.addAll(preArr);</div><div class="line">            result.add(one);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i)&#123;</div><div class="line">           <span class="comment">// 如果nums[i]被用过了，就跳过</span></div><div class="line">            <span class="keyword">if</span>(used[i]) <span class="keyword">continue</span>;</div><div class="line">            <span class="comment">// 否则，加入到当前序列里</span></div><div class="line">            preArr.add(nums[i]);</div><div class="line">            used[i] = <span class="keyword">true</span>;</div><div class="line">            helper(nums,used,preArr);</div><div class="line">            preArr.remove(preArr.size() - <span class="number">1</span>);</div><div class="line">            used[i] = <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</div><div class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</div><div class="line">        result = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        helper(nums,used,<span class="keyword">new</span> LinkedList&lt;&gt;());</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>有没有更优雅的解法呢。</p>
<p>当然是有骚操作的。</p>
<p><strong>Heap’s Algorithm</strong></p>
<p><code>Heap&#39;s Algorithm</code> 是B. R. Heap在1963提出的一种全排列的算法。核心思想就是每次保持<code>n - 2</code>个元素不动，对剩余的两个元素进行交换。什么意思呢？我们以<code>[a,b,c,d]</code>这四个元素的全排列为例，首先，我们将元素<code>d</code>作为固定元素拿出来，对<code>[a,b,c]</code>进行全排列，而对<code>[a,b,c]</code>进行全排列的过程中，我们又将<code>c</code>作为固定元素拿出来，对元素<code>a</code>、<code>b</code>进行交换，这样就得到全排列的两种可能。同理，下一步是我们将<code>b</code>作为固定元素拿出来，对<code>a</code>、<code>c</code>进行交换。依次类推。这张图详细地展示了这一种算法思想，<a href="https://upload.wikimedia.org/wikipedia/commons/1/19/Heap_algorithm_with_4_elements.svg" target="_blank" rel="external">请参考</a>。</p>
<p>可能有点不好理解。我们先看一下伪代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 保持第n个元素不动，对前n-1个元素进行全排列</span></div><div class="line">generate(<span class="keyword">int</span> n, <span class="keyword">int</span>[] A)&#123;</div><div class="line">  <span class="keyword">if</span> n == <span class="number">1</span> <span class="function">then</span></div><div class="line">    <span class="title">output</span><span class="params">(A)</span></div><div class="line">  <span class="keyword">else</span></div><div class="line">    <span class="title">for</span><span class="params">(i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i)</span>&#123;</div><div class="line">      generate(n-<span class="number">1</span>, A)</div><div class="line">        <span class="keyword">if</span>(n%<span class="number">2</span> == <span class="number">0</span>)&#123; <span class="comment">// 如果n是偶数，交换第i个和最后一个元素</span></div><div class="line">          swap(A[i], A[n-<span class="number">1</span>])</div><div class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">// 如果n是奇数，交换第1个和最后一个元素；</span></div><div class="line">          swap(A[<span class="number">0</span>], A[n-<span class="number">1</span>])</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    generate(n-<span class="number">1</span>, A)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然而并不能看懂在干啥。</p>
<p><strong>固定-交换法</strong></p>
<p>还有一种思路，这个更好理解一丢丢：</p>
<p>n个数的全排列，一共有$n!$种情况. （n个位置，第一个位置有n种，当第一个位置固定下来之后，第二个位置有n-1种情况…）</p>
<p>全排列的过程：</p>
<ul>
<li>选择第一个字符</li>
<li>获得第一个字符固定下来之后的所有的全排列<ul>
<li>选择第二个字符</li>
<li>获得第一+ 二个字符固定下来之后的所有的全排列</li>
</ul>
</li>
</ul>
<p>从这个过程可见，这是一个递归的过程。</p>
<p>所以这种方式也是通过固定一个元素，进行剩余元素的交换。缺点是，每次交换过后需要再次交换以回到上一层数组。</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-23-21-01-06.png" alt=""> </p>
<p>代码较为简单些：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> temp = nums[i];</div><div class="line">        nums[i] = nums[j];</div><div class="line">        nums[j] = temp;</div><div class="line">    &#125;</div><div class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> fixed)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(fixed == nums.length)&#123;</div><div class="line">            List&lt;Integer&gt; one = <span class="keyword">new</span> ArrayList&lt;&gt;(nums.length);</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> e : nums)&#123;one.add(e);&#125;</div><div class="line">            result.add(one);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 将fixed依次与后面的元素交换</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = fixed; i &lt; nums.length; ++i)&#123;</div><div class="line">            swap(nums, i, fixed);</div><div class="line">            helper(nums, fixed + <span class="number">1</span>);</div><div class="line">            swap(nums, i, fixed);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</div><div class="line">        helper(nums,<span class="number">0</span>);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="Permutations-II">2.2. Permutations II</h2><p> follow up – 如果输入数组有重复元素，输出全排列</p>
<p><strong>暴力求解</strong></p>
<p>由于这道题有重复元素，因此需要注意重复元素。</p>
<p>最暴力的方式就是先排序，然后当这个元素与上一次循环的元素一样时，跳过</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">    <span class="keyword">boolean</span>[] used;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums,List&lt;Integer&gt; one, <span class="keyword">int</span> i)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(i == nums.length)&#123;</div><div class="line">            List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;(nums.length);</div><div class="line">            res.addAll(one);</div><div class="line">            result.add(res);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> last = Integer.MIN_VALUE;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; ++j)&#123;</div><div class="line">            <span class="keyword">if</span>(used[j] || (j &gt; <span class="number">0</span> &amp;&amp; nums[j] == last)) <span class="keyword">continue</span>; <span class="comment">// 注意这里不可以用nums[j] == nums[j - 1] ！！！</span></div><div class="line">            one.add(nums[j]);</div><div class="line">            used[j] = <span class="keyword">true</span>;</div><div class="line">            helper(nums,one,i + <span class="number">1</span>);</div><div class="line">            used[j] = <span class="keyword">false</span>;</div><div class="line">            one.remove(one.size() - <span class="number">1</span>);</div><div class="line">            last = nums[j];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</div><div class="line">        used = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</div><div class="line">        Arrays.sort(nums);</div><div class="line">        helper(nums,<span class="keyword">new</span> ArrayList&lt;Integer&gt;(nums.length), <span class="number">0</span>);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>固定-交换法</strong></p>
<p>当然，这道题也可以借用上一题“交换”的想法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> temp = nums[i];</div><div class="line">        nums[i] = nums[j];</div><div class="line">        nums[j] = temp;</div><div class="line">    &#125;</div><div class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(i == nums.length)&#123;</div><div class="line">            List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;(nums.length);</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> e : nums)&#123;res.add(e);&#125;</div><div class="line">            result.add(res);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i ; j &lt; nums.length; ++j)&#123;</div><div class="line">            <span class="comment">// 一旦i~j之间有一个元素nums[k]与nums[j]相同，那就不用再交换了（因为nums[k] == nums[j],没有必要再次交换了</span></div><div class="line">            <span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = j - <span class="number">1</span>; k &gt;= i; --k)&#123;</div><div class="line">                <span class="keyword">if</span>(nums[k] == nums[j])&#123;</div><div class="line">                    stop = <span class="keyword">true</span>;<span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(stop)<span class="keyword">continue</span>;</div><div class="line">            <span class="comment">// 将nums[i] 依次与nums[j]交换，然后固定nums[i]</span></div><div class="line">            swap(nums, i, j);</div><div class="line">            helper(nums, i + <span class="number">1</span>);</div><div class="line">            swap(nums, i, j);</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</div><div class="line">        Arrays.sort(nums);</div><div class="line">        helper(nums, <span class="number">0</span>);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="follow-up-字典顺序输出全排列">2.3. follow up - 字典顺序输出全排列</h2><p>如果我们要求按照字典顺序输出全排列呢？</p>
<p><strong>固定-交换法</strong></p>
<p>假如按照上面固定交换法呢？</p>
<p>我们先看看固定-交换法的执行结果：</p>
<p>输入123，输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>	[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line"><span class="number">1</span>	[<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>]</div><div class="line"><span class="number">2</span>	[<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>]</div><div class="line"><span class="number">3</span>	[<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>]</div><div class="line"><span class="number">4</span>	[<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]  -- x</div><div class="line"><span class="number">5</span>	[<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>]  -- x</div></pre></td></tr></table></figure>
<p>我们发现最后两个输出的顺序不是字典顺序。这是因为在之前的交换中，当我们把3固定在首位时，此刻3之后的数字不是顺序了。所以生成有误。</p>
<p>那么我们做出一点改动，即在交换时，我们使用一种shift操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></div><div class="line">   ↓ shift</div><div class="line"><span class="number">4</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></div></pre></td></tr></table></figure>
<p>即保持原数组不变，只把后面的提到前面来</p>
<p>当然在递归结束，还要这样shift_back回去</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> temp = nums[i];</div><div class="line">        nums[i] = nums[j];</div><div class="line">        nums[j] = temp;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shift</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">        <span class="comment">// 将nums[j]挪到nums[i] , 然后将其余的后移</span></div><div class="line">        <span class="keyword">int</span> temp = nums[j];</div><div class="line">        <span class="keyword">while</span> (j &gt; i)&#123;</div><div class="line">            nums[j] = nums[j-<span class="number">1</span>];</div><div class="line">            --j;</div><div class="line">        &#125;</div><div class="line">        nums[i] = temp;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shiftBack</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">        <span class="comment">// 将nums[i]挪到nums[j] , 然后将其余的左移</span></div><div class="line">        <span class="keyword">int</span> temp = nums[i];</div><div class="line">        <span class="keyword">while</span> (i &lt; j)&#123;</div><div class="line">            nums[i] = nums[i + <span class="number">1</span>];</div><div class="line">            ++i;</div><div class="line">        &#125;</div><div class="line">        nums[j] = temp;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> counter = <span class="number">0</span>;</div><div class="line">    String result;</div><div class="line">    <span class="keyword">int</span> k;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(counter &gt; k)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(i == nums.length)&#123;</div><div class="line">            ++counter;</div><div class="line">            <span class="comment">//System.out.println(counter + "\t" + Arrays.toString(nums));</span></div><div class="line">            StringBuilder strBu = <span class="keyword">new</span> StringBuilder();</div><div class="line">            <span class="keyword">if</span>(counter == k)&#123;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> e : nums)strBu.append(e);</div><div class="line">                result = strBu.toString();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; nums.length; ++j)&#123;</div><div class="line">            shift(nums, i, j);</div><div class="line">            helper(nums, i + <span class="number">1</span>);</div><div class="line">            shiftBack(nums, i ,j);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[n];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</div><div class="line">            nums[i] = i + <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.k = k;</div><div class="line">        helper(nums,<span class="number">0</span>);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>然后就万事大吉了！</p>
<p>然而，这种方式非常的慢。</p>
<p>我们还有一种优化，接着看下一题。</p>
<h2 id="Next-Permutation">2.4. Next Permutation</h2><p>输出指定数组的下一个排列</p>
<p>骚操作，<strong>字典法</strong></p>
<p>这个算法的核心思想就是，对于每一种可能排列的情况，我们都想办法使其与某种顺序建立对应关系，这种关系式一一对应的，这样我们就能通过遍历得到的某种顺序来生成全排列，这样就能避免递归过程了。这种按照某种顺序来生成全排列的方法就被称为是字典序。</p>
<p>很显然，最重要的是如何才能找到这样一种一一对应的顺序关系，此处继续用$a={0,1,2,3}$来说明字典序算法的过程。</p>
<p>要找到一种顺序关系，我们就首先要定义大小关系，对于两个序列${0,2,1,3}$和${0,2,3,1}$来说，序列${0,2,3,1}$要比${0,2,1,3}$大，比较的方法是从前到后依次比较相同位置上的元素，如果相同则继续比较下一个元素，直到遇到一个不同的元素，元素值大的序列就大于元素值小的序列。按照这样的大小关系形成的序列的顺序，就是字典序。可以看到，最小的序列一定是${0,1,2,3}$，最大的序列是${3,2,1,0}$。而字典序算法就是从字典序中最小的序列开始，一直不停寻找下一个仅比上一个序列大的序列，直到到达最大的序列。<a href="http://zhouyichu.com/algorithm/Permutation-Generation-1/#fn2" target="_blank" rel="external">[2]</a></p>
<p>现在问题变成了，如何从当前状态生成下一个状态？</p>
<p>假设当前排列是$a[1…..n]$</p>
<ol>
<li>从$a$中找到满足$a[k] &lt; a[k + 1]$（升序）的最后一个k。如果不存在，则$a$已经是字典序最大序列了。</li>
<li>在$a[k + 1,….,n]$ 中寻找比$a[k]$ 大的最小值$a[j]$。（在$a[k+1,…,n]$ 中，$a[k]$ 仅次于$a[j]$ 的数字。将它们交换后，能保证整个序列是最小增长的）</li>
<li>交换$a[k]与a[j]$ ，并将$a[k,…,n]$ 全部排序</li>
</ol>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> temp = nums[i];</div><div class="line">        nums[i] = nums[j];</div><div class="line">        nums[j] = temp;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> n = nums.length;</div><div class="line">        <span class="comment">// 寻找nums的下一个排列</span></div><div class="line">        <span class="comment">// 寻找最后一个升序nums[q]</span></div><div class="line">        <span class="keyword">int</span> q = -<span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</div><div class="line">            <span class="keyword">if</span>(nums[i - <span class="number">1</span>] &lt; nums[i])&#123;</div><div class="line">                q = i - <span class="number">1</span> ;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(q == -<span class="number">1</span>)&#123; <span class="comment">// 此刻nums是最后一个排列</span></div><div class="line">            <span class="keyword">int</span> start = <span class="number">0</span>, end = n-<span class="number">1</span>;</div><div class="line">            <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end)&#123;</div><div class="line">                swap(nums,start,end);</div><div class="line">                ++start; --end;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(start + <span class="number">1</span> == end)&#123;swap(nums,start,end);&#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 寻找比nums[q]大的最小值nums[m]</span></div><div class="line">            <span class="keyword">int</span> m = q, min = Integer.MAX_VALUE;</div><div class="line">            <span class="keyword">int</span> i = q;</div><div class="line">            <span class="keyword">while</span> (i &lt; n) &#123;</div><div class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[q] &amp;&amp; nums[i] &lt; min) &#123;</div><div class="line">                    min = nums[i];</div><div class="line">                    m = i;</div><div class="line">                &#125;</div><div class="line">                ++i;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 将nums[q]与nums[m]交换</span></div><div class="line">            swap(nums, q, m);</div><div class="line">            <span class="comment">// 将[q + 1 ~ n]倒排</span></div><div class="line">            Arrays.sort(nums, q + <span class="number">1</span>, n);</div><div class="line">            <span class="comment">// 输出nums</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>当然有一种优化思路是，优化第1步中：将”从前到后寻找最后一个升序“转化为”从后到前寻找第一个降序“。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> n = nums.length;</div><div class="line">        <span class="comment">// 寻找nums的下一个排列</span></div><div class="line">        <span class="comment">// 寻找最后一个升序nums[q]</span></div><div class="line">        <span class="keyword">int</span> q = nums.length;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i)&#123;</div><div class="line">            <span class="keyword">if</span>(nums[i - <span class="number">1</span>] &lt; nums[i])&#123;</div><div class="line">                q = i - <span class="number">1</span> ;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(q == nums.length)&#123; <span class="comment">// 此刻nums是最后一个排列</span></div><div class="line">            <span class="keyword">int</span> start = <span class="number">0</span>, end = n-<span class="number">1</span>;</div><div class="line">            <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end)&#123;</div><div class="line">                swap(nums,start,end);</div><div class="line">                ++start; --end;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(start + <span class="number">1</span> == end)&#123;swap(nums,start,end);&#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 寻找比nums[q]大的最小值nums[m]</span></div><div class="line">            <span class="keyword">int</span> m = q, min = Integer.MAX_VALUE;</div><div class="line">            <span class="keyword">int</span> i = q;</div><div class="line">            <span class="keyword">while</span> (i &lt; n) &#123;</div><div class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[q] &amp;&amp; nums[i] &lt; min) &#123;</div><div class="line">                    min = nums[i];</div><div class="line">                    m = i;</div><div class="line">                &#125;</div><div class="line">                ++i;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 将nums[q]与nums[m]交换</span></div><div class="line">            swap(nums, q, m);</div><div class="line">            <span class="comment">// 将[q + 1 ~ n]倒排</span></div><div class="line">            Arrays.sort(nums, q + <span class="number">1</span>, n);</div><div class="line">            <span class="comment">// 输出nums</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="Permutation-Sequence">2.5. Permutation Sequence</h2><p>输出1-n数字组成的数字中的字典序第k个排列</p>
<p>思路一：如果用follow up 的代码，是完全可以的。只是时间非常高。</p>
<p>思路二：字典法，依次输出，时间代价还是很昂贵，还有可能超时</p>
<p>思路三：骚操作</p>
<p>n个数的全排列一共有$n!$ 个。基于这个性质我们可以计算出某一位对应的数字是几！骚操作啊！</p>
<p>我们用123来举例。它的全排列为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">            第一位           第二位</div><div class="line"><span class="number">0</span>  <span class="number">123</span>     <span class="number">1</span> = nums[<span class="number">0</span>/<span class="number">2</span>]      <span class="number">2</span></div><div class="line"><span class="number">1</span>  <span class="number">132</span>     <span class="number">1</span> = nums[<span class="number">1</span>/<span class="number">2</span>]      <span class="number">3</span></div><div class="line"><span class="number">2</span>  <span class="number">213</span>     <span class="number">2</span> = nums[<span class="number">2</span>/<span class="number">2</span>]      <span class="number">1</span></div><div class="line"><span class="number">3</span>  <span class="number">231</span>     <span class="number">2</span> = nums[<span class="number">3</span>/<span class="number">2</span>]      <span class="number">3</span></div><div class="line"><span class="number">4</span>  <span class="number">312</span>     <span class="number">3</span> = nums[<span class="number">4</span>/<span class="number">2</span>]      <span class="number">1</span>    </div><div class="line"><span class="number">5</span>  <span class="number">321</span>     <span class="number">3</span> = nums[<span class="number">5</span>/<span class="number">2</span>]      <span class="number">2</span>    &lt;-- k = <span class="number">5</span></div></pre></td></tr></table></figure>
<p>因为当第一位确定时，全排列个数为$(n-1)! = 2$ 个。</p>
<p>所以第一位的重复周期是$(n-1)!$ 。那么第k个就是$\frac{k}{(n-1)!}$ 。</p>
<p>假如第一位是a1 = 3，那么第一位是1和2的全排列都可以去除了！那就是从3开头的全排列中寻找第$k’ = k - (a1-1) * (n-1)! = k \text{ % } (n-1)! = 5 -  4 = 1$ 个！</p>
<p>而且，当第一位确定时，第二位只剩下$n - 1$ 个数字可以选择。因此以3开头的只有$(n-2)!$ 种。所以第二位的数字为$\frac{k`}{(n-2)!}$</p>
<p>然后我们就找到了规律！</p>
<p>a1 = k / (n - 1)!<br>k1 = k</p>
<p>a2 = k1 / (n - 2)!<br>k2 = k1 % (n - 2)!<br>…</p>
<p>an-1 = kn-2 / 1!<br>kn-1 = kn-2 / 1!</p>
<p>an = kn-1 / 0!<br>kn = kn-1 % 0!</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        ArrayList&lt;Integer&gt; candidates = <span class="keyword">new</span> ArrayList&lt;&gt;(n);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</div><div class="line">            candidates.add(i);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 先存下来n!</span></div><div class="line">        <span class="keyword">int</span>[] factorial = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</div><div class="line">        factorial[<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">        factorial[<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// factorial[i] = i!</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</div><div class="line">            factorial[i] = factorial[i-<span class="number">1</span>] * i;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 计算第k位</span></div><div class="line">        k = k - <span class="number">1</span>;</div><div class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</div><div class="line">            <span class="keyword">int</span> idx = k / factorial[n-<span class="number">1</span>-i] ;</div><div class="line">            stringBuilder.append(candidates.get(idx));</div><div class="line">            candidates.remove(idx); <span class="comment">// 注意维护剩余集合</span></div><div class="line">            k = k % factorial[n-<span class="number">1</span>-i];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> stringBuilder.toString();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="Binary-Watch">2.6. Binary Watch</h2><p>有一种二进制的表。其中用4个位数表示小时（0-11），用6个位数表示分钟（0-59）。</p>
<p>给一个n，表示当前亮灯的个数。求可能出现的时刻</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">permutations</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> idx, <span class="keyword">int</span> num, <span class="keyword">int</span> sum, List&lt;Integer&gt; result, <span class="keyword">int</span> limit)</span></span>&#123;</div><div class="line">    <span class="comment">//从候选集里选num个，求相加有多少种结果</span></div><div class="line">    <span class="keyword">if</span>(sum &gt;= limit)<span class="keyword">return</span>;</div><div class="line">    <span class="keyword">if</span>(num == <span class="number">0</span>)&#123;result.add(sum);<span class="keyword">return</span>;&#125;</div><div class="line">    <span class="keyword">if</span>(idx &gt;= candidates.length || candidates.length - idx &lt; num)<span class="keyword">return</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = idx; i &lt; candidates.length; ++i)&#123;</div><div class="line">        permutations(candidates, i + <span class="number">1</span>, num - <span class="number">1</span>, sum + candidates[i], result, limit);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">helper</span><span class="params">(<span class="keyword">int</span> h_num, <span class="keyword">int</span> m_num, <span class="keyword">int</span>[] h, <span class="keyword">int</span>[] m)</span></span>&#123;</div><div class="line">    <span class="comment">// h_num个小时灯，m_num个分钟灯</span></div><div class="line">    List&lt;Integer&gt; hours = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">    permutations(h, <span class="number">0</span>, h_num, <span class="number">0</span>, hours, <span class="number">12</span>);</div><div class="line">    List&lt;Integer&gt; minites = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">    permutations(m, <span class="number">0</span>, m_num, <span class="number">0</span>, minites, <span class="number">60</span>);</div><div class="line">    <span class="comment">//两两组合</span></div><div class="line">    List&lt;String&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">    <span class="keyword">for</span>(Integer hour : hours)&#123;</div><div class="line">        String hour_str = Integer.toString(hour);</div><div class="line">        <span class="keyword">for</span>(Integer minite : minites)&#123;</div><div class="line">            String min_str = minite &lt; <span class="number">10</span> ? <span class="string">"0"</span>+Integer.toString(minite) : Integer.toString(minite);</div><div class="line">            result.add(hour_str + <span class="string">":"</span> + min_str);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">readBinaryWatch</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span>[] h = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>&#125;;</div><div class="line">    <span class="keyword">int</span>[] m = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">16</span>,<span class="number">32</span>&#125;;</div><div class="line">    List&lt;String&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> h_num = <span class="number">0</span>; h_num &lt; <span class="number">4</span>; ++h_num)&#123;</div><div class="line">        <span class="keyword">int</span> m_num = num - h_num;</div><div class="line">        <span class="keyword">if</span>(m_num &gt; <span class="number">6</span>)<span class="keyword">continue</span>;</div><div class="line">        result.addAll(helper(h_num, m_num, h, m));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="元素和、组合问题">3. 元素和、组合问题</h1><h2 id="Combinations">3.1. Combinations</h2><p>用1-n的数字，每次拿k个。输出所有的组合方式。</p>
<p>相当经典的回溯问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> start, List&lt;Integer&gt; candidates)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</div><div class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(candidates));</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= n; ++i)&#123;</div><div class="line">            candidates.add(i);</div><div class="line">            helper(n, k - <span class="number">1</span>, i + <span class="number">1</span>, candidates);</div><div class="line">            candidates.remove(candidates.size() - <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</div><div class="line">        helper(n, k, <span class="number">1</span>, <span class="keyword">new</span> LinkedList&lt;&gt;());</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>在leetcode上看到还有一种思路，很快。但总体复杂度其实差不多。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</div><div class="line">    List&lt;Integer&gt; current = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    dfs(result, current, <span class="number">1</span>, n, k);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; current, <span class="keyword">int</span> c, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (c + k &gt; n + <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</div><div class="line">        List&lt;Integer&gt; tmpList = <span class="keyword">new</span> ArrayList&lt;&gt;(current);</div><div class="line">        result.add(tmpList);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">   <span class="comment">// 使用c这个数字</span></div><div class="line">    current.add(c);</div><div class="line">    dfs(result, current, c + <span class="number">1</span>, n, k - <span class="number">1</span>);</div><div class="line">    current.remove(current.size() - <span class="number">1</span>);</div><div class="line">    <span class="comment">// 不使用c这个数字</span></div><div class="line">    dfs(result, current, c + <span class="number">1</span>, n, k);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Combination-Sum">3.2. Combination Sum</h2><p>给一个数组和一个target.求数组中的元素和等于target的所有可能。元素可以多次取。</p>
<p>思路：典型的回溯。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> start, ArrayList&lt;Integer&gt; added)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(target &lt; <span class="number">0</span>)<span class="keyword">return</span>;</div><div class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</div><div class="line">            List&lt;Integer&gt; aRes = <span class="keyword">new</span> ArrayList&lt;&gt;(added.size());</div><div class="line">            aRes.addAll(added);</div><div class="line">            result.add(aRes);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">       <span class="comment">// 从start开始取（start就是上一次使用的元素）</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; candidates.length; ++i)&#123;</div><div class="line">            added.add(candidates[i]);</div><div class="line">            helper(candidates, target - candidates[i], i,added);</div><div class="line">            added.remove(added.size() - <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</div><div class="line">        Arrays.sort(candidates);</div><div class="line">        helper(candidates,target, <span class="number">0</span>,<span class="keyword">new</span> ArrayList&lt;&gt;(candidates.length));</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>虽然说这道题可以用dp来简化。但是由于重复的边界条件实在是难以处理，所以还是弃用了。</p>
<h2 id="Combination-Sum-II">3.3. Combination Sum II</h2><p>给一个有重数组和一个target.求数组中的元素和等于target的所有可能。元素不可以多次取。</p>
<p>这道题与上一题的最大区别就是不能多次取！需要注意的地方就是递归进入时的i需要加一（跳过本元素）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> start, List&lt;Integer&gt; selected)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(target &lt; <span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</div><div class="line">            List&lt;Integer&gt; one = <span class="keyword">new</span> ArrayList&lt;&gt;(selected);</div><div class="line">            result.add(one);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; candidates.length; ++i)&#123;</div><div class="line">            <span class="keyword">if</span>(i &gt; start  &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>])<span class="keyword">continue</span>; <span class="comment">// 去重</span></div><div class="line">            <span class="keyword">if</span>(target - candidates[i] &lt; <span class="number">0</span>)<span class="keyword">break</span>;<span class="comment">// 剪枝</span></div><div class="line">            <span class="comment">// 回溯</span></div><div class="line">            selected.add(candidates[i]);</div><div class="line">            helper(candidates, target - candidates[i], i + <span class="number">1</span>,selected); <span class="comment">// 从i + 1处继续</span></div><div class="line">            selected.remove(selected.size() - <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</div><div class="line">        Arrays.sort(candidates);</div><div class="line">        helper(candidates,target, <span class="number">0</span>, <span class="keyword">new</span> LinkedList&lt;&gt;());</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="Combination-Sum-III">3.4. Combination Sum III</h2><p>求k个数（0-9的数）的和为n的所有组合。</p>
<p>还是回溯问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> start, <span class="keyword">int</span> target, List&lt;Integer&gt; candidates)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(target &lt; <span class="number">0</span> || k &lt; <span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">if</span>(target == <span class="number">0</span> &amp;&amp; k == <span class="number">0</span>)&#123;</div><div class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(candidates));</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= <span class="number">9</span>; ++i)&#123;</div><div class="line">            <span class="keyword">if</span>(target - i &lt; <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// 剪枝</span></div><div class="line">            candidates.add(i);</div><div class="line">            helper(k - <span class="number">1</span>,i + <span class="number">1</span>, target - i, candidates);</div><div class="line">            candidates.remove(candidates.size() - <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum3(<span class="keyword">int</span> k, <span class="keyword">int</span> n) &#123;</div><div class="line">        helper(k,<span class="number">1</span>, n, <span class="keyword">new</span> LinkedList&lt;&gt;());</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>当然还可以用另一种思路，就是选或者不选的问题。这种思路类似Combinations的第二种解法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> i, <span class="keyword">int</span> target, List&lt;Integer&gt; candidates)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(target == <span class="number">0</span> &amp;&amp; k == <span class="number">0</span>)&#123;</div><div class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(candidates));</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(k == <span class="number">0</span> &amp;&amp; target != <span class="number">0</span>)&#123;<span class="keyword">return</span>;&#125;</div><div class="line">        <span class="keyword">if</span>(i &gt; <span class="number">9</span> || target &lt; <span class="number">0</span> || k &lt; <span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line">        <span class="comment">// 选i</span></div><div class="line">        candidates.add(i);</div><div class="line">        helper(k - <span class="number">1</span>,i + <span class="number">1</span>, target - i, candidates);</div><div class="line">        candidates.remove(candidates.size() - <span class="number">1</span>);</div><div class="line">        <span class="comment">// 不选i</span></div><div class="line">        helper(k,i + <span class="number">1</span>, target, candidates);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum3(<span class="keyword">int</span> k, <span class="keyword">int</span> n) &#123;</div><div class="line">        helper(k,<span class="number">1</span>, n, <span class="keyword">new</span> LinkedList&lt;&gt;());</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h1 id="其它问题">4. 其它问题</h1><h2 id="Count-Numbers-with-Unique-Digits">4.1. Count Numbers with Unique Digits</h2><p>给一个n。求x的个数，其中$0&lt;= x &lt;= 10^n$ ，且x的每一位的数字都不相同。</p>
<p>思路：x是n位数，且每位都不相等。</p>
<p>如果n大于10，那$x &gt; 10^{10}$ 的都不用考虑了</p>
<p>如果n小于等于10，那就考虑0-9能组成多少个n位的数字了！</p>
<p>这道题完全可以用公式完成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">n位数的可能有如下：</div><div class="line"></div><div class="line"><span class="number">0</span>      （就是<span class="number">0</span>）</div><div class="line"><span class="number">1</span> 位数 -&gt; C(<span class="number">9</span>,<span class="number">1</span>)  (从<span class="number">1</span>-<span class="number">9</span>里随机挑选一个)</div><div class="line"><span class="number">2</span> 位数 -&gt; C(<span class="number">9</span>,<span class="number">1</span>) * C(<span class="number">9</span>,<span class="number">1</span>)  (第一位从<span class="number">1</span>-<span class="number">9</span>挑，第二位与第一位不同即可，所以也是<span class="number">9</span>种)</div><div class="line"><span class="number">3</span> 位数 -&gt; C(<span class="number">9</span>,<span class="number">1</span>) * C(<span class="number">9</span>,<span class="number">1</span>) * C(<span class="number">8</span>,<span class="number">1</span>) (第一位从<span class="number">1</span>-<span class="number">9</span>挑，第二位与第一位不同，第三位与前两位不同)</div><div class="line">...</div><div class="line">n 位数</div><div class="line"></div><div class="line">代码：</div><div class="line">    <span class="comment">//  * C(9,1) * C(8,1) *....</span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(k == <span class="number">0</span> || n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        <span class="keyword">return</span> k * helper(n - <span class="number">1</span>, k - <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNumbersWithUniqueDigits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</div><div class="line">            sum += <span class="number">9</span> * helper(i - <span class="number">1</span>, <span class="number">9</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="Letter-Combinations-of-a-Phone-Number">4.2. Letter Combinations of a Phone Number</h2><p>求手机“九宫格”输入数字后组成的字符串的所有可能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">HashMap&lt;Character, String[]&gt; table = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildTable</span><span class="params">()</span></span>&#123;</div><div class="line">        table.put(<span class="string">'1'</span>,<span class="keyword">new</span> String[<span class="number">0</span>]);</div><div class="line">        table.put(<span class="string">'2'</span>,<span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>&#125;);</div><div class="line">        table.put(<span class="string">'3'</span>,<span class="keyword">new</span> String[]&#123;<span class="string">"d"</span>,<span class="string">"e"</span>,<span class="string">"f"</span>&#125;);</div><div class="line">        table.put(<span class="string">'4'</span>,<span class="keyword">new</span> String[]&#123;<span class="string">"g"</span>,<span class="string">"h"</span>,<span class="string">"i"</span>&#125;);</div><div class="line">        table.put(<span class="string">'5'</span>,<span class="keyword">new</span> String[]&#123;<span class="string">"j"</span>,<span class="string">"k"</span>,<span class="string">"l"</span>&#125;);</div><div class="line">        table.put(<span class="string">'6'</span>,<span class="keyword">new</span> String[]&#123;<span class="string">"m"</span>,<span class="string">"n"</span>,<span class="string">"o"</span>&#125;);</div><div class="line">        table.put(<span class="string">'7'</span>,<span class="keyword">new</span> String[]&#123;<span class="string">"p"</span>,<span class="string">"q"</span>,<span class="string">"r"</span>,<span class="string">"s"</span>&#125;);</div><div class="line">        table.put(<span class="string">'8'</span>,<span class="keyword">new</span> String[]&#123;<span class="string">"t"</span>,<span class="string">"u"</span>,<span class="string">"v"</span>&#125;);</div><div class="line">        table.put(<span class="string">'9'</span>,<span class="keyword">new</span> String[]&#123;<span class="string">"w"</span>,<span class="string">"x"</span>,<span class="string">"y"</span>,<span class="string">"z"</span>&#125;);</div><div class="line">        table.put(<span class="string">'0'</span>,<span class="keyword">new</span> String[]&#123;<span class="string">" "</span>&#125;);</div><div class="line">        table.put(<span class="string">'#'</span>,<span class="keyword">new</span> String[]&#123;<span class="string">"#"</span>&#125;);</div><div class="line">        table.put(<span class="string">'*'</span>,<span class="keyword">new</span> String[]&#123;<span class="string">"*"</span>&#125;);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</div><div class="line">        List&lt;String&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        <span class="keyword">if</span>(digits.length() == <span class="number">0</span>) <span class="keyword">return</span> result;</div><div class="line">        buildTable();</div><div class="line">        <span class="keyword">char</span>[] digits_c = digits.toCharArray();</div><div class="line">        <span class="comment">// 初始化</span></div><div class="line">        String[] candicates = table.get(digits_c[<span class="number">0</span>]);</div><div class="line">        <span class="keyword">for</span>(String c : candicates)&#123;</div><div class="line">            String aRes = <span class="keyword">new</span> String(c);</div><div class="line">            result.add(aRes);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 插入</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; digits_c.length; ++i)&#123;</div><div class="line">            candicates = table.get(digits_c[i]);</div><div class="line">            <span class="comment">// 依次将candicates与builder的每个元素组合</span></div><div class="line">            List&lt;String&gt; result_curr = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">            <span class="keyword">for</span>(String aRes : result)&#123;</div><div class="line">                <span class="keyword">for</span>(String c : candicates)&#123;</div><div class="line">                    String aRes_curr = aRes + c;</div><div class="line">                    result_curr.add(aRes_curr);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            result = result_curr;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="Generate-Parentheses">4.3. Generate Parentheses</h2><p>有n对括号。求所有括号可能的摆放次序（括号必须成对先后出现）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> remain_left, <span class="keyword">int</span> remain_right, StringBuilder builder)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(remain_left == <span class="number">0</span> &amp;&amp; remain_right == <span class="number">0</span>)&#123;</div><div class="line">            result.add(builder.toString());</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(remain_left == <span class="number">0</span>)&#123;</div><div class="line">            builder.append(<span class="string">')'</span>);</div><div class="line">            helper(remain_left, remain_right - <span class="number">1</span>, builder);</div><div class="line">            builder.delete(builder.length() - <span class="number">1</span>, builder.length());</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(remain_left &gt;= remain_right || remain_right == <span class="number">0</span>)&#123;</div><div class="line">            builder.append(<span class="string">'('</span>);</div><div class="line">            helper(remain_left - <span class="number">1</span>, remain_right, builder);</div><div class="line">            builder.delete(builder.length() - <span class="number">1</span>, builder.length());</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 要么放一个左括号</span></div><div class="line">        builder.append(<span class="string">'('</span>);</div><div class="line">        helper(remain_left - <span class="number">1</span>, remain_right, builder);</div><div class="line">        builder.delete(builder.length() - <span class="number">1</span>, builder.length());</div><div class="line">        <span class="comment">// 要么放一个右括号</span></div><div class="line">        builder.append(<span class="string">')'</span>);</div><div class="line">        helper(remain_left, remain_right - <span class="number">1</span>, builder);</div><div class="line">        builder.delete(builder.length() - <span class="number">1</span>, builder.length());</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        helper(n,n,<span class="keyword">new</span> StringBuilder());</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>优化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> remain_left, <span class="keyword">int</span> remain_right, StringBuilder builder)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(remain_left == <span class="number">0</span> &amp;&amp; remain_right == <span class="number">0</span>)&#123;</div><div class="line">            result.add(builder.toString());</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(remain_left &gt; <span class="number">0</span>)&#123; <span class="comment">// 只要左括号有富裕，就可以放</span></div><div class="line">            builder.append(<span class="string">'('</span>);</div><div class="line">            helper(remain_left - <span class="number">1</span>, remain_right, builder);</div><div class="line">            builder.delete(builder.length() - <span class="number">1</span>, builder.length());</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(remain_left &lt; remain_right) &#123; <span class="comment">// 左括号比右括号多时，才可以放右括号</span></div><div class="line">            builder.append(<span class="string">')'</span>);</div><div class="line">            helper(remain_left, remain_right - <span class="number">1</span>, builder);</div><div class="line">            builder.delete(builder.length() - <span class="number">1</span>, builder.length());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        helper(n,n,<span class="keyword">new</span> StringBuilder());</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="Sudoku-Solver">4.4. Sudoku Solver</h2><p>$9 \times 9$ 的数独，填入数字1-9，要求行列不重复，且每个宫内不重复。</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-25-17-59-30.png" alt=""> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">boolean</span>[][][] used;</div><div class="line">    <span class="comment">/**used[0][i][q] : 第i列,数字q是否被使用</span></div><div class="line">     * used[1][i][q] : 第i行，数字q是否被使用</div><div class="line">     * used[2][i][q] : 第i个宫中数字q是否被使用</div><div class="line">     * **/</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> filled)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(filled == board.length * board.length)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; ++i)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board.length; ++j)&#123;</div><div class="line">                <span class="keyword">if</span>(board[i][j] != <span class="string">'.'</span>) <span class="keyword">continue</span>;</div><div class="line">                <span class="comment">//尝试给board[i][j]填入数字q</span></div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> q = <span class="number">1</span>; q &lt;= <span class="number">9</span>; ++q)&#123;</div><div class="line">                    <span class="keyword">if</span>(used[<span class="number">0</span>][i][q] || used[<span class="number">1</span>][j][q] || used[<span class="number">2</span>][j/<span class="number">3</span> + <span class="number">3</span> * (i/<span class="number">3</span>)][q]) <span class="keyword">continue</span>;</div><div class="line">                    board[i][j] = (<span class="keyword">char</span>)(q + <span class="number">48</span>);</div><div class="line">                    used[<span class="number">0</span>][i][q] = <span class="keyword">true</span>;</div><div class="line">                    used[<span class="number">1</span>][j][q] = <span class="keyword">true</span>;</div><div class="line">                    used[<span class="number">2</span>][j/<span class="number">3</span> + <span class="number">3</span> * (i/<span class="number">3</span>)][q] = <span class="keyword">true</span>;</div><div class="line">                    <span class="keyword">if</span>(helper(board, filled + <span class="number">1</span>))<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                    board[i][j] = <span class="string">'.'</span>;</div><div class="line">                    used[<span class="number">0</span>][i][q] = <span class="keyword">false</span>;</div><div class="line">                    used[<span class="number">1</span>][j][q] = <span class="keyword">false</span>;</div><div class="line">                    used[<span class="number">2</span>][j/<span class="number">3</span> + <span class="number">3</span> * (i/<span class="number">3</span>)][q] = <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//这个剪枝很重要</span></div><div class="line">                <span class="comment">//board[i][j]填任何数字都不行</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</div><div class="line">        used = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">3</span>][board.length][<span class="number">10</span>];</div><div class="line">        <span class="comment">//初始化</span></div><div class="line">        <span class="keyword">int</span> filled = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; ++i)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board.length; ++j)&#123;</div><div class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">'.'</span>)<span class="keyword">continue</span>;</div><div class="line">                used[<span class="number">0</span>][i][board[i][j]-<span class="number">48</span>] = <span class="keyword">true</span>;</div><div class="line">                used[<span class="number">1</span>][j][board[i][j]-<span class="number">48</span>] = <span class="keyword">true</span>;</div><div class="line">                used[<span class="number">2</span>][j/<span class="number">3</span> + <span class="number">3</span> * (i/<span class="number">3</span>)][board[i][j]-<span class="number">48</span>] = <span class="keyword">true</span>;</div><div class="line">                ++filled;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        helper(board,filled);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="Beautiful-Arrangement">4.5. Beautiful Arrangement</h2><p>给1-N的数字，填入长度为N的数组。令数组的idx从1开始。要求：idx能整除nums[idx]或nums[idx]能整除idx。求所有的可能数。</p>
<p>思路：一开始想多了。其实用暴力遍历就行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> counter = <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">boolean</span>[] used, <span class="keyword">int</span> N)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(idx == used.length)&#123;</div><div class="line">            ++counter;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)&#123;</div><div class="line">            <span class="keyword">if</span>(used[i])<span class="keyword">continue</span>;</div><div class="line">            <span class="keyword">if</span>(idx % i == <span class="number">0</span> || i % idx == <span class="number">0</span>)&#123;</div><div class="line">                used[i] = <span class="keyword">true</span>;</div><div class="line">                helper(idx + <span class="number">1</span>, used, N);</div><div class="line">                used[i] = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countArrangement</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[N + <span class="number">1</span>];</div><div class="line">        helper(<span class="number">1</span>, used, N);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> counter;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="Wildcard-Matching">4.6. Wildcard Matching</h2><p>给两个字符串，其中一个含有<code>*或?</code>。<code>*</code>代表可匹配任意多个字符。<code>?</code>代表可匹配任意元素。求两个字符串是否能完全匹配</p>
<p>思路：回溯，碰到不行的就回退</p>
<p>最后几个样例会超时，所以我又用了dp</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(String s, String p, <span class="keyword">int</span> s_idx, <span class="keyword">int</span> p_idx)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(s_idx &gt;= s.length() &amp;&amp; p_idx &gt;= p.length()) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span>(p_idx &gt;= p.length()) <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span>(s_idx &gt;= s.length())&#123;</div><div class="line">        <span class="keyword">while</span> (p_idx &lt; p.length()) &#123;</div><div class="line">            <span class="keyword">if</span> (p.charAt(p_idx) == <span class="string">'*'</span>)</div><div class="line">                ++p_idx;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(dp[s_idx][p_idx] != <span class="number">0</span>) <span class="keyword">return</span> dp[s_idx][p_idx];</div><div class="line"></div><div class="line">    <span class="keyword">char</span> s_element = s.charAt(s_idx);</div><div class="line">    <span class="keyword">char</span> p_element = p.charAt(p_idx);</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(p_element == <span class="string">'?'</span>)&#123;</div><div class="line">        dp[s_idx][p_idx] = helper(s, p, s_idx + <span class="number">1</span>, p_idx + <span class="number">1</span>);</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p_element == <span class="string">'*'</span>)&#123;</div><div class="line">      <span class="comment">// 跳过连续的******</span></div><div class="line">        <span class="keyword">while</span> (p_idx &lt; p.length() - <span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(p.charAt(p_idx + <span class="number">1</span>) == <span class="string">'*'</span>) ++p_idx;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        dp[s_idx][p_idx] = helper(s, p, s_idx, p_idx + <span class="number">1</span>);</div><div class="line">        <span class="keyword">if</span>(dp[s_idx][p_idx] == -<span class="number">1</span>)</div><div class="line">            dp[s_idx][p_idx] = helper(s, p, s_idx + <span class="number">1</span>, p_idx);</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p_element == s_element)&#123;</div><div class="line">        dp[s_idx][p_idx] = helper(s, p, s_idx + <span class="number">1</span>, p_idx + <span class="number">1</span>);</div><div class="line">    &#125;<span class="keyword">else</span></div><div class="line">        dp[s_idx][p_idx] = -<span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> dp[s_idx][p_idx];</div><div class="line">&#125;</div><div class="line"><span class="keyword">int</span>[][] dp;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</div><div class="line">    dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()][p.length()];</div><div class="line">    <span class="keyword">return</span> helper(s, p, <span class="number">0</span>, <span class="number">0</span>) == <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Regular-Expression-Matching">4.7. Regular Expression Matching</h2><p>给两个字符串，其中一个含有<code>*或.</code>。<code>*</code>代表可匹配前一个元素0个或多个。<code>.</code>代表可匹配任意元素。求两个字符串是否能完全匹配</p>
<p>思路：回溯，碰到不行的就回退</p>
<p>注意边界条件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(String s, String p, <span class="keyword">int</span> s_idx, <span class="keyword">int</span> p_idx)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(s_idx &lt; <span class="number">0</span> &amp;&amp; p_idx &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">if</span>(p_idx &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">if</span>(s_idx &lt; <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(p.charAt(p_idx) == <span class="string">'*'</span>)</div><div class="line">                <span class="keyword">return</span> helper(s, p, s_idx, p_idx - <span class="number">2</span>); <span class="comment">// 匹配0个</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">char</span> p_element = p.charAt(p_idx);</div><div class="line">        <span class="keyword">char</span> s_element = s.charAt(s_idx);</div><div class="line">        <span class="keyword">if</span>(p_element == <span class="string">'.'</span>)&#123;</div><div class="line">            <span class="keyword">return</span> helper(s, p, s_idx - <span class="number">1</span>, p_idx - <span class="number">1</span>);</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p_element == <span class="string">'*'</span>)&#123;</div><div class="line">            <span class="comment">// 比较s[s_idx]与p[p_idx - 1]</span></div><div class="line">            <span class="keyword">if</span>(p_idx == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            <span class="keyword">if</span>((s_element == p.charAt(p_idx - <span class="number">1</span>)) || (p.charAt(p_idx - <span class="number">1</span>) == <span class="string">'.'</span>))&#123;</div><div class="line">                <span class="keyword">return</span> helper(s, p, s_idx - <span class="number">1</span>,p_idx) || <span class="comment">// 匹配1个</span></div><div class="line">                        helper(s, p, s_idx, p_idx - <span class="number">2</span>); <span class="comment">// 匹配0个</span></div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                <span class="keyword">return</span> helper(s, p, s_idx, p_idx - <span class="number">2</span>); <span class="comment">// 匹配0个</span></div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">if</span>(p_element == s_element)&#123;</div><div class="line">                <span class="keyword">return</span> helper(s, p, s_idx - <span class="number">1</span>, p_idx - <span class="number">1</span>);</div><div class="line">            &#125;<span class="keyword">else</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> helper(s, p, s.length() - <span class="number">1</span>,p.length() - <span class="number">1</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="Reconstruct-Itinerary">4.8. Reconstruct Itinerary</h2><p>行程安排问题。一个人从JFK出发，求一种能走得通的行程</p>
<p>这道题写了很久，一开始陷入了拓扑排序的怪圈。以后要注意自己的思维，不要被之前的题限制！</p>
<p>思路：</p>
<ol>
<li>建立每个点的邻接列表</li>
<li>依次往下探测，遇到不合适的就返回</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt;</span>&#123;</div><div class="line">    String departure;</div><div class="line">    ArrayList&lt;Node&gt; neighbors = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    <span class="keyword">boolean</span>[] visited;</div><div class="line">    Node(String departure)&#123;</div><div class="line">        <span class="keyword">this</span>.departure = departure;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node o)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.departure.compareTo(o.departure);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> HashMap&lt;String, Node&gt; <span class="title">countDegree</span><span class="params">(String[][] tickets)</span></span>&#123;</div><div class="line">    HashMap&lt;String, Node&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    <span class="keyword">for</span>(String[] edge : tickets)&#123;</div><div class="line">        hashMap.put(edge[<span class="number">0</span>], <span class="keyword">new</span> Node(edge[<span class="number">0</span>]));</div><div class="line">        hashMap.put(edge[<span class="number">1</span>], <span class="keyword">new</span> Node(edge[<span class="number">1</span>]));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(String[] edge : tickets)&#123;</div><div class="line">        Node neibor = hashMap.get(edge[<span class="number">1</span>]);</div><div class="line">        hashMap.get(edge[<span class="number">0</span>]).neighbors.add(neibor);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 对每个departures的邻居排序</span></div><div class="line">    <span class="keyword">for</span>(Node e : hashMap.values())&#123;</div><div class="line">        Collections.sort(e.neighbors);</div><div class="line">        e.visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[e.neighbors.size()];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> hashMap;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(Node departure, List&lt;String&gt; result, <span class="keyword">int</span> length)</span></span>&#123;</div><div class="line">    <span class="comment">//System.out.println(result);</span></div><div class="line">    <span class="keyword">if</span>(result.size() == length) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(result.size() &gt; length) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; departure.visited.length; ++i)&#123;</div><div class="line">        <span class="keyword">if</span>(departure.visited[i])<span class="keyword">continue</span>;</div><div class="line">        departure.visited[i] = <span class="keyword">true</span>;</div><div class="line">        result.add(departure.neighbors.get(i).departure);</div><div class="line">        <span class="keyword">if</span>(dfs(departure.neighbors.get(i), result, length)) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        result.remove(result.size() - <span class="number">1</span>);</div><div class="line">        departure.visited[i] = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findItinerary</span><span class="params">(String[][] tickets)</span> </span>&#123;</div><div class="line">    <span class="comment">//统计每个站邻居，并做排序</span></div><div class="line">    HashMap&lt;String, Node&gt; departures = countDegree(tickets);</div><div class="line">    <span class="comment">// 开始做dfs</span></div><div class="line">    List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">2</span> + tickets.length - <span class="number">1</span>);</div><div class="line">    result.add(<span class="string">"JFK"</span>);</div><div class="line">    dfs(departures.get(<span class="string">"JFK"</span>), result, <span class="number">2</span> + tickets.length - <span class="number">1</span>);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>用优先队列</strong></p>
<p>下面这个方法真是太鸡贼了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findItinerary</span><span class="params">(String[][] tickets)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (String[] ticket : tickets)</div><div class="line">        targets.computeIfAbsent(ticket[<span class="number">0</span>], k -&gt; <span class="keyword">new</span> PriorityQueue()).add(ticket[<span class="number">1</span>]);</div><div class="line">    visit(<span class="string">"JFK"</span>);</div><div class="line">    <span class="keyword">return</span> route;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Map&lt;String, PriorityQueue&lt;String&gt;&gt; targets = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">List&lt;String&gt; route = <span class="keyword">new</span> LinkedList();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(String airport)</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span>(targets.containsKey(airport) &amp;&amp; !targets.get(airport).isEmpty())</div><div class="line">        visit(targets.get(airport).poll());</div><div class="line">    route.add(<span class="number">0</span>, airport); <span class="comment">// 这里很巧妙</span></div><div class="line">  <span class="comment">// 1. 假设这条路下去是个环路，走回来了，那就暂时先不加，继续从环路递归</span></div><div class="line">  <span class="comment">// 2. 加入这条路不是个环路，那就加进去，然后跳出循环，回到环路，再把环路的结果依次相加</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还有一种非递归，用栈的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findItinerary</span><span class="params">(String[][] tickets)</span> </span>&#123;</div><div class="line">    Map&lt;String, PriorityQueue&lt;String&gt;&gt; targets = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    <span class="keyword">for</span> (String[] ticket : tickets)</div><div class="line">        targets.computeIfAbsent(ticket[<span class="number">0</span>], k -&gt; <span class="keyword">new</span> PriorityQueue()).add(ticket[<span class="number">1</span>]);</div><div class="line">    List&lt;String&gt; route = <span class="keyword">new</span> LinkedList();</div><div class="line">    Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">    stack.push(<span class="string">"JFK"</span>);</div><div class="line">    <span class="keyword">while</span> (!stack.empty()) &#123;</div><div class="line">        <span class="keyword">while</span> (targets.containsKey(stack.peek()) &amp;&amp; !targets.get(stack.peek()).isEmpty())</div><div class="line">            stack.push(targets.get(stack.peek()).poll());</div><div class="line">        route.add(<span class="number">0</span>, stack.pop());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> route;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Matchsticks-to-Square">4.9. Matchsticks to Square</h2><h1 id="参考文献">5. 参考文献</h1><ol>
<li><a href="http://xiaokedada.com/2017/05/05/heap-algorithms/" target="_blank" rel="external">全排列的经典算法-heap’s algorithms</a></li>
<li><a href="http://zhouyichu.com/algorithm/Permutation-Generation-1/" target="_blank" rel="external">全排列算法part1</a></li>
<li><a href="https://segmentfault.com/a/1190000003766760" target="_blank" rel="external">[Leetcode] Permutation Sequence 全排列序列</a></li>
<li><a href="http://www.cnblogs.com/aprilcheny/p/4961412.html" target="_blank" rel="external">[LeetCode]76. Permutation Sequence全排列序列</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[算法-数组与数]]></title>
      <url>/2017/12/11/%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84%E4%B8%8E%E6%95%B0/</url>
      <content type="html"><![CDATA[<h1 id="大纲">1. 大纲</h1><ul>
<li>有序数组<ul>
<li>Merge两个有序数组<ul>
<li>将小数组归并到大数组里</li>
<li>两个数组的交集</li>
<li>数组点乘</li>
</ul>
</li>
</ul>
</li>
<li>子数组<ul>
<li>前缀和</li>
</ul>
</li>
<li>Two Sum<ul>
<li>Hash Map vs Two pointers</li>
</ul>
</li>
<li>Two Pointers</li>
</ul>
<a id="more"></a>
<h1 id="有序数组">2. 有序数组</h1><h2 id="例题1，Merge-Two-Sorted-Array">2.1. 例题1，Merge Two Sorted Array</h2><p>将两个有序数组合并，<code>A = [1,2,3,empty,empty],B = [4,5]</code>。将B合并到A里</p>
<p>思路：从最大的开始放</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> pos = m + n - <span class="number">1</span>;</div><div class="line">        --m;--n;</div><div class="line">        <span class="keyword">while</span> (m &gt;= <span class="number">0</span> &amp;&amp; n &gt;= <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(nums1[m] &gt; nums2[n])&#123;</div><div class="line">                nums1[pos] = nums1[m];</div><div class="line">                --m;</div><div class="line">            &#125;<span class="keyword">else</span> &#123;</div><div class="line">                nums1[pos] = nums2[n];</div><div class="line">                --n;</div><div class="line">            &#125;</div><div class="line">            --pos;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span>(n &gt;= <span class="number">0</span>)&#123;</div><div class="line">            nums1[pos] = nums2[n];</div><div class="line">            --n;</div><div class="line">            --pos;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="例题2，Intersection-of-Two-Arrays">2.2. 例题2，Intersection of Two Arrays</h2><p>求两个数组的交集</p>
<p>思路：先排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">代码</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</div><div class="line">        Arrays.sort(nums1);</div><div class="line">        Arrays.sort(nums2);</div><div class="line">        <span class="keyword">int</span> head1 = <span class="number">0</span>,head2 = <span class="number">0</span>;</div><div class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> counter = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (head1 &lt; nums1.length &amp;&amp; head2 &lt; nums2.length)&#123;</div><div class="line">            <span class="keyword">if</span>(nums1[head1] == nums2[head2])&#123;</div><div class="line">                result.add(nums1[head1]);</div><div class="line">                ++counter;</div><div class="line">                <span class="keyword">int</span> temp = nums1[head1];</div><div class="line">                <span class="keyword">while</span> (head1 &lt; nums1.length &amp;&amp; nums1[head1] == temp)&#123;</div><div class="line">                    ++head1;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">while</span> (head2 &lt; nums2.length &amp;&amp; nums2[head2] == temp)&#123;</div><div class="line">                    ++head2;</div><div class="line">                &#125;</div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums1[head1] &lt; nums2[head2])&#123;</div><div class="line">                ++head1;</div><div class="line">            &#125;<span class="keyword">else</span> &#123;</div><div class="line">                ++head2;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[] resArr = <span class="keyword">new</span> <span class="keyword">int</span>[counter];</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(Integer ele : result)&#123;</div><div class="line">            resArr[i] = ele;</div><div class="line">            ++i;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> resArr;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="Intersection-of-Two-Arrays-II">2.3. Intersection of Two Arrays II</h2><p>求两个数组的交集，交集不用去重</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</div><div class="line">        Arrays.sort(nums1);</div><div class="line">        Arrays.sort(nums2);</div><div class="line">        <span class="keyword">int</span> head1 = <span class="number">0</span>,head2 = <span class="number">0</span>;</div><div class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> counter = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (head1 &lt; nums1.length &amp;&amp; head2 &lt; nums2.length)&#123;</div><div class="line">            <span class="keyword">if</span>(nums1[head1] == nums2[head2])&#123;</div><div class="line">                result.add(nums1[head1]);</div><div class="line">                ++counter;</div><div class="line">                ++head1;</div><div class="line">                ++head2;</div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums1[head1] &lt; nums2[head2])&#123;</div><div class="line">                ++head1;</div><div class="line">            &#125;<span class="keyword">else</span> &#123;</div><div class="line">                ++head2;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[] resArr = <span class="keyword">new</span> <span class="keyword">int</span>[counter];</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(Integer ele : result)&#123;</div><div class="line">            resArr[i] = ele;</div><div class="line">            ++i;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> resArr;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>几个follow up:</p>
<ul>
<li>如果数组有序——那简直太完美了</li>
<li>如果nums1很短，怎样优化会好些？<ul>
<li>可以将nums1放在hash表里</li>
</ul>
</li>
<li>如果nums2存储在磁盘中，内存限制不能一次性读取全部，怎么办？<ul>
<li>如果只有nums2太大，那就把nums1放在一个hash表里，然后一块块读取nums2，依次匹配交集</li>
<li>如果两个数组都很大，那就只能先排序，然后再依次读取了</li>
</ul>
</li>
</ul>
<h2 id="例题3，点乘">2.4. 例题3，点乘</h2><p>数组内积（点乘）FOLLOW UP: 两个数组都非常大，但是其中都包含很多0</p>
<p>首先改变存储，因为0特别多，所以只存储非0元素的下标和数值。<br>计算内积的时候，只有下标都出现的数值相乘才有值，所以要计算两个数组的下标的交集，最后把值算出来。<br>所以本问题就转变成了求两个数组交的问题了。</p>
<h2 id="Sparse-Matrix-Multiplication">2.5. Sparse Matrix Multiplication</h2><p>求稀疏矩阵的乘法</p>
<p>然而这种方式依然很慢。其实直接遍历就可以了。我们知道一个 i x k 的矩阵A乘以一个 k x j 的矩阵B会得到一个 i x j 大小的矩阵C，那么我们来看结果矩阵中的某个元素<code>C[i][j]</code>是怎么来的，起始是<code>A[i][0]*B[0][j] + A[i][1]*B[1][j] + ... + A[i][k]*B[k][j]</code>，直观地写成代码就是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; row ; ++i)&#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j) &#123;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; A[<span class="number">0</span>].length ; ++k) &#123;</div><div class="line">                    result[i][j] += A[i][k]*B[k][j];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然而如果有很多0的话，必然会导致大量的0的乘法。这是会超时的。</p>
<p>就算我们这么写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; row ; ++i)&#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j) &#123;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; A[<span class="number">0</span>].length ; ++k) &#123;</div><div class="line">                    <span class="keyword">if</span>(A[i][k] != <span class="number">0</span> &amp;&amp; B[k][j] !=<span class="number">0</span>) &#123;</div><div class="line">                        result[i][j] += A[i][k] * B[k][j];</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>这虽然能过，但beats 1.75%，非常的慢。</p>
<p>那么为了不重复计算0乘0，我们将遍历顺序变一下。首先遍历A数组，要确保<code>A[i][k]</code>不为0，才继续计算，然后我们遍历B矩阵的第k行，如果<code>B[K][J]</code>不为0，我们累加结果矩阵<code>res[i][j] += A[i][k] * B[k][j]</code>; 这样我们就能高效的算出稀疏矩阵的乘法，参见代码如下：</p>
<p>哇快了有十倍！可以说是相当的机制了。</p>
<p>（仔细多想想，究竟省去了什么，才变得这么快？）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] multiply(<span class="keyword">int</span>[][] A, <span class="keyword">int</span>[][] B) &#123;</div><div class="line">        <span class="keyword">if</span>(A.length == <span class="number">0</span> || A[<span class="number">0</span>].length == <span class="number">0</span> || B.length == <span class="number">0</span> || B[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> row = A.length , col = B[<span class="number">0</span>].length ;</div><div class="line">        <span class="keyword">int</span>[][] result = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; row ; ++i)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; A[<span class="number">0</span>].length ; ++k) &#123; <span class="comment">// 先遍历k</span></div><div class="line">                <span class="keyword">if</span>(A[i][k] == <span class="number">0</span>) <span class="keyword">continue</span>;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j) &#123;</div><div class="line">                    <span class="keyword">if</span>(B[k][j] ==<span class="number">0</span>) <span class="keyword">continue</span>;</div><div class="line">                    result[i][j] += A[i][k] * B[k][j];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>另一种思路</strong>：借用上一题的思路，建立A的每行的非零元素和B的每列的非零元素的索引。然后再乘。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> val;</div><div class="line">        ListNode next;</div><div class="line">        ListNode(<span class="keyword">int</span> val)&#123;</div><div class="line">            <span class="keyword">this</span>.val = val;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] multiply(<span class="keyword">int</span>[][] A, <span class="keyword">int</span>[][] B) &#123;</div><div class="line">        <span class="keyword">if</span>(A.length == <span class="number">0</span> || A[<span class="number">0</span>].length == <span class="number">0</span> || B.length == <span class="number">0</span> || B[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        <span class="comment">// A - 某行不为0的index</span></div><div class="line">        ListNode[] index_A = <span class="keyword">new</span> ListNode[A.length];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; A.length ; ++i)&#123;</div><div class="line">            ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">            ListNode curr = dummy;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; A[i].length ; ++j)&#123;</div><div class="line">                <span class="keyword">if</span>(A[i][j] != <span class="number">0</span>) &#123;</div><div class="line">                    ListNode next = <span class="keyword">new</span> ListNode(j);</div><div class="line">                    curr.next = next;</div><div class="line">                    curr = next;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            index_A[i] = dummy.next;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// B - 某列不为0的index</span></div><div class="line">        ListNode[] index_B = <span class="keyword">new</span> ListNode[B[<span class="number">0</span>].length];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; B[<span class="number">0</span>].length ; ++j)&#123;</div><div class="line">            ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">            ListNode curr = dummy;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; B.length ; ++i)&#123;</div><div class="line">                <span class="keyword">if</span>(B[i][j] != <span class="number">0</span>)&#123;</div><div class="line">                    ListNode next = <span class="keyword">new</span> ListNode(i);</div><div class="line">                    curr.next = next;</div><div class="line">                    curr = next;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            index_B[j] = dummy.next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> row = A.length , col = B[<span class="number">0</span>].length ;</div><div class="line">        <span class="keyword">int</span>[][] result = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; row ; ++i)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; col ; ++j)&#123;</div><div class="line">                <span class="comment">// 求A的第i行 与 B的第j列 非零元素的和</span></div><div class="line">                result[i][j] = getSum(i,j,A,B,index_A,index_B);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> row,<span class="keyword">int</span> col, <span class="keyword">int</span>[][] A,<span class="keyword">int</span> [][] B, ListNode[] index_A, ListNode[] index_B)</span></span>&#123;</div><div class="line">        ListNode curr_A = index_A[row];</div><div class="line">        ListNode curr_B = index_B[col];</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != curr_A &amp;&amp; <span class="keyword">null</span> != curr_B)&#123;</div><div class="line">            <span class="keyword">if</span>(curr_A.val == curr_B.val)&#123;</div><div class="line">                sum += A[row][curr_A.val]*B[curr_A.val][col];</div><div class="line">                curr_A = curr_A.next;</div><div class="line">                curr_B = curr_B.next;</div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(curr_A.val &lt; curr_B.val)&#123;</div><div class="line">                curr_A = curr_A.next;</div><div class="line">            &#125;<span class="keyword">else</span> &#123;</div><div class="line">                curr_B = curr_B.next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="例题5，Kth-Largest-Element">2.6. 例题5，Kth Largest Element</h2><p>一个数组的第k大数</p>
<p>之前有一个实现方法，用堆。复杂度是$O(nlogk)$</p>
<p>这次使用快速选择，复杂度是$O(n)$</p>
<p>思路：</p>
<p><strong>快速选择</strong></p>
<ul>
<li><code>Quick select</code>算法因其高效和良好的average case时间复杂度而被广为应用。<code>Quick select</code>的average case时间复杂度为<code>O(n)</code>，然而其worst case时间复杂度为<code>O(n^2)</code>。</li>
<li>总体而言，<code>Quick select</code>采用和<code>Quick sort</code>类似的步骤。首先选定一个<code>pivot</code>，然后根据每个数字与该<code>pivot</code>的大小关系将整个数组分为两部分。那么与<code>Quick sort</code>不同的是，<code>Quick select</code>只考虑所寻找的目标所在的那一部分子数组，而非像<code>Quick sort</code>一样分别再对两边进行分割。正是因为如此，<code>Quick select</code>将平均时间复杂度从<code>O(nlogn)</code>降到了<code>O(n)</code>。</li>
</ul>
<p>步骤：</p>
<ol>
<li>从数列中挑出一个元素，称为”基准”（pivot）。</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。</li>
<li>判断第k个最小元素位于左侧还是右侧，然后对该侧进行递归。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div></pre></td><td class="code"><pre><div class="line">过程</div><div class="line">假设寻找第k=<span class="number">3</span>大的元素，也就是找第<span class="number">6</span>- <span class="number">3</span> + <span class="number">1</span>= <span class="number">4</span>小的元素 , 也就是<span class="number">7</span></div><div class="line"></div><div class="line">为了方便起见，我们下面的index都是从<span class="number">1</span>开始</div><div class="line"></div><div class="line">i              j</div><div class="line">↓              ↓</div><div class="line"><span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span></div><div class="line"><span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">4</span></div><div class="line">      </div><div class="line">    pivot = <span class="number">7</span></div><div class="line">  </div><div class="line">++i 两次</div><div class="line">   </div><div class="line">      i        j</div><div class="line"><span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">4</span></div><div class="line">  </div><div class="line">交换i,j，并++i,--j</div><div class="line"></div><div class="line">         i  j</div><div class="line"><span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span></div><div class="line"></div><div class="line">--j</div><div class="line">  </div><div class="line">      j  i</div><div class="line"><span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>  </div><div class="line">  </div><div class="line">总之，通过加加减减交换，以上数组变为</div><div class="line">      j  i</div><div class="line">      ↓  ↓</div><div class="line"><span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span></div><div class="line"><span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span></div><div class="line">      </div><div class="line">    pivot = <span class="number">7</span></div><div class="line"> </div><div class="line"> 此时j&lt;i，跳出<span class="keyword">while</span>循环</div><div class="line">此时:</div><div class="line">- [<span class="number">1</span>,j]的元素都小于pivot</div><div class="line">- [i,n]的元素都大于pivot</div><div class="line"> </div><div class="line"> 然后看第k小的元素是在左边还是右边：</div><div class="line"> - 如果在左边，那k &lt;= j</div><div class="line"> - 如果在右边，那k &gt;= i</div><div class="line"> 我们发现 k &gt;= i (<span class="number">4</span> &gt;= <span class="number">4</span>)，那就再在右边找：</div><div class="line">=====================================</div><div class="line">         i     j</div><div class="line">         ↓     ↓</div><div class="line"><span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span></div><div class="line"><span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span></div><div class="line">            </div><div class="line">          pivot = <span class="number">9</span></div><div class="line"> </div><div class="line"> 通过加加减减交换，以上数组变为</div><div class="line">            j  i</div><div class="line">            ↓  ↓</div><div class="line"><span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span></div><div class="line"><span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">9</span></div><div class="line">            </div><div class="line">          pivot = <span class="number">9</span></div><div class="line"> </div><div class="line"> 此时j&lt;i，跳出<span class="keyword">while</span>循环</div><div class="line"> </div><div class="line"> 然后看第k小的元素是在左边还是右边：</div><div class="line"> - 如果在左边，那k &lt;= j</div><div class="line"> - 如果在右边，那k &gt;= i</div><div class="line"> 我们发现 k &lt;= j (<span class="number">4</span> &lt;= <span class="number">5</span>)，那就继续向右边寻找</div><div class="line">=====================================</div><div class="line">           j,i</div><div class="line">            ↓ </div><div class="line"><span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span></div><div class="line"><span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">9</span></div><div class="line">  </div><div class="line">此时j == i ,直接输出<span class="number">7</span></div><div class="line"></div><div class="line"></div><div class="line">而在代码中，idx从<span class="number">0</span>开始，因此直接给k-<span class="number">1</span>即可</div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line">参考代码：</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthLargestElement</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] nums)</span></span>&#123;</div><div class="line">  <span class="keyword">return</span> quickSelece(nums,<span class="number">0</span>,nums.length - <span class="number">1</span>, nums.length - k + <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">quickSelect</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> k)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(start == end)&#123;</div><div class="line">      <span class="keyword">return</span> nums[start];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> mid = start + (end - start)/<span class="number">2</span>;</div><div class="line">  <span class="comment">// 1. 从数列中挑出一个元素，称为”基准”（pivot）</span></div><div class="line">  <span class="keyword">int</span> pivot = nums[mid];</div><div class="line">  </div><div class="line">  <span class="comment">// 2. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置</span></div><div class="line">  <span class="keyword">int</span> i = start, j = end;</div><div class="line">  <span class="keyword">while</span>(i &lt;= j)&#123;</div><div class="line">    <span class="comment">// nums[i]之前  &lt; pivot</span></div><div class="line">    <span class="keyword">while</span>(i &lt;= j &amp;&amp; nums[i] &lt; pivot)&#123;</div><div class="line">      i++;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// nums[j]之后 &gt; pivot</span></div><div class="line">    <span class="keyword">while</span>(i &lt;= j &amp;&amp; nums[j] &gt; pivot)&#123;</div><div class="line">      j--;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 此时nums[i] &gt; pivot ， nums[j] &lt; pivot，不符合“左边比pivot小，右边比pivot大”的原则，那么交换i，j    </span></div><div class="line">    <span class="keyword">if</span>(i &lt;= j)&#123;</div><div class="line">       <span class="comment">// 交换i,j</span></div><div class="line">       <span class="keyword">int</span> temp = nums[i];</div><div class="line">       nums[i] = nums[j];</div><div class="line">       nums[j] = temp;</div><div class="line">       i++;</div><div class="line">       j--;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 3. 判断第k个最小元素位于左侧还是右侧，然后对该侧进行递归</span></div><div class="line">  </div><div class="line">  <span class="comment">// 得到一个分割点-[j+1,i-1]</span></div><div class="line">  <span class="comment">//[start,j],[j+1,i-1],[i,end]</span></div><div class="line">  </div><div class="line">  <span class="comment">// start ~ j之前够k个数，直接在start~j之间找</span></div><div class="line">  <span class="keyword">if</span>(start + k - <span class="number">1</span> &lt;= j)&#123;</div><div class="line">  	<span class="keyword">return</span> quickSelect(nums, start, i, k);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// i ~ end之前不够k个数，在i之后找</span></div><div class="line">  <span class="keyword">if</span>(start + k - <span class="number">1</span> &gt;= i)&#123;</div><div class="line">  	<span class="keyword">return</span> quickSelect(nums, i, end, k - (i - start));</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// j + 1 ~ i - 1 要么只有一个数pivot,要么没有</span></div><div class="line">  <span class="comment">// 正好在中间</span></div><div class="line">  <span class="keyword">return</span> nums[j + <span class="number">1</span>];</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">代码：</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        <span class="keyword">return</span> quickSelect(<span class="number">0</span>,nums.length - <span class="number">1</span>,nums,nums.length - k);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">quickSelect</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(start == end)&#123; <span class="keyword">return</span> nums[start]; &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</div><div class="line">        <span class="comment">// 主元</span></div><div class="line">        <span class="keyword">int</span> pivot = nums[mid];</div><div class="line">        <span class="keyword">int</span> i = start,j = end;</div><div class="line">        <span class="keyword">while</span> (i &lt;= j)&#123;</div><div class="line">            <span class="keyword">while</span> (i &lt;= j &amp;&amp; nums[i] &lt; pivot)&#123;</div><div class="line">                ++i;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">while</span> (i &lt;= j &amp;&amp; nums[j] &gt; pivot)&#123;</div><div class="line">                --j;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(i &lt;= j)&#123;</div><div class="line">                <span class="comment">// swap i,j</span></div><div class="line">                <span class="keyword">int</span> temp = nums[i];</div><div class="line">                nums[i] = nums[j];</div><div class="line">                nums[j] = temp;</div><div class="line">                ++i;</div><div class="line">                --j;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// i之前的都比pivot小，j之后的都比pivot大</span></div><div class="line">        <span class="comment">//[start,j],[j+1,i-1],[i,end]</span></div><div class="line"></div><div class="line">        <span class="comment">//[start,j] 都比pivot小 | [i,end]都比pivot 大</span></div><div class="line">        </div><div class="line">        <span class="keyword">if</span>(k &lt;= j)&#123;</div><div class="line">            <span class="comment">// 第k小的数还在右边</span></div><div class="line">            <span class="keyword">return</span> quickSelect(start,j,nums,k);</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k &gt;= i)&#123;</div><div class="line">            <span class="comment">// 第k小的数在左边</span></div><div class="line">            <span class="keyword">return</span> quickSelect(i,end,nums,k);</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> pivot; <span class="comment">// 也是nums[j + 1]</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="例题6，Median-of-two-Sorted-Arrays">2.7. 例题6，Median of two Sorted Arrays</h2><p>两个排序数组的中位数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line">思路，先找Kth 小，与之前链表的题思路差不多</div><div class="line"></div><div class="line">A[k/<span class="number">2</span>] &lt;B[k/<span class="number">2</span>]  -&gt; 先丢掉前A[k/<span class="number">2</span>]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findKth</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> A_start, <span class="keyword">int</span>[] B, <span class="keyword">int</span> B_start, <span class="keyword">int</span> k)</span></span>&#123;</div><div class="line">	<span class="comment">//边界</span></div><div class="line">    <span class="keyword">if</span>(A_start &gt;= A.length)&#123;</div><div class="line">    	<span class="keyword">return</span> B[B_start + k - <span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(B_start &gt;= B.length)&#123;</div><div class="line">    	<span class="keyword">return</span> A[A_start + k - <span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 递归出口</span></div><div class="line">    <span class="keyword">if</span>( k == <span class="number">1</span>)&#123;</div><div class="line">    	<span class="keyword">return</span> Math.min(A[A,start], B_[B_start]);</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">	<span class="comment">// 拿到A和B的第k/2大的数</span></div><div class="line">	<span class="comment">// 骚操作：如果溢出了，就给一个MAX_VALUE,把机会自动让给另外一个</span></div><div class="line">	<span class="keyword">int</span> A_key = A_start + k/<span class="number">2</span> &lt;= A.length ? A[A_start + k/<span class="number">2</span> - <span class="number">1</span>] : Interger.MAX_VALUE;</div><div class="line">	<span class="keyword">int</span> B_key = B_start + k/<span class="number">2</span> &lt;= B.length ? B[B_start + k/<span class="number">2</span> - <span class="number">1</span>] : Interger.MAX_VALUE;</div><div class="line">	</div><div class="line">    <span class="keyword">if</span>(A_key &lt; B_key)&#123;</div><div class="line">    	<span class="keyword">return</span> findKth(A, start + k/<span class="number">2</span>, B, B_start, k - k/<span class="number">2</span>);</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">return</span> findKth(A, start, B, B_start + k/<span class="number">2</span>, k - k/<span class="number">2</span>);</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">这道题在二分法里面讲过了</div><div class="line"></div><div class="line">二刷！</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findKth</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> A_start, <span class="keyword">int</span>[] B, <span class="keyword">int</span> B_start, <span class="keyword">int</span> k)</span></span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(A_start &gt;= A.length)&#123;</div><div class="line">            <span class="keyword">return</span> B[B_start + k];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(B_start &gt;= B.length)&#123;</div><div class="line">            <span class="keyword">return</span> A[A_start + k];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">return</span> Math.min(A[A_start],B[B_start]);</div><div class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(A[A_start] &gt; B[B_start])&#123;</div><div class="line">                <span class="keyword">return</span> findKth(A,A_start,B,B_start+<span class="number">1</span>,<span class="number">0</span>);</div><div class="line">            &#125;<span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> findKth(A,A_start+<span class="number">1</span>,B,B_start,<span class="number">0</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(A_start + k/<span class="number">2</span> &gt;= A.length)&#123;</div><div class="line">            <span class="keyword">if</span>(A[A.length - <span class="number">1</span>] &gt; B[B_start + k/<span class="number">2</span>])&#123;</div><div class="line">                <span class="keyword">return</span> findKth(A,A_start,B,B_start + k/<span class="number">2</span>, k - k/<span class="number">2</span>);</div><div class="line">            &#125;<span class="keyword">else</span> &#123;</div><div class="line">                k -= A.length - A_start;</div><div class="line">                <span class="keyword">return</span> findKth(A,A.length,B,B_start,k);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(B_start + k/<span class="number">2</span> &gt;= B.length)&#123;</div><div class="line">            <span class="keyword">if</span>(B[B.length - <span class="number">1</span>] &gt; A[A_start + k/<span class="number">2</span>])&#123;</div><div class="line">                <span class="keyword">return</span> findKth(A,A_start + k/<span class="number">2</span>,B,B_start, k - k/<span class="number">2</span>);</div><div class="line">            &#125;<span class="keyword">else</span> &#123;</div><div class="line">                k -= B.length - B_start;</div><div class="line">                <span class="keyword">return</span> findKth(A,A_start,B,B.length,k);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(A[A_start + k/<span class="number">2</span>] &gt; B[B_start + k/<span class="number">2</span>])&#123;</div><div class="line">            <span class="keyword">return</span> findKth(A,A_start,B,B_start + k/<span class="number">2</span>, k - k/<span class="number">2</span>);</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> findKth(A,A_start + k/<span class="number">2</span>,B,B_start, k - k/<span class="number">2</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(nums1.length == <span class="number">0</span> &amp;&amp; nums2.length == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> total = nums1.length + nums2.length;</div><div class="line">        <span class="keyword">if</span>(total%<span class="number">2</span> == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">double</span> a = findKth(nums1,<span class="number">0</span>,nums2,<span class="number">0</span>,total/<span class="number">2</span> - <span class="number">1</span>);</div><div class="line">            <span class="keyword">double</span> b = findKth(nums1,<span class="number">0</span>,nums2,<span class="number">0</span>,total/<span class="number">2</span> );</div><div class="line">            <span class="keyword">return</span> (a + b)/<span class="number">2</span>;</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> findKth(nums1,<span class="number">0</span>,nums2,<span class="number">0</span>,total/<span class="number">2</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="Find-the-Duplicate-Number">2.8. Find the Duplicate Number</h2><p>给n+1个数，数的值为1~n。有且只有一个数有重复。返回这个重复的数。</p>
<p>思路：利用下标。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(nums.length &lt;= <span class="number">0</span>)<span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> idx;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i)&#123;</div><div class="line">            idx = Math.abs(nums[i]);</div><div class="line">            <span class="keyword">if</span>(nums[idx] &lt; <span class="number">0</span>)<span class="keyword">return</span> idx;</div><div class="line">            nums[idx] = -nums[idx];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="Remove-Duplicates-from-Sorted-Array-II">2.9. Remove Duplicates from Sorted Array II</h2><p>从数组中去除重复次数大于2的数字，并返回去重后的长度</p>
<p>边界条件啊！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(nums.length &lt;= <span class="number">2</span>) <span class="keyword">return</span> nums.length;</div><div class="line">    <span class="keyword">int</span> last = nums[<span class="number">0</span>];</div><div class="line">    <span class="keyword">int</span> lastCounter = <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> length = nums.length;</div><div class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; ++i)&#123;</div><div class="line">        <span class="keyword">if</span>(nums[i] == last)&#123;</div><div class="line">            ++lastCounter;</div><div class="line">            <span class="keyword">if</span>(lastCounter &gt; <span class="number">2</span>)&#123;</div><div class="line">                ++step;</div><div class="line">                --length;</div><div class="line">                --i;</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            last = nums[i];</div><div class="line">            lastCounter = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(i + <span class="number">1</span> + step &gt;= nums.length) <span class="keyword">break</span>;</div><div class="line">        nums[i + <span class="number">1</span>] = nums[i + <span class="number">1</span> + step];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> length;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>快慢指针！骚操作</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"> fast -- 第一个新的数字</div><div class="line"> slow -- 之前都是去重了的</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length &lt;= <span class="number">2</span>) &#123;</div><div class="line">            <span class="keyword">return</span> nums.length;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> slow = <span class="number">2</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> fast = <span class="number">2</span>; fast &lt; nums.length; fast++) &#123;</div><div class="line">            <span class="keyword">if</span>(nums[fast] != nums[slow-<span class="number">2</span>]) &#123;</div><div class="line">                nums[slow++] = nums[fast];</div><div class="line">            &#125;<span class="comment">// 当nums[fast]重复时，就跳过nums[fast]</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> slow;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h1 id="子数组问题">3. 子数组问题</h1><h2 id="例题7，Maximum-Subarray">3.1. 例题7，Maximum Subarray</h2><p>求一个数组的最大的连续子数组和。</p>
<p>转化：前缀和。最大子数组就是股票问题！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">sum[i] = sum(nums[<span class="number">0</span> ~ i])</div><div class="line">  </div><div class="line">sum[i~j] = sum[j] - sum[i]</div><div class="line"></div><div class="line">参考程序：</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] A)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(A == <span class="keyword">null</span> || A.length == <span class="number">0</span>)&#123;</div><div class="line">  	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> max = Integer.MIN_VALUE, sum = <span class="number">0</span>, minSum = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++)&#123;</div><div class="line">  	sum += A[i]; <span class="comment">// sum就是前缀和</span></div><div class="line">  	max = Math.max(max, sum - minSum);</div><div class="line">  	minSum = Math.min(minSum, sum); <span class="comment">// minSum就是当前i之前最小的前缀和</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> max;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">自己的另一种思路：</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> maxLast = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length ; ++i)&#123;</div><div class="line">            maxLast = Math.max(maxLast + nums[i],nums[i]);</div><div class="line">            max = Math.max(maxLast,max);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="例题8，二维数组的Maximum-Subarray">3.2. 例题8，二维数组的Maximum Subarray</h2><p>前缀和</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">  i-<span class="number">1</span>  i           x</div><div class="line">   *---*---*---*---*</div><div class="line">   |   |   |   |   |</div><div class="line">j-<span class="number">1</span>*---*---*---*---*</div><div class="line">   |   |   |   |   |</div><div class="line"> j *-[i,j]-*---*---*</div><div class="line">   |   |   |   |   |</div><div class="line">   *---*---*---*---*</div><div class="line">   |   |   |   |   |</div><div class="line">y  *---*---*---*-[x,y]</div><div class="line"></div><div class="line"></div><div class="line">sum[i,j - x,y] = sum[x,y] - sum[x,j-<span class="number">1</span>] - sum[i-<span class="number">1</span>,y] + sum[i-<span class="number">1</span>,j-<span class="number">1</span>]</div></pre></td></tr></table></figure>
<h2 id="Range-Sum-Query-2D-Immutable">3.3. Range Sum Query 2D - Immutable</h2><p>给一个二维数组，定义(row1,col1)到(row2,col2)的矩阵的和时sumRegion(row1,col1,row2,col2);求任意的两点之间的和。</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-14-16-59-04.png" alt=""> </p>
<p>样例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Given matrix = [</div><div class="line">  [3, 0, 1, 4, 2],</div><div class="line">  [5, 6, 3, 2, 1],</div><div class="line">  [1, 2, 0, 1, 5],</div><div class="line">  [4, 1, 0, 1, 7],</div><div class="line">  [1, 0, 3, 0, 5]</div><div class="line">]</div><div class="line"></div><div class="line">sumRegion(2, 1, 4, 3) -&gt; 8</div><div class="line">sumRegion(1, 1, 2, 2) -&gt; 11</div><div class="line">sumRegion(1, 2, 2, 4) -&gt; 12</div></pre></td></tr></table></figure>
<p>与样题思路差不多。先将sum存下来，然后再计算sumRegion</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span>[][] matrix;</div><div class="line">    <span class="keyword">int</span>[][] sum;</div><div class="line">    <span class="keyword">int</span> n;</div><div class="line">    <span class="keyword">int</span> m;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">this</span>.matrix = matrix;</div><div class="line">        n = matrix.length;</div><div class="line">        m = matrix[<span class="number">0</span>].length;</div><div class="line">        sum = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</div><div class="line">        <span class="comment">// 边界</span></div><div class="line">        sum[<span class="number">0</span>][<span class="number">0</span>] = matrix[<span class="number">0</span>][<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</div><div class="line">            sum[i][<span class="number">0</span>] = sum[i-<span class="number">1</span>][<span class="number">0</span>] + matrix[i][<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m; ++j)&#123;</div><div class="line">            sum[<span class="number">0</span>][j] = sum[<span class="number">0</span>][j-<span class="number">1</span>] + matrix[<span class="number">0</span>][j];</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 计算</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m; ++j)&#123;</div><div class="line">                sum[i][j] = sum[i-<span class="number">1</span>][j] + sum[i][j-<span class="number">1</span>] - sum[i-<span class="number">1</span>][j-<span class="number">1</span>] + matrix[i][j];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRegion</span><span class="params">(<span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(row1 == <span class="number">0</span> &amp;&amp; col1 == <span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> sum[row2][col2] ;</div><div class="line">        <span class="keyword">if</span>(row1 == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> sum[row2][col2]  - sum[row2][col1 - <span class="number">1</span>] ;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(col1 == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> sum[row2][col2]  - sum[row1 - <span class="number">1</span>][col2] ;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sum[row2][col2] - sum[row1 - <span class="number">1</span>][col2] - sum[row2][col1 - <span class="number">1</span>] + sum[row1-<span class="number">1</span>][col1-<span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Range-Sum-Query-2D-Mutable">3.4. Range Sum Query 2D - Mutable</h2><p>将上一题加一个条件，随时都有可能改变matrix中的某个值。</p>
<p>我们只需要加一个<code>public void update(int row, int col, int val)</code>即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> val)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> cha = val - matrix[row][col] ;</div><div class="line">        <span class="keyword">if</span>(cha == <span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line">        matrix[row][col] = val;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = row ; i &lt; n; ++i)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = col; j &lt; m; ++j)&#123;</div><div class="line">                sum[i][j] += cha;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="例题10，Minimum-Subarray">3.5. 例题10，Minimum Subarray</h2><p>最小子数组</p>
<p>转化：将所有数字取相反数，取最大即可</p>
<h2 id="Minimum-Size-Subarray-Sum">3.6. Minimum Size Subarray Sum</h2><p>给一个数组和一个s，求连续子数组和大于等于的最小长度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">我的思路：</div><div class="line"></div><div class="line"><span class="number">0</span>,<span class="number">1</span>,....,i,...,j</div><div class="line"></div><div class="line">对于每个j，从j到<span class="number">0</span>遍历i，当i-j的和大于等于s时，当前长度为j-i，与全局最小长度作比较，取最小值。</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; ++i)&#123;</div><div class="line">            nums[i] = nums[i-<span class="number">1</span>] + nums[i];</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// nums[i]表示[0,i-1]的和  </span></div><div class="line">        <span class="keyword">int</span> minLen = Integer.MAX_VALUE;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i)&#123;</div><div class="line">            <span class="keyword">if</span>(nums[i]  &gt;= s)&#123;</div><div class="line">                minLen = Math.min(i + <span class="number">1</span>, minLen);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i - <span class="number">1</span>; j&gt;= <span class="number">0</span>; --j)&#123;</div><div class="line">                <span class="keyword">if</span>(nums[i] - nums[j] &gt;= s)&#123;</div><div class="line">                    minLen = Math.min(minLen, i - j);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> minLen == Integer.MAX_VALUE ? <span class="number">0</span> : minLen;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>然而这种方式很慢，复杂度大约为$O(n^2)$</p>
<p>上面这种方式有一个二分法的优化，复杂度为$O(nlogn)$</p>
<p>以上代码中，<code>nums[i]</code>表示<code>[0,i-1]</code>的和。而原nums都是正数，因此nums是递增的。对于每一个i，用二分查找法找到子数组的右边界j的位置，使子数组<code>[i,j]</code>之和大于 s，然后我们更新最短长度的距离即可</p>
<p>然而，重点在于<code>sum[i,j] = nums[j]-nums[i-1]</code>，我们可以采取巧妙的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">nums[j] - nums[i - <span class="number">1</span>] &gt;= s</div><div class="line">          ↓ 变为</div><div class="line">nums[j] &gt;= s + nums[i-<span class="number">1</span>]</div></pre></td></tr></table></figure>
<p>即，只需要找一个<code>nums[j]</code>，使得它大于等于<code>s+nums[i-1]</code>即可！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>[] nums;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; ++i)&#123;</div><div class="line">            nums[i] = nums[i-<span class="number">1</span>] + nums[i];</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// nums[i]表示[0,i-1]的和</span></div><div class="line">        <span class="keyword">this</span>.nums = nums;</div><div class="line">        <span class="comment">// sum[x,y] = nums[y] - nums[x-1]</span></div><div class="line"></div><div class="line">        <span class="keyword">int</span> minLen = Integer.MAX_VALUE;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i)&#123;</div><div class="line">            <span class="comment">// 找一个nums[j]，使得它大于等于s+nums[i-1]</span></div><div class="line">            <span class="keyword">int</span> j = bitSearch(nums,i,nums.length - <span class="number">1</span>, s + getNums(i-<span class="number">1</span>));</div><div class="line">            minLen = Math.min(minLen, j - i + <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> minLen == Integer.MAX_VALUE ? <span class="number">0</span> : minLen;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getNums</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(i == -<span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> nums[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">bitSearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> target)</span></span>&#123;</div><div class="line">        <span class="comment">// 寻找nums[i]，使它大于target</span></div><div class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end)&#123;</div><div class="line">            <span class="keyword">int</span> mid = start + (end - start)/<span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span>(getNums(mid) &gt;= target)&#123;</div><div class="line">                end = mid;</div><div class="line">            &#125;<span class="keyword">else</span> &#123;</div><div class="line">                start = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(getNums(start) &gt;= target) <span class="keyword">return</span> start;</div><div class="line">        <span class="keyword">if</span>(getNums(end) &gt;= target) <span class="keyword">return</span> end;</div><div class="line">        <span class="keyword">return</span> Integer.MAX_VALUE;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>居然还有更骚的操作：滑动窗口解法，复杂度为$O(n)$</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> minLen = Integer.MAX_VALUE;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> windowSum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (j &lt; nums.length)&#123;</div><div class="line">            <span class="keyword">while</span>(j &lt; nums.length &amp;&amp; windowSum &lt; s)&#123;</div><div class="line">                windowSum += nums[j];</div><div class="line">                ++j;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; s &gt;= windowSum)&#123;</div><div class="line">                minLen = Math.min(minLen, j - i + <span class="number">1</span>);</div><div class="line">                windowSum -= nums[i];</div><div class="line">                ++i;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> minLen == nums.length + <span class="number">1</span> ? <span class="number">0</span> : minLen;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="例题11，Maximum-Subarray-II">3.7. 例题11，Maximum Subarray II</h2><p>求两个不重叠子数组，使他们和最大</p>
<p>思路：一条分割线，求左右的最大maxSub，然后相加。然后求全局的最大。</p>
<p>优化：移动的时候，左边的maxArray并不需要重新计算！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxTwoSubArrays</span><span class="params">(List&lt;Integer&gt; nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == nums)<span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> n = nums.size();</div><div class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> nums.get(<span class="number">0</span>);</div><div class="line">        <span class="keyword">int</span>[] maxBefore = <span class="keyword">new</span> <span class="keyword">int</span>[n];</div><div class="line">        maxBefore[<span class="number">0</span>] = nums.get(<span class="number">0</span>);</div><div class="line">        <span class="keyword">int</span> lastMax = maxBefore[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</div><div class="line">            <span class="comment">// 计算[0,i]的最大和</span></div><div class="line">            lastMax = Math.max(lastMax + nums.get(i), nums.get(i));</div><div class="line">            maxBefore[i] = Math.max(maxBefore[i-<span class="number">1</span>],lastMax);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[] maxAfter = <span class="keyword">new</span> <span class="keyword">int</span>[n];</div><div class="line">        maxAfter[n-<span class="number">1</span>] = nums.get(n-<span class="number">1</span>);</div><div class="line">        lastMax = maxAfter[n-<span class="number">1</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span> ; --i)&#123;</div><div class="line">            <span class="comment">// 计算[i,n]的最大和</span></div><div class="line">            lastMax = Math.max(lastMax + nums.get(i), nums.get(i));</div><div class="line">            maxAfter[i] = Math.max(maxAfter[i+<span class="number">1</span>],lastMax);</div><div class="line">        &#125;</div><div class="line">  		<span class="comment">// 求全局最大</span></div><div class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i)&#123;</div><div class="line">            max = Math.max(max, maxBefore[i] + maxAfter[i+<span class="number">1</span>]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="例题12，Max-Subarray-Difference">3.8. 例题12，Max Subarray Difference</h2><p>求两个不重叠子数组，使他们绝对值最大</p>
<p>与上一题思路相似</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDiffSubArrays</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> n = nums.length;</div><div class="line">        <span class="keyword">int</span>[] maxBefore = <span class="keyword">new</span> <span class="keyword">int</span>[n];</div><div class="line">        <span class="keyword">int</span>[] minBefore = <span class="keyword">new</span> <span class="keyword">int</span>[n];</div><div class="line">        maxBefore[<span class="number">0</span>] = nums[<span class="number">0</span>];</div><div class="line">        minBefore[<span class="number">0</span>] = nums[<span class="number">0</span>];</div><div class="line">        <span class="keyword">int</span> lastMax = nums[<span class="number">0</span>];</div><div class="line">        <span class="keyword">int</span> lastMin = nums[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n ; ++i)&#123;</div><div class="line">            <span class="comment">// [0,i]的最大和、最小和</span></div><div class="line">            lastMax = Math.max(lastMax + nums[i], nums[i]);</div><div class="line">            lastMin = Math.min(lastMin + nums[i], nums[i]);</div><div class="line">            maxBefore[i] = Math.max(maxBefore[i-<span class="number">1</span>] , lastMax);</div><div class="line">            minBefore[i] = Math.min(minBefore[i-<span class="number">1</span>] , lastMin);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span>[] maxAfter = <span class="keyword">new</span> <span class="keyword">int</span>[n];</div><div class="line">        <span class="keyword">int</span>[] minAfter = <span class="keyword">new</span> <span class="keyword">int</span>[n];</div><div class="line">        maxAfter[n-<span class="number">1</span>] = nums[n-<span class="number">1</span>];</div><div class="line">        minAfter[n-<span class="number">1</span>] = nums[n-<span class="number">1</span>];</div><div class="line">        lastMax = nums[n-<span class="number">1</span>];</div><div class="line">        lastMin = nums[n-<span class="number">1</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)&#123;</div><div class="line">            <span class="comment">// [i,n]的最大和、最小和</span></div><div class="line">            lastMax = Math.max(lastMax + nums[i], nums[i]);</div><div class="line">            lastMin = Math.min(lastMin + nums[i], nums[i]);</div><div class="line">            maxAfter[i] = Math.max(maxAfter[i+<span class="number">1</span>] , lastMax);</div><div class="line">            minAfter[i] = Math.min(minAfter[i+<span class="number">1</span>] , lastMin);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 全局最大差</span></div><div class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i)&#123;</div><div class="line">            max = Math.max(max,</div><div class="line">                    Math.abs(maxBefore[i] - minAfter[i+<span class="number">1</span>]));</div><div class="line">            max = Math.max(max,</div><div class="line">                    Math.abs(minBefore[i] - maxAfter[i+<span class="number">1</span>]));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="例题13，Subarray-Sum">3.9. 例题13，Subarray Sum</h2><p>求一个子数组的和为0的子数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">一开始思路很暴力，就直接用前缀数组来求每个sum[i,j]，然后与<span class="number">0</span>比较。然而，超时了</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> n = nums.length;</div><div class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> result;</div><div class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>] == <span class="number">0</span>) &#123;</div><div class="line">            result.add(<span class="number">0</span>);result.add(<span class="number">0</span>);</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; ++i)&#123;</div><div class="line">            nums[i] += nums[i-<span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n-<span class="number">1</span>; i &gt;=<span class="number">0</span> ; --i)&#123;</div><div class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</div><div class="line">                result.add(<span class="number">0</span>);result.add(i);</div><div class="line">                <span class="keyword">return</span> result;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n; ++j)&#123;</div><div class="line">                <span class="comment">// sum[i,j]</span></div><div class="line">                <span class="keyword">if</span>(nums[j] - nums[i-<span class="number">1</span>] == <span class="number">0</span>)&#123;</div><div class="line">                    result.add(i);</div><div class="line">                    result.add(j);</div><div class="line">                    <span class="keyword">return</span> result;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>改进：哈希表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">根据给的例子：[-<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, -<span class="number">3</span>, <span class="number">4</span>]，其累加和:</div><div class="line"></div><div class="line">nums [-<span class="number">3</span>, <span class="number">1</span>,  <span class="number">2</span>, -<span class="number">3</span>,  <span class="number">4</span>]</div><div class="line">      <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span></div><div class="line">sum [-<span class="number">3</span>，-<span class="number">2</span>， <span class="number">0</span>， -<span class="number">3</span>， <span class="number">1</span>]</div><div class="line">      i           j</div><div class="line"><span class="number">1</span>. i=<span class="number">2</span>出现了一个数<span class="number">0</span> -&gt; sum[<span class="number">0</span>,i] = <span class="number">0</span>  ,是一个答案</div><div class="line"></div><div class="line"><span class="number">2</span>. 同时在i,j发现两个-<span class="number">3</span>   -&gt; sum[i+<span class="number">1</span>,j] = <span class="number">0</span> ,是一个答案</div><div class="line"></div><div class="line">代码：</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> n = nums.length;</div><div class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> result;</div><div class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>] == <span class="number">0</span>) &#123;</div><div class="line">            result.add(<span class="number">0</span>);result.add(<span class="number">0</span>);</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">        HashMap&lt;Integer,Integer&gt; set = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        set.put(nums[<span class="number">0</span>],<span class="number">0</span>);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; ++i)&#123;</div><div class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</div><div class="line">                result.add(i);result.add(i);</div><div class="line">                <span class="keyword">return</span> result;</div><div class="line">            &#125;</div><div class="line">            nums[i] += nums[i-<span class="number">1</span>];</div><div class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</div><div class="line">                result.add(<span class="number">0</span>);result.add(i);</div><div class="line">                <span class="keyword">return</span> result;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(set.containsKey(nums[i]))&#123;</div><div class="line">                result.add(set.get(nums[i]) + <span class="number">1</span>);</div><div class="line">                result.add(i);</div><div class="line">                <span class="keyword">return</span> result;</div><div class="line">            &#125;</div><div class="line">            set.put(nums[i],i);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>##例题14， Subarray Sum Closest</p>
<p>求一个数组的子数组最接近0的子数组</p>
<p>一开始想法依然很暴力，但超时了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] subarraySumClosest(<span class="keyword">int</span>[] nums) &#123;</div><div class="line">        <span class="keyword">int</span> n = nums.length;</div><div class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</div><div class="line">        <span class="keyword">int</span> min = Math.abs(nums[<span class="number">0</span>]);</div><div class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> ans;</div><div class="line">        <span class="comment">// 计算前缀和</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</div><div class="line">            nums[i] += nums[i-<span class="number">1</span>];</div><div class="line">            <span class="comment">// [0,i]时</span></div><div class="line">            <span class="keyword">if</span>(Math.abs(nums[i]) &lt; min)&#123;</div><div class="line">                min = Math.abs(nums[i]);</div><div class="line">                ans[<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">                ans[<span class="number">1</span>] = i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 计算</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</div><div class="line">            <span class="comment">// [i,j]时</span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n; ++j)&#123;</div><div class="line">                <span class="keyword">if</span>(Math.abs(nums[j] - nums[i-<span class="number">1</span>]) &lt; min)&#123;</div><div class="line">                    min = Math.abs(nums[j] - nums[i-<span class="number">1</span>]);</div><div class="line">                    ans[<span class="number">0</span>] = i;</div><div class="line">                    ans[<span class="number">1</span>] = j;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ans;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>思路：对前缀和排序，然后for</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PreSum</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">PreSum</span>&gt;</span>&#123;</div><div class="line">        <span class="keyword">int</span> sum;</div><div class="line">        <span class="keyword">int</span> idx;</div><div class="line">        PreSum(<span class="keyword">int</span> sum, <span class="keyword">int</span> idx)&#123;</div><div class="line">            <span class="keyword">this</span>.sum = sum;</div><div class="line">            <span class="keyword">this</span>.idx = idx;</div><div class="line">        &#125;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(PreSum o)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.sum - o.sum;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] subarraySumClosest(<span class="keyword">int</span>[] nums) &#123;</div><div class="line">        <span class="keyword">int</span> n = nums.length;</div><div class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</div><div class="line">        PreSum[] preSum = <span class="keyword">new</span> PreSum[n]; <span class="comment">// 存放前缀和</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span> ans;</div><div class="line">        <span class="comment">// 计算前缀和</span></div><div class="line">        <span class="keyword">int</span> sum = nums[<span class="number">0</span>];</div><div class="line">        preSum[<span class="number">0</span>] = <span class="keyword">new</span> PreSum(sum,<span class="number">0</span>);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</div><div class="line">            sum += nums[i];</div><div class="line">            preSum[i] = <span class="keyword">new</span> PreSum(sum,i);</div><div class="line">        &#125;</div><div class="line">        Arrays.sort(preSum);</div><div class="line">        <span class="keyword">int</span> min = Math.abs(nums[<span class="number">0</span>]);</div><div class="line">        <span class="comment">//ans[0] = 0;ans[1] = 0;</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n; ++i)&#123;</div><div class="line">            <span class="keyword">if</span>(min &gt; preSum[i].sum - preSum[i-<span class="number">1</span>].sum)&#123;</div><div class="line">                min = preSum[i].sum - preSum[i-<span class="number">1</span>].sum;</div><div class="line">                ans[<span class="number">0</span>] = preSum[i-<span class="number">1</span>].idx;</div><div class="line">                ans[<span class="number">1</span>] = preSum[i].idx;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 将idx大的放后面，小的放前面</span></div><div class="line">        <span class="keyword">if</span>(ans[<span class="number">0</span>] &gt; ans[<span class="number">1</span>])&#123;</div><div class="line">            <span class="keyword">int</span> temp = ans[<span class="number">0</span>];</div><div class="line">            ans[<span class="number">0</span>] = ans[<span class="number">1</span>];</div><div class="line">            ans[<span class="number">1</span>] = temp;</div><div class="line">        &#125;</div><div class="line">        ans[<span class="number">0</span>] += <span class="number">1</span>;</div><div class="line">        <span class="keyword">return</span> ans;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="Contiguous-Array">3.10. Contiguous Array</h2><p>给一个数组，元素是1或0。求子数组的最大长度。要求子数组的1和0个数相等。</p>
<p>思路一：（会超memory)</p>
<p>如果[i,j]的1和0个数相等，则sum(i,j) *2 = j - i +1</p>
<p> 用<code>dp[i][j]</code>存储子数组<code>[i,j]</code>是否是1和0个数相等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>[][] dp;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(end == start) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span>(dp[start][end] != <span class="number">0</span>) <span class="keyword">return</span> dp[start][end];</div><div class="line">        <span class="keyword">int</span> sum; <span class="comment">// sum[start,end]</span></div><div class="line">        <span class="keyword">if</span>(start == <span class="number">0</span>)&#123;</div><div class="line">            sum = nums[end];</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            sum = nums[end] - nums[start - <span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> n = end - start + <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span>(n%<span class="number">2</span> == <span class="number">0</span> &amp;&amp; sum*<span class="number">2</span> == n)&#123;</div><div class="line">            dp[start][end] = n;</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            dp[start][end] = Math.max(find(nums,start+<span class="number">1</span>,end),</div><div class="line">                    find(nums,start,end-<span class="number">1</span>));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dp[start][end];</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length][nums.length];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; ++i)&#123;</div><div class="line">            nums[i] += nums[i-<span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> find(nums,<span class="number">0</span>,nums.length - <span class="number">1</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>思路二，骚操作：</p>
<p>将0替换为-1.那这道题就转化为了求最长子数组，子数组和为0。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i)&#123;</div><div class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)nums[i] = -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        HashMap&lt;Integer,Integer&gt; hash = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> maxLenth = <span class="number">0</span>;</div><div class="line">        hash.put(<span class="number">0</span>,-<span class="number">1</span>);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i)&#123;</div><div class="line">            sum += nums[i];</div><div class="line">            <span class="keyword">if</span>(hash.containsKey(sum))&#123;</div><div class="line">                maxLenth = Math.max(maxLenth,</div><div class="line">                        Math.abs(i - hash.get(sum)));</div><div class="line">            &#125;<span class="keyword">else</span> &#123;</div><div class="line">              <span class="comment">// 注意这里，只有不存在时才添加（因为要保留第一个idx）</span></div><div class="line">                hash.put(sum, i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxLenth;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="Longest-Continuous-Increasing-Subsequence">3.11. Longest Continuous Increasing Subsequence</h2><p>求数组的最长连续递增子数组</p>
<p>思路：灰常简单，直接遍历就好</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == nums || nums.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> max = <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> curr = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; ++i)&#123;</div><div class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i-<span class="number">1</span>])&#123;</div><div class="line">                ++curr;</div><div class="line">                max = Math.max(max,curr);</div><div class="line">            &#125;<span class="keyword">else</span> &#123;</div><div class="line">                curr = <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="Degree-of-an-Array">3.12. Degree of an Array</h2><p>给一个数组，求最多出现的那个元素的最短连续子数组。</p>
<p>思路：建立一个Node，其中存每个元素第一次出现的位置、最后一次出现的位置、出现次数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> idx0;<span class="comment">// 第一次出现的位置</span></div><div class="line">        <span class="keyword">int</span> idxn; <span class="comment">// 最后一次出现的位置</span></div><div class="line">        <span class="keyword">int</span> counter; <span class="comment">// 出现次数</span></div><div class="line">        Node(<span class="keyword">int</span> idx0)&#123;</div><div class="line">            <span class="keyword">this</span>.idx0 = idx0;</div><div class="line">            counter = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findShortestSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums.length;</div><div class="line">        HashMap&lt;Integer,Node&gt; hash = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> maxCounter = <span class="number">1</span>; <span class="comment">// 最多出现的元素的出现次数</span></div><div class="line">        <span class="keyword">int</span> minLength = Integer.MAX_VALUE; <span class="comment">// 返回值</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i)&#123;</div><div class="line">            <span class="keyword">if</span>(hash.containsKey(nums[i]))&#123;</div><div class="line">                Node curr = hash.get(nums[i]);</div><div class="line">                curr.counter ++;</div><div class="line">                curr.idxn = i;</div><div class="line">                <span class="keyword">if</span>(curr.counter &gt; maxCounter)&#123;</div><div class="line">                    minLength = i - curr.idx0 + <span class="number">1</span>;</div><div class="line">                    maxCounter = curr.counter;</div><div class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(curr.counter == maxCounter)&#123;</div><div class="line">                    minLength = Math.min(minLength,</div><div class="line">                            i - curr.idx0 + <span class="number">1</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;<span class="keyword">else</span> &#123;</div><div class="line">                Node curr = <span class="keyword">new</span> Node(i);</div><div class="line">                hash.put(nums[i],curr);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> minLength == Integer.MAX_VALUE ? <span class="number">1</span> : minLength;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="Maximum-Product-Subarray">3.13. Maximum Product Subarray</h2><p>求数组的最大子数组积</p>
<p>思路一：（<strong>最后一个样例超memory了</strong>）</p>
<p>按照老方法，申请一个数组<code>prod[]</code>，其中<code>prod[i]</code>表示<code>[0,i]</code>的乘积。但是<code>[0,i]</code>中可能存在0，因此不太可行。变化一下方式，如果<code>nums[k]==0</code>，那么<code>prod[i] = [k+1,i]的乘积</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>)<span class="keyword">return</span> nums[<span class="number">0</span>];</div><div class="line">        <span class="keyword">int</span>[] prod = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</div><div class="line">        prod[<span class="number">0</span>] = nums[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; ++i)&#123;</div><div class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</div><div class="line">                prod[i] = <span class="number">0</span>;</div><div class="line">            &#125;<span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span>(prod[i-<span class="number">1</span>] == <span class="number">0</span> )&#123;</div><div class="line">                    prod[i]  = <span class="number">1</span> * nums[i];</div><div class="line">                &#125;<span class="keyword">else</span> &#123;</div><div class="line">                    prod[i]  = prod[i-<span class="number">1</span>] * nums[i];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> max = prod[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; ++i)&#123;</div><div class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</div><div class="line">                max = Math.max(<span class="number">0</span>,max);</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            max = Math.max(prod[i],max);</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; nums.length; ++j)&#123;</div><div class="line">                <span class="keyword">if</span>(nums[j] ==<span class="number">0</span>)&#123;</div><div class="line">                    max = Math.max(<span class="number">0</span>,max);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(nums[i-<span class="number">1</span>] == <span class="number">0</span>)&#123;</div><div class="line">                    max = Math.max(prod[j],max);</div><div class="line">                &#125;<span class="keyword">else</span> &#123;</div><div class="line">                    max = Math.max(prod[j]/prod[i-<span class="number">1</span>], max);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>思路二：动态规划，可以说是相当机智了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">- 用数组positive_max[i]维护原始数组前i个数的子数组乘积中正数的最大值</div><div class="line">- 用数组negative_min[i]维护原始数组前i个数的子数组乘积中负数的最小值</div><div class="line"></div><div class="line">状态转移方程为：</div><div class="line"></div><div class="line"><span class="keyword">if</span> A[x] &gt; <span class="number">0</span>:</div><div class="line">	<span class="comment">// 如果pos_max[x-1] == 0,那pos_max[x] = A[x]</span></div><div class="line">    <span class="comment">// 否则，pos_max[x] = positive_max[x - 1] * A[x]</span></div><div class="line">	positive_max[x] = max(positive_max[x - <span class="number">1</span>] * A[x], A[x])</div><div class="line">    <span class="comment">// 如果neg_min[x-1] == 0，那neg_min[x] = 0</span></div><div class="line">    <span class="comment">// 否则，neg_min = negative_min[x - 1] * A[x]</span></div><div class="line">	negative_min[x] = negative_min[x - <span class="number">1</span>] * A[x]</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> A[x] &lt; <span class="number">0</span>:</div><div class="line">	positive_max[x] = negative_min[x - <span class="number">1</span>] * A[x]</div><div class="line">	negative_min[x] = min(positive_max[x - <span class="number">1</span>] * A[x], A[x])</div><div class="line">      </div><div class="line">      </div><div class="line">代码：</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>)<span class="keyword">return</span> nums[<span class="number">0</span>];</div><div class="line"></div><div class="line">        <span class="keyword">int</span>[] pos_max = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</div><div class="line">        <span class="keyword">int</span>[] neg_min = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</div><div class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>] &gt; <span class="number">0</span>)&#123;</div><div class="line">            pos_max[<span class="number">0</span>] = nums[<span class="number">0</span>];</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            neg_min[<span class="number">0</span>] = nums[<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> max = nums[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; ++i)&#123;</div><div class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>)&#123;</div><div class="line">                pos_max[i] = Math.max(pos_max[i-<span class="number">1</span>]*nums[i], nums[i]);</div><div class="line">                neg_min[i] = neg_min[i-<span class="number">1</span>] * nums[i];</div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &lt; <span class="number">0</span>)&#123;</div><div class="line">                pos_max[i] = neg_min[i-<span class="number">1</span>] * nums[i];</div><div class="line">                neg_min[i] = Math.min(pos_max[i-<span class="number">1</span>]*nums[i],nums[i]);</div><div class="line">            &#125;<span class="keyword">else</span> &#123;</div><div class="line">                pos_max[i] = <span class="number">0</span>;</div><div class="line">                neg_min[i] = <span class="number">0</span>;</div><div class="line">                max = Math.max(max, <span class="number">0</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(pos_max[i] &gt; <span class="number">0</span>)&#123;</div><div class="line">                max = Math.max(max, pos_max[i]);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line"></div><div class="line">其实我们可以用更简便的方式，将Pos_max 与 neg_min 压缩：</div><div class="line"></div><div class="line">我们只需要在维护一个局部最大的同时，在维护一个局部最小，这样如果下一个元素遇到负数时，就有可能与这个最小相乘得到当前最大的乘积和，这也是利用乘法的性质得到的。</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;  </div><div class="line">    <span class="keyword">if</span>(A==<span class="keyword">null</span> || A.length==<span class="number">0</span>)  </div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </div><div class="line">    <span class="keyword">if</span>(A.length == <span class="number">1</span>)  </div><div class="line">        <span class="keyword">return</span> A[<span class="number">0</span>];  </div><div class="line">    <span class="keyword">int</span> max_local = A[<span class="number">0</span>];  </div><div class="line">    <span class="keyword">int</span> min_local = A[<span class="number">0</span>];  </div><div class="line">    <span class="keyword">int</span> global = A[<span class="number">0</span>];  </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;A.length;i++)  </div><div class="line">    &#123;  </div><div class="line">        <span class="keyword">int</span> max_copy = max_local;  </div><div class="line">        max_local = Math.max(Math.max(A[i]*max_local, A[i]), A[i]*min_local);  </div><div class="line">        min_local = Math.min(Math.min(A[i]*max_copy, A[i]), A[i]*min_local);  </div><div class="line">        global = Math.max(global, max_local);  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> global;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Product-of-Array-Except-Self">3.14. Product of Array Except Self</h2><p>给一个数。令每个元素等于除了本元素的所有的乘积。求输出。</p>
<p>主要注意：一旦本位为0，就会影响到后面！</p>
<p>思路一：同时考虑一下有几个0.</p>
<p>如果只有1个0，那么只有0位的值为其它元素的乘积。其它位都为0.</p>
<p>如果有大于等于两个0，那每一位都是0.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</div><div class="line">        <span class="keyword">long</span> allProdcut = <span class="number">1L</span>;</div><div class="line">        <span class="keyword">int</span> zero = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i)&#123;</div><div class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</div><div class="line">                ++zero;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            allProdcut *= nums[i];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i)&#123;</div><div class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</div><div class="line">                <span class="keyword">if</span>(zero == <span class="number">1</span>) nums[i] = (<span class="keyword">int</span>)allProdcut;</div><div class="line">            &#125;<span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (zero &gt; <span class="number">0</span>) nums[i] = <span class="number">0</span>;</div><div class="line">                <span class="keyword">else</span> nums[i] = (<span class="keyword">int</span>) allProdcut / nums[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> nums;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>思路二：骚操作</p>
<p>数组的乘积由左边部分的乘积和右边部分的乘积 乘起来得到！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> n = nums.length;</div><div class="line"><span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</div><div class="line"><span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> res;</div><div class="line"></div><div class="line">res[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 记录每个元素左边的乘积</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n; ++i)&#123;</div><div class="line">  res[i] = res[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>];</div><div class="line">&#125;</div><div class="line"><span class="keyword">int</span> r = <span class="number">1</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = n - <span class="number">2</span>; j &gt;= <span class="number">0</span>; --j)&#123;</div><div class="line">  r *= nums[j + <span class="number">1</span>]; <span class="comment">// j右边的乘积</span></div><div class="line">  res[j] *= r; <span class="comment">// 左边乘以右边</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> res;</div></pre></td></tr></table></figure>
<h2 id="Container-With-Most-Water">3.15. Container With Most Water</h2><p>给一个非负整数数组，其中元素代表挡板的高度。求某两个挡板，使挡板之间能够乘的水最多。</p>
<p>思路：这道题其实用了一点贪心的思路。</p>
<p>思考公式$min(a_i,a_j)\times(j-i)$ 。若 a[l] &lt; a[r]，只能通过增加二者中较小的a[l]来增加面积，因为j – i已经是目前能达到的最大值了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</div><div class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = height.length - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (low &lt; high)&#123;</div><div class="line">            <span class="keyword">if</span>(height[low] &lt; height[high])&#123;</div><div class="line">                max = Math.max(max, height[low]*(high - low));</div><div class="line">                ++low;</div><div class="line">            &#125;<span class="keyword">else</span> &#123;</div><div class="line">                max = Math.max(max, height[high] * (high - low));</div><div class="line">                --high;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="Array-Nesting">3.16. Array Nesting</h2><p>给n个点，数组的$A[i]$ 表示边$(i,A[i])$。 问此图最长的环有多长。</p>
<p>思路：一开始没有理清题意。其实这道题很简单哇。哎。</p>
<p>用$O(n)$的时间！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arrayNesting</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums.length;</div><div class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i)&#123;</div><div class="line">            <span class="keyword">int</span> idx = i;</div><div class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</div><div class="line">            <span class="keyword">while</span> (nums[idx] &gt;= <span class="number">0</span>)&#123;</div><div class="line">                <span class="keyword">int</span> idx_next = nums[idx];</div><div class="line">                nums[idx] = -<span class="number">1</span>; <span class="comment">// 标记为已访问</span></div><div class="line">                idx = idx_next;</div><div class="line">                ++len;</div><div class="line">            &#125;</div><div class="line">            max = Math.max(max, len);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="Find-Pivot-Index">3.17. Find Pivot Index</h2><p>给一个数组。寻找一个idx，使得它左边的和等于它右边的和。如果不存在，返回-1。</p>
<p>思路：一个个遍历求leftSum和rightSum就好。</p>
<p>注意边界条件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pivotIndex</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(nums.length &lt;= <span class="number">3</span>) <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> rightSum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; ++i) rightSum += nums[i];</div><div class="line">    <span class="keyword">if</span>(rightSum == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> leftSum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; ++i)&#123;</div><div class="line">        leftSum += nums[i];</div><div class="line">        rightSum -= nums[i+<span class="number">1</span>];</div><div class="line">        <span class="keyword">if</span>(leftSum == rightSum)&#123;</div><div class="line">            <span class="keyword">return</span> i+<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="股票问题">4. 股票问题</h1><h2 id="例题9，Best-Time-to-Buy-and-Sell-Time">4.1. 例题9，Best Time to Buy and Sell Time</h2><p><strong>方案一，动态规划法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">动态规划法。从前向后遍历数组，记录当前出现过的最低价格，作为买入价格，并计算以当天价格出售的收益，作为可能的最大收益，整个遍历过程中，出现过的最大收益就是所求</div><div class="line"></div><div class="line">sell[i]  第i天卖出赚的最多的钱 = price[i] - min</div><div class="line"></div><div class="line">代码：</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; ++i)&#123;</div><div class="line">            min = Math.min(min, prices[i]);</div><div class="line">            max = Math.max(max, prices[i] - min);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>股票问题是一系列的问题。我实在是太笨了。现在翻译一下大神的解答好了。</p>
<p><strong>方案二，通用解法</strong></p>
<p>定义如下符号：</p>
<ul>
<li><code>prices</code> 长度为<code>n</code></li>
<li><code>k</code> 代表最大允许的买入次数</li>
<li><code>T[i][k]</code> ： 在第i天结束时，通过至多k次交易后，的最大利润。</li>
</ul>
<p>很容易得出初始化<code>T[-1][k]=T[i][0]=0</code>（没有股票或没有交易时的利润）</p>
<p>同时，第i天都可以——买入、卖出、休息。而且题目要求买入和卖出不可以在同一天进行，且一天最多只可以持有一支股票。那么如果我们在第i天买入，那么这一天之前只能有0只股票。如果我们在第i天卖出，那这一天只能有1只股票。因此我们定义：</p>
<ul>
<li><code>T[i][k][0]</code> 为第i天通过至多k次交易后，当天没有股票（保持原样或卖出）的最大利润</li>
<li><code>T[i][k][1]</code> 为第i天通过至多k次交易后，当天有股票（保持原样或买入）的最大利润</li>
</ul>
<p>因此我们得到了初始化方案：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">T[-<span class="number">1</span>][k][<span class="number">0</span>] = T[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 第-1天持股0，利润为0 ; 第i天0交易0持股，利润为0</span></div><div class="line">T[-<span class="number">1</span>][k][<span class="number">1</span>] = T[i][<span class="number">0</span>][<span class="number">1</span>] = -Infinity <span class="comment">// 第-1天持股1，不可能，利润为负无穷；第i天交易0持股1，不可能，利润为负无穷</span></div></pre></td></tr></table></figure>
<p>递推公式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">T[i][k][<span class="number">0</span>] = max(T[i-<span class="number">1</span>][k][<span class="number">0</span>], T[i-<span class="number">1</span>][k][<span class="number">1</span>] + prices[i]);</div><div class="line">T[i][k][<span class="number">1</span>] = max(T[i-<span class="number">1</span>][k][<span class="number">1</span>], T[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>] - prices[i]);</div></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span>[][][] maxProfits = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length][<span class="number">2</span>][<span class="number">2</span>];</div><div class="line">        <span class="comment">// maxProfits[i][k][0] ： 在第i天,交易k次，没有股票的最大利润</span></div><div class="line">        <span class="comment">// maxProfits[i][k][1] :  在第i天交易k次，有股票的最大利润</span></div><div class="line">        maxProfits[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">        maxProfits[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>] = Integer.MIN_VALUE;</div><div class="line">        maxProfits[<span class="number">0</span>][<span class="number">1</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</div><div class="line">        maxProfits[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>] = Integer.MIN_VALUE;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; ++i)&#123;</div><div class="line">            maxProfits[i][<span class="number">1</span>][<span class="number">0</span>] = Math.max(maxProfits[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>], maxProfits[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] + prices[i]);</div><div class="line">            maxProfits[i][<span class="number">1</span>][<span class="number">1</span>] = Math.max(maxProfits[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>], maxProfits[i-<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] - prices[i]);</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> Math.max(maxProfits[prices.length - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>],<span class="number">0</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>事实上，递推公式的第二个：<code>maxProfits[i][1][1] = Math.max(maxProfits[i-1][1][1], maxProfits[i-1][0][0] - prices[i]);</code>中的<code>maxProfits[i-1][0][0]</code>恒为0。因此我们可以将代码简化为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> T_i10 = <span class="number">0</span>, T_i11 = Integer.MIN_VALUE;</div><div class="line">        </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> price : prices) &#123;</div><div class="line">        T_i10 = Math.max(T_i10, T_i11 + price);</div><div class="line">        T_i11 = Math.max(T_i11, -price);</div><div class="line">    &#125;</div><div class="line">        </div><div class="line">    <span class="keyword">return</span> T_i10;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Best-Time-to-Buy-and-Sell-Stock-II">4.2. Best Time to Buy and Sell Stock II</h2><p>如果可以允许多次买入卖出，但不可以同一天买卖。求最大利润。</p>
<p><strong>方案一，贪婪法</strong></p>
<p>这道题没有交易费的限制，所以我们就无脑贪婪就可以了，见到利润就往上加</p>
<p>哎，明明很简单的题。感觉自己宛如智障。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; ++i)&#123;</div><div class="line">            <span class="keyword">if</span>(prices[i] &gt; prices[i-<span class="number">1</span>])&#123;total += (prices[i] - prices[i-<span class="number">1</span>]);&#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> total;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>方案二，通用法</strong></p>
<p>按照上一题的思路，此时k随意了,且递推公式变成了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">T[i][k][<span class="number">0</span>] = max(T[i-<span class="number">1</span>][k][<span class="number">0</span>], T[i-<span class="number">1</span>][k][<span class="number">1</span>] + prices[i]);</div><div class="line">T[i][k][<span class="number">1</span>] = max(T[i-<span class="number">1</span>][k][<span class="number">1</span>], T[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>] - prices[i])</div><div class="line">           = max(T[i-<span class="number">1</span>][k][<span class="number">1</span>], T[i-<span class="number">1</span>][k][<span class="number">0</span>] - prices[i])</div><div class="line"></div><div class="line">因为T[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>] == T[i-<span class="number">1</span>][k][<span class="number">0</span>] ， 即第i-<span class="number">1</span>天时如果不持股，那么k-<span class="number">1</span>次交易与k次交易的最大利润应该是一样的</div><div class="line"></div><div class="line">后期插入：我的理解是，如果这一天允许操作k-<span class="number">1</span>次或者k次，其实都是一样的，因此多出来的一次没什么用，不足以在一天之内完成。</div><div class="line"></div><div class="line">但这里我不太明白为什么，原作者指出：</div><div class="line"></div><div class="line"> Sorry <span class="keyword">for</span> the confusion. So there are two interpretations here. First from a mathematical point of view, limit(k) <span class="function">is the same as <span class="title">limit</span><span class="params">(k<span class="number">-1</span>)</span> when k approaches +infinity. Second, more relevant to <span class="keyword">this</span> problem, as I said <span class="keyword">for</span> the <span class="keyword">case</span> of arbitrary k, when k is sufficiently large, the maximum profits will on longer depend on k but be bound by the number of available stocks. This means <span class="keyword">if</span> k goes to +infinity, the profits won't change <span class="keyword">if</span> you increase or decrease the value of k, that is, T[i][k][0] will be the same as T[i][k-1][0] and T[i][k][1] the same as T[i][k-1][1]. Hope <span class="keyword">this</span> clarifies things a little bit.</span></div><div class="line"></div><div class="line">坐等张思遥看看吧</div></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> T_ik0 = <span class="number">0</span>, T_ik1 = Integer.MIN_VALUE;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; ++i)&#123;</div><div class="line">        <span class="keyword">int</span> T_ik0_old = T_ik0;</div><div class="line">        T_ik0 = Math.max(T_ik0, T_ik1 + prices[i]);</div><div class="line">        T_ik1 = Math.max(T_ik1, T_ik0_old - prices[i]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> T_ik0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee">4.3. Best Time to Buy and Sell Stock with Transaction Fee</h2><p>接上题，如果买出时有一个手续费。求最大利润。</p>
<p>这道题拿到之后没有思路，就懵了。看了解答才模模糊糊知道了。先把答案记下来吧。哎。难受。</p>
<p>这道题有了交易费，所以当卖出的利润小于交易费的时候，我们就不应该卖了，不然亏了。</p>
<p><strong>通用解法</strong></p>
<p>递推此时有两种写法，要么交易费在买入的时候收取，要么在卖出的时候收取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">卖出的时候收取</div><div class="line">T[i][k][<span class="number">0</span>] = max(T[i-<span class="number">1</span>][k][<span class="number">0</span>], T[i-<span class="number">1</span>][k][<span class="number">1</span>] + prices[i] - fee);</div><div class="line">T[i][k][<span class="number">1</span>] = max(T[i-<span class="number">1</span>][k][<span class="number">1</span>], T[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>] - prices[i]);</div><div class="line">  </div><div class="line">买入的时候收取</div><div class="line">T[i][k][<span class="number">0</span>] = max(T[i-<span class="number">1</span>][k][<span class="number">0</span>], T[i-<span class="number">1</span>][k][<span class="number">1</span>] + prices[i]);</div><div class="line">T[i][k][<span class="number">1</span>] = max(T[i-<span class="number">1</span>][k][<span class="number">1</span>], T[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>] - prices[i] - fee);</div><div class="line"></div><div class="line"></div><div class="line">而 T[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>] == T[i-<span class="number">1</span>][k][<span class="number">0</span>]</div></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> T_ik0 = <span class="number">0</span>, T_ik1 = Integer.MIN_VALUE;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; ++i)&#123;</div><div class="line">            <span class="keyword">int</span> T_ik0_old = T_ik0;</div><div class="line">            T_ik0 = Math.max(T_ik0, T_ik1 + prices[i]);</div><div class="line">            T_ik1 = Math.max(T_ik1, T_ik0_old - prices[i] - fee);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> T_ik0;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>带一点贪心的思路</strong></p>
<ul>
<li>该天结束后手里没有股票。可能是保持前一天的状态，也有可能是今天卖出了。令此时收益为cache</li>
<li>该天结束后手里有股票。可能是保持前一天的状态，也有可能是今天买入了。用hold表示</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices, <span class="keyword">int</span> fee)</span> </span>&#123;</div><div class="line">       <span class="keyword">int</span> sold = <span class="number">0</span>, hold = -prices[<span class="number">0</span>];</div><div class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> price : prices) &#123;</div><div class="line">           <span class="keyword">int</span> t = sold;</div><div class="line">           sold = max(sold, hold + price - fee);</div><div class="line">           hold = max(hold, t - price);</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> sold;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h2 id="Best-Time-to-Buy-and-Sell-Stock-with-Cooldown">4.4. Best Time to Buy and Sell Stock with Cooldown</h2><p>假设可以多次买入卖出，但卖出之后必须休息一天才可以继续买入</p>
<p>按照上一题的思路，此时的转移方程为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">T[i][k][<span class="number">0</span>] = max(T[i-<span class="number">1</span>][k][<span class="number">0</span>], T[i-<span class="number">1</span>][k][<span class="number">1</span>] + prices[i]);</div><div class="line">T[i][k][<span class="number">1</span>] = max(T[i-<span class="number">1</span>][k][<span class="number">1</span>], T[i-<span class="number">2</span>][k-<span class="number">1</span>][<span class="number">0</span>] - prices[i])</div><div class="line">           = max(T[i-<span class="number">1</span>][k][<span class="number">1</span>], T[i-<span class="number">2</span>][k][<span class="number">0</span>] - prices[i]);</div><div class="line"></div><div class="line">同时 T[i-<span class="number">2</span>][k-<span class="number">1</span>][<span class="number">0</span>] == T[i-<span class="number">2</span>][k][<span class="number">0</span>]</div></pre></td></tr></table></figure>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(prices.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="comment">// i == 1时的初始化</span></div><div class="line">        <span class="keyword">int</span> Tlastik_0 = <span class="number">0</span>, <span class="comment">// i == 0</span></div><div class="line">            Tlastik_1 = -prices[<span class="number">0</span>],<span class="comment">// i == 0</span></div><div class="line">            Tik_0 = <span class="number">0</span>, <span class="comment">// i == 1</span></div><div class="line">            Tik_1 = Math.max(Tlastik_1,-prices[<span class="number">1</span>]);<span class="comment">// i == 1</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; ++i)&#123;</div><div class="line">            <span class="keyword">int</span> Tik_0_old = Tik_0,</div><div class="line">            Tik_1_old = Tik_1;</div><div class="line">            Tik_0 = Math.max(Tik_0, Tik_1 + prices[i]);</div><div class="line">            Tik_1 = Math.max(Tik_1, Tlastik_0 - prices[i]);</div><div class="line">            Tlastik_0 =Tik_0_old;</div><div class="line">            Tlastik_1 = Tik_1;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> Math.max(Tik_0, Tik_1);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="Best-Time-to-Buy-and-Sell-Stock-III">4.5. Best Time to Buy and Sell Stock III</h2><p>如果允许最多交易两次。那么求最大利润。</p>
<p>按照上一题的思路，此时k &lt;= 2，那么递推公式为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">T[i][k][<span class="number">0</span>] = max(T[i-<span class="number">1</span>][k][<span class="number">0</span>], T[i-<span class="number">1</span>][k][<span class="number">1</span>] + prices[i]);</div><div class="line">T[i][k][<span class="number">1</span>] = max(T[i-<span class="number">1</span>][k][<span class="number">1</span>], T[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>] - prices[i]);</div><div class="line"></div><div class="line">由于 k &lt;= <span class="number">2</span>，因此</div><div class="line"></div><div class="line"><span class="keyword">if</span> k == <span class="number">0</span></div><div class="line">T[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></div><div class="line">T[i][<span class="number">0</span>][<span class="number">1</span>] = -Inifity</div><div class="line"></div><div class="line"><span class="keyword">if</span> k == <span class="number">1</span></div><div class="line">T[i][<span class="number">1</span>][<span class="number">0</span>] = max(T[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>], T[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] + prices[i]);</div><div class="line">T[i][<span class="number">1</span>][<span class="number">1</span>] = max(T[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>], T[i-<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] - prices[i]);</div><div class="line">           = max(T[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>], <span class="number">0</span> - prices[i]);</div><div class="line"><span class="keyword">if</span> k == <span class="number">2</span></div><div class="line">T[i][<span class="number">2</span>][<span class="number">0</span>] = max(T[i-<span class="number">1</span>][<span class="number">2</span>][<span class="number">0</span>], T[i-<span class="number">1</span>][<span class="number">2</span>][<span class="number">1</span>] + prices[i]);</div><div class="line">T[i][<span class="number">2</span>][<span class="number">1</span>] = max(T[i-<span class="number">1</span>][<span class="number">2</span>][<span class="number">1</span>], T[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>] - prices[i]);</div></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="comment">// i == -1时的初始化</span></div><div class="line">        <span class="keyword">int</span> Ti_k0_0 = <span class="number">0</span>, <span class="comment">// k==0,不持股</span></div><div class="line">        Ti_k0_1 = Integer.MIN_VALUE, <span class="comment">// k == 0,持股</span></div><div class="line"> </div><div class="line">        Ti_k1_0 = <span class="number">0</span>, <span class="comment">// k == 1,不持股</span></div><div class="line">        Ti_k1_1 = Integer.MIN_VALUE, <span class="comment">// k == 1,持股</span></div><div class="line">        Ti_k2_0 = <span class="number">0</span>, <span class="comment">// k == 2,不持股</span></div><div class="line">        Ti_k2_1 = Integer.MIN_VALUE; <span class="comment">// k == 2，持股</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; ++i)&#123;</div><div class="line">            <span class="comment">// k == 0 ，可以省略不写</span></div><div class="line">            <span class="comment">// Ti_k0_0 = 0;</span></div><div class="line">            <span class="comment">// Ti_k0_1 = Integer.MIN_VALUE;</span></div><div class="line">            <span class="comment">// k == 2</span></div><div class="line">            Ti_k2_0 = Math.max(Ti_k2_0, Ti_k2_1 + prices[i]);</div><div class="line">            Ti_k2_1 = Math.max(Ti_k2_1, Ti_k1_0 - prices[i]);</div><div class="line">            <span class="comment">// k == 1</span></div><div class="line">            Ti_k1_0 = Math.max(Ti_k1_0, Ti_k1_1 + prices[i]);</div><div class="line">            Ti_k1_1 = Math.max(Ti_k1_1, -prices[i]);</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> Math.max(Ti_k2_0, Math.max(Ti_k1_0, Ti_k0_0));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>当然也有另一种相似的初始化方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="comment">// i == 0时的初始化</span></div><div class="line">        <span class="keyword">int</span> Ti_k0_0 = <span class="number">0</span>, <span class="comment">// k==0,不持股</span></div><div class="line">        Ti_k0_1 = Integer.MIN_VALUE, <span class="comment">// k == 0,持股</span></div><div class="line"></div><div class="line">        Ti_k1_0 = <span class="number">0</span>, <span class="comment">// k == 1,不持股</span></div><div class="line">        Ti_k1_1 = -prices[<span class="number">0</span>], <span class="comment">// k == 1,持股</span></div><div class="line"></div><div class="line">        Ti_k2_0 = <span class="number">0</span>, <span class="comment">// k == 2,不持股</span></div><div class="line">        Ti_k2_1 = -prices[<span class="number">0</span>]; <span class="comment">// k == 2，持股</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; ++i)&#123;</div><div class="line">            <span class="comment">// k == 0 ，可以省略不写</span></div><div class="line">            <span class="comment">// Ti_k0_0 = 0;</span></div><div class="line">            <span class="comment">// Ti_k0_1 = Integer.MIN_VALUE;</span></div><div class="line">            <span class="comment">// k == 2</span></div><div class="line">            Ti_k2_0 = Math.max(Ti_k2_0, Ti_k2_1 + prices[i]);</div><div class="line">            Ti_k2_1 = Math.max(Ti_k2_1, Ti_k1_0 - prices[i]);</div><div class="line">            <span class="comment">// k == 1</span></div><div class="line">            Ti_k1_0 = Math.max(Ti_k1_0, Ti_k1_1 + prices[i]);</div><div class="line">            Ti_k1_1 = Math.max(Ti_k1_1, -prices[i]);</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> Math.max(Ti_k2_0, Math.max(Ti_k1_0, Ti_k0_0));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h1 id="Two-Sum问题">5. Two Sum问题</h1><h2 id="例题15，Two-Sum">5.1. 例题15，Two Sum</h2><p>给一个数组，求两数之和等于target的idx。</p>
<p>方法一：哈希表</p>
<p>空间$O(n)$</p>
<p>如果不要求返回idx，只返回数字呢？</p>
<p>空间$O(1)$，时间$O(nlogn + n)$</p>
<ol>
<li>先排序</li>
<li>两个指针，一头一尾</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">i = <span class="number">0</span>,j = n-<span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="keyword">while</span>(i &lt; j)&#123;</div><div class="line">  <span class="keyword">if</span>(nums[i] + nums[j] &gt; target)&#123; <span class="comment">// nums[j] 加上最小的都更大，因此不用考虑了</span></div><div class="line">    --j;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] + nums[j] &lt; target)&#123; <span class="comment">//nums[i]加上最大的都更小，因此不用考虑了</span></div><div class="line">    ++i;</div><div class="line">  &#125;<span class="keyword">else</span>&#123;</div><div class="line">    <span class="keyword">return</span> [nums[i],nums[j]]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Two-Sum-II">5.2. Two Sum II</h2><p>给一个有序数组，求两数之和等于target的idx。</p>
<p>方法一：hash表</p>
<p>方法二：Two Pointer方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = nums.length - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (i &lt; j)&#123;</div><div class="line">            <span class="keyword">if</span>(nums[i] + nums[j] == target)&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i + <span class="number">1</span>,j + <span class="number">1</span>&#125;;</div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] + nums[j] &gt; target)&#123;</div><div class="line">                --j;</div><div class="line">            &#125;<span class="keyword">else</span> &#123;</div><div class="line">                ++i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="例题16，Two-Sum-Closest">5.3. 例题16，Two Sum Closest</h2><p>求两数之和最接近target，返回两数和与target的差</p>
<p>相似套路</p>
<h2 id="Valid-Triangle-Number">5.4. Valid Triangle Number</h2><p>给一个数组。求数组中能组成三角形的个数。</p>
<p>明明就是two pointer的变种。怎么想都想不出来。哎。我的智商真的有问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">triangleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(nums.length &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        Arrays.sort(nums);</div><div class="line">        <span class="keyword">int</span> counter = <span class="number">0</span>, n = nums.length;</div><div class="line">        <span class="comment">// 遍历最高位</span></div><div class="line">        <span class="comment">/**其实就是固定target之后，寻找a + b &gt; target的组合**/</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> high = n - <span class="number">1</span>; high &gt;= <span class="number">2</span>; --high)&#123;</div><div class="line">            <span class="keyword">int</span> low = <span class="number">0</span>, mid = high - <span class="number">1</span>;</div><div class="line">            <span class="keyword">while</span> (low &lt; mid)&#123;</div><div class="line">                <span class="keyword">if</span>(nums[low] + nums[mid] &gt; nums[high])&#123;</div><div class="line">                    <span class="comment">//any + nums[mid] &gt; nums[high]</span></div><div class="line">                    <span class="comment">// any有mid-low个</span></div><div class="line">                    counter += mid - low;</div><div class="line">                    --mid;</div><div class="line">                &#125;<span class="keyword">else</span>&#123;</div><div class="line">                    ++low;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> counter;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="例题17，Three-Sum">5.5. 例题17，Three Sum</h2><p>方法一：hash + 遍历 , 空间$O(n)$ + 时间$O(n^2)$</p>
<p>方法二：排序后two pointer，空间$O(1)$ + 时间$O(n^2)$</p>
<ol>
<li>排序</li>
<li>求a+b+c = target<br>固定a ， 然后对b + c利用Two Sum方法</li>
</ol>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums)&#123;</div><div class="line">        Arrays.sort(nums);</div><div class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; nums.length; ++a)&#123;</div><div class="line">           	<span class="comment">// 跳过重复的</span></div><div class="line">            <span class="keyword">if</span>(a &gt; <span class="number">0</span> &amp;&amp; nums[a] == nums[a - <span class="number">1</span>]) <span class="keyword">continue</span>;</div><div class="line">            <span class="keyword">int</span> i = a + <span class="number">1</span>, j = nums.length - <span class="number">1</span>;</div><div class="line">            <span class="keyword">int</span> target = -nums[a];</div><div class="line">            <span class="keyword">int</span> sum;</div><div class="line">            <span class="keyword">while</span> (i &lt; j)&#123;</div><div class="line">                sum = nums[i] + nums[j];</div><div class="line">                <span class="keyword">if</span>(sum == target)&#123;</div><div class="line">                    List&lt;Integer&gt; one = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(<span class="number">3</span>);</div><div class="line">                    one.add(nums[a]);</div><div class="line">                    one.add(nums[i]);</div><div class="line">                    one.add(nums[j]);</div><div class="line">                    ans.add(one);</div><div class="line">                    ++i;--j;</div><div class="line">                    <span class="comment">// 跳过重复的 , 一定要注意这里，我自己没做上</span></div><div class="line">                    <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] == nums[i-<span class="number">1</span>])&#123;</div><div class="line">                        ++i;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] == nums[j + <span class="number">1</span>])&#123;</div><div class="line">                        --j;</div><div class="line">                    &#125;</div><div class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target)&#123;</div><div class="line">                    --j;</div><div class="line">                &#125;<span class="keyword">else</span> &#123;</div><div class="line">                    ++i;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ans;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="Three-Sum-Closest">5.6. Three Sum Closest</h2><p>给一个数组和一个target。求三个数之和最接近target的和。</p>
<p>思路：与之前的相似。</p>
<ol>
<li>排序</li>
<li>求a+b+c = target<br>固定a ， 然后对b + c利用Two Sum方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">    Arrays.sort(nums);</div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> minDiff = Integer.MAX_VALUE;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; nums.length; ++a)&#123;</div><div class="line">        <span class="keyword">int</span> t = target - nums[a];</div><div class="line">        <span class="comment">// find b + c = t</span></div><div class="line">        <span class="keyword">int</span> i = a + <span class="number">1</span>, j = nums.length - <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> sum2,currDiff;</div><div class="line">        <span class="keyword">while</span> ( i &lt; j )&#123;</div><div class="line">            sum2 = nums[i] + nums[j];</div><div class="line">            currDiff = Math.abs(sum2 - t);</div><div class="line">            <span class="keyword">if</span>(currDiff &lt; minDiff)&#123;</div><div class="line">                sum = sum2 + nums[a];</div><div class="line">                minDiff = currDiff;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(sum2 &gt; t)&#123; <span class="comment">// nums[j]太大</span></div><div class="line">                --j;</div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum2 &lt; t)&#123; <span class="comment">// nuums[i]太小</span></div><div class="line">                ++i;</div><div class="line">            &#125;<span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> target;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Three-Sum-Smaller">5.7. Three Sum Smaller</h2><p>给一个数组和一个target，求三个数相加小于target的个数。</p>
<p>相似套路。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumSmaller</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">       Arrays.sort(nums);</div><div class="line">       <span class="keyword">int</span> counter = <span class="number">0</span>;</div><div class="line">       <span class="keyword">int</span> target_curr;</div><div class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; nums.length; ++a)&#123;</div><div class="line">           target_curr = target - nums[a];</div><div class="line">           <span class="keyword">int</span> i = a + <span class="number">1</span>, j = nums.length - <span class="number">1</span>;</div><div class="line">           <span class="keyword">while</span> (i &lt; j)&#123;</div><div class="line">               <span class="keyword">if</span>(nums[i] + nums[j] &lt; target_curr)&#123;</div><div class="line">                   <span class="comment">// nums[i]是当前最小的,它加上任意一个都是小于target_curr</span></div><div class="line">                   counter += (j - i);</div><div class="line">                   ++i;</div><div class="line">               &#125;<span class="keyword">else</span>&#123;</div><div class="line">                   <span class="comment">// nums[j]太大了</span></div><div class="line">                   --j;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> counter;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h2 id="Four-Sum">5.8. Four Sum</h2><p>给一个数组和一个target。求四个数相加等于target的所有可能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</div><div class="line">        Arrays.sort(nums);</div><div class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; nums.length; ++a)&#123;</div><div class="line">            <span class="comment">// target = -nums[a]</span></div><div class="line">            <span class="keyword">if</span>(a &gt; <span class="number">0</span> &amp;&amp; nums[a] == nums[a - <span class="number">1</span>])<span class="keyword">continue</span>;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> b = a + <span class="number">1</span>; b &lt; nums.length; ++b)&#123;</div><div class="line">                <span class="comment">// target = -nums[a] - nums[b]</span></div><div class="line">                <span class="keyword">if</span>(b &gt; a + <span class="number">1</span> &amp;&amp; nums[b] == nums[b-<span class="number">1</span>])<span class="keyword">continue</span>;</div><div class="line">                <span class="keyword">int</span> i = b + <span class="number">1</span>, j = nums.length - <span class="number">1</span>;</div><div class="line">                <span class="keyword">while</span> (i &lt; j)&#123;</div><div class="line">                    <span class="keyword">if</span>(nums[a] + nums[b] + nums[i] + nums[j] &gt; target)&#123;</div><div class="line">                        --j;</div><div class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[a] + nums[b] + nums[i] + nums[j] &lt; target)&#123;</div><div class="line">                        ++i;</div><div class="line">                    &#125;<span class="keyword">else</span> &#123;</div><div class="line">                        List&lt;Integer&gt; oneAns = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">                        oneAns.add(nums[a]);oneAns.add(nums[b]);</div><div class="line">                        oneAns.add(nums[i]);oneAns.add(nums[j]);</div><div class="line">                        ans.add(oneAns);</div><div class="line">                        ++i;</div><div class="line">                        --j;</div><div class="line">                        <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])&#123;</div><div class="line">                            ++i;</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] == nums[j + <span class="number">1</span>])&#123;</div><div class="line">                            --j;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ans;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h1 id="Two-Pointer问题">6. Two Pointer问题</h1><h2 id="Subarray-Product-Less-Than-K">6.1. Subarray Product Less Than K</h2><p>给一个正整数数组和一个k。求子数组小于k的个数。</p>
<p>思想：维护一个始终小于k的窗口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>] &gt; k ? <span class="number">1</span> : <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = <span class="number">0</span>;</div><div class="line">        <span class="keyword">long</span> product = <span class="number">1L</span>;</div><div class="line">        <span class="keyword">int</span> counter = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (low &lt;= high &amp;&amp; high &lt; nums.length)&#123;</div><div class="line">            product *= nums[high];</div><div class="line">            <span class="keyword">while</span> (low &lt;= high &amp;&amp; product &gt;= k)&#123;</div><div class="line">                product/= nums[low];</div><div class="line">                ++low;</div><div class="line">            &#125;</div><div class="line">            counter += (high - low + <span class="number">1</span>);</div><div class="line">            ++high;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> counter;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="Longest-Substring-Without-Repeating-Characters">6.2. Longest Substring Without Repeating Characters</h2><p>给一个字符串。求字符串的最长无重子数组。</p>
<p>思路：两个指针，如果两个指针内没有重复的元素，就把后面的继续后移。如果有重复的，就把前面的移到重复的下一个。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == s || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="comment">// 寻找最长的无重子数组</span></div><div class="line">        <span class="keyword">char</span>[] c = s.toCharArray();</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">        HashMap&lt;Character,Integer&gt; set = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        <span class="keyword">while</span> (j &lt; c.length)&#123;</div><div class="line">            <span class="keyword">if</span>(!set.containsKey(c[j]))&#123;</div><div class="line">                set.put(c[j], j);</div><div class="line">                max = Math.max(j - i + <span class="number">1</span>, max);</div><div class="line">                ++j;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                <span class="keyword">int</span> repeatIdx = set.get(c[j]);</div><div class="line">                <span class="comment">// 去除从i到repeatIdx的元素</span></div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt;= repeatIdx; ++k)&#123;</div><div class="line">                    set.remove(c[k]);</div><div class="line">                &#125;</div><div class="line">                set.put(c[j],j);</div><div class="line">                i = repeatIdx + <span class="number">1</span>;</div><div class="line">                max = Math.max(j - i, max);</div><div class="line">                ++j;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>然而上面的这个表现很差。才beats了百分之几。</p>
<p>其实，这个题里面的hashMap的元素不一定必须去除！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == s || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="comment">// 寻找最长的无重子数组</span></div><div class="line">        <span class="keyword">char</span>[] c = s.toCharArray();</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">        HashMap&lt;Character,Integer&gt; set = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        <span class="keyword">while</span> (j &lt; c.length)&#123;</div><div class="line">            <span class="keyword">if</span>(!set.containsKey(c[j]))&#123;</div><div class="line">                set.put(c[j], j);</div><div class="line">                max = Math.max(j - i + <span class="number">1</span>, max);</div><div class="line">                ++j;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                <span class="keyword">int</span> repeatIdx = set.get(c[j]);</div><div class="line">                <span class="keyword">if</span>(repeatIdx &gt;= i)&#123; <span class="comment">// 哇，骚操作</span></div><div class="line">                    i = repeatIdx + <span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">                set.put(c[j],j);</div><div class="line">                max = Math.max(j - i + <span class="number">1</span>, max);</div><div class="line">                ++j;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>可以改成一个长度为256的数组。骚操作啊骚操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongtestSubString</span><span class="params">(String s)</span></span>&#123;</div><div class="line">  <span class="keyword">char</span>[] str = s.toCharArray();</div><div class="line">  <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, max = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span>[] memo = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</div><div class="line">  Arrays.fill(memo, -<span class="number">1</span>);</div><div class="line">  <span class="keyword">while</span>(r &lt; str.length)&#123;</div><div class="line">    <span class="keyword">int</span> index = memo[str[r]];</div><div class="line">    <span class="keyword">if</span>(index &gt;= l)&#123;</div><div class="line">      l = index + <span class="number">1</span>;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">      max = Math.max(r-l+<span class="number">1</span>, max);</div><div class="line">    &#125;</div><div class="line">    memo[str[r]] = r;</div><div class="line">    ++r;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> max;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Implement-strStr">6.3. Implement strStr()</h2><p>给两个字符串a和b。如果b在a中，返回b的开始idx。</p>
<p><strong>暴力思路：</strong></p>
<p>一个个比较。当然这个思路非常的慢，想哭。只beats了4%。真的伤心。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(<span class="keyword">char</span>[] haystack, <span class="keyword">char</span>[] needle, <span class="keyword">int</span> h_idx)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : needle)&#123;</div><div class="line">        <span class="keyword">if</span>(h_idx &lt; haystack.length &amp;&amp; c == haystack[h_idx])&#123;</div><div class="line">            ++h_idx;</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</div><div class="line">    <span class="keyword">char</span>[] needle_chars = needle.toCharArray();</div><div class="line">    <span class="keyword">char</span>[] hays_chars = haystack.toCharArray();</div><div class="line">    <span class="keyword">if</span>(needle_chars.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span>(hays_chars.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> haystackStart = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hays_chars.length; ++i)&#123;</div><div class="line">        <span class="keyword">if</span>(helper(hays_chars, needle_chars, i)) <span class="keyword">return</span> i;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>优化</strong></p>
<p>其实。。。。只需要。。。。在大循环的时候，限制i的终止条件就好。。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(<span class="keyword">char</span>[] haystack, <span class="keyword">char</span>[] needle, <span class="keyword">int</span> h_idx)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : needle)&#123;</div><div class="line">        <span class="keyword">if</span>(h_idx &lt; haystack.length &amp;&amp; c == haystack[h_idx])&#123;</div><div class="line">            ++h_idx;</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</div><div class="line">    <span class="keyword">char</span>[] needle_chars = needle.toCharArray();</div><div class="line">    <span class="keyword">char</span>[] hays_chars = haystack.toCharArray();</div><div class="line">    <span class="keyword">if</span>(needle_chars.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span>(hays_chars.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> haystackStart = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= hays_chars.length - needle_chars.length; ++i)&#123; <span class="comment">// i的终止条件</span></div><div class="line">        <span class="keyword">if</span>(helper(hays_chars, needle_chars, i)) <span class="keyword">return</span> i;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>字符串操作</strong></p>
<p>这是最快的操作。真的伤心。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> haystack.indexOf(needle);</div></pre></td></tr></table></figure>
<h2 id="Reverse-String">6.4. Reverse String</h2><p>反转字符串</p>
<p>简单</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseString</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">    <span class="keyword">char</span>[] chars = s.toCharArray();</div><div class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = chars.length - <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span> (low &lt; high)&#123;</div><div class="line">        <span class="keyword">char</span> temp = chars[low];</div><div class="line">        chars[low] = chars[high];</div><div class="line">        chars[high] = temp;</div><div class="line">        ++low; --high;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> String.valueOf(chars);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Reverse-Vowels-of-a-String">6.5. Reverse Vowels of a String</h2><p>反转字符串中的元音字节</p>
<p>简单的题</p>
<p>元音就是<code>&#39;a&#39;,&#39;e&#39;,&#39;i&#39;,&#39;o&#39;,&#39;u&#39;,&#39;A&#39;,&#39;E&#39;,&#39;I&#39;,&#39;O&#39;,&#39;U&#39;</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseVowels</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">    HashSet&lt;Character&gt; vowels = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">    <span class="keyword">char</span>[] v = &#123;<span class="string">'a'</span>,<span class="string">'e'</span>,<span class="string">'i'</span>,<span class="string">'o'</span>,<span class="string">'u'</span>,<span class="string">'A'</span>,<span class="string">'E'</span>,<span class="string">'I'</span>,<span class="string">'O'</span>,<span class="string">'U'</span>&#125;;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : v) vowels.add(c);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = s.length() - <span class="number">1</span>;</div><div class="line">    <span class="keyword">char</span>[] s_chars = s.toCharArray();</div><div class="line">    <span class="keyword">while</span> (low &lt; high)&#123;</div><div class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; !vowels.contains(s_chars[low])) ++low;</div><div class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; !vowels.contains(s_chars[high]))--high;</div><div class="line">        <span class="keyword">if</span>(low &lt; high)&#123;</div><div class="line">            <span class="keyword">char</span> temp = s_chars[low];</div><div class="line">            s_chars[low] = s_chars[high];</div><div class="line">            s_chars[high] = temp;</div><div class="line">            ++low;</div><div class="line">            --high;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> String.valueOf(s_chars);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="子串的滑动窗口">7. 子串的滑动窗口</h1><h2 id="Valid-Anagram">7.1. Valid Anagram</h2><p>给两个字符串。判断一个是否是另一个的全排列（字谜）</p>
<p>思路：用两个256的hash表！（其实用一个就行）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(s.length() != t.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">int</span>[] hash = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i)&#123;</div><div class="line">            ++hash[s.charAt(i)];</div><div class="line">            --hash[t.charAt(i)];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i)&#123;</div><div class="line">            <span class="keyword">if</span>(hash[i] != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="Group-Anagrams">7.2. Group Anagrams</h2><p>这一题，看了答案，差点被气死，怎么会有如此无理取闹的算法</p>
<h2 id="Find-All-Anagrams-in-a-String">7.3. Find All Anagrams in a String</h2><p>给两个字符串<code>s</code>和<code>p</code>。求<code>p</code>的全排列出现在’s’中的所有起始坐标</p>
<p>思路：按照上一题的滑动窗口的操作！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s, String p)</span> </span>&#123;</div><div class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        <span class="keyword">if</span>(s.length() &lt; p.length() || p.length() == <span class="number">0</span>) <span class="keyword">return</span> result;</div><div class="line">        <span class="keyword">int</span>[] s_hash = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</div><div class="line">        <span class="keyword">int</span>[] p_hash = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</div><div class="line">        <span class="comment">// 与p长度相等的窗口</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.length(); ++i)&#123;</div><div class="line">            ++s_hash[s.charAt(i)];</div><div class="line">            ++p_hash[p.charAt(i)];</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 检验长度为p.length的窗口内相等元素的个数</span></div><div class="line">        <span class="keyword">int</span> counter = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i)&#123;</div><div class="line">            <span class="keyword">if</span>(s_hash[i] == p_hash[i]) ++counter;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 将窗口依次向右挪动</span></div><div class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = p.length() - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(counter == <span class="number">256</span>)&#123;result.add(low);&#125;</div><div class="line">            <span class="keyword">char</span> low_c = s.charAt(low);</div><div class="line">            <span class="keyword">if</span>(s_hash[low_c] == p_hash[low_c])--counter;</div><div class="line">            --s_hash[low_c];</div><div class="line">            <span class="keyword">if</span>(s_hash[low_c] == p_hash[low_c])++counter; <span class="comment">// 注意！</span></div><div class="line">            ++low;</div><div class="line">            ++high;</div><div class="line">            <span class="keyword">if</span>(high &gt;= s.length()) <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">char</span> high_c = s.charAt(high);</div><div class="line">            <span class="keyword">if</span>(s_hash[high_c] == p_hash[high_c])--counter;</div><div class="line">            ++s_hash[high_c];</div><div class="line">            <span class="keyword">if</span>(s_hash[high_c] == p_hash[high_c]) ++counter; <span class="comment">// 注意！</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(counter == <span class="number">256</span>)&#123;result.add(low);&#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="Permutation-in-String">7.4. Permutation in String</h2><p>判断字符串s2是否包含s1的任意排列的子串</p>
<p>这道题是这一类型的我做的第一道。刚开始的时候想不到滑动窗口，很艰辛。花了一整天时间才消化了。不过之后遇到其它问题的时候还挺顺利的。以后遇到不会的题要使劲总结！加油啊甲乙小朋友！</p>
<p>思路：灰常暴力</p>
<p>给s2一个low和一个high：</p>
<ol>
<li>初始时，low = 0, high = low</li>
<li>当<code>s2[high]</code> 出现在s1中时，将s1这个位置标记为使用过，将high挪到下一格</li>
<li>如果顺利的话，s1中每个位置都被标记为使用过，那么<code>low --- high</code>之间的字符就是s1的一个排列。</li>
</ol>
<p>实现的时候过于暴力。借用了hash。当然结果也是非常的慢，大概只beats了2%。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> counter;</div><div class="line">    <span class="keyword">int</span> used;</div><div class="line">    Node(<span class="keyword">int</span> counter, <span class="keyword">int</span> used)&#123;</div><div class="line">        <span class="keyword">this</span>.counter = counter;</div><div class="line">        <span class="keyword">this</span>.used = used;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(HashMap&lt;Character, Node&gt; hash)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>(Map.Entry&lt;Character,Node&gt; entry : hash.entrySet())&#123;</div><div class="line">        entry.getValue().used = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</div><div class="line">    HashMap&lt;Character, Node&gt; hash = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : s1.toCharArray())&#123;</div><div class="line">        <span class="keyword">if</span>(hash.containsKey(c))&#123;hash.get(c).counter += <span class="number">1</span>;&#125;</div><div class="line">        <span class="keyword">else</span>&#123;hash.put(c,<span class="keyword">new</span> Node(<span class="number">1</span>,<span class="number">0</span>));&#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = <span class="number">0</span>;</div><div class="line">    <span class="keyword">char</span>[] s2_chars = s2.toCharArray();</div><div class="line">    <span class="keyword">int</span> counter = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (high &lt; s2_chars.length)&#123;</div><div class="line">        <span class="keyword">if</span>(hash.containsKey(s2_chars[high]))&#123;</div><div class="line">            Node temp = hash.get(s2_chars[high]);</div><div class="line">            <span class="keyword">if</span>(temp.used &gt;= temp.counter)&#123;</div><div class="line">                <span class="comment">// 清空所有used</span></div><div class="line">                clear(hash);</div><div class="line">                low += <span class="number">1</span>;</div><div class="line">                high = low;</div><div class="line">                counter = <span class="number">0</span>;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                counter += <span class="number">1</span>;</div><div class="line">                <span class="keyword">if</span>(counter == s1.length()) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                temp.used += <span class="number">1</span>;</div><div class="line">                ++high;</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span>(counter &gt; <span class="number">0</span>)&#123;clear(hash);counter = <span class="number">0</span>;&#125;</div><div class="line">            ++low;</div><div class="line">            high = low;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>优化1，滑动窗口</strong></p>
<p>一共就26个字母，那就为s1和s2各申请一个长度为26的数组。当两个数组完全相等时，即匹配！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (s1.length() &gt; s2.length())</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">int</span>[] s1map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</div><div class="line">    <span class="keyword">int</span>[] s2map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</div><div class="line">    <span class="comment">// 窗口大小为s1的长度</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length(); i++) &#123;</div><div class="line">        s1map[s1.charAt(i) - <span class="string">'a'</span>]++;</div><div class="line">        s2map[s2.charAt(i) - <span class="string">'a'</span>]++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s2.length() - s1.length(); i++) &#123;</div><div class="line">        <span class="keyword">if</span> (matches(s1map, s2map)) <span class="comment">// 窗口内部元素完全一致</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        <span class="comment">// 窗口右移</span></div><div class="line">        s2map[s2.charAt(i + s1.length()) - <span class="string">'a'</span>]++;</div><div class="line">        s2map[s2.charAt(i) - <span class="string">'a'</span>]--;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> matches(s1map, s2map);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(<span class="keyword">int</span>[] s1map, <span class="keyword">int</span>[] s2map)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (s1map[i] != s2map[i])</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然，match操作也有优化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (s1.length() &gt; s2.length())</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">int</span>[] s1map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</div><div class="line">    <span class="keyword">int</span>[] s2map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length(); i++) &#123;</div><div class="line">        s1map[s1.charAt(i) - <span class="string">'a'</span>]++;</div><div class="line">        s2map[s2.charAt(i) - <span class="string">'a'</span>]++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</div><div class="line">        <span class="keyword">if</span> (s1map[i] == s2map[i])</div><div class="line">            count++;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s2.length() - s1.length(); i++) &#123;</div><div class="line">        <span class="keyword">int</span> r = s2.charAt(i + s1.length()) - <span class="string">'a'</span>, l = s2.charAt(i) - <span class="string">'a'</span>;</div><div class="line">        <span class="keyword">if</span> (count == <span class="number">26</span>)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        s2map[r]++;</div><div class="line">        <span class="keyword">if</span> (s2map[r] == s1map[r])</div><div class="line">            count++;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s2map[r] == s1map[r] + <span class="number">1</span>)</div><div class="line">            count--;</div><div class="line">        s2map[l]--;</div><div class="line">        <span class="keyword">if</span> (s2map[l] == s1map[l])</div><div class="line">            count++;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s2map[l] == s1map[l] - <span class="number">1</span>)</div><div class="line">            count--;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> count == <span class="number">26</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>优化2，骚操作</strong></p>
<p>哎。明明知道有优化，就是自己想不出来。</p>
<p>其实不需要找到s1的全排列，因为我们只需要考虑s2中是否包含s1中同样个数的字符，并且这些字符是连在一起的就行了。因此，我们可以使用一个滑动窗口，在s2上滑动。在移动的过程中，先保证窗口内部包含了所有的s1的每个字符。如果当前窗口长度大于s1的长度，那就把窗口左边向右移。</p>
<p>当high往后移动时，即代表将<code>s2[high]</code>加入到窗口中</p>
<ol>
<li>如果s1中包含<code>s2[high]</code>，那么<code>count[s2[high]] &gt; 0</code>，就将计数器<code>cnt--</code></li>
<li>如果s1中不包含<code>s2[high]</code>,那么就将<code>count[s2[high]]--</code></li>
</ol>
<p>直到窗口内部的元素恰好全部包含了s1时：</p>
<ol>
<li>如果窗口大小恰好等于s1，那么就返回true</li>
<li>否则的话，窗口大小一定是大于s1的。那我们就要尝试将窗口变小，也就是将前面的<code>low</code>往后移动<ol>
<li>通过上面的操作，如果一个<code>count[s2[low]]==0</code>，那就说明<code>s2[low]</code>一定是出现在s1中的，只是被减去了，而且窗口内部的<code>s2[low]</code>个数恰好等于s1中的个数。为了将low往后移动，那么就要将cnt+1,来弥补这个错误</li>
<li>同时，无论<code>count[s2[low]]</code> 等于几，为了将low向后移动，它都要加一</li>
</ol>
</li>
</ol>
<p>一定要注意用一个<code>int[256]</code>来对字符进行hash 的操作！！！！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span></span>&#123;</div><div class="line">  <span class="comment">/**if end - start == len, return true</span></div><div class="line">     if arr[i] == 0, positive count, recover count++</div><div class="line">     recover i++ count[arr[i]]++**/</div><div class="line">  <span class="keyword">if</span>(s1.length() &gt; s2.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>]; <span class="comment">// 又是这个操作</span></div><div class="line">  <span class="comment">// count[i] 代表字符i的个数</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">char</span> c : s1.toCharArray())&#123;</div><div class="line">    count[c]++;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> len = s1.length();</div><div class="line">  <span class="keyword">int</span> cnt = len;</div><div class="line">  <span class="keyword">char</span> arr[] = s2.toCharArray();</div><div class="line">  <span class="keyword">int</span> high = <span class="number">0</span>, low = <span class="number">0</span>;</div><div class="line">  <span class="keyword">while</span>(high &lt; arr.length)&#123;</div><div class="line">    <span class="comment">//尝试将high往后滑动</span></div><div class="line">    <span class="keyword">if</span>(count[arr[high]] &gt; <span class="number">0</span>)&#123;</div><div class="line">      cnt--;</div><div class="line">    &#125;</div><div class="line">    count[arr[high]]--;</div><div class="line">    ++high;</div><div class="line">    <span class="keyword">while</span>(cnt == <span class="number">0</span>)&#123;</div><div class="line">      <span class="keyword">if</span>(high - low == len)&#123;<span class="keyword">return</span> <span class="keyword">true</span>;&#125;</div><div class="line">      <span class="comment">// 尝试将low往后滑动</span></div><div class="line">      <span class="keyword">if</span>(count[arr[low]] == <span class="number">0</span>)&#123; <span class="comment">// 中间肯定多出现了一次arr[low]</span></div><div class="line">        cnt++;</div><div class="line">      &#125; </div><div class="line">      count[arr[low]]++;</div><div class="line">      low++;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>优化3，骚操作</strong></p>
<p>先看这种解法：</p>
<p>对于每个遍历到的字符，我们在hash表中对于该字符次数减1。一旦该字符次数小于0，那么该字符要么在s1中不曾出现，或者出现的次数超过了s1中的该字符出现次数。那么此时我们就移动窗口的low边界。需要注意的是，每次移动右边界时，hash表对应的字符次数都要+1。如果此时次数不等于0，那么说明该字符不在s1中，继续向右移。直到更新后的次数为0为止。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(s1.length() &gt; s2.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>]; <span class="comment">// 又是这个操作</span></div><div class="line">    <span class="comment">// count[i] 代表字符i的个数</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : s1.toCharArray())&#123;</div><div class="line">        count[c]++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> len = s1.length();</div><div class="line">    <span class="keyword">char</span> arr[] = s2.toCharArray();</div><div class="line">    <span class="keyword">int</span> high = <span class="number">0</span>, low = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(high &lt; arr.length)&#123;</div><div class="line">        --count[arr[high]];</div><div class="line">        ++high;</div><div class="line">        <span class="comment">// 当count[arr[high]]小于0时，说明该字符在s1中不曾出现，</span></div><div class="line">        <span class="comment">// 或者出现的次数超过了s1中的该字符的出现次数，那就移动窗口左边界</span></div><div class="line">        <span class="keyword">if</span>(count[arr[high]] &lt; <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">while</span> (count[arr[low]] != <span class="number">0</span>)&#123;</div><div class="line">                ++low;</div><div class="line">                ++count[arr[low]];</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 此时窗口内部的字符arr[low]个数恰好等于s1中该字符的出现次数</span></div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(high - low + <span class="number">1</span> == len) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> s1.length() == <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Minimum-Window-Substring">7.5. Minimum Window Substring</h2><p>给两个字符串，找到一个包含另一个所有元素的最小子串</p>
<p>思路：hash + 双指针！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">goHigh</span><span class="params">(<span class="keyword">int</span>[] hash_s, <span class="keyword">int</span>[] hash_t, String s, String t, <span class="keyword">int</span> high, <span class="keyword">int</span> same)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(high == s.length() - <span class="number">1</span>) <span class="keyword">return</span> same;</div><div class="line">        ++high;</div><div class="line">        <span class="keyword">char</span> s_element = s.charAt(high);</div><div class="line">        <span class="comment">// t中还有多余的这个元素没有匹配到</span></div><div class="line">        <span class="keyword">if</span>(hash_t[s_element] &gt; hash_s[s_element])</div><div class="line">            same += <span class="number">1</span>;</div><div class="line">        hash_s[s_element]++;</div><div class="line">        <span class="keyword">return</span> same;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">goLow</span><span class="params">(<span class="keyword">int</span>[] hash_s, <span class="keyword">int</span>[] hash_t, String s, String t, <span class="keyword">int</span> low, <span class="keyword">int</span> same)</span></span>&#123;</div><div class="line">        <span class="keyword">char</span> s_element = s.charAt(low);</div><div class="line">        <span class="comment">// t中这个元素还没匹配完</span></div><div class="line">        <span class="keyword">if</span>(hash_t[s_element] &gt; <span class="number">0</span> &amp;&amp; hash_s[s_element] &lt;= hash_t[s_element])&#123;</div><div class="line">            same -= <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        hash_s[s_element]--;</div><div class="line">        ++low;</div><div class="line">        <span class="keyword">return</span> same;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(s.length() &lt; t.length() || t.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">        <span class="keyword">int</span>[] hash_s = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</div><div class="line">        <span class="keyword">int</span>[] hash_t = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); ++i)&#123;</div><div class="line">            hash_s[s.charAt(i)]++;</div><div class="line">            hash_t[t.charAt(i)]++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> same = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i)&#123;</div><div class="line">            <span class="keyword">if</span>(hash_t[i] &gt; <span class="number">0</span> &amp;&amp; hash_s[i] &gt; <span class="number">0</span>)&#123;</div><div class="line">                same += Math.min(hash_s[i], hash_t[i]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> window = Integer.MAX_VALUE;</div><div class="line">        <span class="keyword">int</span> start = -<span class="number">1</span>, end = -<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = t.length() - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (low&lt;= s.length() - t.length() &amp;&amp; high &lt; s.length())&#123;</div><div class="line">            <span class="keyword">if</span>(same == t.length())&#123;</div><div class="line">                <span class="keyword">if</span>(high - low + <span class="number">1</span> &lt; window)&#123;</div><div class="line">                    start = low;</div><div class="line">                    end = high;</div><div class="line">                    window = high - low + <span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">                same = goLow(hash_s, hash_t, s, t, low, same);</div><div class="line">                ++low;</div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(same &lt; t.length())&#123;</div><div class="line">                same = goHigh(hash_s, hash_t, s, t, high, same);</div><div class="line">                ++high;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                same = goLow(hash_s, hash_t, s, t, high, same);</div><div class="line">                ++low;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//System.out.println();</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(start == -<span class="number">1</span>) <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">        <span class="keyword">return</span> s.substring(start, end + <span class="number">1</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h1 id="数组划分问题">8. 数组划分问题</h1><h2 id="例题18，Partition-Array">8.1. 例题18，Partition Array</h2><p>给一个数组和一个k。移动数组使得小于k的在左边，大于k的在右边。</p>
<p>思路；Two  Pointer方法</p>
<ol>
<li>从左往右找到第一个大于k的</li>
<li>从右往左找到第一个小于k的</li>
<li>交换他俩</li>
</ol>
<h2 id="例题19，Sort-letters-by-case">8.2. 例题19，Sort letters by case</h2><p>字符大小写排序</p>
<h2 id="例题20，Sort-Colors">8.3. 例题20，Sort Colors</h2><p>方法1：</p>
<ol>
<li>先分成0一组，12一组</li>
<li>然后再将12分开</li>
</ol>
<p>方法2：</p>
<p>参考程序，三分方法</p>
<p>变形：分成三个部分：</p>
<ol>
<li>x&lt;= low</li>
<li>low&lt; x &lt;= high</li>
<li>x &gt; high</li>
</ol>
<h2 id="Sort-Color-II">8.4. Sort Color II</h2><h2 id="Interleaving-Positive-and-Negative-Numbers">8.5. Interleaving Positive and Negative Numbers</h2><h1 id="螺旋数组问题">9. 螺旋数组问题</h1><h2 id="Spiral-Matrix">9.1. Spiral Matrix</h2><p>螺旋输出二维数组</p>
<p>要注意边界条件等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">0</span>);</div><div class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;(matrix.length * matrix[<span class="number">0</span>].length);</div><div class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = matrix[<span class="number">0</span>].length - <span class="number">1</span>, top = <span class="number">0</span>, bottom = matrix.length - <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (bottom &gt;= top &amp;&amp; left &lt;= right) &#123;</div><div class="line">        j = left;</div><div class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; j &lt;= right) &#123;</div><div class="line">            res.add(matrix[top][j]);</div><div class="line">            ++j;</div><div class="line">        &#125;</div><div class="line">        top++;</div><div class="line">        i = top;</div><div class="line">        <span class="keyword">while</span> (bottom &gt;= top &amp;&amp; i &lt;= bottom) &#123;</div><div class="line">            res.add(matrix[i][right]);</div><div class="line">            ++i;</div><div class="line">        &#125;</div><div class="line">        right--;</div><div class="line">        j = right;</div><div class="line">        <span class="keyword">while</span> (bottom &gt;= top &amp;&amp; j &gt;= left) &#123;</div><div class="line">            res.add(matrix[bottom][j]);</div><div class="line">            --j;</div><div class="line">        &#125;</div><div class="line">        bottom--;</div><div class="line">        i = bottom;</div><div class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; i &gt;= top) &#123;</div><div class="line">            res.add(matrix[i][left]);</div><div class="line">            --i;</div><div class="line">        &#125;</div><div class="line">        left++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Spiral-Matrix-II">9.2. Spiral Matrix II</h2><p>输出$n\times n$ 的螺旋数组（元素从1开始依次递增）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] generateMatrix(<span class="keyword">int</span> n) &#123;</div><div class="line">    <span class="keyword">int</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> val = <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>, top = <span class="number">0</span>, bottom = n - <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span> (left &lt;= right &amp;&amp; top &lt;= bottom)&#123;</div><div class="line">        j = left;</div><div class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; j &lt;= right)&#123;</div><div class="line">            matrix[top][j++] = val++;</div><div class="line">        &#125;</div><div class="line">        i = ++top;</div><div class="line">        <span class="keyword">while</span> (top &lt;= bottom &amp;&amp; i &lt;= bottom)&#123;</div><div class="line">            matrix[i++][right] = val++;</div><div class="line">        &#125;</div><div class="line">        j = --right;</div><div class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; j &gt;= left)&#123;</div><div class="line">            matrix[bottom][j--] = val++;</div><div class="line">        &#125;</div><div class="line">        i = --bottom;</div><div class="line">        <span class="keyword">while</span> (top &lt;= bottom &amp;&amp; i &gt;= top)&#123;</div><div class="line">            matrix[i--][left] = val++;</div><div class="line">        &#125;</div><div class="line">        ++left;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> matrix;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="区间问题">10. 区间问题</h1><h2 id="Merge-Intervals">10.1. Merge Intervals</h2><p>给一些区间。输出区间的合并结果。</p>
<p>要点：</p>
<ol>
<li>List 的<code>Collections.sort()</code>排序</li>
<li><code>Comparator</code>的用法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompareInterval</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Interval</span>&gt;</span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Interval o1, Interval o2)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> o1.start - o2.start;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Interval&gt; <span class="title">merge</span><span class="params">(List&lt;Interval&gt; intervals)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(intervals.size() == <span class="number">0</span>) <span class="keyword">return</span> intervals;</div><div class="line">    <span class="comment">// 先按照start排序</span></div><div class="line">    Collections.sort(intervals, <span class="keyword">new</span> CompareInterval()); <span class="comment">// 注意这个排序的用法</span></div><div class="line">    <span class="keyword">int</span> start = intervals.get(<span class="number">0</span>).start, end = intervals.get(<span class="number">0</span>).end;</div><div class="line">    List&lt;Interval&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">    <span class="keyword">for</span>(Interval interval : intervals)&#123;</div><div class="line">        <span class="keyword">if</span>(interval.start &lt;= end)&#123;</div><div class="line">            end = Math.max(end,interval.end);</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            result.add(<span class="keyword">new</span> Interval(start,end));</div><div class="line">            start = interval.start;</div><div class="line">            end = interval.end;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(intervals.size() &gt; <span class="number">0</span>)&#123;result.add(<span class="keyword">new</span> Interval(start,end));&#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Insert-Interval">10.2. Insert Interval</h2><p>给一些区间。将另一个区间与这些区间合并。</p>
<p>要点：细心！边界条件！！！！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Interval&gt; <span class="title">insert</span><span class="params">(List&lt;Interval&gt; intervals, Interval newInterval)</span> </span>&#123;</div><div class="line">        List&lt;Interval&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        <span class="keyword">boolean</span> begin = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        Interval last = newInterval;</div><div class="line">        <span class="keyword">for</span>(Interval interval : intervals)&#123;</div><div class="line">            <span class="keyword">if</span>(!begin) &#123;</div><div class="line">                <span class="keyword">if</span> (interval.end &gt;= newInterval.start &amp;&amp; interval.start &lt;= newInterval.end) &#123;</div><div class="line">                    interval.end = Math.max(interval.end, newInterval.end);</div><div class="line">                    interval.start = Math.min(interval.start, newInterval.start);</div><div class="line">                    last = interval;</div><div class="line">                    begin = <span class="keyword">true</span>;</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(interval.start &gt; newInterval.end)&#123;</div><div class="line">                    result.add(newInterval);</div><div class="line">                    begin = <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">                result.add(interval);</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                <span class="keyword">if</span>(interval.start &lt;= last.end)&#123;</div><div class="line">                    last.end = Math.max(interval.end, last.end);</div><div class="line">                &#125;<span class="keyword">else</span>&#123;</div><div class="line">                    result.add(interval);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(!begin)&#123;</div><div class="line">            result.add(newInterval);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="Summary-Ranges">10.3. Summary Ranges</h2><p>给一个无重数组，如果相邻两个数字差为1，则这两个数在一个区间。输出数组的所有区间。</p>
<p>这道题还好。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">summaryRanges</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        List&lt;String&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>)<span class="keyword">return</span> result;</div><div class="line">        <span class="keyword">int</span> start = nums[<span class="number">0</span>];</div><div class="line">        <span class="keyword">int</span> end = nums[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; ++i)&#123;</div><div class="line">            <span class="keyword">if</span>(nums[i] == nums[i - <span class="number">1</span>] + <span class="number">1</span>)&#123;</div><div class="line">                end = nums[i];</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                <span class="keyword">if</span>(start == end)&#123;</div><div class="line">                    result.add(String.valueOf(start));</div><div class="line">                &#125;<span class="keyword">else</span>&#123;</div><div class="line">                    result.add(String.valueOf(start)+<span class="string">"-&gt;"</span>+String.valueOf(end));</div><div class="line">                &#125;</div><div class="line">                start = nums[i];</div><div class="line">                end = nums[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(start == end)&#123;</div><div class="line">            result.add(String.valueOf(start));</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            result.add(String.valueOf(start)+<span class="string">"-&gt;"</span>+String.valueOf(end));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h1 id="My-Calendar-I">11. My Calendar I</h1><p>设计一个Calendar类，每次进行<code>book(start, end)</code>操作。如果这次时间与之前的行程冲突，那么返回false。否则保存新的行程，并返回true。</p>
<p>思路：想着用树来表示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">节点： 区间，由start和end表示</div><div class="line">左孩子：所有在start之前的行程</div><div class="line">右孩子：所有在end之后的行程</div><div class="line"></div><div class="line">代码：</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCalendar</span> </span>&#123;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> start;</div><div class="line">        <span class="keyword">int</span> end;</div><div class="line">        Node left;</div><div class="line">        Node right;</div><div class="line">        Node(<span class="keyword">int</span> start, <span class="keyword">int</span> end)&#123;</div><div class="line">            <span class="keyword">this</span>.start = start;</div><div class="line">            <span class="keyword">this</span>.end = end;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    Node root;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCalendar</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">book</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == root)&#123;</div><div class="line">            root = <span class="keyword">new</span> Node(start,end);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            Node curr = root;</div><div class="line">            Node parent = root;</div><div class="line">            <span class="keyword">int</span> ifLeft = <span class="number">0</span>;</div><div class="line">            <span class="keyword">while</span> (<span class="keyword">null</span> != curr)&#123;</div><div class="line">                parent = curr;</div><div class="line">                <span class="keyword">if</span>(end &lt;= curr.start)&#123;</div><div class="line">                    curr = curr.left;</div><div class="line">                    ifLeft = <span class="number">1</span>;</div><div class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(start &gt;= curr.end)&#123;</div><div class="line">                    curr = curr.right;</div><div class="line">                    ifLeft = -<span class="number">1</span>;</div><div class="line">                &#125;<span class="keyword">else</span>&#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(ifLeft == <span class="number">1</span>)&#123;</div><div class="line">                parent.left = <span class="keyword">new</span> Node(start,end);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ifLeft == -<span class="number">1</span>)&#123;</div><div class="line">                parent.right = <span class="keyword">new</span> Node(start,end);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>  <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="其它数组操作">12. 其它数组操作</h1><h2 id="Game-of-Life">12.1. Game of Life</h2><p>给一个二维数组，1代表本轮活着，0代表本轮死了。如果：</p>
<ul>
<li><p>如果某点的活着的邻居少于两个，则它死亡</p>
<ul>
<li>如果某点有2/3个活着的邻居，则它可以进入下一代</li>
<li>如果某点有3个以上活着的邻居，则它死亡</li>
<li>如果某死点周围只有三个活着的邻居，则它复活</li>
</ul>
</li>
</ul>
<p>思路：为了在原地进行替换，我们定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">令下一时刻：</div><div class="line">* 1 = 下一轮活（本轮活）</div><div class="line">* 2 = 下一轮死（本轮是活的）</div><div class="line">*</div><div class="line">* -1 = 复活（本轮是死的）</div><div class="line">* -2 = 下一轮死（本轮死）</div></pre></td></tr></table></figure>
<p>因此：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getBoardVal</span><span class="params">(<span class="keyword">int</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= board.length || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length )&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(board[i][j] &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getLiveNeighbors</span><span class="params">(<span class="keyword">int</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> live = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> q = -<span class="number">1</span>; q &lt; <span class="number">2</span>; ++q) &#123;</div><div class="line">        live += getBoardVal(board, i - <span class="number">1</span>, j + q);</div><div class="line">        live += getBoardVal(board, i + <span class="number">1</span>, j + q);</div><div class="line">    &#125;</div><div class="line">    live += getBoardVal(board, i, j + <span class="number">1</span>);</div><div class="line">    live += getBoardVal(board, i, j - <span class="number">1</span>);</div><div class="line">    <span class="keyword">return</span> live;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gameOfLife</span><span class="params">(<span class="keyword">int</span>[][] board)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(board.length == <span class="number">0</span> || board[<span class="number">0</span>].length == <span class="number">0</span>)<span class="keyword">return</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     *  令下一时刻：</div><div class="line">     * 1 = 下一轮活（本轮活）</div><div class="line">     * 2 = 下一轮死（本轮是活的）</div><div class="line">     *</div><div class="line">     * -1 = 复活（本轮是死的）</div><div class="line">     * 0 = 下一轮死（本轮死）**/</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; ++i)&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; ++j)&#123;</div><div class="line">            <span class="keyword">if</span>(board[i][j] &lt;= <span class="number">0</span>)&#123;</div><div class="line">                <span class="keyword">if</span>(getLiveNeighbors(board,i,j) == <span class="number">3</span>)&#123;</div><div class="line">                    board[i][j] = -<span class="number">1</span>; <span class="comment">// 下一轮复活</span></div><div class="line">                &#125;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                <span class="keyword">int</span> liveNeibor = getLiveNeighbors(board,i,j);</div><div class="line">                <span class="keyword">if</span>(liveNeibor &lt; <span class="number">2</span> || liveNeibor &gt; <span class="number">3</span>)&#123;<span class="comment">//下一轮死</span></div><div class="line">                    board[i][j] = <span class="number">2</span>;</div><div class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">// 下一轮活</span></div><div class="line">                    <span class="comment">//board[i][j] = 1;</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; ++i)&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; ++j)&#123;</div><div class="line">            <span class="keyword">if</span>(board[i][j] == <span class="number">1</span> || board[i][j] == -<span class="number">1</span>)&#123;</div><div class="line">                board[i][j] = <span class="number">1</span>;</div><div class="line">            &#125;<span class="keyword">else</span> &#123;</div><div class="line">                board[i][j] = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Beautiful-Arrangement-II">12.2. Beautiful Arrangement II</h2><p>给一个n和一个k。求一个长度为n的数组，要求数组的$a_{i+1}-a_i$ 至少有k个不同的数。</p>
<p>思路：找到规律，直接生成即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] constructArray(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</div><div class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[n];</div><div class="line">        <span class="keyword">int</span> max = k + <span class="number">1</span>, min = <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> filled = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (filled &lt; n )&#123;</div><div class="line">            <span class="keyword">if</span>(max &gt; min)&#123;</div><div class="line">                nums[filled] = min;</div><div class="line">                ++filled;</div><div class="line">                nums[filled] = max;</div><div class="line">                ++filled;</div><div class="line">                --max; ++min;</div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(max == min)&#123;</div><div class="line">                nums[filled] = max;</div><div class="line">                ++filled;</div><div class="line">                --max;++min;</div><div class="line">            &#125;<span class="keyword">else</span> &#123;</div><div class="line">                nums[filled] = filled + <span class="number">1</span>;</div><div class="line">                ++filled;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> nums;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="1-bit-and-2-bit-Characters">12.3. 1-bit and 2-bit Characters</h2><p>给一个数组，元素由1或0.其中<code>0</code>代表一个东西，<code>10 or 11</code> 代表另一个东西。求这个数组是否可以以<code>0</code>结尾。</p>
<p>思路：碰到1就跳两格，碰到0就只能跳一格。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] bits, <span class="keyword">int</span> idx)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(idx &gt;= bits.length) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">if</span>(idx == bits.length - <span class="number">1</span>) <span class="keyword">return</span> bits[idx] == <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span>(bits[idx] == <span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> helper(bits, idx + <span class="number">2</span>);</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> helper(bits, idx + <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOneBitCharacter</span><span class="params">(<span class="keyword">int</span>[] bits)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> helper(bits,<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Multiply-Strings">12.4. Multiply Strings</h2><p>计算字符串的大数乘法</p>
<p>我的思路：按照竖式计算乘法的方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span>((num1.length() == <span class="number">0</span> || num2.length() == <span class="number">0</span>)||</div><div class="line">          (num1.length() == <span class="number">1</span> &amp;&amp; num1.equals(<span class="string">"0"</span>))||</div><div class="line">          (num2.length() == <span class="number">1</span> &amp;&amp; num2.equals(<span class="string">"0"</span>))) <span class="keyword">return</span> <span class="string">"0"</span>;</div><div class="line">      <span class="keyword">if</span>(num1.length() &gt; num2.length())&#123;</div><div class="line">          String temp = num1;</div><div class="line">          num1 = num2;</div><div class="line">          num2 = temp;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">int</span>[] nums1 = <span class="keyword">new</span> <span class="keyword">int</span>[num1.length()], nums2 = <span class="keyword">new</span> <span class="keyword">int</span>[num2.length()];</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num1.length(); ++i) nums1[i] = num1.charAt(i) - <span class="string">'0'</span>;</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num2.length(); ++i) nums2[i] = num2.charAt(i) - <span class="string">'0'</span>;</div><div class="line">      <span class="comment">// num1 是短的，num2是长的</span></div><div class="line">      <span class="keyword">int</span> n1 = num1.length(), n2 = num2.length();</div><div class="line">      <span class="keyword">int</span>[][] temp = <span class="keyword">new</span> <span class="keyword">int</span>[n1][n2];</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = n1 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</div><div class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n2; ++j)&#123;</div><div class="line">              temp[i][j] = nums1[n1 - i - <span class="number">1</span>] * nums2[n2 - j - <span class="number">1</span>];</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">      StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">      <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">      <span class="keyword">int</span> last = <span class="number">0</span>;</div><div class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</div><div class="line">          <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">          <span class="keyword">boolean</span> finsh = <span class="keyword">true</span>;</div><div class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> line = <span class="number">0</span>; line &lt; n1; ++line)&#123;</div><div class="line">              <span class="keyword">if</span>(j - line &gt;= <span class="number">0</span> &amp;&amp; j - line &lt; n2)&#123;</div><div class="line">                  sum += temp[line][j - line];</div><div class="line">                  finsh = <span class="keyword">false</span>;</div><div class="line">              &#125;</div><div class="line">              <span class="keyword">if</span>(j - line &lt; <span class="number">0</span>) <span class="keyword">break</span>;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">if</span>(finsh) <span class="keyword">break</span>;</div><div class="line">          sum += last;</div><div class="line">          last = sum / <span class="number">10</span>;</div><div class="line">          sum = sum % <span class="number">10</span>;</div><div class="line">          sb.append(sum);</div><div class="line">          ++j;</div><div class="line"></div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span>(last &gt; <span class="number">0</span>)sb.append(last);</div><div class="line">      <span class="keyword">return</span> sb.reverse().toString();</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>自己吭哧吭哧写半天，还是人家写的好。。。。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">multiply</span><span class="params">(String nums1, String nums2)</span></span>&#123;</div><div class="line">  <span class="keyword">int</span> m = num1.length(), n = num2.length();</div><div class="line">  <span class="keyword">int</span>[] pos = <span class="keyword">new</span> <span class="keyword">int</span>[m + n];</div><div class="line">  </div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)&#123;</div><div class="line">      <span class="keyword">int</span> mul = (num1.charAt(i) - <span class="string">'0'</span>) * (num2.charAt(j) - <span class="string">'0'</span>);</div><div class="line">      <span class="keyword">int</span> p1 = i + j, p2 = p1 + <span class="number">1</span>; <span class="comment">// 这个我自己怎么就想不到呢，哎，其实就是矩阵的对角线啊！</span></div><div class="line">      mol += pos(p2);</div><div class="line">      pos[p1] += sum/<span class="number">10</span>;</div><div class="line">      pos[p2] = sum%<span class="number">10</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> p : pos)<span class="keyword">if</span>(!(sb.length() == <span class="number">0</span> &amp;&amp; p = <span class="number">0</span>)) sb.append(p);</div><div class="line">  <span class="keyword">return</span> sb.length() == <span class="number">0</span> ? <span class="string">"0"</span> : sb.toString();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="参考资料">13. 参考资料</h1><ol>
<li><a href="https://discuss.leetcode.com/topic/107998/most-consistent-ways-of-dealing-with-the-series-of-stock-problems" target="_blank" rel="external">Most consistent ways of dealing with the series of stock problems</a></li>
<li><a href="https://www.jianshu.com/p/9fa0faff99da" target="_blank" rel="external">【刷题总结】买卖股票最大利润问题</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[深度学习实践-1-4-2-用神经网络识别猫]]></title>
      <url>/2017/12/10/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5-1-4-2-%E7%94%A8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E8%AF%86%E5%88%AB%E7%8C%AB/</url>
      <content type="html"><![CDATA[<p>本文主要参考自<a href="http://blog.csdn.net/koala_tree/article/details/78092337" target="_blank" rel="external">吴恩达Coursera深度学习课程 DeepLearning.ai 编程作业（1-4）</a></p>
<p>吴恩达Coursera课程 DeepLearning.ai 编程作业系列，本文为《神经网络与深度学习》部分的第四周“深层神经网络”的课程作业。</p>
<p>本节的主要内容是：利用之前实现的神经网络，来识别图片中的猫</p>
<a id="more"></a>
<h1 id="import">1. import</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> warnings</div><div class="line">warnings.filterwarnings(<span class="string">"ignore"</span>) </div><div class="line"></div><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> h5py</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="keyword">import</span> scipy</div><div class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</div><div class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> ndimage</div><div class="line"><span class="keyword">from</span> dnn_app_utils_v2 <span class="keyword">import</span> *</div><div class="line"></div><div class="line">%matplotlib inline</div><div class="line">plt.rcParams[<span class="string">'figure.figsize'</span>] = (<span class="number">5.0</span>, <span class="number">4.0</span>) <span class="comment"># set default size of plots</span></div><div class="line">plt.rcParams[<span class="string">'image.interpolation'</span>] = <span class="string">'nearest'</span></div><div class="line">plt.rcParams[<span class="string">'image.cmap'</span>] = <span class="string">'gray'</span></div><div class="line"></div><div class="line">%load_ext autoreload</div><div class="line">%autoreload <span class="number">2</span></div><div class="line"></div><div class="line">np.random.seed(<span class="number">1</span>)</div></pre></td></tr></table></figure>
<pre><code>The autoreload extension is already loaded. To reload it, use:
  %reload_ext autoreload
</code></pre><h1 id="数据集">2. 数据集</h1><p>用到“猫-非猫”数据集 <code>data.h5</code> :</p>
<ul>
<li>training set : m_train</li>
<li>test set : m_test</li>
<li>每个图片的大小是 (num_px, num_px, 3) </li>
</ul>
<p>接下来我们将图片加载出来：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_data</span><span class="params">()</span>:</span></div><div class="line">    train_dataset = h5py.File(<span class="string">'datasets/train_catvnoncat.h5'</span>, <span class="string">"r"</span>)</div><div class="line">    train_set_x_orig = np.array(train_dataset[<span class="string">"train_set_x"</span>][:]) <span class="comment"># your train set features</span></div><div class="line">    train_set_y_orig = np.array(train_dataset[<span class="string">"train_set_y"</span>][:]) <span class="comment"># your train set labels</span></div><div class="line"></div><div class="line">    test_dataset = h5py.File(<span class="string">'datasets/test_catvnoncat.h5'</span>, <span class="string">"r"</span>)</div><div class="line">    test_set_x_orig = np.array(test_dataset[<span class="string">"test_set_x"</span>][:]) <span class="comment"># your test set features</span></div><div class="line">    test_set_y_orig = np.array(test_dataset[<span class="string">"test_set_y"</span>][:]) <span class="comment"># your test set labels</span></div><div class="line"></div><div class="line">    classes = np.array(test_dataset[<span class="string">"list_classes"</span>][:]) <span class="comment"># the list of classes</span></div><div class="line">    </div><div class="line">    train_set_y_orig = train_set_y_orig.reshape((<span class="number">1</span>, train_set_y_orig.shape[<span class="number">0</span>]))</div><div class="line">    test_set_y_orig = test_set_y_orig.reshape((<span class="number">1</span>, test_set_y_orig.shape[<span class="number">0</span>]))</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> train_set_x_orig, train_set_y_orig, test_set_x_orig, test_set_y_orig, classes</div><div class="line"></div><div class="line">train_x_orig, train_y, test_x_orig, test_y, classes = load_data()</div><div class="line"></div><div class="line"><span class="comment"># 数据集样例</span></div><div class="line">index = <span class="number">10</span></div><div class="line">plt.imshow(train_x_orig[index])</div><div class="line"><span class="keyword">print</span> (<span class="string">"y = "</span> + str(train_y[<span class="number">0</span>,index]) + <span class="string">". It's a "</span> + classes[train_y[<span class="number">0</span>,index]].decode(<span class="string">"utf-8"</span>) +  <span class="string">" picture."</span>)</div></pre></td></tr></table></figure>
<pre><code>y = 0. It&apos;s a non-cat picture.
</code></pre><p>​    </p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-10-18-09-04.png" alt=""> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 再探数据集</span></div><div class="line"></div><div class="line">m_train = train_x_orig.shape[<span class="number">0</span>]</div><div class="line">num_px = train_x_orig.shape[<span class="number">1</span>]</div><div class="line">m_test = test_x_orig.shape[<span class="number">0</span>]</div><div class="line"></div><div class="line"><span class="keyword">print</span> (<span class="string">"训练集样本数: "</span> + str(m_train))</div><div class="line"><span class="keyword">print</span> (<span class="string">"测试集样本数: "</span> + str(m_test))</div><div class="line"><span class="keyword">print</span> (<span class="string">"单张图片shape: ("</span> + str(num_px) + <span class="string">", "</span> + str(num_px) + <span class="string">", 3)"</span>)</div><div class="line"><span class="keyword">print</span> (<span class="string">"train_x_orig shape: "</span> + str(train_x_orig.shape))</div><div class="line"><span class="keyword">print</span> (<span class="string">"train_y shape: "</span> + str(train_y.shape))</div><div class="line"><span class="keyword">print</span> (<span class="string">"test_x_orig shape: "</span> + str(test_x_orig.shape))</div><div class="line"><span class="keyword">print</span> (<span class="string">"test_y shape: "</span> + str(test_y.shape))</div></pre></td></tr></table></figure>
<pre><code>训练集样本数: 209
测试集样本数: 50
单张图片shape: (64, 64, 3)
train_x_orig shape: (209L, 64L, 64L, 3L)
train_y shape: (1L, 209L)
test_x_orig shape: (50L, 64L, 64L, 3L)
test_y shape: (1L, 50L)
</code></pre><p>为了方便运算，我们需要将图片reshape为标准格式：如下图所示：<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-10-15-57-08.png" alt=""><br>而reshape的代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Reshape the training and test examples </span></div><div class="line">train_x_flatten = train_x_orig.reshape(train_x_orig.shape[<span class="number">0</span>], <span class="number">-1</span>).T   <span class="comment"># The "-1" makes reshape flatten the remaining dimensions</span></div><div class="line">test_x_flatten = test_x_orig.reshape(test_x_orig.shape[<span class="number">0</span>], <span class="number">-1</span>).T</div><div class="line"></div><div class="line"><span class="comment"># Standardize data to have feature values between 0 and 1.</span></div><div class="line">train_x = train_x_flatten/<span class="number">255.</span></div><div class="line">test_x = test_x_flatten/<span class="number">255.</span></div><div class="line"></div><div class="line"><span class="keyword">print</span> (<span class="string">"train_x's shape: "</span> + str(train_x.shape))</div><div class="line"><span class="keyword">print</span> (<span class="string">"test_x's shape: "</span> + str(test_x.shape))</div><div class="line"></div><div class="line"><span class="comment"># 12,288  =  64×64×3</span></div></pre></td></tr></table></figure>
<pre><code>train_x&apos;s shape: (12288L, 209L)
test_x&apos;s shape: (12288L, 50L)
</code></pre><p>接下来来时建立基于深度神经网络的图片分类模型</p>
<p>建立两个模型：</p>
<ul>
<li>两层的神经网络</li>
<li>L层的深度神经网络</li>
</ul>
<h1 id="两层神经网络">3. 两层神经网络</h1><p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-10-15-59-23.png" alt=""> </p>
<p>上图的模型可以总结为：INPUT -&gt; LINEAR -&gt; RELU -&gt; LINEAR -&gt; SIGMOID -&gt; OUTPUT.</p>
<p>详细地说，也就是：</p>
<ul>
<li>输入是将(64,64,3)的图片reshape为(12288,1)的数据，作为 $[x_0,x_1,…,x_{12287}]^T$ - 将上面的X乘上权重向量：$W^{[1]}$ ，而W的大小是 $(n^{[1]}, 12288)$</li>
<li>然后加上偏置向量，再填入relu函数中，得到了结果$[a_0^{[1]}, a_1^{[1]},…, a_{n^{[1]}-1}^{[1]}]^T$</li>
<li>重复上面的步骤</li>
<li>将最终的结果通过sigmoid函数，大于0.5的置为true，否则置为false</li>
</ul>
<p>将以上流程包装为函数，即以下几个：(已经在上一节中写过了，此处直接调用）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize_parameters</span><span class="params">(n_x, n_h, n_y)</span>:</span></div><div class="line">    ...</div><div class="line">    <span class="keyword">return</span> parameters </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">linear_activation_forward</span><span class="params">(A_prev, W, b, activation)</span>:</span></div><div class="line">    ...</div><div class="line">    <span class="keyword">return</span> A, cache</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_cost</span><span class="params">(AL, Y)</span>:</span></div><div class="line">    ...</div><div class="line">    <span class="keyword">return</span> cost</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">linear_activation_backward</span><span class="params">(dA, cache, activation)</span>:</span></div><div class="line">    ...</div><div class="line">    <span class="keyword">return</span> dA_prev, dW, db</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_parameters</span><span class="params">(parameters, grads, learning_rate)</span>:</span></div><div class="line">    ...</div><div class="line">    <span class="keyword">return</span> parameters</div></pre></td></tr></table></figure>
<p>接下来我们实现两层的神经网络：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">two_layer_model</span><span class="params">(X, Y, layer_dims, learning_rate = <span class="number">0.0075</span>, num_iterations = <span class="number">3000</span>, print_cost = False)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    实现两层神经网络：LINEAR-&gt;RELU-&gt;LINEAR-&gt;SIGMOID</div><div class="line">    </div><div class="line">    输入：</div><div class="line">    X -- 训练特征 ,n_x 个</div><div class="line">    Y -- 真实label向量</div><div class="line">    layer_dims --  (n_x, n_h, n_y)</div><div class="line">    num_iterations -- 迭代次数</div><div class="line">    learning_rate -- 学习率</div><div class="line">    print_cost -- 如果为真，就会每一百次迭代输出一次cost</div><div class="line">    </div><div class="line">    Returns:</div><div class="line">    parameters -- python dict, 包含W1, W2, b1, b2</div><div class="line">    """</div><div class="line">    </div><div class="line">    np.random.seed(<span class="number">1</span>)</div><div class="line">    grads = &#123;&#125;</div><div class="line">    costs = []</div><div class="line">    m = X.shape[<span class="number">1</span>]</div><div class="line">    (n_x, n_h, n_y) = layer_dims</div><div class="line">    </div><div class="line">    <span class="comment"># 初始化</span></div><div class="line">    </div><div class="line">    parameters = initialize_parameters(n_x, n_h, n_y)</div><div class="line">    W1 = parameters[<span class="string">"W1"</span>]</div><div class="line">    b1 = parameters[<span class="string">"b1"</span>]</div><div class="line">    W2 = parameters[<span class="string">"W2"</span>]</div><div class="line">    b2 = parameters[<span class="string">"b2"</span>]</div><div class="line"></div><div class="line">    <span class="comment"># 迭代</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, num_iterations):</div><div class="line">        <span class="comment"># 前向传播： LINEAR -&gt; RELU -&gt; LINEAR -&gt; SIGMOID</span></div><div class="line">        <span class="comment"># 输入 ： X, W1, b1</span></div><div class="line">        <span class="comment"># 输出 ： A1, cache1, A2, cache2</span></div><div class="line">        A1, cache1 = linear_activation_forward(X, W1, b1, activation = <span class="string">"relu"</span>)</div><div class="line">        A2, cache2 = linear_activation_forward(A1,W2, b2, activation = <span class="string">"sigmoid"</span>)</div><div class="line">        </div><div class="line">        <span class="comment"># 计算cost</span></div><div class="line">        cost = compute_cost(A2, Y)</div><div class="line">        </div><div class="line">        <span class="comment"># 初始化反向传播</span></div><div class="line">        dA2 = - (np.divide(Y, A2) - np.divide(<span class="number">1</span> - Y, <span class="number">1</span> - A2))</div><div class="line">        </div><div class="line">        <span class="comment"># 反向传播</span></div><div class="line">        <span class="comment"># 输入 ： dA2, cache2, cache1</span></div><div class="line">        <span class="comment"># 输出 ： dA1, dW2, db2; also dA0 (not used), dW1, db1</span></div><div class="line">        </div><div class="line">        dA1, dW2, db2 = linear_activation_backward(dA2, cache2, activation = <span class="string">"sigmoid"</span>)</div><div class="line">        dA0, dW1, db1 = linear_activation_backward(dA1, cache1, activation = <span class="string">"relu"</span>)</div><div class="line">        </div><div class="line">        grads[<span class="string">'dW1'</span>] = dW1</div><div class="line">        grads[<span class="string">'db1'</span>] = db1</div><div class="line">        grads[<span class="string">'dW2'</span>] = dW2</div><div class="line">        grads[<span class="string">'db2'</span>] = db2</div><div class="line">        </div><div class="line">        </div><div class="line">        <span class="comment"># 更新参数</span></div><div class="line">        parameters = update_parameters(parameters, grads, learning_rate)</div><div class="line">        </div><div class="line">        W1 = parameters[<span class="string">"W1"</span>]</div><div class="line">        b1 = parameters[<span class="string">"b1"</span>]</div><div class="line">        W2 = parameters[<span class="string">"W2"</span>]</div><div class="line">        b2 = parameters[<span class="string">"b2"</span>]</div><div class="line">        </div><div class="line">        <span class="comment"># 打印</span></div><div class="line">        <span class="keyword">if</span> print_cost <span class="keyword">and</span> i % <span class="number">100</span> == <span class="number">0</span>:</div><div class="line">            print(<span class="string">"Cost after iteration &#123;&#125;: &#123;&#125;"</span>.format(i, np.squeeze(cost)))</div><div class="line">        <span class="keyword">if</span> print_cost <span class="keyword">and</span> i % <span class="number">100</span> == <span class="number">0</span>:</div><div class="line">            costs.append(cost)</div><div class="line">    </div><div class="line">        </div><div class="line">    <span class="comment"># plot the cost</span></div><div class="line"></div><div class="line">    plt.plot(np.squeeze(costs))</div><div class="line">    plt.ylabel(<span class="string">'cost'</span>)</div><div class="line">    plt.xlabel(<span class="string">'iterations (per tens)'</span>)</div><div class="line">    plt.title(<span class="string">"Learning rate ="</span> + str(learning_rate))</div><div class="line">    plt.show()</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> parameters</div><div class="line"></div><div class="line">n_x = <span class="number">12288</span>     <span class="comment"># num_px * num_px * 3</span></div><div class="line">n_h = <span class="number">7</span></div><div class="line">n_y = <span class="number">1</span></div><div class="line">layers_dims = (n_x, n_h, n_y)</div><div class="line">parameters = two_layer_model(train_x, train_y, layers_dims, num_iterations = <span class="number">2500</span>, print_cost=<span class="keyword">True</span>)</div></pre></td></tr></table></figure>
<pre><code>Cost after iteration 0: 0.69304973566
Cost after iteration 100: 0.646432095343
Cost after iteration 200: 0.632514064791
Cost after iteration 300: 0.601502492035
Cost after iteration 400: 0.560196631161
Cost after iteration 500: 0.515830477276
Cost after iteration 600: 0.475490131394
Cost after iteration 700: 0.433916315123
Cost after iteration 800: 0.40079775362
Cost after iteration 900: 0.358070501132
Cost after iteration 1000: 0.339428153837
Cost after iteration 1100: 0.30527536362
Cost after iteration 1200: 0.274913772821
Cost after iteration 1300: 0.246817682106
Cost after iteration 1400: 0.198507350375
Cost after iteration 1500: 0.174483181126
Cost after iteration 1600: 0.170807629781
Cost after iteration 1700: 0.113065245622
Cost after iteration 1800: 0.0962942684594
Cost after iteration 1900: 0.0834261795973
Cost after iteration 2000: 0.0743907870432
Cost after iteration 2100: 0.0663074813227
Cost after iteration 2200: 0.0591932950104
Cost after iteration 2300: 0.0533614034856
Cost after iteration 2400: 0.0485547856288
</code></pre><p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-10-18-09-35.png" alt=""> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 接下来预测</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(X, y, parameters)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    This function is used to predict the results of a  L-layer neural network.</div><div class="line"></div><div class="line">    Arguments:</div><div class="line">    X -- data set of examples you would like to label</div><div class="line">    parameters -- parameters of the trained model</div><div class="line"></div><div class="line">    Returns:</div><div class="line">    p -- predictions for the given dataset X</div><div class="line">    """</div><div class="line"></div><div class="line">    m = X.shape[<span class="number">1</span>]</div><div class="line">    n = len(parameters) / <span class="number">2</span> <span class="comment"># number of layers in the neural network</span></div><div class="line">    p = np.zeros((<span class="number">1</span>,m))</div><div class="line"></div><div class="line">    <span class="comment"># Forward propagation</span></div><div class="line">    probas, caches = L_model_forward(X, parameters)</div><div class="line"></div><div class="line">    </div><div class="line">    <span class="comment"># convert probas to 0/1 predictions</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, probas.shape[<span class="number">1</span>]):</div><div class="line">        <span class="keyword">if</span> probas[<span class="number">0</span>,i] &gt; <span class="number">0.1</span>:</div><div class="line">            p[<span class="number">0</span>,i] = <span class="number">1</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            p[<span class="number">0</span>,i] = <span class="number">0</span></div><div class="line"></div><div class="line">    print(<span class="string">"Accuracy: "</span>  + str(float(np.sum(p == y)/float(m))))</div><div class="line">    <span class="keyword">return</span> p</div><div class="line"></div><div class="line">predictions_train = predict(train_x, train_y, parameters)</div><div class="line"></div><div class="line">predictions_test = predict(test_x, test_y, parameters)</div></pre></td></tr></table></figure>
<pre><code>Accuracy: 0.961722488038
Accuracy: 0.74
</code></pre><h1 id="L层深度神经网络">4. L层深度神经网络</h1><p>虽然说L层深度神经网络很繁琐，但我们可以通过下面的方式来简化它：<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-10-16-09-01.png" alt=""> </p>
<p>上图的模型可以总结为：[LINEAR -&gt; RELU] × (L-1) -&gt; LINEAR -&gt; SIGMOID</p>
<p>详细地说，也就是：</p>
<ul>
<li>输入是将(64,64,3)的图片reshape为(12288,1)的数据，作为 $[x_0,x_1,…,x_{12287}]^T$ - 将上面的X乘上权重向量：$W^{[1]}$ ，再加上偏置$b^{[1]}$，作为linear单元</li>
<li>然后将linear单元的输出填入relu-linear单元。这个过程重复L-1次</li>
<li>将最终的结果通过sigmoid函数，大于0.5的置为true，否则置为false</li>
</ul>
<p>构建方法的流程如下所示：</p>
<ul>
<li>初始化参数</li>
<li>循环：<ul>
<li>前向传播</li>
<li>计算cost</li>
<li>后向传播</li>
<li>更新参数</li>
</ul>
</li>
<li>用训练参数去预测label</li>
</ul>
<p>所需的函数为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize_parameters_deep</span><span class="params">(layer_dims)</span>:</span></div><div class="line">    ...</div><div class="line">    <span class="keyword">return</span> parameters </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">L_model_forward</span><span class="params">(X, parameters)</span>:</span></div><div class="line">    ...</div><div class="line">    <span class="keyword">return</span> AL, caches</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_cost</span><span class="params">(AL, Y)</span>:</span></div><div class="line">    ...</div><div class="line">    <span class="keyword">return</span> cost</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">L_model_backward</span><span class="params">(AL, Y, caches)</span>:</span></div><div class="line">    ...</div><div class="line">    <span class="keyword">return</span> grads</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_parameters</span><span class="params">(parameters, grads, learning_rate)</span>:</span></div><div class="line">    ...</div><div class="line">    <span class="keyword">return</span> parameters</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">L_layer_model</span><span class="params">(X, Y, layers_dims, learning_rate = <span class="number">0.0075</span>, num_iterations = <span class="number">3000</span>, print_cost = False)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    L层神经网络的实现：[LINEAR-&gt;RELU]*(L-1)-&gt;LINEAR-&gt;SIGMOID</div><div class="line">    </div><div class="line">    输入：</div><div class="line">    X -- 训练集，shape = (num_px * num_px * 3)</div><div class="line">    Y -- label向量</div><div class="line">    layers_dims -- list, 包含每层输入数据的大小</div><div class="line">    learning_rate -- 学习率</div><div class="line">    num_iterations -- 迭代次数</div><div class="line">    print_cost -- 如果为True，就每一百轮打印一次cost</div><div class="line">    </div><div class="line">    Returns:</div><div class="line">    parameters -- 学习到的参数</div><div class="line">    """</div><div class="line">    </div><div class="line">    <span class="comment"># 初始化</span></div><div class="line">    costs = []</div><div class="line">    parameters = initialize_parameters_deep(layers_dims)</div><div class="line">    </div><div class="line">    <span class="comment"># 循环</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, num_iterations):</div><div class="line">        <span class="comment"># 前向传播 : [LINEAR -&gt; RELU]*(L-1) -&gt; LINEAR -&gt; SIGMOID</span></div><div class="line">        AL, caches = L_model_forward(X, parameters)</div><div class="line">        </div><div class="line">        <span class="comment"># 计算cost</span></div><div class="line">        cost = compute_cost(AL, Y)</div><div class="line">        </div><div class="line">        <span class="comment"># 反向传播：</span></div><div class="line">        grads = L_model_backward(AL, Y, caches)</div><div class="line">        </div><div class="line">        <span class="comment"># 更新参数</span></div><div class="line">        parameters = update_parameters(parameters, grads, learning_rate)</div><div class="line">        </div><div class="line">        <span class="comment"># Print the cost every 100 training example</span></div><div class="line">        <span class="keyword">if</span> print_cost <span class="keyword">and</span> i % <span class="number">100</span> == <span class="number">0</span>:</div><div class="line">            <span class="keyword">print</span> (<span class="string">"Cost after iteration %i: %f"</span> %(i, cost))</div><div class="line">        <span class="keyword">if</span> print_cost <span class="keyword">and</span> i % <span class="number">100</span> == <span class="number">0</span>:</div><div class="line">            costs.append(cost)</div><div class="line"></div><div class="line">    <span class="comment"># plot the cost</span></div><div class="line">    plt.plot(np.squeeze(costs))</div><div class="line">    plt.ylabel(<span class="string">'cost'</span>)</div><div class="line">    plt.xlabel(<span class="string">'iterations (per tens)'</span>)</div><div class="line">    plt.title(<span class="string">"Learning rate ="</span> + str(learning_rate))</div><div class="line">    plt.show()</div><div class="line"></div><div class="line">    <span class="keyword">return</span> parameters</div><div class="line">       </div><div class="line">    </div><div class="line"><span class="comment"># 测试</span></div><div class="line">parameters = L_layer_model(train_x, train_y, layers_dims, num_iterations = <span class="number">2500</span>, print_cost = <span class="keyword">True</span>)</div></pre></td></tr></table></figure>
<pre><code>Cost after iteration 0: 0.695046
Cost after iteration 100: 0.589260
Cost after iteration 200: 0.523261
Cost after iteration 300: 0.449769
Cost after iteration 400: 0.420900
Cost after iteration 500: 0.372464
Cost after iteration 600: 0.347421
Cost after iteration 700: 0.317192
Cost after iteration 800: 0.266438
Cost after iteration 900: 0.219914
Cost after iteration 1000: 0.143579
Cost after iteration 1100: 0.453092
Cost after iteration 1200: 0.094994
Cost after iteration 1300: 0.080141
Cost after iteration 1400: 0.069402
Cost after iteration 1500: 0.060217
Cost after iteration 1600: 0.053274
Cost after iteration 1700: 0.047629
Cost after iteration 1800: 0.042976
Cost after iteration 1900: 0.039036
Cost after iteration 2000: 0.035683
Cost after iteration 2100: 0.032915
Cost after iteration 2200: 0.030472
Cost after iteration 2300: 0.028388
Cost after iteration 2400: 0.026615
</code></pre><p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-10-18-09-49.png" alt=""> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 预测</span></div><div class="line"></div><div class="line">pred_train = predict(train_x, train_y, parameters)</div><div class="line"></div><div class="line">pred_test = predict(test_x, test_y, parameters)</div></pre></td></tr></table></figure>
<pre><code>Accuracy: 0.980861244019
Accuracy: 0.78
</code></pre><h1 id="结果分析">5. 结果分析</h1><p>首先我们来看看有哪些图片被我们的模型分错了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print_mislabeled_images(classes, test_x, test_y, pred_test)</div></pre></td></tr></table></figure>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-10-18-10-04.png" alt=""> </p>
<p>我们发现主要有以下几类：</p>
<ul>
<li>猫的身子是歪的</li>
<li>猫出现在某种与它颜色相近的地方</li>
<li>非正常颜色或形状的猫</li>
<li>摄像角度</li>
<li>暗照片</li>
<li>非常大或非常小的猫</li>
</ul>
<h1 id="dnn-app-utils-v2-py">6. dnn_app_utils_v2.py</h1><p>在此附上附录的代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div><div class="line">363</div><div class="line">364</div><div class="line">365</div><div class="line">366</div><div class="line">367</div><div class="line">368</div><div class="line">369</div><div class="line">370</div><div class="line">371</div><div class="line">372</div><div class="line">373</div><div class="line">374</div><div class="line">375</div><div class="line">376</div><div class="line">377</div><div class="line">378</div><div class="line">379</div><div class="line">380</div><div class="line">381</div><div class="line">382</div><div class="line">383</div><div class="line">384</div><div class="line">385</div><div class="line">386</div><div class="line">387</div><div class="line">388</div><div class="line">389</div><div class="line">390</div><div class="line">391</div><div class="line">392</div><div class="line">393</div><div class="line">394</div><div class="line">395</div><div class="line">396</div><div class="line">397</div><div class="line">398</div><div class="line">399</div><div class="line">400</div><div class="line">401</div><div class="line">402</div><div class="line">403</div><div class="line">404</div><div class="line">405</div><div class="line">406</div><div class="line">407</div><div class="line">408</div><div class="line">409</div><div class="line">410</div><div class="line">411</div><div class="line">412</div><div class="line">413</div><div class="line">414</div><div class="line">415</div><div class="line">416</div><div class="line">417</div><div class="line">418</div><div class="line">419</div><div class="line">420</div><div class="line">421</div><div class="line">422</div><div class="line">423</div><div class="line">424</div><div class="line">425</div><div class="line">426</div><div class="line">427</div><div class="line">428</div><div class="line">429</div><div class="line">430</div><div class="line">431</div><div class="line">432</div><div class="line">433</div><div class="line">434</div><div class="line">435</div><div class="line">436</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="keyword">import</span> h5py</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(Z)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Implements the sigmoid activation in numpy</div><div class="line">    </div><div class="line">    Arguments:</div><div class="line">    Z -- numpy array of any shape</div><div class="line">    </div><div class="line">    Returns:</div><div class="line">    A -- output of sigmoid(z), same shape as Z</div><div class="line">    cache -- returns Z as well, useful during backpropagation</div><div class="line">    """</div><div class="line">    </div><div class="line">    A = <span class="number">1</span>/(<span class="number">1</span>+np.exp(-Z))</div><div class="line">    cache = Z</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> A, cache</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">relu</span><span class="params">(Z)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Implement the RELU function.</div><div class="line"></div><div class="line">    Arguments:</div><div class="line">    Z -- Output of the linear layer, of any shape</div><div class="line"></div><div class="line">    Returns:</div><div class="line">    A -- Post-activation parameter, of the same shape as Z</div><div class="line">    cache -- a python dictionary containing "A" ; stored for computing the backward pass efficiently</div><div class="line">    """</div><div class="line">    </div><div class="line">    A = np.maximum(<span class="number">0</span>,Z)</div><div class="line">    </div><div class="line">    <span class="keyword">assert</span>(A.shape == Z.shape)</div><div class="line">    </div><div class="line">    cache = Z </div><div class="line">    <span class="keyword">return</span> A, cache</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">relu_backward</span><span class="params">(dA, cache)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Implement the backward propagation for a single RELU unit.</div><div class="line"></div><div class="line">    Arguments:</div><div class="line">    dA -- post-activation gradient, of any shape</div><div class="line">    cache -- 'Z' where we store for computing backward propagation efficiently</div><div class="line"></div><div class="line">    Returns:</div><div class="line">    dZ -- Gradient of the cost with respect to Z</div><div class="line">    """</div><div class="line">    </div><div class="line">    Z = cache</div><div class="line">    dZ = np.array(dA, copy=<span class="keyword">True</span>) <span class="comment"># just converting dz to a correct object.</span></div><div class="line">    </div><div class="line">    <span class="comment"># When z &lt;= 0, you should set dz to 0 as well. </span></div><div class="line">    dZ[Z &lt;= <span class="number">0</span>] = <span class="number">0</span></div><div class="line">    </div><div class="line">    <span class="keyword">assert</span> (dZ.shape == Z.shape)</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> dZ</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid_backward</span><span class="params">(dA, cache)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Implement the backward propagation for a single SIGMOID unit.</div><div class="line"></div><div class="line">    Arguments:</div><div class="line">    dA -- post-activation gradient, of any shape</div><div class="line">    cache -- 'Z' where we store for computing backward propagation efficiently</div><div class="line"></div><div class="line">    Returns:</div><div class="line">    dZ -- Gradient of the cost with respect to Z</div><div class="line">    """</div><div class="line">    </div><div class="line">    Z = cache</div><div class="line">    </div><div class="line">    s = <span class="number">1</span>/(<span class="number">1</span>+np.exp(-Z))</div><div class="line">    dZ = dA * s * (<span class="number">1</span>-s)</div><div class="line">    </div><div class="line">    <span class="keyword">assert</span> (dZ.shape == Z.shape)</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> dZ</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_data</span><span class="params">()</span>:</span></div><div class="line">    train_dataset = h5py.File(<span class="string">'datasets/train_catvnoncat.h5'</span>, <span class="string">"r"</span>)</div><div class="line">    train_set_x_orig = np.array(train_dataset[<span class="string">"train_set_x"</span>][:]) <span class="comment"># your train set features</span></div><div class="line">    train_set_y_orig = np.array(train_dataset[<span class="string">"train_set_y"</span>][:]) <span class="comment"># your train set labels</span></div><div class="line"></div><div class="line">    test_dataset = h5py.File(<span class="string">'datasets/test_catvnoncat.h5'</span>, <span class="string">"r"</span>)</div><div class="line">    test_set_x_orig = np.array(test_dataset[<span class="string">"test_set_x"</span>][:]) <span class="comment"># your test set features</span></div><div class="line">    test_set_y_orig = np.array(test_dataset[<span class="string">"test_set_y"</span>][:]) <span class="comment"># your test set labels</span></div><div class="line"></div><div class="line">    classes = np.array(test_dataset[<span class="string">"list_classes"</span>][:]) <span class="comment"># the list of classes</span></div><div class="line">    </div><div class="line">    train_set_y_orig = train_set_y_orig.reshape((<span class="number">1</span>, train_set_y_orig.shape[<span class="number">0</span>]))</div><div class="line">    test_set_y_orig = test_set_y_orig.reshape((<span class="number">1</span>, test_set_y_orig.shape[<span class="number">0</span>]))</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> train_set_x_orig, train_set_y_orig, test_set_x_orig, test_set_y_orig, classes</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize_parameters</span><span class="params">(n_x, n_h, n_y)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Argument:</div><div class="line">    n_x -- size of the input layer</div><div class="line">    n_h -- size of the hidden layer</div><div class="line">    n_y -- size of the output layer</div><div class="line">    </div><div class="line">    Returns:</div><div class="line">    parameters -- python dictionary containing your parameters:</div><div class="line">                    W1 -- weight matrix of shape (n_h, n_x)</div><div class="line">                    b1 -- bias vector of shape (n_h, 1)</div><div class="line">                    W2 -- weight matrix of shape (n_y, n_h)</div><div class="line">                    b2 -- bias vector of shape (n_y, 1)</div><div class="line">    """</div><div class="line">    </div><div class="line">    np.random.seed(<span class="number">1</span>)</div><div class="line">    </div><div class="line">    W1 = np.random.randn(n_h, n_x)*<span class="number">0.01</span></div><div class="line">    b1 = np.zeros((n_h, <span class="number">1</span>))</div><div class="line">    W2 = np.random.randn(n_y, n_h)*<span class="number">0.01</span></div><div class="line">    b2 = np.zeros((n_y, <span class="number">1</span>))</div><div class="line">    </div><div class="line">    <span class="keyword">assert</span>(W1.shape == (n_h, n_x))</div><div class="line">    <span class="keyword">assert</span>(b1.shape == (n_h, <span class="number">1</span>))</div><div class="line">    <span class="keyword">assert</span>(W2.shape == (n_y, n_h))</div><div class="line">    <span class="keyword">assert</span>(b2.shape == (n_y, <span class="number">1</span>))</div><div class="line">    </div><div class="line">    parameters = &#123;<span class="string">"W1"</span>: W1,</div><div class="line">                  <span class="string">"b1"</span>: b1,</div><div class="line">                  <span class="string">"W2"</span>: W2,</div><div class="line">                  <span class="string">"b2"</span>: b2&#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> parameters     </div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize_parameters_deep</span><span class="params">(layer_dims)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Arguments:</div><div class="line">    layer_dims -- python array (list) containing the dimensions of each layer in our network</div><div class="line">    </div><div class="line">    Returns:</div><div class="line">    parameters -- python dictionary containing your parameters "W1", "b1", ..., "WL", "bL":</div><div class="line">                    Wl -- weight matrix of shape (layer_dims[l], layer_dims[l-1])</div><div class="line">                    bl -- bias vector of shape (layer_dims[l], 1)</div><div class="line">    """</div><div class="line">    </div><div class="line">    np.random.seed(<span class="number">1</span>)</div><div class="line">    parameters = &#123;&#125;</div><div class="line">    L = len(layer_dims)            <span class="comment"># number of layers in the network</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> range(<span class="number">1</span>, L):</div><div class="line">        parameters[<span class="string">'W'</span> + str(l)] = np.random.randn(layer_dims[l], layer_dims[l<span class="number">-1</span>]) / np.sqrt(layer_dims[l<span class="number">-1</span>]) <span class="comment">#*0.01</span></div><div class="line">        parameters[<span class="string">'b'</span> + str(l)] = np.zeros((layer_dims[l], <span class="number">1</span>))</div><div class="line">        </div><div class="line">        <span class="keyword">assert</span>(parameters[<span class="string">'W'</span> + str(l)].shape == (layer_dims[l], layer_dims[l<span class="number">-1</span>]))</div><div class="line">        <span class="keyword">assert</span>(parameters[<span class="string">'b'</span> + str(l)].shape == (layer_dims[l], <span class="number">1</span>))</div><div class="line"></div><div class="line">        </div><div class="line">    <span class="keyword">return</span> parameters</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">linear_forward</span><span class="params">(A, W, b)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Implement the linear part of a layer's forward propagation.</div><div class="line"></div><div class="line">    Arguments:</div><div class="line">    A -- activations from previous layer (or input data): (size of previous layer, number of examples)</div><div class="line">    W -- weights matrix: numpy array of shape (size of current layer, size of previous layer)</div><div class="line">    b -- bias vector, numpy array of shape (size of the current layer, 1)</div><div class="line"></div><div class="line">    Returns:</div><div class="line">    Z -- the input of the activation function, also called pre-activation parameter </div><div class="line">    cache -- a python dictionary containing "A", "W" and "b" ; stored for computing the backward pass efficiently</div><div class="line">    """</div><div class="line">    </div><div class="line">    Z = W.dot(A) + b</div><div class="line">    </div><div class="line">    <span class="keyword">assert</span>(Z.shape == (W.shape[<span class="number">0</span>], A.shape[<span class="number">1</span>]))</div><div class="line">    cache = (A, W, b)</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> Z, cache</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">linear_activation_forward</span><span class="params">(A_prev, W, b, activation)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Implement the forward propagation for the LINEAR-&gt;ACTIVATION layer</div><div class="line"></div><div class="line">    Arguments:</div><div class="line">    A_prev -- activations from previous layer (or input data): (size of previous layer, number of examples)</div><div class="line">    W -- weights matrix: numpy array of shape (size of current layer, size of previous layer)</div><div class="line">    b -- bias vector, numpy array of shape (size of the current layer, 1)</div><div class="line">    activation -- the activation to be used in this layer, stored as a text string: "sigmoid" or "relu"</div><div class="line"></div><div class="line">    Returns:</div><div class="line">    A -- the output of the activation function, also called the post-activation value </div><div class="line">    cache -- a python dictionary containing "linear_cache" and "activation_cache";</div><div class="line">             stored for computing the backward pass efficiently</div><div class="line">    """</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> activation == <span class="string">"sigmoid"</span>:</div><div class="line">        <span class="comment"># Inputs: "A_prev, W, b". Outputs: "A, activation_cache".</span></div><div class="line">        Z, linear_cache = linear_forward(A_prev, W, b)</div><div class="line">        A, activation_cache = sigmoid(Z)</div><div class="line">    </div><div class="line">    <span class="keyword">elif</span> activation == <span class="string">"relu"</span>:</div><div class="line">        <span class="comment"># Inputs: "A_prev, W, b". Outputs: "A, activation_cache".</span></div><div class="line">        Z, linear_cache = linear_forward(A_prev, W, b)</div><div class="line">        A, activation_cache = relu(Z)</div><div class="line">    </div><div class="line">    <span class="keyword">assert</span> (A.shape == (W.shape[<span class="number">0</span>], A_prev.shape[<span class="number">1</span>]))</div><div class="line">    cache = (linear_cache, activation_cache)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> A, cache</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">L_model_forward</span><span class="params">(X, parameters)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Implement forward propagation for the [LINEAR-&gt;RELU]*(L-1)-&gt;LINEAR-&gt;SIGMOID computation</div><div class="line">    </div><div class="line">    Arguments:</div><div class="line">    X -- data, numpy array of shape (input size, number of examples)</div><div class="line">    parameters -- output of initialize_parameters_deep()</div><div class="line">    </div><div class="line">    Returns:</div><div class="line">    AL -- last post-activation value</div><div class="line">    caches -- list of caches containing:</div><div class="line">                every cache of linear_relu_forward() (there are L-1 of them, indexed from 0 to L-2)</div><div class="line">                the cache of linear_sigmoid_forward() (there is one, indexed L-1)</div><div class="line">    """</div><div class="line"></div><div class="line">    caches = []</div><div class="line">    A = X</div><div class="line">    L = len(parameters) // <span class="number">2</span>                  <span class="comment"># number of layers in the neural network</span></div><div class="line">    </div><div class="line">    <span class="comment"># Implement [LINEAR -&gt; RELU]*(L-1). Add "cache" to the "caches" list.</span></div><div class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> range(<span class="number">1</span>, L):</div><div class="line">        A_prev = A </div><div class="line">        A, cache = linear_activation_forward(A_prev, parameters[<span class="string">'W'</span> + str(l)], parameters[<span class="string">'b'</span> + str(l)], activation = <span class="string">"relu"</span>)</div><div class="line">        caches.append(cache)</div><div class="line">    </div><div class="line">    <span class="comment"># Implement LINEAR -&gt; SIGMOID. Add "cache" to the "caches" list.</span></div><div class="line">    AL, cache = linear_activation_forward(A, parameters[<span class="string">'W'</span> + str(L)], parameters[<span class="string">'b'</span> + str(L)], activation = <span class="string">"sigmoid"</span>)</div><div class="line">    caches.append(cache)</div><div class="line">    </div><div class="line">    <span class="keyword">assert</span>(AL.shape == (<span class="number">1</span>,X.shape[<span class="number">1</span>]))</div><div class="line">            </div><div class="line">    <span class="keyword">return</span> AL, caches</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_cost</span><span class="params">(AL, Y)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Implement the cost function defined by equation (7).</div><div class="line"></div><div class="line">    Arguments:</div><div class="line">    AL -- probability vector corresponding to your label predictions, shape (1, number of examples)</div><div class="line">    Y -- true "label" vector (for example: containing 0 if non-cat, 1 if cat), shape (1, number of examples)</div><div class="line"></div><div class="line">    Returns:</div><div class="line">    cost -- cross-entropy cost</div><div class="line">    """</div><div class="line">    </div><div class="line">    m = Y.shape[<span class="number">1</span>]</div><div class="line"></div><div class="line">    <span class="comment"># Compute loss from aL and y.</span></div><div class="line">    cost = (<span class="number">1.</span>/m) * (-np.dot(Y,np.log(AL).T) - np.dot(<span class="number">1</span>-Y, np.log(<span class="number">1</span>-AL).T))</div><div class="line">    </div><div class="line">    cost = np.squeeze(cost)      <span class="comment"># To make sure your cost's shape is what we expect (e.g. this turns [[17]] into 17).</span></div><div class="line">    <span class="keyword">assert</span>(cost.shape == ())</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> cost</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">linear_backward</span><span class="params">(dZ, cache)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Implement the linear portion of backward propagation for a single layer (layer l)</div><div class="line"></div><div class="line">    Arguments:</div><div class="line">    dZ -- Gradient of the cost with respect to the linear output (of current layer l)</div><div class="line">    cache -- tuple of values (A_prev, W, b) coming from the forward propagation in the current layer</div><div class="line"></div><div class="line">    Returns:</div><div class="line">    dA_prev -- Gradient of the cost with respect to the activation (of the previous layer l-1), same shape as A_prev</div><div class="line">    dW -- Gradient of the cost with respect to W (current layer l), same shape as W</div><div class="line">    db -- Gradient of the cost with respect to b (current layer l), same shape as b</div><div class="line">    """</div><div class="line">    A_prev, W, b = cache</div><div class="line">    m = A_prev.shape[<span class="number">1</span>]</div><div class="line"></div><div class="line">    dW = <span class="number">1.</span>/m * np.dot(dZ,A_prev.T)</div><div class="line">    db = <span class="number">1.</span>/m * np.sum(dZ, axis = <span class="number">1</span>, keepdims = <span class="keyword">True</span>)</div><div class="line">    dA_prev = np.dot(W.T,dZ)</div><div class="line">    </div><div class="line">    <span class="keyword">assert</span> (dA_prev.shape == A_prev.shape)</div><div class="line">    <span class="keyword">assert</span> (dW.shape == W.shape)</div><div class="line">    <span class="keyword">assert</span> (db.shape == b.shape)</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> dA_prev, dW, db</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">linear_activation_backward</span><span class="params">(dA, cache, activation)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Implement the backward propagation for the LINEAR-&gt;ACTIVATION layer.</div><div class="line">    </div><div class="line">    Arguments:</div><div class="line">    dA -- post-activation gradient for current layer l </div><div class="line">    cache -- tuple of values (linear_cache, activation_cache) we store for computing backward propagation efficiently</div><div class="line">    activation -- the activation to be used in this layer, stored as a text string: "sigmoid" or "relu"</div><div class="line">    </div><div class="line">    Returns:</div><div class="line">    dA_prev -- Gradient of the cost with respect to the activation (of the previous layer l-1), same shape as A_prev</div><div class="line">    dW -- Gradient of the cost with respect to W (current layer l), same shape as W</div><div class="line">    db -- Gradient of the cost with respect to b (current layer l), same shape as b</div><div class="line">    """</div><div class="line">    linear_cache, activation_cache = cache</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> activation == <span class="string">"relu"</span>:</div><div class="line">        dZ = relu_backward(dA, activation_cache)</div><div class="line">        dA_prev, dW, db = linear_backward(dZ, linear_cache)</div><div class="line">        </div><div class="line">    <span class="keyword">elif</span> activation == <span class="string">"sigmoid"</span>:</div><div class="line">        dZ = sigmoid_backward(dA, activation_cache)</div><div class="line">        dA_prev, dW, db = linear_backward(dZ, linear_cache)</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> dA_prev, dW, db</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">L_model_backward</span><span class="params">(AL, Y, caches)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Implement the backward propagation for the [LINEAR-&gt;RELU] * (L-1) -&gt; LINEAR -&gt; SIGMOID group</div><div class="line">    </div><div class="line">    Arguments:</div><div class="line">    AL -- probability vector, output of the forward propagation (L_model_forward())</div><div class="line">    Y -- true "label" vector (containing 0 if non-cat, 1 if cat)</div><div class="line">    caches -- list of caches containing:</div><div class="line">                every cache of linear_activation_forward() with "relu" (there are (L-1) or them, indexes from 0 to L-2)</div><div class="line">                the cache of linear_activation_forward() with "sigmoid" (there is one, index L-1)</div><div class="line">    </div><div class="line">    Returns:</div><div class="line">    grads -- A dictionary with the gradients</div><div class="line">             grads["dA" + str(l)] = ... </div><div class="line">             grads["dW" + str(l)] = ...</div><div class="line">             grads["db" + str(l)] = ... </div><div class="line">    """</div><div class="line">    grads = &#123;&#125;</div><div class="line">    L = len(caches) <span class="comment"># the number of layers</span></div><div class="line">    m = AL.shape[<span class="number">1</span>]</div><div class="line">    Y = Y.reshape(AL.shape) <span class="comment"># after this line, Y is the same shape as AL</span></div><div class="line">    </div><div class="line">    <span class="comment"># Initializing the backpropagation</span></div><div class="line">    dAL = - (np.divide(Y, AL) - np.divide(<span class="number">1</span> - Y, <span class="number">1</span> - AL))</div><div class="line">    </div><div class="line">    <span class="comment"># Lth layer (SIGMOID -&gt; LINEAR) gradients. Inputs: "AL, Y, caches". Outputs: "grads["dAL"], grads["dWL"], grads["dbL"]</span></div><div class="line">    current_cache = caches[L<span class="number">-1</span>]</div><div class="line">    grads[<span class="string">"dA"</span> + str(L)], grads[<span class="string">"dW"</span> + str(L)], grads[<span class="string">"db"</span> + str(L)] = linear_activation_backward(dAL, current_cache, activation = <span class="string">"sigmoid"</span>)</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> reversed(range(L<span class="number">-1</span>)):</div><div class="line">        <span class="comment"># lth layer: (RELU -&gt; LINEAR) gradients.</span></div><div class="line">        current_cache = caches[l]</div><div class="line">        dA_prev_temp, dW_temp, db_temp = linear_activation_backward(grads[<span class="string">"dA"</span> + str(l + <span class="number">2</span>)], current_cache, activation = <span class="string">"relu"</span>)</div><div class="line">        grads[<span class="string">"dA"</span> + str(l + <span class="number">1</span>)] = dA_prev_temp</div><div class="line">        grads[<span class="string">"dW"</span> + str(l + <span class="number">1</span>)] = dW_temp</div><div class="line">        grads[<span class="string">"db"</span> + str(l + <span class="number">1</span>)] = db_temp</div><div class="line"></div><div class="line">    <span class="keyword">return</span> grads</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_parameters</span><span class="params">(parameters, grads, learning_rate)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Update parameters using gradient descent</div><div class="line">    </div><div class="line">    Arguments:</div><div class="line">    parameters -- python dictionary containing your parameters </div><div class="line">    grads -- python dictionary containing your gradients, output of L_model_backward</div><div class="line">    </div><div class="line">    Returns:</div><div class="line">    parameters -- python dictionary containing your updated parameters </div><div class="line">                  parameters["W" + str(l)] = ... </div><div class="line">                  parameters["b" + str(l)] = ...</div><div class="line">    """</div><div class="line">    </div><div class="line">    L = len(parameters) // <span class="number">2</span> <span class="comment"># number of layers in the neural network</span></div><div class="line"></div><div class="line">    <span class="comment"># Update rule for each parameter. Use a for loop.</span></div><div class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> range(L):</div><div class="line">        parameters[<span class="string">"W"</span> + str(l+<span class="number">1</span>)] = parameters[<span class="string">"W"</span> + str(l+<span class="number">1</span>)] - learning_rate * grads[<span class="string">"dW"</span> + str(l+<span class="number">1</span>)]</div><div class="line">        parameters[<span class="string">"b"</span> + str(l+<span class="number">1</span>)] = parameters[<span class="string">"b"</span> + str(l+<span class="number">1</span>)] - learning_rate * grads[<span class="string">"db"</span> + str(l+<span class="number">1</span>)]</div><div class="line">        </div><div class="line">    <span class="keyword">return</span> parameters</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(X, y, parameters)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    This function is used to predict the results of a  L-layer neural network.</div><div class="line">    </div><div class="line">    Arguments:</div><div class="line">    X -- data set of examples you would like to label</div><div class="line">    parameters -- parameters of the trained model</div><div class="line">    </div><div class="line">    Returns:</div><div class="line">    p -- predictions for the given dataset X</div><div class="line">    """</div><div class="line">    </div><div class="line">    m = X.shape[<span class="number">1</span>]</div><div class="line">    n = len(parameters) // <span class="number">2</span> <span class="comment"># number of layers in the neural network</span></div><div class="line">    p = np.zeros((<span class="number">1</span>,m))</div><div class="line">    </div><div class="line">    <span class="comment"># Forward propagation</span></div><div class="line">    probas, caches = L_model_forward(X, parameters)</div><div class="line"></div><div class="line">    </div><div class="line">    <span class="comment"># convert probas to 0/1 predictions</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, probas.shape[<span class="number">1</span>]):</div><div class="line">        <span class="keyword">if</span> probas[<span class="number">0</span>,i] &gt; <span class="number">0.5</span>:</div><div class="line">            p[<span class="number">0</span>,i] = <span class="number">1</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            p[<span class="number">0</span>,i] = <span class="number">0</span></div><div class="line">    </div><div class="line">    <span class="comment">#print results</span></div><div class="line">    <span class="comment">#print ("predictions: " + str(p))</span></div><div class="line">    <span class="comment">#print ("true labels: " + str(y))</span></div><div class="line">    print(<span class="string">"Accuracy: "</span>  + str(np.sum((p == y)/m)))</div><div class="line">        </div><div class="line">    <span class="keyword">return</span> p</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_mislabeled_images</span><span class="params">(classes, X, y, p)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Plots images where predictions and truth were different.</div><div class="line">    X -- dataset</div><div class="line">    y -- true labels</div><div class="line">    p -- predictions</div><div class="line">    """</div><div class="line">    a = p + y</div><div class="line">    mislabeled_indices = np.asarray(np.where(a == <span class="number">1</span>))</div><div class="line">    plt.rcParams[<span class="string">'figure.figsize'</span>] = (<span class="number">40.0</span>, <span class="number">40.0</span>) <span class="comment"># set default size of plots</span></div><div class="line">    num_images = len(mislabeled_indices[<span class="number">0</span>])</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num_images):</div><div class="line">        index = mislabeled_indices[<span class="number">1</span>][i]</div><div class="line">        </div><div class="line">        plt.subplot(<span class="number">2</span>, num_images, i + <span class="number">1</span>)</div><div class="line">        plt.imshow(X[:,index].reshape(<span class="number">64</span>,<span class="number">64</span>,<span class="number">3</span>), interpolation=<span class="string">'nearest'</span>)</div><div class="line">        plt.axis(<span class="string">'off'</span>)</div><div class="line">        plt.title(<span class="string">"Prediction: "</span> + classes[int(p[<span class="number">0</span>,index])].decode(<span class="string">"utf-8"</span>) + <span class="string">" \n Class: "</span> + classes[y[<span class="number">0</span>,index]].decode(<span class="string">"utf-8"</span>))</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 深度学习算法 </category>
            
            <category> 神经网络 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[深度学习实践-1-4-1-构建深层神经网络]]></title>
      <url>/2017/12/10/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5-1-4-1-%E6%9E%84%E5%BB%BA%E6%B7%B1%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
      <content type="html"><![CDATA[<p>本文主要参考自<a href="http://blog.csdn.net/koala_tree/article/details/78092337" target="_blank" rel="external">吴恩达Coursera深度学习课程 DeepLearning.ai 编程作业（1-4）</a></p>
<p>吴恩达Coursera课程 DeepLearning.ai 编程作业系列，本文为《神经网络与深度学习》部分的第四周“深层神经网络”的课程作业。</p>
<p>本节的主要内容是：实现L层的神经网络</p>
<h1 id="大纲">1. 大纲</h1><p>首先完成一些helper function。然后再建立两层、多层神经网络：</p>
<ul>
<li>两层和多层神经网络的初始化</li>
<li>实现前向传播模型<ul>
<li>实现某一层的前向传播 - 输出$Z^{[l]}$</li>
<li>激活层已给出</li>
<li>将前两步结合</li>
<li>将前向传播迭代L-1次，然后将激活层加到最后，就完成了L层的前向传播</li>
</ul>
</li>
<li>计算误差</li>
<li>实现后向传播模型<ul>
<li>实现某一层的后向传播</li>
<li>激活层的后向传播已给出</li>
<li>将前两步结合</li>
<li>将后向传播迭代L-1次，然后将激活层加到最后，完成了L层的后向传播</li>
</ul>
</li>
<li>更新参数</li>
</ul>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-08-15-15-25.png" alt=""> </p>
<a id="more"></a>
<h1 id="import">2. import</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> warnings</div><div class="line">warnings.filterwarnings(<span class="string">"ignore"</span>) </div><div class="line"></div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> h5py</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"></div><div class="line">%matplotlib inline</div><div class="line">plt.rcParams[<span class="string">'figure.figsize'</span>] = (<span class="number">5.0</span>, <span class="number">4.0</span>) <span class="comment"># set default size of plots</span></div><div class="line">plt.rcParams[<span class="string">'image.interpolation'</span>] = <span class="string">'nearest'</span></div><div class="line">plt.rcParams[<span class="string">'image.cmap'</span>] = <span class="string">'gray'</span></div><div class="line"></div><div class="line">%load_ext autoreload</div><div class="line">%autoreload <span class="number">2</span></div><div class="line"></div><div class="line">np.random.seed(<span class="number">1</span>)</div></pre></td></tr></table></figure>
<h1 id="初始化">3. 初始化</h1><ul>
<li>完成两层模型的初始化</li>
<li>完成多层模型的初始化</li>
</ul>
<h2 id="两层模型的初始化">3.1. 两层模型的初始化</h2><ul>
<li>模型结构是： LINEAR - RELU - LINEAR - SIGMOID</li>
<li>用随机数初始化w</li>
<li>用0初始化b</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 参数初始化</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize_parameters</span><span class="params">(n_x, n_h, n_y)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    参数：</div><div class="line">    n_x -- 输入层的大小</div><div class="line">    n_h -- 隐藏层的大小</div><div class="line">    n_y -- 输出层的大小</div><div class="line">    </div><div class="line">    Returns:</div><div class="line">    parameters -- python dict ：</div><div class="line">                    W1 -- weight matrix of shape (n_h, n_x)</div><div class="line">                    b1 -- bias vector of shape (n_h, 1)</div><div class="line">                    W2 -- weight matrix of shape (n_y, n_h)</div><div class="line">                    b2 -- bias vector of shape (n_y, 1)</div><div class="line">    """</div><div class="line">    <span class="comment"># 初始化</span></div><div class="line">    W1 = np.random.randn(n_h, n_x)*<span class="number">0.01</span></div><div class="line">    b1 = np.zeros((n_h, <span class="number">1</span>))</div><div class="line">    W2 = np.random.randn(n_y, n_h)*<span class="number">0.01</span></div><div class="line">    b2 = np.zeros((n_y, <span class="number">1</span>))</div><div class="line">    </div><div class="line">    <span class="comment"># 验证</span></div><div class="line">    <span class="keyword">assert</span>(W1.shape == (n_h, n_x))</div><div class="line">    <span class="keyword">assert</span>(b1.shape == (n_h, <span class="number">1</span>))</div><div class="line">    <span class="keyword">assert</span>(W2.shape == (n_y, n_h))</div><div class="line">    <span class="keyword">assert</span>(b2.shape == (n_y, <span class="number">1</span>))</div><div class="line"></div><div class="line">    parameters = &#123;<span class="string">"W1"</span>: W1,</div><div class="line">                  <span class="string">"b1"</span>: b1,</div><div class="line">                  <span class="string">"W2"</span>: W2,</div><div class="line">                  <span class="string">"b2"</span>: b2&#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> parameters    </div><div class="line"></div><div class="line">parameters = initialize_parameters(<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>)</div><div class="line">print(<span class="string">"W1 = "</span> + str(parameters[<span class="string">"W1"</span>]))</div><div class="line">print(<span class="string">"b1 = "</span> + str(parameters[<span class="string">"b1"</span>]))</div><div class="line">print(<span class="string">"W2 = "</span> + str(parameters[<span class="string">"W2"</span>]))</div><div class="line">print(<span class="string">"b2 = "</span> + str(parameters[<span class="string">"b2"</span>]))</div></pre></td></tr></table></figure>
<pre><code>W1 = [[ 0.01624345 -0.00611756 -0.00528172]
 [-0.01072969  0.00865408 -0.02301539]]
b1 = [[ 0.]
 [ 0.]]
W2 = [[ 0.01744812 -0.00761207]]
b2 = [[ 0.]]
</code></pre><h2 id="L层模型的初始化">3.2. L层模型的初始化</h2><p>这个比较复杂。我们先来看一个X.shape = (12288,209)的例子:</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>W.shape</strong></th>
<th><strong>b.shape</strong></th>
<th style="text-align:center"><strong>A</strong></th>
<th><strong>A.shape</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Layer 1</strong></td>
<td>(n[1],12288)</td>
<td>(n[1],1)</td>
<td style="text-align:center">Z[1]=W[1]X+b[1]</td>
<td>(n[1],209)</td>
</tr>
<tr>
<td><strong>Layer 2</strong></td>
<td>(n[2],n[1])</td>
<td>(n[2],1)</td>
<td style="text-align:center">Z[2]=W[2]A[1]+b[2]</td>
<td>(n[2],209)</td>
</tr>
<tr>
<td>⋮</td>
<td>⋮</td>
<td>⋮</td>
<td style="text-align:center">⋮</td>
<td>⋮</td>
</tr>
<tr>
<td><strong>Layer L-1</strong></td>
<td>(n[L−1],n[L−2])</td>
<td>(n[L−1],1)</td>
<td style="text-align:center">Z[L−1]=W[L−1]A[L−2]+b[L−1]</td>
<td>(n[L−1],209)</td>
</tr>
<tr>
<td><strong>Layer L</strong></td>
<td>(n[L],n[L−1])</td>
<td>(n[L],1)</td>
<td style="text-align:center">Z[L]=W[L]A[L−1]+b[L]</td>
<td>(n[L],209)</td>
</tr>
</tbody>
</table>
<p>实现：</p>
<ul>
<li>模型结构是 [LINEAR -&gt; RELU]  ×  (L-1) -&gt; LINEAR -&gt; SIGMOID . 也就是说，有L-1层的ReLU激活函数，还有一层sigmoid输出</li>
<li>w用随机初始化</li>
<li>b用0初始化</li>
<li>将$n^{[l]}$存入数组变量layer_dims中，代表第l层的n</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize_parameters_deep</span><span class="params">(layer_dims)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    输入：</div><div class="line">    layer_dims: 数组变量，代表每一层的维度</div><div class="line">    </div><div class="line">    Returns:</div><div class="line">    parameters -- python dict , 包含 "W1", "b1", ..., "WL", "bL":</div><div class="line">            Wl -- 权重矩阵，W1.shape =  (layer_dims[l], layer_dims[l-1])</div><div class="line">            bl -- 偏置向量，b1.shape =  (layer_dims[l], 1)</div><div class="line"></div><div class="line">    """</div><div class="line">    </div><div class="line">    parameters = &#123;&#125;</div><div class="line">    L = len(layer_dims) <span class="comment"># 网络的层数</span></div><div class="line">    </div><div class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> range(<span class="number">1</span>, L):</div><div class="line">        <span class="comment"># 初始化第l层参数</span></div><div class="line">        parameters[<span class="string">'W'</span> + str(l)] = np.random.randn(layer_dims[l], layer_dims[l<span class="number">-1</span>]) * <span class="number">0.01</span></div><div class="line">        parameters[<span class="string">'b'</span> + str(l)] = np.zeros((layer_dims[l], <span class="number">1</span>))</div><div class="line">        </div><div class="line">        <span class="comment"># 验证</span></div><div class="line">        <span class="keyword">assert</span>(parameters[<span class="string">'W'</span> + str(l)].shape == (layer_dims[l], layer_dims[l<span class="number">-1</span>]))</div><div class="line">        <span class="keyword">assert</span>(parameters[<span class="string">'b'</span> + str(l)].shape == (layer_dims[l], <span class="number">1</span>))</div><div class="line">        </div><div class="line">    <span class="keyword">return</span> parameters</div><div class="line"></div><div class="line">parameters = initialize_parameters_deep([<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>])</div><div class="line">print(<span class="string">"W1 = "</span> + str(parameters[<span class="string">"W1"</span>]))</div><div class="line">print(<span class="string">"b1 = "</span> + str(parameters[<span class="string">"b1"</span>]))</div><div class="line">print(<span class="string">"W2 = "</span> + str(parameters[<span class="string">"W2"</span>]))</div><div class="line">print(<span class="string">"b2 = "</span> + str(parameters[<span class="string">"b2"</span>]))</div></pre></td></tr></table></figure>
<pre><code>W1 = [[ 0.00319039 -0.0024937   0.01462108 -0.02060141 -0.00322417]
 [-0.00384054  0.01133769 -0.01099891 -0.00172428 -0.00877858]
 [ 0.00042214  0.00582815 -0.01100619  0.01144724  0.00901591]
 [ 0.00502494  0.00900856 -0.00683728 -0.0012289  -0.00935769]]
b1 = [[ 0.]
 [ 0.]
 [ 0.]
 [ 0.]]
W2 = [[-0.00267888  0.00530355 -0.00691661 -0.00396754]
 [-0.00687173 -0.00845206 -0.00671246 -0.00012665]
 [-0.0111731   0.00234416  0.01659802  0.00742044]]
b2 = [[ 0.]
 [ 0.]
 [ 0.]]
</code></pre><h1 id="前向传播">4. 前向传播</h1><p>按照如下顺序实现：</p>
<ul>
<li>LINEAR</li>
<li>LINEAR -&gt; ACTIVATION where ACTIVATION will be either ReLU or Sigmoid.</li>
<li>[LINEAR -&gt; RELU] × (L-1) -&gt; LINEAR -&gt; SIGMOID (whole model)</li>
</ul>
<h2 id="LINEAR">4.1. LINEAR</h2><p>线性模型如下：</p>
<p>$$Z^{[l]} = W^{[l]}A^{[l-1]} +b^{[l]}\tag{4}$$</p>
<p>where $A^{[0]} = X$. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">linear_forward</span><span class="params">(A,W,b)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    实现前向传播的线性部分</div><div class="line">    </div><div class="line">    输入：</div><div class="line">    </div><div class="line">    A -- 上一层的输出，也是本层的输入</div><div class="line">    W -- 权重矩阵 ， W.shape = (n_(l-1), n_l)</div><div class="line">    b -- 偏置向量 ， b.shape = (n_l , 1)</div><div class="line">    </div><div class="line">    Returns : </div><div class="line">    Z -- 激活函数的输入，也叫"pre-activation parameter"</div><div class="line">    cache - dict，包含A,W,b</div><div class="line">    """</div><div class="line">    </div><div class="line">    <span class="comment"># 线性部分</span></div><div class="line">    Z = np.dot(W,A) + b</div><div class="line">    </div><div class="line">    <span class="comment"># 验证</span></div><div class="line">    <span class="keyword">assert</span>(Z.shape == (W.shape[<span class="number">0</span>], A.shape[<span class="number">1</span>]))</div><div class="line">    </div><div class="line">    <span class="comment"># 暂存</span></div><div class="line">    cache = (A, W, b)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> Z, cache</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 测试函数</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">linear_forward_test_case</span><span class="params">()</span>:</span></div><div class="line">    np.random.seed(<span class="number">1</span>)</div><div class="line">    <span class="string">"""</span></div><div class="line">    X = np.array([[-1.02387576, 1.12397796],</div><div class="line"> [-1.62328545, 0.64667545],</div><div class="line"> [-1.74314104, -0.59664964]])</div><div class="line">    W = np.array([[ 0.74505627, 1.97611078, -1.24412333]])</div><div class="line">    b = np.array([[1]])</div><div class="line">    """</div><div class="line">    A = np.random.randn(<span class="number">3</span>,<span class="number">2</span>)</div><div class="line">    W = np.random.randn(<span class="number">1</span>,<span class="number">3</span>)</div><div class="line">    b = np.random.randn(<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> A, W, b</div><div class="line"><span class="comment"># 测试</span></div><div class="line">A, W, b = linear_forward_test_case()</div><div class="line"></div><div class="line">Z, linear_cache = linear_forward(A, W, b)</div><div class="line">print(<span class="string">"Z = "</span> + str(Z))</div></pre></td></tr></table></figure>
<pre><code>Z = [[ 3.26295337 -1.23429987]]
</code></pre><p>​    </p>
<h2 id="LINEAR-gt-ACTIVATION">4.2. LINEAR -&gt; ACTIVATION</h2><p>本层的公式是：</p>
<p> $A^{[l]} = g(Z^{[l]}) = g(W^{[l]}A^{[l-1]} +b^{[l]})$</p>
<p>其中,g()有两种选择：</p>
<p><strong>sigmod</strong> ： </p>
<p>$\sigma(Z) = \sigma(W A + b) = \frac{1}{ 1 + e^{-(W A + b)}}$</p>
<p>sigmod的实现如下所示</p>
<p>输出:</p>
<ul>
<li>A</li>
<li>cache = z</li>
</ul>
<p><strong>ReLU</strong> :</p>
<p>$A = RELU(Z) = max(0, Z)$</p>
<p>ReLU的实现如下所示<br>输出：</p>
<ul>
<li>A</li>
<li>cache = Z</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(Z)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Implements the sigmoid activation in numpy</div><div class="line"></div><div class="line">    Arguments:</div><div class="line">    Z -- numpy array of any shape</div><div class="line"></div><div class="line">    Returns:</div><div class="line">    A -- output of sigmoid(z), same shape as Z</div><div class="line">    cache -- returns Z as well, useful during backpropagation</div><div class="line">    """</div><div class="line"></div><div class="line">    A = <span class="number">1</span>/(<span class="number">1</span>+np.exp(-Z))</div><div class="line">    cache = Z</div><div class="line"></div><div class="line">    <span class="keyword">return</span> A, cache</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">relu</span><span class="params">(Z)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Implement the RELU function.</div><div class="line"></div><div class="line">    Arguments:</div><div class="line">    Z -- Output of the linear layer, of any shape</div><div class="line"></div><div class="line">    Returns:</div><div class="line">    A -- Post-activation parameter, of the same shape as Z</div><div class="line">    cache -- a python dictionary containing "A" ; stored for computing the backward pass efficiently</div><div class="line">    """</div><div class="line"></div><div class="line">    A = np.maximum(<span class="number">0</span>,Z)</div><div class="line"></div><div class="line">    <span class="keyword">assert</span>(A.shape == Z.shape)</div><div class="line"></div><div class="line">    cache = Z </div><div class="line">    <span class="keyword">return</span> A, cache</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 实现LINEAR-&gt;ACTIVATION层</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">linear_activation_forward</span><span class="params">(A_prev, W, b, activation)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    LINEAR-&gt;ACTIVATION的实现</div><div class="line">    </div><div class="line">    输入：</div><div class="line">    A_prev -- 上一层的输出</div><div class="line">    W -- 权重矩阵 ， W.shape = (n_l, n_(l-1))</div><div class="line">    b -- 偏置向量 ， b.shape = (n_l , 1)</div><div class="line">    activation -- 激活的名称，"sigmoid"或"relu"</div><div class="line">    </div><div class="line">    Returns:</div><div class="line">    A -- 激活层输出，也叫post-activation value</div><div class="line">    cache  -- python dict, 包含 "linear_cache" 和 "activation_cache"</div><div class="line">    """</div><div class="line">    </div><div class="line">    <span class="comment"># 线性输出</span></div><div class="line">    Z, linear_cache = linear_forward(A_prev, W, b)</div><div class="line">    </div><div class="line">    <span class="comment"># 激活</span></div><div class="line">    <span class="keyword">if</span> activation == <span class="string">"sigmoid"</span>:</div><div class="line">        A, activation_cache = sigmoid(Z)</div><div class="line">        </div><div class="line">    <span class="keyword">elif</span> activation == <span class="string">"relu"</span>:</div><div class="line">        A, activation_cache = relu(Z)</div><div class="line">        </div><div class="line">    <span class="comment"># 验证</span></div><div class="line">    <span class="keyword">assert</span> (A.shape == (W.shape[<span class="number">0</span>], A_prev.shape[<span class="number">1</span>]))</div><div class="line">    cache = (linear_cache, activation_cache)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> A, cache</div><div class="line">    </div><div class="line">    </div><div class="line"><span class="comment"># 测试</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">linear_activation_forward_test_case</span><span class="params">()</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    X = np.array([[-1.02387576, 1.12397796],</div><div class="line"> [-1.62328545, 0.64667545],</div><div class="line"> [-1.74314104, -0.59664964]])</div><div class="line">    W = np.array([[ 0.74505627, 1.97611078, -1.24412333]])</div><div class="line">    b = 5</div><div class="line">    """</div><div class="line">    np.random.seed(<span class="number">2</span>)</div><div class="line">    A_prev = np.random.randn(<span class="number">3</span>,<span class="number">2</span>)</div><div class="line">    W = np.random.randn(<span class="number">1</span>,<span class="number">3</span>)</div><div class="line">    b = np.random.randn(<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">    <span class="keyword">return</span> A_prev, W, b</div><div class="line"></div><div class="line">A_prev, W, b = linear_activation_forward_test_case()</div><div class="line"></div><div class="line">A, linear_activation_cache = linear_activation_forward(A_prev, W, b, activation = <span class="string">"sigmoid"</span>)</div><div class="line">print(<span class="string">"With sigmoid: A = "</span> + str(A))</div><div class="line"></div><div class="line">A, linear_activation_cache = linear_activation_forward(A_prev, W, b, activation = <span class="string">"relu"</span>)</div><div class="line">print(<span class="string">"With ReLU: A = "</span> + str(A))</div></pre></td></tr></table></figure>
<pre><code>With sigmoid: A = [[ 0.96890023  0.11013289]]
With ReLU: A = [[ 3.43896131  0.        ]]
</code></pre><h2 id="L-Model-Forward">4.3. L-Model Forward</h2><ul>
<li>用RELU，重复之前的linear_activation_forward，L-1次</li>
<li>最后输入SIGMOID 的linear_activation_forward</li>
</ul>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-08-16-51-52.png" alt=""> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">L_model_forward</span><span class="params">(X, parameters)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    实现后向传播的[LINEAR-&gt;RELU]*(L-1)-&gt;LINEAR-&gt;SIGMOID步骤</div><div class="line">    </div><div class="line">    输入：</div><div class="line">    </div><div class="line">    X -- 数据集</div><div class="line">    parameters -- initialize_parameters_deep()的输出，是多层网络初始化后的参数</div><div class="line">    </div><div class="line">    Returns:</div><div class="line">    </div><div class="line">    AL -- 最终输出</div><div class="line">    caches -- 每层的caches：</div><div class="line">            1 ~ L - 1层 的 linear_relu_forward()</div><div class="line">            L 层 的 linear_sigmoid_forward()</div><div class="line">    """</div><div class="line">    </div><div class="line">    caches = []</div><div class="line">    L = len(parameters) / <span class="number">2</span></div><div class="line">    A = X</div><div class="line">    </div><div class="line">    <span class="comment"># 1~ L-1 层，迭代</span></div><div class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> range(<span class="number">1</span>,L):</div><div class="line">        A_prev = A</div><div class="line">        A, cache = linear_activation_forward(A_prev, parameters[<span class="string">'W'</span> + str(l)], parameters[<span class="string">'b'</span> + str(l)], <span class="string">"relu"</span>)</div><div class="line">        caches.append(cache)</div><div class="line">        </div><div class="line">    <span class="comment"># L 层     </span></div><div class="line">    AL, cache = linear_activation_forward(A, parameters[<span class="string">'W'</span> + str(L)], parameters[<span class="string">'b'</span> + str(L)], <span class="string">"sigmoid"</span>)</div><div class="line">    caches.append(cache)</div><div class="line">        </div><div class="line">    <span class="comment"># 验证</span></div><div class="line">    <span class="keyword">assert</span>(AL.shape == (<span class="number">1</span>,X.shape[<span class="number">1</span>]))</div><div class="line"></div><div class="line">    <span class="keyword">return</span> AL, caches</div><div class="line"></div><div class="line"><span class="comment"># 测试</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">L_model_forward_test_case</span><span class="params">()</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    X = np.array([[-1.02387576, 1.12397796],</div><div class="line"> [-1.62328545, 0.64667545],</div><div class="line"> [-1.74314104, -0.59664964]])</div><div class="line">    parameters = &#123;'W1': np.array([[ 1.62434536, -0.61175641, -0.52817175],</div><div class="line">        [-1.07296862,  0.86540763, -2.3015387 ]]),</div><div class="line"> 'W2': np.array([[ 1.74481176, -0.7612069 ]]),</div><div class="line"> 'b1': np.array([[ 0.],</div><div class="line">        [ 0.]]),</div><div class="line"> 'b2': np.array([[ 0.]])&#125;</div><div class="line">    """</div><div class="line">    np.random.seed(<span class="number">1</span>)</div><div class="line">    X = np.random.randn(<span class="number">4</span>,<span class="number">2</span>)</div><div class="line">    W1 = np.random.randn(<span class="number">3</span>,<span class="number">4</span>)</div><div class="line">    b1 = np.random.randn(<span class="number">3</span>,<span class="number">1</span>)</div><div class="line">    W2 = np.random.randn(<span class="number">1</span>,<span class="number">3</span>)</div><div class="line">    b2 = np.random.randn(<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">    parameters = &#123;<span class="string">"W1"</span>: W1,</div><div class="line">                  <span class="string">"b1"</span>: b1,</div><div class="line">                  <span class="string">"W2"</span>: W2,</div><div class="line">                  <span class="string">"b2"</span>: b2&#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> X, parameters</div><div class="line"></div><div class="line"><span class="comment"># 获取X和初始化参数</span></div><div class="line">X, parameters = L_model_forward_test_case()</div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"X.shape = "</span> + str(X.shape) , <span class="string">"，即"</span>,X.shape[<span class="number">0</span>],<span class="string">"行"</span>,X.shape[<span class="number">1</span>],<span class="string">"列"</span></div><div class="line"></div><div class="line"><span class="comment"># 前向传播</span></div><div class="line">AL, caches = L_model_forward(X, parameters)</div><div class="line">print(<span class="string">"AL = "</span> + str(AL))</div><div class="line">print(<span class="string">"Length of caches list = "</span> + str(len(caches)))</div></pre></td></tr></table></figure>
<pre><code>X.shape = (4L, 2L) ，即 4 行 2 列
AL = [[ 0.17007265  0.2524272 ]]
Length of caches list = 2
</code></pre><h1 id="计算误差">5. 计算误差</h1><p>误差公式如下：</p>
<p> $$-\frac{1}{m} \sum\limits_{i = 1}^{m} (y^{(i)}\log\left(a^{[L] (i)}\right) + (1-y^{(i)})\log\left(1- a^{<a href="i">L</a>}\right)) \tag{7}$$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_cost</span><span class="params">(AL, Y)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    实现公式7的误差计算</div><div class="line">    </div><div class="line">    输入：</div><div class="line">    AL -- 上一步计算出的结果</div><div class="line">    Y -- 实际的label</div><div class="line">    </div><div class="line">    Returns : </div><div class="line">    cost -- 交叉熵误差</div><div class="line">    """</div><div class="line">    </div><div class="line">    m = Y.shape[<span class="number">1</span>]</div><div class="line">    </div><div class="line">    <span class="comment"># 计算</span></div><div class="line">    cost = -np.sum(np.multiply(np.log(AL),Y) + np.multiply(np.log(<span class="number">1</span> - AL), <span class="number">1</span> - Y)) / m</div><div class="line">    cost = np.squeeze(cost)</div><div class="line">    </div><div class="line">    <span class="comment"># 验证</span></div><div class="line">    <span class="keyword">assert</span>(cost.shape == ())</div><div class="line"></div><div class="line">    <span class="keyword">return</span> cost</div><div class="line">    </div><div class="line"><span class="comment"># 测试</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_cost_test_case</span><span class="params">()</span>:</span></div><div class="line">    Y = np.asarray([[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]])</div><div class="line">    aL = np.array([[<span class="number">.8</span>,<span class="number">.9</span>,<span class="number">0.4</span>]])</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> Y, aL</div><div class="line"></div><div class="line">Y, AL = compute_cost_test_case()</div><div class="line"></div><div class="line">print(<span class="string">"cost = "</span> + str(compute_cost(AL, Y)))</div></pre></td></tr></table></figure>
<pre><code>cost = 0.414931599615
</code></pre><p>​    </p>
<h1 id="后向传播">6. 后向传播</h1><p>后向传播是用来计算梯度的</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-08-17-11-51.png" alt=""> </p>
<p>紫色方块代表前向传播<br>红色方块代表后向传播</p>
<p>我们的目标是计算出$dw^{[l]}和db^{[l]}, l = 1,2,…L$，以便之后更新w和b。</p>
<p>为了计算$dw^{[1]}和db^{[1]}$，要使用如下链式法则：</p>
<p>$dw^{[1]}=\frac{dL}{dw^{[1]}}=\frac{dL}{dz^{[1]}} \times \frac{dz}{dw^{[1]}}=dz^{[1]}\times \frac{dz}{dw^{[1]}}$</p>
<p>$db^{[1]}=\frac{dL}{db^{[1]}} = \frac{dL}{dz^{[1]}} \times \frac{dz^{[1]}}{db^{[1]}} = dz^{[1]} \times \frac{dz^{[1]}}{db^{[1]}}$</p>
<p>因此我们首先要算出$dz^{[1]}$ : </p>
<p>$$\frac{dL(a^{[2]},y)}{dz^{[1]}}=\frac{dL(a^{[2]},y)}{da^{[2]}}\frac{da^{[2]}}{dz^{[2]}}\frac{dz^{[2]}}{da^{[1]}}\frac{da^{[1]}}{dz^{[1]}}$$</p>
<p>而要算出$dz^{[1]}$，由上公示可以看出，我们必须先计算$dz^{[2]}$等</p>
<p>因此此过程叫做<strong>后向传播</strong></p>
<p>总之，后向传播需要完成：</p>
<ul>
<li>LINEAR</li>
<li>LINEAR -&gt; ACTIVATION </li>
<li>[LINEAR -&gt; RELU] × (L-1) -&gt; LINEAR -&gt; SIGMOID backward (whole model)</li>
</ul>
<h2 id="LINEAR-1">6.1. LINEAR</h2><p>对于第l层来说，这一层的Linear部分是：$Z^{[l]} = W^{[l]} A^{[l-1]} + b^{[l]}$</p>
<p>假设此时你已经计算好了 $dZ^{[l]} = \frac{\partial \mathcal{L} }{\partial Z^{[l]}}$</p>
<p>你接下来想要得到$(dW^{[l]}, db^{[l]} dA^{[l-1]})$</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-08-20-17-43.png" alt=""> </p>
<p>我们可以通过如下的公式，通过$dZ^{[l]}$来计算出这三个东西$(dW^{[l]}, db^{[l]}, dA^{[l-1]})$:</p>
<p>$$ dW^{[l]} = \frac{\partial \mathcal{L} }{\partial W^{[l]}} = \frac{1}{m} dZ^{[l]} A^{[l-1] T} \tag{8}$$<br>$$ db^{[l]} = \frac{\partial \mathcal{L} }{\partial b^{[l]}} = \frac{1}{m} \sum_{i = 1}^{m} dZ^{<a href="i">l</a>}\tag{9}$$<br>$$ dA^{[l-1]} = \frac{\partial \mathcal{L} }{\partial A^{[l-1]}} = W^{[l] T} dZ^{[l]} \tag{10}$$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">linear_backward</span><span class="params">(dZ, cache)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    实现后向传播的linear部分</div><div class="line">    </div><div class="line">    输入：</div><div class="line">    dZ -- dL/dz</div><div class="line">    cache -- 三元组(A_prev, W, b) , 来自于当前层的前向传播</div><div class="line">    </div><div class="line">    Returns:</div><div class="line">    dA_prev -- 上一层A的梯度</div><div class="line">    dW -- w的梯度</div><div class="line">    db -- b的梯度</div><div class="line">    """</div><div class="line">    </div><div class="line">    A_prev, W, b = cache</div><div class="line">    m = A_prev.shape[<span class="number">1</span>]</div><div class="line">    </div><div class="line">    <span class="comment"># 计算dw，db，dA_prev</span></div><div class="line">    dW = np.dot(dZ, A_prev.T) / m</div><div class="line">    db = np.sum(dZ, axis = <span class="number">1</span>, keepdims = <span class="keyword">True</span>) / m </div><div class="line">    dA_prev = np.dot(W.T, dZ) </div><div class="line">    </div><div class="line">    <span class="comment"># 验证</span></div><div class="line">    <span class="keyword">assert</span> (dA_prev.shape == A_prev.shape)</div><div class="line">    <span class="keyword">assert</span> (dW.shape == W.shape)</div><div class="line">    <span class="keyword">assert</span> (db.shape == b.shape)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> dA_prev, dW, db</div><div class="line"><span class="comment"># 测试</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">linear_backward_test_case</span><span class="params">()</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    z, linear_cache = (np.array([[-0.8019545 ,  3.85763489]]), (np.array([[-1.02387576,  1.12397796],</div><div class="line">       [-1.62328545,  0.64667545],</div><div class="line">       [-1.74314104, -0.59664964]]), np.array([[ 0.74505627,  1.97611078, -1.24412333]]), np.array([[1]]))</div><div class="line">    """</div><div class="line">    np.random.seed(<span class="number">1</span>)</div><div class="line">    dZ = np.random.randn(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">    A = np.random.randn(<span class="number">3</span>,<span class="number">2</span>)</div><div class="line">    W = np.random.randn(<span class="number">1</span>,<span class="number">3</span>)</div><div class="line">    b = np.random.randn(<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">    linear_cache = (A, W, b)</div><div class="line">    <span class="keyword">return</span> dZ, linear_cache </div><div class="line"></div><div class="line">dZ, linear_cache = linear_backward_test_case()</div><div class="line"></div><div class="line">dA_prev, dW, db = linear_backward(dZ, linear_cache)</div><div class="line"><span class="keyword">print</span> (<span class="string">"dA_prev = "</span>+ str(dA_prev))</div><div class="line"><span class="keyword">print</span> (<span class="string">"dW = "</span> + str(dW))</div><div class="line"><span class="keyword">print</span> (<span class="string">"db = "</span> + str(db))</div></pre></td></tr></table></figure>
<pre><code>dA_prev = [[ 0.51822968 -0.19517421]
 [-0.40506361  0.15255393]
 [ 2.37496825 -0.89445391]]
dW = [[-0.10076895  1.40685096  1.64992505]]
db = [[ 0.50629448]]
</code></pre><h2 id="LINEAR-gt-ACTIVATION-1">6.2. LINEAR -&gt; ACTIVATION</h2><p>本节要加入后向传播中的activation部分：</p>
<p>假设$g(.)$是激活函数，</p>
<p>而下面给出的两个函数：<code>sigmoid_backward</code> 和 <code>relu_backward</code> 计算了$dL/dz$ :<br>$$dZ^{[l]} = dA^{[l]} * g’(Z^{[l]}) \tag{11}$$. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">relu_backward</span><span class="params">(dA, cache)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Implement the backward propagation for a single RELU unit.</div><div class="line"></div><div class="line">    Arguments:</div><div class="line">    dA -- post-activation gradient, of any shape</div><div class="line">    cache -- 'Z' where we store for computing backward propagation efficiently</div><div class="line"></div><div class="line">    Returns:</div><div class="line">    dZ -- Gradient of the cost with respect to Z</div><div class="line">    """</div><div class="line">    </div><div class="line">    Z = cache</div><div class="line">    dZ = np.array(dA, copy=<span class="keyword">True</span>) <span class="comment"># just converting dz to a correct object.</span></div><div class="line">    </div><div class="line">    <span class="comment"># When z &lt;= 0, you should set dz to 0 as well. </span></div><div class="line">    dZ[Z &lt;= <span class="number">0</span>] = <span class="number">0</span></div><div class="line">    </div><div class="line">    <span class="keyword">assert</span> (dZ.shape == Z.shape)</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> dZ</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid_backward</span><span class="params">(dA, cache)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Implement the backward propagation for a single SIGMOID unit.</div><div class="line"></div><div class="line">    Arguments:</div><div class="line">    dA -- post-activation gradient, of any shape</div><div class="line">    cache -- 'Z' where we store for computing backward propagation efficiently</div><div class="line"></div><div class="line">    Returns:</div><div class="line">    dZ -- Gradient of the cost with respect to Z</div><div class="line">    """</div><div class="line">    </div><div class="line">    Z = cache</div><div class="line">    </div><div class="line">    s = <span class="number">1</span>/(<span class="number">1</span>+np.exp(-Z))</div><div class="line">    dZ = dA * s * (<span class="number">1</span>-s)</div><div class="line">    </div><div class="line">    <span class="keyword">assert</span> (dZ.shape == Z.shape)</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> dZ</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">linear_activation_backward</span><span class="params">(dA, cache, activation)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    后向传播的LINEAR-&gt;ACTIVATION实现</div><div class="line">    </div><div class="line">    输入：</div><div class="line">    dA -- 当前层的输出A的导数</div><div class="line">    cache -- 二元组(linear_cache, activation_cache)，也就是之前前向传播计算时的cache</div><div class="line">    activation -- 本层的激活函数，是"sigmoid"或"relu"</div><div class="line">    </div><div class="line">    Returns :</div><div class="line">    dA_prev -- 上一层输出的导数</div><div class="line">    dW -- 本层W的导数</div><div class="line">    db -- 本层b的导数</div><div class="line">    """</div><div class="line">    </div><div class="line">    linear_cache, activation_cache = cache</div><div class="line">    <span class="comment"># 计算dZ</span></div><div class="line">    <span class="keyword">if</span> activation == <span class="string">"relu"</span>:</div><div class="line">        dZ = relu_backward(dA, activation_cache)</div><div class="line">    <span class="keyword">elif</span> activation == <span class="string">"sigmoid"</span>:</div><div class="line">        dZ = sigmoid_backward(dA,activation_cache)</div><div class="line">    <span class="comment"># 已知dZ, 计算dA_prev, dW, db</span></div><div class="line">    dA_prev, dW, db = linear_backward(dZ, linear_cache)</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> dA_prev, dW, db</div><div class="line"><span class="comment"># 测试</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">linear_activation_backward_test_case</span><span class="params">()</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    aL, linear_activation_cache = (np.array([[ 3.1980455 ,  7.85763489]]), ((np.array([[-1.02387576,  1.12397796], [-1.62328545,  0.64667545], [-1.74314104, -0.59664964]]), np.array([[ 0.74505627,  1.97611078, -1.24412333]]), 5), np.array([[ 3.1980455 ,  7.85763489]])))</div><div class="line">    """</div><div class="line">    np.random.seed(<span class="number">2</span>)</div><div class="line">    dA = np.random.randn(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">    A = np.random.randn(<span class="number">3</span>,<span class="number">2</span>)</div><div class="line">    W = np.random.randn(<span class="number">1</span>,<span class="number">3</span>)</div><div class="line">    b = np.random.randn(<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">    Z = np.random.randn(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">    linear_cache = (A, W, b)</div><div class="line">    activation_cache = Z</div><div class="line">    linear_activation_cache = (linear_cache, activation_cache)</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> dA, linear_activation_cache</div><div class="line"></div><div class="line">AL, linear_activation_cache = linear_activation_backward_test_case()</div><div class="line"></div><div class="line">dA_prev, dW, db = linear_activation_backward(AL, linear_activation_cache, activation = <span class="string">"sigmoid"</span>)</div><div class="line"><span class="keyword">print</span> (<span class="string">"sigmoid:"</span>)</div><div class="line"><span class="keyword">print</span> (<span class="string">"dA_prev = "</span>+ str(dA_prev))</div><div class="line"><span class="keyword">print</span> (<span class="string">"dW = "</span> + str(dW))</div><div class="line"><span class="keyword">print</span> (<span class="string">"db = "</span> + str(db) + <span class="string">"\n"</span>)</div><div class="line"></div><div class="line">dA_prev, dW, db = linear_activation_backward(AL, linear_activation_cache, activation = <span class="string">"relu"</span>)</div><div class="line"><span class="keyword">print</span> (<span class="string">"relu:"</span>)</div><div class="line"><span class="keyword">print</span> (<span class="string">"dA_prev = "</span>+ str(dA_prev))</div><div class="line"><span class="keyword">print</span> (<span class="string">"dW = "</span> + str(dW))</div><div class="line"><span class="keyword">print</span> (<span class="string">"db = "</span> + str(db))</div></pre></td></tr></table></figure>
<pre><code>sigmoid:
dA_prev = [[ 0.11017994  0.01105339]
 [ 0.09466817  0.00949723]
 [-0.05743092 -0.00576154]]
dW = [[ 0.10266786  0.09778551 -0.01968084]]
db = [[-0.05729622]]

(1L, 2L)
(1L, 2L)
relu:
dA_prev = [[ 0.44090989 -0.        ]
 [ 0.37883606 -0.        ]
 [-0.2298228   0.        ]]
dW = [[ 0.44513824  0.37371418 -0.10478989]]
db = [[-0.20837892]]
</code></pre><h2 id="L-Model-Backward">6.3. L-Model Backward</h2><p>接下来就该将后向传播应用在整个网络了。步骤如下：</p>
<ol>
<li>前向传播 - <code>L_model_forward()</code>,在每一层都存下了(X,W,b,z)</li>
<li>后向传播 - <code>L_model_backward()</code>，利用之前存的值，一层层向前计算导数</li>
</ol>
<p>后向传播计算导数的流程如下图所示：<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-09-13-40-28.png" alt=""> </p>
<p><strong>初始化部分</strong></p>
<p>对于贯穿网络的后向传播来说，我们知道输出是$A^{[L]} = \sigma(Z^{[L]})$.<br>我们需要计算出 ：  <code>dAL</code> $= \frac{\partial \mathcal{L}}{\partial A^{[L]}}$.</p>
<p>为了完成这个目标，我们用如下公式实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dAL = - (np.divide(Y, AL) - np.divide(<span class="number">1</span> - Y, <span class="number">1</span> - AL)) <span class="comment"># 相对于AL的成本衍生物</span></div></pre></td></tr></table></figure></p>
<p>这个公式计算了LINEAR-&gt;SIGMOID后向传播部分</p>
<p>接下来就该计算LINEAR-&gt;RELU后向传播部分了，这一部分需要存储每一步的dA, dW, db，用如下公式实现：<br>$$grads[“dW” + str(l)] = dW^{[l]}\tag{15} $$<br>例如，l=3，就将dw3 存储在<code>grads[&quot;dw3&quot;]</code>中</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">L_model_backward</span><span class="params">(AL, Y, chache)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    [LINEAR-&gt;RELU] * (L-1) -&gt; LINEAR -&gt; SIGMOID 的后向传播的实现</div><div class="line">    </div><div class="line">    输入：</div><div class="line">    AL -- 概率向量，是前向传播L_model_forward()的输出</div><div class="line">    Y  -- 标签向量</div><div class="line">    caches -- caches列表：</div><div class="line">                     1 ~ L - 1 : relu的linear_activation_forward()的caches</div><div class="line">                     L         : sigmoid 的 linear_activation_forward()的caches</div><div class="line">                     </div><div class="line">    Returns:</div><div class="line">    </div><div class="line">    grads -- 梯度dict :</div><div class="line">        grads["dA" + str(l)] = ...</div><div class="line">        grads["dW" + str(l)] = ...</div><div class="line">        grads["db" + str(l)] = ...</div><div class="line">    """</div><div class="line">    </div><div class="line">    grads = &#123;&#125;</div><div class="line">    L = len(caches)</div><div class="line">    m = AL.shape[<span class="number">1</span>]</div><div class="line">    Y = Y.reshape(AL.shape)</div><div class="line">    </div><div class="line">    <span class="comment">#后向传播的初始化</span></div><div class="line">    dAL = -(np.divide(Y, AL) - np.divide(<span class="number">1</span> - Y, <span class="number">1</span> - AL)) </div><div class="line">    </div><div class="line">    <span class="comment"># 计算dAL,dWL,dbL</span></div><div class="line">    <span class="comment"># 第L层 - (SIGMOID -&gt; LINEAR)  - 的梯度</span></div><div class="line">    <span class="comment"># 输入 ：AL, Y, caches</span></div><div class="line">    <span class="comment"># 输出 ：grads["dAL"], grads["dWL"]</span></div><div class="line">    current_cache = caches[L - <span class="number">1</span>]</div><div class="line">    grads[<span class="string">"dA"</span> + str(L)], grads[<span class="string">"dW"</span> + str(L)], grads[<span class="string">"db"</span> + str(L)] = linear_activation_backward(dAL,current_cache, <span class="string">"sigmoid"</span>)</div><div class="line">    </div><div class="line">    <span class="comment"># 计算dAl,dWl,dbl , l = 1~L-1</span></div><div class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> reversed(range(L<span class="number">-1</span>)):</div><div class="line">        <span class="comment"># 第l层：(RELU -&gt; LINEAR) 的梯度</span></div><div class="line">        <span class="comment"># 输入 ： "grads["dA" + str(l + 2)], caches". </span></div><div class="line">        <span class="comment"># 输出: "grads["dA" + str(l + 1)] , grads["dW" + str(l + 1)] , grads["db" + str(l + 1)] </span></div><div class="line">        current_cache = caches[l]</div><div class="line">        dA_prev_temp, dW_temp, db_temp = linear_activation_backward(grads[<span class="string">"dA"</span> + str(l + <span class="number">2</span>)], current_cache, <span class="string">"relu"</span>)</div><div class="line">        grads[<span class="string">"dA"</span> + str(l + <span class="number">1</span>)] = dA_prev_temp</div><div class="line">        grads[<span class="string">"dW"</span> + str(l + <span class="number">1</span>)] = dW_temp</div><div class="line">        grads[<span class="string">"db"</span> + str(l + <span class="number">1</span>)] = db_temp</div><div class="line">    <span class="keyword">return</span> grads</div><div class="line"></div><div class="line"><span class="comment"># 测试</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">L_model_backward_test_case</span><span class="params">()</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    X = np.random.rand(3,2)</div><div class="line">    Y = np.array([[1, 1]])</div><div class="line">    parameters = &#123;'W1': np.array([[ 1.78862847,  0.43650985,  0.09649747]]), 'b1': np.array([[ 0.]])&#125;</div><div class="line"></div><div class="line">    aL, caches = (np.array([[ 0.60298372,  0.87182628]]), [((np.array([[ 0.20445225,  0.87811744],</div><div class="line">           [ 0.02738759,  0.67046751],</div><div class="line">           [ 0.4173048 ,  0.55868983]]),</div><div class="line">    np.array([[ 1.78862847,  0.43650985,  0.09649747]]),</div><div class="line">    np.array([[ 0.]])),</div><div class="line">   np.array([[ 0.41791293,  1.91720367]]))])</div><div class="line">   """</div><div class="line">    np.random.seed(<span class="number">3</span>)</div><div class="line">    AL = np.random.randn(<span class="number">1</span>, <span class="number">2</span>)</div><div class="line">    Y = np.array([[<span class="number">1</span>, <span class="number">0</span>]])</div><div class="line"></div><div class="line">    A1 = np.random.randn(<span class="number">4</span>,<span class="number">2</span>)</div><div class="line">    W1 = np.random.randn(<span class="number">3</span>,<span class="number">4</span>)</div><div class="line">    b1 = np.random.randn(<span class="number">3</span>,<span class="number">1</span>)</div><div class="line">    Z1 = np.random.randn(<span class="number">3</span>,<span class="number">2</span>)</div><div class="line">    linear_cache_activation_1 = ((A1, W1, b1), Z1)</div><div class="line"></div><div class="line">    A2 = np.random.randn(<span class="number">3</span>,<span class="number">2</span>)</div><div class="line">    W2 = np.random.randn(<span class="number">1</span>,<span class="number">3</span>)</div><div class="line">    b2 = np.random.randn(<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">    Z2 = np.random.randn(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">    linear_cache_activation_2 = ( (A2, W2, b2), Z2)</div><div class="line"></div><div class="line">    caches = (linear_cache_activation_1, linear_cache_activation_2)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> AL, Y, caches</div><div class="line"></div><div class="line">AL, Y_assess, caches = L_model_backward_test_case()</div><div class="line">grads = L_model_backward(AL, Y_assess, caches)</div><div class="line"><span class="keyword">print</span> (<span class="string">"dW1 = "</span>+ str(grads[<span class="string">"dW1"</span>]))</div><div class="line"><span class="keyword">print</span> (<span class="string">"db1 = "</span>+ str(grads[<span class="string">"db1"</span>]))</div><div class="line"><span class="keyword">print</span> (<span class="string">"dA1 = "</span>+ str(grads[<span class="string">"dA1"</span>]))</div></pre></td></tr></table></figure>
<pre><code>(3L, 2L)
(3L, 2L)
dW1 = [[ 0.41010002  0.07807203  0.13798444  0.10502167]
 [ 0.          0.          0.          0.        ]
 [ 0.05283652  0.01005865  0.01777766  0.0135308 ]]
db1 = [[-0.22007063]
 [ 0.        ]
 [-0.02835349]]
dA1 = [[ 0.          0.52257901]
 [ 0.         -0.3269206 ]
 [ 0.         -0.32070404]
 [ 0.         -0.74079187]]
</code></pre><h1 id="更新参数">7. 更新参数</h1><p>在这一部分我们用以上模型更新参数：</p>
<p>$$ W^{[l]} = W^{[l]} - \alpha \text{ } dW^{[l]} \tag{16}$$<br>$$ b^{[l]} = b^{[l]} - \alpha \text{ } db^{[l]} \tag{17}$$</p>
<p>其中，$\alpha$是学习率。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_parameters</span><span class="params">(parameters, grads, learning_rate)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    用梯度下降更新参数</div><div class="line">    </div><div class="line">    输入：</div><div class="line">    parameters -- python dict，里面包含一些参数</div><div class="line">    grads -- python dict, 包含梯度</div><div class="line">    </div><div class="line">    Returns:</div><div class="line">    parameters -- python dict, 包含更新后的参数：</div><div class="line">                  parameters["W" + str(l)] = ... </div><div class="line">                  parameters["b" + str(l)] = ...</div><div class="line">    """</div><div class="line">    </div><div class="line">    L = len(parameters) / <span class="number">2</span></div><div class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> range(L):</div><div class="line">        parameters[<span class="string">"W"</span> + str(l+<span class="number">1</span>)] = parameters[<span class="string">"W"</span> + str(l+<span class="number">1</span>)] - learning_rate * grads[<span class="string">"dW"</span> + str(l+<span class="number">1</span>)]</div><div class="line">        parameters[<span class="string">"b"</span> + str(l+<span class="number">1</span>)] = parameters[<span class="string">"b"</span> + str(l+<span class="number">1</span>)] - learning_rate * grads[<span class="string">"db"</span> + str(l+<span class="number">1</span>)]</div><div class="line">    <span class="keyword">return</span> parameters</div><div class="line"></div><div class="line"><span class="comment"># 测试</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_parameters_test_case</span><span class="params">()</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    parameters = &#123;'W1': np.array([[ 1.78862847,  0.43650985,  0.09649747],</div><div class="line">        [-1.8634927 , -0.2773882 , -0.35475898],</div><div class="line">        [-0.08274148, -0.62700068, -0.04381817],</div><div class="line">        [-0.47721803, -1.31386475,  0.88462238]]),</div><div class="line"> 'W2': np.array([[ 0.88131804,  1.70957306,  0.05003364, -0.40467741],</div><div class="line">        [-0.54535995, -1.54647732,  0.98236743, -1.10106763],</div><div class="line">        [-1.18504653, -0.2056499 ,  1.48614836,  0.23671627]]),</div><div class="line"> 'W3': np.array([[-1.02378514, -0.7129932 ,  0.62524497],</div><div class="line">        [-0.16051336, -0.76883635, -0.23003072]]),</div><div class="line"> 'b1': np.array([[ 0.],</div><div class="line">        [ 0.],</div><div class="line">        [ 0.],</div><div class="line">        [ 0.]]),</div><div class="line"> 'b2': np.array([[ 0.],</div><div class="line">        [ 0.],</div><div class="line">        [ 0.]]),</div><div class="line"> 'b3': np.array([[ 0.],</div><div class="line">        [ 0.]])&#125;</div><div class="line">    grads = &#123;'dW1': np.array([[ 0.63070583,  0.66482653,  0.18308507],</div><div class="line">        [ 0.        ,  0.        ,  0.        ],</div><div class="line">        [ 0.        ,  0.        ,  0.        ],</div><div class="line">        [ 0.        ,  0.        ,  0.        ]]),</div><div class="line"> 'dW2': np.array([[ 1.62934255,  0.        ,  0.        ,  0.        ],</div><div class="line">        [ 0.        ,  0.        ,  0.        ,  0.        ],</div><div class="line">        [ 0.        ,  0.        ,  0.        ,  0.        ]]),</div><div class="line"> 'dW3': np.array([[-1.40260776,  0.        ,  0.        ]]),</div><div class="line"> 'da1': np.array([[ 0.70760786,  0.65063504],</div><div class="line">        [ 0.17268975,  0.15878569],</div><div class="line">        [ 0.03817582,  0.03510211]]),</div><div class="line"> 'da2': np.array([[ 0.39561478,  0.36376198],</div><div class="line">        [ 0.7674101 ,  0.70562233],</div><div class="line">        [ 0.0224596 ,  0.02065127],</div><div class="line">        [-0.18165561, -0.16702967]]),</div><div class="line"> 'da3': np.array([[ 0.44888991,  0.41274769],</div><div class="line">        [ 0.31261975,  0.28744927],</div><div class="line">        [-0.27414557, -0.25207283]]),</div><div class="line"> 'db1': 0.75937676204411464,</div><div class="line"> 'db2': 0.86163759922811056,</div><div class="line"> 'db3': -0.84161956022334572&#125;</div><div class="line">    """</div><div class="line">    np.random.seed(<span class="number">2</span>)</div><div class="line">    W1 = np.random.randn(<span class="number">3</span>,<span class="number">4</span>)</div><div class="line">    b1 = np.random.randn(<span class="number">3</span>,<span class="number">1</span>)</div><div class="line">    W2 = np.random.randn(<span class="number">1</span>,<span class="number">3</span>)</div><div class="line">    b2 = np.random.randn(<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">    parameters = &#123;<span class="string">"W1"</span>: W1,</div><div class="line">                  <span class="string">"b1"</span>: b1,</div><div class="line">                  <span class="string">"W2"</span>: W2,</div><div class="line">                  <span class="string">"b2"</span>: b2&#125;</div><div class="line">    np.random.seed(<span class="number">3</span>)</div><div class="line">    dW1 = np.random.randn(<span class="number">3</span>,<span class="number">4</span>)</div><div class="line">    db1 = np.random.randn(<span class="number">3</span>,<span class="number">1</span>)</div><div class="line">    dW2 = np.random.randn(<span class="number">1</span>,<span class="number">3</span>)</div><div class="line">    db2 = np.random.randn(<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">    grads = &#123;<span class="string">"dW1"</span>: dW1,</div><div class="line">             <span class="string">"db1"</span>: db1,</div><div class="line">             <span class="string">"dW2"</span>: dW2,</div><div class="line">             <span class="string">"db2"</span>: db2&#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> parameters, grads</div><div class="line"></div><div class="line">parameters, grads = update_parameters_test_case()</div><div class="line">parameters = update_parameters(parameters, grads, <span class="number">0.1</span>)</div><div class="line"></div><div class="line"><span class="keyword">print</span> (<span class="string">"W1 = "</span>+ str(parameters[<span class="string">"W1"</span>]))</div><div class="line"><span class="keyword">print</span> (<span class="string">"b1 = "</span>+ str(parameters[<span class="string">"b1"</span>]))</div><div class="line"><span class="keyword">print</span> (<span class="string">"W2 = "</span>+ str(parameters[<span class="string">"W2"</span>]))</div><div class="line"><span class="keyword">print</span> (<span class="string">"b2 = "</span>+ str(parameters[<span class="string">"b2"</span>]))</div></pre></td></tr></table></figure>
<pre><code>W1 = [[-0.59562069 -0.09991781 -2.14584584  1.82662008]
 [-1.76569676 -0.80627147  0.51115557 -1.18258802]
 [-1.0535704  -0.86128581  0.68284052  2.20374577]]
b1 = [[-0.04659241]
 [-1.28888275]
 [ 0.53405496]]
W2 = [[-0.55569196  0.0354055   1.32964895]]
b2 = [[-0.84610769]]
</code></pre>]]></content>
      
        <categories>
            
            <category> 深度学习算法 </category>
            
            <category> 神经网络 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[深度学习算法-几种常见的卷积网络]]></title>
      <url>/2017/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8D%B7%E7%A7%AF%E7%BD%91%E7%BB%9C/</url>
      <content type="html"><![CDATA[<p>我们先回顾一些经典的卷积网络，然后看看当下比较流行的几种网络</p>
<h1 id="经典的卷积网络">1. 经典的卷积网络</h1><p>介绍几种经典的卷积神经网络结构，分别是LeNet、AlexNet、VGGNet</p>
<a id="more"></a>
<h2 id="LeNet-5">1.1. LeNet-5</h2><p>LeNet-5主要是针对灰度设计的，所以输入较小，为$32\times 32 \times 1$，其结构如下：</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-08-10-44-59.png" alt=""> </p>
<p>在LetNet中，存在的经典模式：</p>
<ul>
<li>随着网络的深度增加，图像的大小在缩小，与此同时，通道的数量却在增加；</li>
<li>每个卷积层后面接一个池化层。</li>
</ul>
<p>LeNet-5是1998年写的，大约有6万个参数，基本的网络结构跟今天差不多，只是有几点不同：</p>
<p>激活函数用sigmoid或tanh，没有用relu；当时比较流行使用平均池化；池化后使用了sigmoid激活函数；没有使用pdding；</p>
<p>当时的每个卷积核是跟原图像的通道数是一样的，是因为当时计算能力弱，为了减少计算量用了很复杂的运算进行，现在一般都不这么用了；</p>
<h2 id="AlexNext">1.2. AlexNext</h2><p>AlextNet和LeNet类似，但是网络大了很多，参数大约有6000万个；相比于LeNet-5它使用了relu激活函数；当时的GPU运行还比较慢，用了多GPU的方式训练。</p>
<p>从这篇论文开始，计算机视觉研究者开始关注深度学习，并相信深度学习可以应用于计算机视觉领域，此后，深度学习在计算机视觉及其它领域的影响力与日俱增。</p>
<p>AlexNet直接对彩色的大图片进行处理，其结构如下：</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-02-22-05-21.png" alt=""> </p>
<h2 id="VGG-16">1.3. VGG-16</h2><p>VGG-16总共包含约1.38亿个参数，但是它的结构并不复杂，很整齐，卷积核大小和池化参数恒定，几个卷积后面跟着一个池化，卷积核的数量以加倍的方式变化，每次池化后图片高度宽度减半，这种相对一致的网络结构对研究者很有吸引力。而主要缺点在于需要训练的参数特点多。VGG-19比VGG-16更大，只是它们的效果差不多，所以很多人还是用VGG-16。</p>
<p>如果想研读论文的话，ng的建议顺序是AlexNet（比较好懂），VGG，LeNet-5（比较晦涩）。</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-02-22-06-16.png" alt=""> </p>
<h1 id="残差网络-ResNets">2. 残差网络 (ResNets)</h1><p>Residual Networks</p>
<p>因为存在梯度消失和梯度爆炸的问题，深度很深的网络是很难训练的。我们可以通过跳过连接( skip connections ) ，来构建能训练深度网络的ResNets。</p>
<p>先回顾一下正常网络的前向传播计算步骤：</p>
<ul>
<li>Linear：$z^{[l+1]} = W^{[l+1]}a^{[l]} + b^{[l+1]}$</li>
<li>Relu：$a^{[l+1]} = g(z^{[l+1]})$</li>
<li>Linear：$z^{[l+2]} = W^{[l+2]}a^{[l+1]} + b^{[l+2]}$</li>
<li>Relu：$a^{[l+2]} = g(z^{[l+2]})$</li>
</ul>
<p>残差网络是由残差块构成的。正常的网络按照一个主路径传递，如果我们在某层的输出后跳过了一层（或者好几层），直接达到后层的激活函数之前（例如下图的从$a^{[l]}到z^{[l+2]}$ 的连接），这条路就是捷径（称之为short cut 或 skip connection），含有捷径的这一块（包含主路径）就叫残差块。</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-02-22-08-33.png" alt=""> </p>
<p>也就是前向传播公式的最后一个步骤变为：$a^{[l+2]} = g(z^{[l+2]}+a^{[l]})$</p>
<p>那么残差块的网络结构就是：</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-02-22-13-16.png" alt=""> </p>
<p>所谓构建残差网络（ResNets）就是通过很多这样的残差块堆积在一起，形成一个深度神经网络。其结构如下：</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-02-22-14-05.png" alt=""> </p>
<p>如下图所示，在普通网络（plain network）中，理论上随着深度的加深，错误率不断下降。然而实际上因为太深的原因难以训练，到了后面训练错误率会上升。</p>
<p>在残差网络中，随着深度的不断增加，错误率不断下降。</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-02-22-14-35.png" alt=""> </p>
<p>ResNet对于中间的激活函数来说，有助于能够达到更深的网络，解决梯度消失和梯度爆炸的问题。</p>
<p>为什么残差会有用呢？看个例子。假设有个比较大的神经网络，输入为$x$，输出为$a^{[l]}$。如果我们想增加网络的深度，这里再给网络增加一个残差块：</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-02-22-17-55.png" alt=""> </p>
<p>假定使用relu激活函数，现在$a^{[l]}$跳过了$a^{[l+1]}$层，那么有</p>
<p>$$a^{[l+2]} = g(z^{[l+2]}+a^{[l]})=g(W^{[l+2]}a^{[l+1]}+b^{[l+2]}+a^{[l]})$$</p>
<p>如果我们做了2正则化或者权重衰减，会压缩W和b的值，那么假设$W^{[l+2]}=0$ 且$b^{[l+2]}=0$，那么上式子就变为：</p>
<p>$$a^{[l+2]} = g(z^{[l+2]}+a^{[l]})=g(a^{[l]})=relu(a^{[l]})= a^{[l]}$$</p>
<p>因为使用的是relu，而且a[l]是已经被激活过的，结果表明残差块学习这个恒等式函数并不难，即使中间隔着两层我们还是能得到a[l+2] = a[l]。</p>
<p>值得注意的是这里$a^{[l+2]} =g(z^{[l+2]}+a^{[l]})$ ， 想相加那就必须维度一致。所以残差网络中使用了很多相同的卷积来保留维度。如果维度不一致的话，z[i+2] + a[l]的时候，在a[l]前面乘上一个权重，来保持维度一致，这个维度是网络自己学习得到的参数，它用0填充a[l]或者其它手段使得维度一致。</p>
<h1 id="Inception-Net">3. Inception Net</h1><h2 id="1-times-1-卷积">3.1. $1 \times 1$ 卷积</h2><p>在二维上，$1\times 1$ 卷积就相当于每个元素与一个数字相乘。如下图所示：</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-02-22-27-35.png" alt=""> </p>
<p>但假如是多通道的三维上，如果一个三维的东西与一个$1\times1\times n_C$ 的东西相乘，如下图所示，就相当于三维图形上的$1\times1\times n_C$ 切片，也就是$n_c$ 个点乘以权重，通过Relu函数后，输出对应的结果。而不同的卷积核则相当于不同的隐层神经元结点与切片上的点进行一一连接。</p>
<p>最终三维的图形应用1×1的卷积核得到一个相同长宽但第三维度变为卷积核个数的图片。</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-02-22-28-07.png" alt=""> </p>
<p>所以根本上1×1卷积核相当于对一个切片上的$n_c$个单元都应用了一个全连接的神经网络。</p>
<p><strong>1x1卷积应用：</strong></p>
<ul>
<li>维度压缩：使用目标维度的1×1的卷积核个数。</li>
<li>增加非线性：保持与原维度相同的1×1的卷积核个数。</li>
</ul>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-02-22-30-39.png" alt=""> </p>
<h2 id="Inception-Network">3.2. Inception Network</h2><p>Inception Network 的作用就是使我们无需去考虑在构建深度卷积神经网络时，使用多大的卷积核以及是否添加池化层等问题。</p>
<p>用机器代替人工来确定卷积层中的卷积核类型，或者确定是否需要创建卷积层或池化层。</p>
<p>对于一个输入的图像，是用1<em>1，还是3</em>3，还是5*5的卷积，还是做一种特殊的池化，Inception会把他们都计算出来叠在一起，由网络自己学习应该采用什么运算。</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-02-22-42-14.png" alt=""> </p>
<p>在上面的Inception结构中，应用了不同的卷积核，以及带padding的池化层。在保持输入图片大小不变的情况下，通过不同运算结果的叠加，增加了通道的数量。</p>
<p><strong>计算成本问题</strong></p>
<p>对于上面的5×5大小卷积核的计算成本：</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-02-22-52-38.png" alt=""> </p>
<ul>
<li>1 filters：5×5×192；</li>
<li>32 个 filters；</li>
<li>总的计算成本：28×28×32×5×5×192=120M</li>
</ul>
<p>现在考虑先用1<em>1的卷积，构造一个瓶颈层，</em>用作过渡的计算成本，也将下面的中间的层叫做“bottleneck layer”：</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-02-22-53-50.png" alt=""> </p>
<ul>
<li>1×1卷积层计算成本：28×28×16×1×1×192=2.4M</li>
<li>5×5卷积层计算成本：28×28×32×5×5×16=10.0M</li>
<li>总的计算成本：2.4M+10.0M=12.4M</li>
</ul>
<p>这样需要计算的乘法运算次数约等于1200千万次，比之前缩小了10倍，如上图所示。</p>
<p>事实证明，只要合理地设置“bottleneck layer”，既可以显著减小上层的规模，同时又能降低计算成本，从而不会影响网络的性能。</p>
<p><strong>结合</strong></p>
<p>利用1*1卷积可以减小计算量，把这个和上面说的Inception结合起来，可以得到下图所示模块。</p>
<p><img src="https://images2018.cnblogs.com/blog/1160281/201711/1160281-20171124151010078-1933005968.png" alt="img"></p>
<p>这些一个个Inception模块堆叠起来，就是一个大的Inception网络，如下图所示。可以注意到除了最后的输出外，还有几个分支输出，这些分支输出是根据中间隐藏层进行预测的输出，它确保了中间隐藏层也参与了特征计算，它们也能预测图片的分类，它起到一种调整的作用，并且能防止网络过拟合。</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-02-22-56-19.png" alt=""> </p>
<h1 id="迁移学习">4. 迁移学习</h1><p><strong>小数据集：</strong></p>
<p>如今在深度学习领域，许多研究者都会将他们的工作共享到网络上。在我们实施自己的工作的时候，比如说做某种物体的识别分类，但是只有少量的数据集，对于从头开始训练一个深度网络结构是远远不够的。</p>
<p>但是我们可以应用迁移学习，应用其他研究者建立的模型和参数，用少量的数据仅训练最后自定义的softmax网络。从而能够在小数据集上达到很好的效果。</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-02-22-58-22.png" alt=""> </p>
<p><strong>大数据集：</strong></p>
<p>如果我们在自己的问题上也拥有大量的数据集，我们可以多训练后面的几层。总之随着数据集的增加，我们需要“ freeze”的层数越来越少。最后如果我们有十分庞大的数据集，那么我们可以训练网络模型的所有参数，将其他研究者训练的模型参数作为参数的初始化来替代随机初始化，来加速我们模型的训练。</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-02-22-58-39.png" alt=""> </p>
<h1 id="数据扩充">5. 数据扩充</h1><p>与其他机器学习问题相比，在计算机视觉领域当下最主要的问题是没有办法得到充足的数据。所以在我们训练计算机数据模型的时候，数据的扩充就是会非常有用。</p>
<p><strong>数据扩充的方法：</strong></p>
<ul>
<li>镜像翻转（Mirroring）；</li>
<li>随机剪裁（Random Cropping）；</li>
<li>色彩转换（Color shifting）：<br>为图片的RGB三个色彩通道进行增减值，如（R：+20，G：-20，B：+20）；PCA颜色增强：对图片的主色的变化较大，图片的次色变化较小，使总体的颜色保持一致。</li>
</ul>
<p><strong>训练过程中的数据扩充：</strong></p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-02-22-59-09.png" alt=""> </p>
<p>为了节省时间，数据扩充的过程和训练过程可以多CPU多线程来并行的实现。</p>
<h1 id="计算机视觉现状">6. 计算机视觉现状</h1><p><strong>数据和手工工程：</strong></p>
<p>不同问题当前的数据集大小：</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2018-01-02-22-59-38.png" alt=""> </p>
<p>在有大量数据的时候，我们更倾向于使用简单的算法和更少的手工工程。因为此时有大量的数据，我们不需要为这个问题来精心设计特征，我们使用一个大的网络结果或者更简单的模型就能够解决。</p>
<p>相反，在有少量数据的时候，我们从事更多的是手工工程。因为数据量太少，较大的网络结构或者模型很难从这些少量的数据中获取足够的特征，而手工工程实际上是获得良好表现的最佳方式。</p>
<p>对于机器学习应用：</p>
<ul>
<li>标记数据，（x,y）；</li>
<li>手工特征工程/网络结构/其他构建。</li>
</ul>
<p><strong>Tips for doing well：</strong></p>
<p>在基准研究和比赛中，下面的tips可能会有较好的表现：</p>
<ul>
<li>Ensembling：独立地训练多个网络模型，输出平均结果或加权平均结果；</li>
<li>测试时的 Multi-crop：在测试图片的多种版本上运行分类器，输出平均结果。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 深度学习算法 </category>
            
            <category> 卷积网络 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[深度学习实践-1-3-构建浅层神经网络]]></title>
      <url>/2017/12/05/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5-1-3-%E6%9E%84%E5%BB%BA%E6%B5%85%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
      <content type="html"><![CDATA[<h1 id="序言">1. 序言</h1><p>本文主要参考自<a href="http://blog.csdn.net/koala_tree/article/details/78067464" target="_blank" rel="external">吴恩达Coursera深度学习课程 DeepLearning.ai 编程作业（1-3）</a></p>
<p>吴恩达Coursera课程 DeepLearning.ai 编程作业系列，本文为《神经网络与深度学习》部分的第三周“浅层神经网络”的课程作业。</p>
<p>本节的主要内容是：利用浅层神经网络实现平面数据分类</p>
<a id="more"></a>
<h1 id="1-import的包">2. 1 - import的包</h1><ul>
<li>numpy</li>
<li>sklearn</li>
<li>matplotlib</li>
<li>testCase - 提供了测试样例</li>
<li>pannar_utils - 一些有用的工具</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> warnings</div><div class="line">warnings.filterwarnings(<span class="string">"ignore"</span>) </div><div class="line"></div><div class="line"><span class="comment"># Package imports</span></div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="keyword">from</span> testCases <span class="keyword">import</span> *</div><div class="line"><span class="keyword">import</span> sklearn</div><div class="line"><span class="keyword">import</span> sklearn.datasets</div><div class="line"><span class="keyword">import</span> sklearn.linear_model</div><div class="line"><span class="keyword">from</span> planar_utils <span class="keyword">import</span> plot_decision_boundary, sigmoid, load_planar_dataset, load_extra_datasets</div><div class="line"></div><div class="line">%matplotlib inline</div><div class="line"></div><div class="line">np.random.seed(<span class="number">1</span>) <span class="comment"># 给np.random设定一个种子，这样随机数就固定了</span></div></pre></td></tr></table></figure>
<h1 id="2-数据集">3. 2 - 数据集</h1><p>下面的代码生成了“花”的二类数据集</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 这个函数原本在panar_utils.py里</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_planar_dataset</span><span class="params">()</span>:</span></div><div class="line">    np.random.seed(<span class="number">1</span>)</div><div class="line">    m = <span class="number">400</span> <span class="comment"># 样本数量</span></div><div class="line">    N = int(m/<span class="number">2</span>) <span class="comment"># 每个类别的数量</span></div><div class="line">    D = <span class="number">2</span> <span class="comment"># 维度</span></div><div class="line">    <span class="comment"># 初始化X,Y</span></div><div class="line">    X = np.zeros((m,D))</div><div class="line">    Y = np.zeros((m,<span class="number">1</span>),dtype=<span class="string">'uint8'</span>)</div><div class="line">    a = <span class="number">4</span> <span class="comment"># 花儿最大长度</span></div><div class="line">    </div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>):</div><div class="line">        ix = range(N*j,N*(j+<span class="number">1</span>))</div><div class="line">        t = np.linspace(j*<span class="number">3.12</span>,(j+<span class="number">1</span>)*<span class="number">3.12</span>,N) + np.random.randn(N)*<span class="number">0.2</span> <span class="comment"># theta</span></div><div class="line">        r = a*np.sin(<span class="number">4</span>*t) + np.random.randn(N)*<span class="number">0.2</span> <span class="comment"># radius</span></div><div class="line">        X[ix] = np.c_[r*np.sin(t), r*np.cos(t)]</div><div class="line">        Y[ix] = j</div><div class="line">        </div><div class="line">    X = X.T</div><div class="line">    Y = Y.T</div><div class="line"></div><div class="line">    <span class="keyword">return</span> X, Y</div><div class="line"></div><div class="line">X,Y = load_planar_dataset()</div><div class="line"><span class="keyword">print</span> X.shape,Y.shape</div></pre></td></tr></table></figure>
<pre><code>(2L, 400L) (1L, 400L)
</code></pre><p>​    </p>
<p>此时你得到了：</p>
<ul>
<li>一个numpy-array(matrix) X,包括特征（X1，X2）</li>
<li>一个numpy-arrya(vector) Y,包含一列标签（0或1）</li>
</ul>
<p>接下来用matplotlib将这个“花儿”数据集可视化，其中：</p>
<ul>
<li>y = 0 -&gt; 红色</li>
<li>y = 1 -&gt; 蓝色</li>
</ul>
<p>我们的目标是建立一个模型，能将红色和蓝色分开</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 数据可视化</span></div><div class="line">plt.scatter(X[<span class="number">0</span>, :], X[<span class="number">1</span>, :], c=Y, s=<span class="number">40</span>, cmap=plt.cm.Spectral)</div></pre></td></tr></table></figure>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-05-21-55-52.png" alt=""> </p>
<h1 id="简单的逻辑回归">4. 简单的逻辑回归</h1><p>首先我们看看LR在这个问题上表现如何：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Train the logistic regression classifier</span></div><div class="line">clf = sklearn.linear_model.LogisticRegressionCV();</div><div class="line">clf.fit(X.T, Y.T);</div><div class="line"></div><div class="line"><span class="comment"># 画出LR的决策边界</span></div><div class="line">plot_decision_boundary(<span class="keyword">lambda</span> x: clf.predict(x), X, Y)</div><div class="line">plt.title(<span class="string">"Logistic Regression"</span>)</div><div class="line"></div><div class="line"><span class="comment"># 打印准确率</span></div><div class="line">LR_predictions = clf.predict(X.T)</div><div class="line"><span class="keyword">print</span> (<span class="string">'LR的准确率是: %d '</span> % float((np.dot(Y,LR_predictions) + np.dot(<span class="number">1</span>-Y,<span class="number">1</span>-LR_predictions))/float(Y.size)*<span class="number">100</span>) +</div><div class="line">       <span class="string">'% '</span>)</div></pre></td></tr></table></figure>
<pre><code>LR的准确率是: 47 % 
</code></pre><p>​    </p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-05-21-56-33.png" alt=""> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 以上的plot_decision_boundary()函数定义如下：</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_decision_boundary</span><span class="params">(model, X, y)</span>:</span></div><div class="line">    <span class="comment"># Set min and max values and give it some padding</span></div><div class="line">    x_min, x_max = X[<span class="number">0</span>, :].min() - <span class="number">1</span>, X[<span class="number">0</span>, :].max() + <span class="number">1</span></div><div class="line">    y_min, y_max = X[<span class="number">1</span>, :].min() - <span class="number">1</span>, X[<span class="number">1</span>, :].max() + <span class="number">1</span></div><div class="line">    h = <span class="number">0.01</span></div><div class="line">    <span class="comment"># Generate a grid of points with distance h between them</span></div><div class="line">    xx, yy = np.meshgrid(np.arange(x_min, x_max, h), np.arange(y_min, y_max, h))</div><div class="line">    <span class="comment"># Predict the function value for the whole grid</span></div><div class="line">    Z = model(np.c_[xx.ravel(), yy.ravel()])</div><div class="line">    Z = Z.reshape(xx.shape)</div><div class="line">    <span class="comment"># Plot the contour and training examples</span></div><div class="line">    plt.contourf(xx, yy, Z, cmap=plt.cm.Spectral)</div><div class="line">    plt.ylabel(<span class="string">'x2'</span>)</div><div class="line">    plt.xlabel(<span class="string">'x1'</span>)</div><div class="line">    plt.scatter(X[<span class="number">0</span>, :], X[<span class="number">1</span>, :], c=y, cmap=plt.cm.Spectral)</div></pre></td></tr></table></figure>
<h1 id="神经网络模型">5. 神经网络模型</h1><p>我们本次<strong>模型</strong>为：<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-05-20-50-56.png" alt=""> </p>
<p><strong>数学模型</strong><br>对于一条样本$x^{i}$</p>
<p>$$z^{[1] (i)} =  W^{[1]} x^{(i)} + b^{[1] (i)}\tag{1}$$<br>$$a^{[1] (i)} = \tanh(z^{[1] (i)})\tag{2}$$<br>$$z^{[2] (i)} = W^{[2]} a^{[1] (i)} + b^{[2] (i)}\tag{3}$$<br>$$\hat{y}^{(i)} = a^{[2] (i)} = \sigma(z^{ [2] (i)})\tag{4}$$<br>$$y^{(i)}_{prediction} = \begin{cases} 1 &amp; \mbox{if } a^{<a href="i">2</a>} &gt; 0.5 \ 0 &amp; \mbox{otherwise } \end{cases}\tag{5}$$</p>
<p>通过上式计算出所有样本的预测误差，我们可以通过下式计算出误差函数：<br>$$J = - \frac{1}{m} \sum\limits_{i = 0}^{m} \large\left(\small y^{(i)}\log\left(a^{[2] (i)}\right) + (1-y^{(i)})\log\left(1- a^{[2] (i)}\right)  \large  \right) \small \tag{6}$$</p>
<p>回忆一下，计算神经网络的步骤为：</p>
<ol>
<li>定义网络结构</li>
<li>初始化模型参数</li>
<li>迭代<ul>
<li>前向传播计算预测值</li>
<li>计算误差</li>
<li>后向传播计算梯度</li>
<li>根据梯度更新参数</li>
</ul>
</li>
</ol>
<h1 id="定义网络结构">6. 定义网络结构</h1><p>约定：</p>
<ul>
<li>n_x : 输入层的数据个数</li>
<li>n_h : 隐藏层数 （此处设置为4）</li>
<li>n_y : 输出层的数据个数（类别个数）</li>
</ul>
<p>可定义如下函数来获取以上三个数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># GRADED FUNCTION: layer_sizes</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">layer_sizes</span><span class="params">(X, Y)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Arguments:</div><div class="line">    X -- input dataset of shape (input size, number of examples)</div><div class="line">    Y -- labels of shape (output size, number of examples)</div><div class="line"></div><div class="line">    Returns:</div><div class="line">    n_x -- the size of the input layer</div><div class="line">    n_h -- the size of the hidden layer</div><div class="line">    n_y -- the size of the output layer</div><div class="line">    """</div><div class="line">    <span class="comment">### START CODE HERE ### (≈ 3 lines of code)</span></div><div class="line">    n_x = X.shape[<span class="number">0</span>] <span class="comment"># size of input layer</span></div><div class="line">    n_h = <span class="number">4</span></div><div class="line">    n_y = Y.shape[<span class="number">0</span>]<span class="comment"># size of output layer</span></div><div class="line">    <span class="comment">### END CODE HERE ###</span></div><div class="line">    <span class="keyword">return</span> (n_x, n_h, n_y)</div><div class="line">n_x, n_h, n_y = layer_sizes(X,Y)</div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"n_x = "</span>,n_x</div><div class="line"><span class="keyword">print</span> <span class="string">"n_h = "</span>,n_h</div><div class="line"><span class="keyword">print</span> <span class="string">"n_y = "</span>,n_y</div></pre></td></tr></table></figure>
<pre><code>n_x =  2
n_h =  4
n_y =  1
</code></pre><h2 id="初始化参数">6.1. 初始化参数</h2><p>需要初始化的参数主要是W和b</p>
<p>Exercise: Implement the function initialize_parameters().</p>
<p>Instructions: </p>
<ul>
<li>Make sure your parameters’ sizes are right. Refer to the neural network figure above if needed. </li>
<li>You will initialize the weights matrices with random values. </li>
<li>Use: np.random.randn(a,b) * 0.01 to randomly initialize a matrix of shape (a,b). </li>
<li>You will initialize the bias vectors as zeros. </li>
<li>Use: np.zeros((a,b)) to initialize a matrix of shape (a,b) with zeros.</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># GRADED FUNCTION: initialize_parameters</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize_parameters</span><span class="params">(n_x, n_h, n_y)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Argument:</div><div class="line">    n_x -- size of the input layer</div><div class="line">    n_h -- size of the hidden layer</div><div class="line">    n_y -- size of the output layer</div><div class="line"></div><div class="line">    Returns:</div><div class="line">    params -- python dictionary containing your parameters:</div><div class="line">                    W1 -- weight matrix of shape (n_h, n_x)</div><div class="line">                    b1 -- bias vector of shape (n_h, 1)</div><div class="line">                    W2 -- weight matrix of shape (n_y, n_h)</div><div class="line">                    b2 -- bias vector of shape (n_y, 1)</div><div class="line">    """</div><div class="line"></div><div class="line">    np.random.seed(<span class="number">2</span>) <span class="comment"># we set up a seed so that your output matches ours although the initialization is random.</span></div><div class="line"></div><div class="line">    <span class="comment">### START CODE HERE ### (≈ 4 lines of code)</span></div><div class="line">    W1 = np.random.randn(n_h, n_x)</div><div class="line">    b1 = np.zeros((n_h, <span class="number">1</span>))</div><div class="line">    W2 = np.random.randn(n_y, n_h)</div><div class="line">    b2 = np.zeros((n_y, <span class="number">1</span>))</div><div class="line">    <span class="comment">### END CODE HERE ###</span></div><div class="line"></div><div class="line">    <span class="keyword">assert</span> (W1.shape == (n_h, n_x))</div><div class="line">    <span class="keyword">assert</span> (b1.shape == (n_h, <span class="number">1</span>))</div><div class="line">    <span class="keyword">assert</span> (W2.shape == (n_y, n_h))</div><div class="line">    <span class="keyword">assert</span> (b2.shape == (n_y, <span class="number">1</span>))</div><div class="line"></div><div class="line">    parameters = &#123;<span class="string">"W1"</span>: W1,</div><div class="line">                  <span class="string">"b1"</span>: b1,</div><div class="line">                  <span class="string">"W2"</span>: W2,</div><div class="line">                  <span class="string">"b2"</span>: b2&#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> parameters</div><div class="line"></div><div class="line">parameters = initialize_parameters(n_x, n_h, n_y)</div><div class="line">print(<span class="string">"W1 = "</span> + str(parameters[<span class="string">"W1"</span>]))</div><div class="line">print(<span class="string">"b1 = "</span> + str(parameters[<span class="string">"b1"</span>]))</div><div class="line">print(<span class="string">"W2 = "</span> + str(parameters[<span class="string">"W2"</span>]))</div><div class="line">print(<span class="string">"b2 = "</span> + str(parameters[<span class="string">"b2"</span>]))</div></pre></td></tr></table></figure>
<pre><code>W1 = [[-0.41675785 -0.05626683]
 [-2.1361961   1.64027081]
 [-1.79343559 -0.84174737]
 [ 0.50288142 -1.24528809]]
b1 = [[ 0.]
 [ 0.]
 [ 0.]
 [ 0.]]
W2 = [[-1.05795222 -0.90900761  0.55145404  2.29220801]]
b2 = [[ 0.]]
</code></pre><h2 id="迭代">6.2. 迭代</h2><h3 id="前向传播">6.2.1. 前向传播</h3><p><strong>问题</strong>: 实现 <code>forward_propagation()</code>.</p>
<p><strong>Instructions</strong>:</p>
<ul>
<li>Look above at the mathematical representation of your classifier.</li>
<li>You can use the function <code>sigmoid()</code>. It is built-in (imported) in the notebook.</li>
<li>You can use the function <code>np.tanh()</code>. It is part of the numpy library.</li>
<li>The steps you have to implement are:<ol>
<li>Retrieve each parameter from the dictionary “parameters” (which is the output of <code>initialize_parameters()</code>) by using <code>parameters[&quot;..&quot;]</code>.</li>
<li>Implement Forward Propagation. Compute $Z^{[1]}, A^{[1]}, Z^{[2]}$ and $A^{[2]}$ (the vector of all your predictions on all the examples in the training set).</li>
</ol>
</li>
<li>Values needed in the backpropagation are stored in “<code>cache</code>“. The <code>cache</code> will be given as an input to the backpropagation function.</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 前向传播</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward_propagation</span><span class="params">(X, parameters)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Argument:</div><div class="line">    X -- input data of size (n_x, m)</div><div class="line">    parameters -- python dictionary containing your parameters (output of initialization function)</div><div class="line"></div><div class="line">    Returns:</div><div class="line">    A2 -- The sigmoid output of the second activation</div><div class="line">    cache -- a dictionary containing "Z1", "A1", "Z2" and "A2"</div><div class="line">    """</div><div class="line">    <span class="comment"># Retrieve each parameter from the dictionary "parameters"</span></div><div class="line">    <span class="comment">### START CODE HERE ### (≈ 4 lines of code)</span></div><div class="line">    <span class="comment"># 参数获取</span></div><div class="line">    W1 = parameters[<span class="string">"W1"</span>]</div><div class="line">    b1 = parameters[<span class="string">"b1"</span>]</div><div class="line">    W2 = parameters[<span class="string">"W2"</span>]</div><div class="line">    b2 = parameters[<span class="string">"b2"</span>]</div><div class="line">    <span class="comment">### END CODE HERE ###</span></div><div class="line"></div><div class="line">    <span class="comment"># Implement Forward Propagation to calculate A2 (probabilities)</span></div><div class="line">    <span class="comment">### START CODE HERE ### (≈ 4 lines of code)</span></div><div class="line">    <span class="comment"># 计算预测值</span></div><div class="line">    Z1 = np.dot(W1, X) + b1</div><div class="line">    A1 = np.tanh(Z1)</div><div class="line">    Z2 = np.dot(W2, A1) + b2 </div><div class="line">    A2 = sigmoid(Z2)</div><div class="line">    <span class="comment">### END CODE HERE ###</span></div><div class="line"></div><div class="line">    <span class="keyword">assert</span>(A2.shape == (<span class="number">1</span>, X.shape[<span class="number">1</span>]))</div><div class="line"></div><div class="line">    cache = &#123;<span class="string">"Z1"</span>: Z1,</div><div class="line">             <span class="string">"A1"</span>: A1,</div><div class="line">             <span class="string">"Z2"</span>: Z2,</div><div class="line">             <span class="string">"A2"</span>: A2&#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> A2, cache</div><div class="line"></div><div class="line">X_assess, parameters = forward_propagation_test_case()</div><div class="line">A2, cache = forward_propagation(X_assess, parameters)</div><div class="line"></div><div class="line"><span class="comment"># Note: we use the mean here just to make sure that your output matches ours. </span></div><div class="line">print(np.mean(cache[<span class="string">'Z1'</span>]) ,np.mean(cache[<span class="string">'A1'</span>]),np.mean(cache[<span class="string">'Z2'</span>]),np.mean(cache[<span class="string">'A2'</span>]))</div></pre></td></tr></table></figure>
<pre><code>(-0.00049975577774199022, -0.00049696335323177901, 0.00043818745095914658, 0.50010954685243103)
</code></pre><p>​    </p>
<h3 id="计算误差">6.2.2. 计算误差</h3><p>现在我们已经计算除了预测值A2，接下来我们需要计算本轮误差：</p>
<p>$$J = - \frac{1}{m} \sum\limits_{i = 0}^{m} \large{(} \small y^{(i)}\log\left(a^{[2] (i)}\right) + (1-y^{(i)})\log\left(1- a^{[2] (i)}\right) \large{)} \small\tag{13}$$</p>
<p><strong>Exercise</strong>: Implement <code>compute_cost()</code> to compute the value of the cost $J$.</p>
<p><strong>Instructions</strong>:</p>
<ul>
<li>There are many ways to implement the cross-entropy loss. To help you, we give you how we would have implemented<br>$- \sum\limits_{i=0}^{m}  y^{(i)}\log(a^{<a href="i">2</a>})$:<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">logprobs = np.multiply(np.log(A2),Y)</div><div class="line">cost = - np.sum(logprobs)                <span class="comment"># no need to use a for loop!</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>(you can use either <code>np.multiply()</code> and then <code>np.sum()</code> or directly <code>np.dot()</code>).</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># GRADED FUNCTION: compute_cost</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_cost</span><span class="params">(A2, Y, parameters)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Computes the cross-entropy cost given in equation (13)</div><div class="line"></div><div class="line">    Arguments:</div><div class="line">    A2 -- The sigmoid output of the second activation, of shape (1, number of examples)</div><div class="line">    Y -- "true" labels vector of shape (1, number of examples)</div><div class="line">    parameters -- python dictionary containing your parameters W1, b1, W2 and b2</div><div class="line"></div><div class="line">    Returns:</div><div class="line">    cost -- cross-entropy cost given equation (13)</div><div class="line">    """</div><div class="line"></div><div class="line">    m = Y.shape[<span class="number">1</span>] <span class="comment"># number of example</span></div><div class="line"></div><div class="line">    <span class="comment"># Compute the cross-entropy cost</span></div><div class="line">    <span class="comment">### START CODE HERE ### (≈ 2 lines of code)</span></div><div class="line">    <span class="comment"># 误差计算</span></div><div class="line">    logprobs = np.multiply(np.log(A2), Y) + np.multiply(np.log(<span class="number">1</span>-A2), (<span class="number">1</span>-Y))</div><div class="line">    cost = -(<span class="number">1.0</span>/m)*np.sum(logprobs)</div><div class="line">    <span class="comment">### END CODE HERE ###</span></div><div class="line"></div><div class="line">    cost = np.squeeze(cost)     <span class="comment"># makes sure cost is the dimension we expect. </span></div><div class="line">                                <span class="comment"># E.g., turns [[17]] into 17 </span></div><div class="line">    <span class="keyword">assert</span>(isinstance(cost, float))</div><div class="line"></div><div class="line">    <span class="keyword">return</span> cost</div><div class="line">A2, Y_assess, parameters = compute_cost_test_case()</div><div class="line"></div><div class="line">print(<span class="string">"cost = "</span> + str(compute_cost(A2, Y_assess, parameters)))</div></pre></td></tr></table></figure>
<pre><code>cost = 0.692919893776
</code></pre><p>​    </p>
<h3 id="后向传播计算梯度">6.2.3. 后向传播计算梯度</h3><p>Using the cache computed during forward propagation, you can now implement backward propagation.</p>
<p><strong>Question</strong>: Implement the function <code>backward_propagation()</code>.</p>
<p><strong>Instructions</strong>:<br>Backpropagation is usually the hardest (most mathematical) part in deep learning. To help you, here again is the slide from the lecture on backpropagation. You’ll want to use the six equations on the right of this slide, since you are building a vectorized implementation.  </p>
<p>$\frac{\partial \mathcal{J} }{ \partial z_{2}^{(i)} } = \frac{1}{m} (a^{<a href="i">2</a>} - y^{(i)})$</p>
<p>$\frac{\partial \mathcal{J} }{ \partial W_2 } = \frac{\partial \mathcal{J} }{ \partial z_{2}^{(i)} } a^{[1] (i) T} $</p>
<p>$\frac{\partial \mathcal{J} }{ \partial b_2 } = \sum_i{\frac{\partial \mathcal{J} }{ \partial z_{2}^{(i)}}}$</p>
<p>$\frac{\partial \mathcal{J} }{ \partial z_{1}^{(i)} } =  W_2^T \frac{\partial \mathcal{J} }{ \partial z_{2}^{(i)} } * ( 1 - a^{[1] (i) 2}) $</p>
<p>$\frac{\partial \mathcal{J} }{ \partial W_1 } = \frac{\partial \mathcal{J} }{ \partial z_{1}^{(i)} }  X^T $</p>
<p>$\frac{\partial \mathcal{J} _i }{ \partial b_1 } = \sum_i{\frac{\partial \mathcal{J} }{ \partial z_{1}^{(i)}}}$</p>
<ul>
<li>Note that $*$ denotes elementwise multiplication.</li>
<li>The notation you will use is common in deep learning coding:<ul>
<li>dW1 = $\frac{\partial \mathcal{J} }{ \partial W_1 }$</li>
<li>db1 = $\frac{\partial \mathcal{J} }{ \partial b_1 }$</li>
<li>dW2 = $\frac{\partial \mathcal{J} }{ \partial W_2 }$</li>
<li>db2 = $\frac{\partial \mathcal{J} }{ \partial b_2 }$</li>
</ul>
</li>
</ul>
<ul>
<li>Tips:<ul>
<li>To compute dZ1 you’ll need to compute $g^{[1]’}(Z^{[1]})$. Since $g^{[1]}(.)$ is the tanh activation function, if $a = g^{[1]}(z)$ then $g^{[1]’}(z) = 1-a^2$. So you can compute<br>$g^{[1]’}(Z^{[1]})$ using <code>(1 - np.power(A1, 2))</code>.</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># GRADED FUNCTION: backward_propagation</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">backward_propagation</span><span class="params">(parameters, cache, X, Y)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Implement the backward propagation using the instructions above.</div><div class="line"></div><div class="line">    Arguments:</div><div class="line">    parameters -- python dictionary containing our parameters </div><div class="line">    cache -- a dictionary containing "Z1", "A1", "Z2" and "A2".</div><div class="line">    X -- input data of shape (2, number of examples)</div><div class="line">    Y -- "true" labels vector of shape (1, number of examples)</div><div class="line"></div><div class="line">    Returns:</div><div class="line">    grads -- python dictionary containing your gradients with respect to different parameters</div><div class="line">    """</div><div class="line">    m = X.shape[<span class="number">1</span>]</div><div class="line"></div><div class="line">    <span class="comment"># First, retrieve W1 and W2 from the dictionary "parameters".</span></div><div class="line">    <span class="comment"># 获取参数</span></div><div class="line">    W1 = parameters[<span class="string">"W1"</span>]</div><div class="line">    W2 = parameters[<span class="string">"W2"</span>]</div><div class="line"></div><div class="line">    A1 = cache[<span class="string">"A1"</span>]</div><div class="line">    A2 = cache[<span class="string">"A2"</span>]</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment"># Backward propagation: calculate dW1, db1, dW2, db2. </span></div><div class="line">    <span class="comment"># 后向传播</span></div><div class="line">    dZ2 = A2 - Y</div><div class="line">    dW2 = <span class="number">1.0</span>/m*np.dot(dZ2, A1.T)</div><div class="line">    db2 = <span class="number">1.0</span>/m*np.sum(dZ2, axis=<span class="number">1</span>, keepdims=<span class="keyword">True</span>)</div><div class="line">    dZ1 = np.dot(W2.T, dZ2)*(<span class="number">1</span>-np.power(A1, <span class="number">2</span>))</div><div class="line">    dW1 = <span class="number">1.0</span>/m*np.dot(dZ1, X.T)</div><div class="line">    db1 = <span class="number">1.0</span>/m*np.sum(dZ1, axis=<span class="number">1</span>, keepdims=<span class="keyword">True</span>)</div><div class="line"></div><div class="line"></div><div class="line">    grads = &#123;<span class="string">"dW1"</span>: dW1,</div><div class="line">             <span class="string">"db1"</span>: db1,</div><div class="line">             <span class="string">"dW2"</span>: dW2,</div><div class="line">             <span class="string">"db2"</span>: db2&#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> grads</div><div class="line"></div><div class="line">parameters, cache, X_assess, Y_assess = backward_propagation_test_case()</div><div class="line"></div><div class="line">grads = backward_propagation(parameters, cache, X_assess, Y_assess)</div><div class="line"><span class="keyword">print</span> (<span class="string">"dW1 = "</span>+ str(grads[<span class="string">"dW1"</span>]))</div><div class="line"><span class="keyword">print</span> (<span class="string">"db1 = "</span>+ str(grads[<span class="string">"db1"</span>]))</div><div class="line"><span class="keyword">print</span> (<span class="string">"dW2 = "</span>+ str(grads[<span class="string">"dW2"</span>]))</div><div class="line"><span class="keyword">print</span> (<span class="string">"db2 = "</span>+ str(grads[<span class="string">"db2"</span>]))</div></pre></td></tr></table></figure>
<pre><code>dW1 = [[ 0.01018708 -0.00708701]
 [ 0.00873447 -0.0060768 ]
 [-0.00530847  0.00369379]
 [-0.02206365  0.01535126]]
db1 = [[-0.00069728]
 [-0.00060606]
 [ 0.000364  ]
 [ 0.00151207]]
dW2 = [[ 0.00363613  0.03153604  0.01162914 -0.01318316]]
db2 = [[ 0.06589489]]
</code></pre><h3 id="更新参数">6.2.4. 更新参数</h3><p><strong>Question</strong>: Implement the update rule. Use gradient descent. You have to use (dW1, db1, dW2, db2) in order to update (W1, b1, W2, b2).</p>
<p><strong>General gradient descent rule</strong>: $ \theta = \theta - \alpha \frac{\partial J }{ \partial \theta }$ where $\alpha$ is the learning rate and $\theta$ represents a parameter.</p>
<p><strong>Illustration</strong>: The gradient descent algorithm with a good learning rate (converging) and a bad learning rate (diverging). Images courtesy of Adam Harley.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># GRADED FUNCTION: update_parameters</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_parameters</span><span class="params">(parameters, grads, learning_rate = <span class="number">1.2</span>)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Updates parameters using the gradient descent update rule given above</div><div class="line">    </div><div class="line">    Arguments:</div><div class="line">    parameters -- python dictionary containing your parameters </div><div class="line">    grads -- python dictionary containing your gradients </div><div class="line">    </div><div class="line">    Returns:</div><div class="line">    parameters -- python dictionary containing your updated parameters </div><div class="line">    """</div><div class="line">    <span class="comment"># Retrieve each parameter from the dictionary "parameters"</span></div><div class="line">    <span class="comment"># 获取参数</span></div><div class="line">    W1 = parameters[<span class="string">"W1"</span>]</div><div class="line">    b1 = parameters[<span class="string">"b1"</span>]</div><div class="line">    W2 = parameters[<span class="string">"W2"</span>]</div><div class="line">    b2 = parameters[<span class="string">"b2"</span>]</div><div class="line"></div><div class="line">    </div><div class="line">    <span class="comment"># Retrieve each gradient from the dictionary "grads"</span></div><div class="line">    <span class="comment"># 获取梯度</span></div><div class="line">    dW1 = grads[<span class="string">"dW1"</span>]</div><div class="line">    db1 = grads[<span class="string">"db1"</span>]</div><div class="line">    dW2 = grads[<span class="string">"dW2"</span>]</div><div class="line">    db2 = grads[<span class="string">"db2"</span>]</div><div class="line"></div><div class="line">    </div><div class="line">    <span class="comment"># Update rule for each parameter</span></div><div class="line">    <span class="comment"># 根据梯度更新参数</span></div><div class="line">    W1 = W1 - learning_rate * dW1</div><div class="line">    b1 = b1 - learning_rate * db1</div><div class="line">    W2 = W2 - learning_rate * dW2</div><div class="line">    b2 = b2 - learning_rate * db2</div><div class="line">    </div><div class="line">    parameters = &#123;<span class="string">"W1"</span>: W1,</div><div class="line">                  <span class="string">"b1"</span>: b1,</div><div class="line">                  <span class="string">"W2"</span>: W2,</div><div class="line">                  <span class="string">"b2"</span>: b2&#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> parameters</div><div class="line"></div><div class="line">parameters, grads = update_parameters_test_case()</div><div class="line">parameters = update_parameters(parameters, grads)</div><div class="line"></div><div class="line">print(<span class="string">"W1 = "</span> + str(parameters[<span class="string">"W1"</span>]))</div><div class="line">print(<span class="string">"b1 = "</span> + str(parameters[<span class="string">"b1"</span>]))</div><div class="line">print(<span class="string">"W2 = "</span> + str(parameters[<span class="string">"W2"</span>]))</div><div class="line">print(<span class="string">"b2 = "</span> + str(parameters[<span class="string">"b2"</span>]))</div></pre></td></tr></table></figure>
<pre><code>W1 = [[-0.00643025  0.01936718]
 [-0.02410458  0.03978052]
 [-0.01653973 -0.02096177]
 [ 0.01046864 -0.05990141]]
b1 = [[ -1.02420756e-06]
 [  1.27373948e-05]
 [  8.32996807e-07]
 [ -3.20136836e-06]]
W2 = [[-0.01041081 -0.04463285  0.01758031  0.04747113]]
b2 = [[ 0.00010457]]
</code></pre><h3 id="将前面三步合在一起">6.2.5. 将前面三步合在一起</h3><p><strong>Question</strong>: Build your neural network model in <code>nn_model()</code>.</p>
<p><strong>Instructions</strong>: The neural network model has to use the previous functions in the right order.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># GRADED FUNCTION: nn_model</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">nn_model</span><span class="params">(X, Y, n_h, num_iterations = <span class="number">10000</span>, print_cost=False)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Arguments:</div><div class="line">    X -- dataset of shape (2, number of examples)</div><div class="line">    Y -- labels of shape (1, number of examples)</div><div class="line">    n_h -- size of the hidden layer</div><div class="line">    num_iterations -- Number of iterations in gradient descent loop</div><div class="line">    print_cost -- if True, print the cost every 1000 iterations</div><div class="line"></div><div class="line">    Returns:</div><div class="line">    parameters -- parameters learnt by the model. They can then be used to predict.</div><div class="line">    """</div><div class="line"></div><div class="line">    np.random.seed(<span class="number">3</span>)</div><div class="line">    n_x = layer_sizes(X, Y)[<span class="number">0</span>]</div><div class="line">    n_y = layer_sizes(X, Y)[<span class="number">2</span>]</div><div class="line"></div><div class="line">    <span class="comment"># Initialize parameters, then retrieve W1, b1, W2, b2. Inputs: "n_x, n_h, n_y". Outputs = "W1, b1, W2, b2, parameters".</span></div><div class="line">    <span class="comment"># 获取初始化参数</span></div><div class="line">    parameters = initialize_parameters(n_x, n_h, n_y)</div><div class="line">    W1 = parameters[<span class="string">"W1"</span>]</div><div class="line">    b1 = parameters[<span class="string">"b1"</span>]</div><div class="line">    W2 = parameters[<span class="string">"W2"</span>]</div><div class="line">    b2 = parameters[<span class="string">"b2"</span>]</div><div class="line"></div><div class="line">    <span class="comment"># Loop (gradient descent)</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, num_iterations):</div><div class="line"></div><div class="line">        <span class="comment"># Forward propagation. Inputs: "X, parameters". Outputs: "A2, cache".</span></div><div class="line">        <span class="comment"># 前向传播计算预测值</span></div><div class="line">        A2, cache = forward_propagation(X, parameters)</div><div class="line"></div><div class="line">        <span class="comment"># Cost function. Inputs: "A2, Y, parameters". Outputs: "cost".</span></div><div class="line">        <span class="comment"># 计算误差</span></div><div class="line">        cost = compute_cost(A2, Y, parameters)</div><div class="line"></div><div class="line">        <span class="comment"># Backpropagation. Inputs: "parameters, cache, X, Y". Outputs: "grads".</span></div><div class="line">        <span class="comment"># 后向传播计算梯度</span></div><div class="line">        grads = backward_propagation(parameters, cache, X, Y)</div><div class="line"></div><div class="line">        <span class="comment"># Gradient descent parameter update. Inputs: "parameters, grads". Outputs: "parameters".</span></div><div class="line">        <span class="comment"># 根据梯度更新参数</span></div><div class="line">        parameters = update_parameters(parameters, grads)</div><div class="line"></div><div class="line">        <span class="comment"># Print the cost every 1000 iterations</span></div><div class="line">        <span class="keyword">if</span> print_cost <span class="keyword">and</span> i % <span class="number">1000</span> == <span class="number">0</span>:</div><div class="line">            <span class="keyword">print</span> (<span class="string">"Cost after iteration %i: %f"</span> %(i, cost))</div><div class="line"></div><div class="line">    <span class="keyword">return</span> parameters</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">nn_model_test_case</span><span class="params">()</span>:</span></div><div class="line">    np.random.seed(<span class="number">1</span>)</div><div class="line">    X_assess = np.random.randn(<span class="number">2</span>, <span class="number">3</span>)</div><div class="line">    Y_assess = np.random.randn(<span class="number">1</span>, <span class="number">3</span>)</div><div class="line">    <span class="keyword">return</span> X_assess, Y_assess</div><div class="line"></div><div class="line">X_assess, Y_assess = nn_model_test_case()</div><div class="line"><span class="keyword">print</span> X_assess</div><div class="line"><span class="keyword">print</span> Y_assess</div><div class="line">parameters = nn_model(X_assess, Y_assess, <span class="number">4</span>, num_iterations=<span class="number">10000</span>, print_cost=<span class="keyword">True</span>)</div><div class="line">print(<span class="string">"W1 = "</span> + str(parameters[<span class="string">"W1"</span>]))</div><div class="line">print(<span class="string">"b1 = "</span> + str(parameters[<span class="string">"b1"</span>]))</div><div class="line">print(<span class="string">"W2 = "</span> + str(parameters[<span class="string">"W2"</span>]))</div><div class="line">print(<span class="string">"b2 = "</span> + str(parameters[<span class="string">"b2"</span>]))</div></pre></td></tr></table></figure>
<pre><code>[[ 1.62434536 -0.61175641 -0.52817175]
 [-1.07296862  0.86540763 -2.3015387 ]]
[[ 1.74481176 -0.7612069   0.3190391 ]]
Cost after iteration 0: -0.734104
Cost after iteration 1000: -inf
Cost after iteration 2000: -inf
Cost after iteration 3000: -inf
Cost after iteration 4000: -inf
Cost after iteration 5000: -inf
Cost after iteration 6000: -inf
Cost after iteration 7000: -inf
Cost after iteration 8000: -inf
Cost after iteration 9000: -inf
W1 = [[-7.53845806  1.20775367]
 [-4.25271792  5.29708473]
 [-7.53823957  1.20769882]
 [ 4.1479613  -5.35960029]]
b1 = [[ 3.81060333]
 [ 2.31388695]
 [ 3.81043858]
 [-2.32850837]]
W2 = [[-6012.41560745 -6036.77027646 -6010.58554698  6038.039225  ]]
b2 = [[-53.79862878]]
</code></pre><h3 id="预测">6.2.6. 预测</h3><p><strong>Question</strong>: Use your model to predict by building predict().<br>Use forward propagation to predict results.</p>
<p><strong>Reminder</strong>: predictions = $y_{prediction} = \mathbb 1 (\text{ if activation &gt; 0.5}) $  </p>
<p>As an example, if you would like to set the entries of a matrix X to 0 and 1 based on a threshold you would do: <figure class="highlight plain"><figcaption><span>= (X > threshold)```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">```python</div><div class="line"># GRADED FUNCTION: predict</div><div class="line"></div><div class="line">def predict(parameters, X):</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    Using the learned parameters, predicts a class for each example in X</div><div class="line"></div><div class="line">    Arguments:</div><div class="line">    parameters -- python dictionary containing your parameters </div><div class="line">    X -- input data of size (n_x, m)</div><div class="line"></div><div class="line">    Returns</div><div class="line">    predictions -- vector of predictions of our model (red: 0 / blue: 1)</div><div class="line">    &quot;&quot;&quot;</div><div class="line"></div><div class="line">    # Computes probabilities using forward propagation, and classifies to 0/1 using 0.5 as the threshold.</div><div class="line">    ### START CODE HERE ### (≈ 2 lines of code)</div><div class="line">    A2, cache = forward_propagation(X, parameters)</div><div class="line">    predictions = (A2 &gt; 0.5)</div><div class="line">    ### END CODE HERE ###</div><div class="line"></div><div class="line">    return predictions</div><div class="line"></div><div class="line"></div><div class="line">parameters, X_assess = predict_test_case()</div><div class="line"></div><div class="line">predictions = predict(parameters, X_assess)</div><div class="line">print(&quot;predictions mean = &quot; + str(np.mean(predictions)))</div></pre></td></tr></table></figure></p>
<pre><code>predictions mean = 0.666666666667
</code></pre><p>​    </p>
<h1 id="应用模型">7. 应用模型</h1><p>将上面这个模型用在数据集上：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Build a model with a n_h-dimensional hidden layer</span></div><div class="line">parameters = nn_model(X, Y, n_h = <span class="number">4</span>, num_iterations = <span class="number">10000</span>, print_cost=<span class="keyword">True</span>)</div><div class="line"></div><div class="line"><span class="comment"># Plot the decision boundary</span></div><div class="line">plot_decision_boundary(<span class="keyword">lambda</span> x: predict(parameters, x.T), X, Y)</div><div class="line">plt.title(<span class="string">"Decision Boundary for hidden layer size "</span> + str(<span class="number">4</span>))</div><div class="line"></div><div class="line"><span class="comment"># Print accuracy</span></div><div class="line">predictions = predict(parameters, X)</div><div class="line"><span class="keyword">print</span> (<span class="string">'Accuracy: %d'</span> % float((np.dot(Y,predictions.T) + np.dot(<span class="number">1</span>-Y,<span class="number">1</span>-predictions.T))/float(Y.size)*<span class="number">100</span>) + <span class="string">'%'</span>)</div></pre></td></tr></table></figure>
<pre><code>Cost after iteration 0: 1.127380
Cost after iteration 1000: 0.288553
Cost after iteration 2000: 0.276386
Cost after iteration 3000: 0.268077
Cost after iteration 4000: 0.263069
Cost after iteration 5000: 0.259617
Cost after iteration 6000: 0.257070
Cost after iteration 7000: 0.255105
Cost after iteration 8000: 0.253534
Cost after iteration 9000: 0.252245
Accuracy: 91%
</code></pre><p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-05-21-57-06.png" alt=""> </p>
<h1 id="观测不同的隐藏层数对于模型的影响">8. 观测不同的隐藏层数对于模型的影响</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># This may take about 2 minutes to run</span></div><div class="line"></div><div class="line">plt.figure(figsize=(<span class="number">16</span>, <span class="number">32</span>))</div><div class="line">hidden_layer_sizes = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">20</span>, <span class="number">50</span>]</div><div class="line"><span class="keyword">for</span> i, n_h <span class="keyword">in</span> enumerate(hidden_layer_sizes):</div><div class="line">    plt.subplot(<span class="number">5</span>, <span class="number">2</span>, i+<span class="number">1</span>)</div><div class="line">    plt.title(<span class="string">'Hidden Layer of size %d'</span> % n_h)</div><div class="line">    parameters = nn_model(X, Y, n_h, num_iterations = <span class="number">5000</span>)</div><div class="line">    plot_decision_boundary(<span class="keyword">lambda</span> x: predict(parameters, x.T), X, Y)</div><div class="line">    predictions = predict(parameters, X)</div><div class="line">    accuracy = float((np.dot(Y,predictions.T) + np.dot(<span class="number">1</span>-Y,<span class="number">1</span>-predictions.T))/float(Y.size)*<span class="number">100</span>)</div><div class="line">    <span class="keyword">print</span> (<span class="string">"Accuracy for &#123;&#125; hidden units: &#123;&#125; %"</span>.format(n_h, accuracy))</div></pre></td></tr></table></figure>
<pre><code>Accuracy for 1 hidden units: 61.5 %
Accuracy for 2 hidden units: 70.5 %
Accuracy for 3 hidden units: 66.25 %
Accuracy for 4 hidden units: 90.75 %
Accuracy for 5 hidden units: 90.5 %
Accuracy for 20 hidden units: 92.0 %
Accuracy for 50 hidden units: 90.75 %
</code></pre><p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-05-21-57-24.png" alt=""> </p>
]]></content>
      
        <categories>
            
            <category> 深度学习算法 </category>
            
            <category> 神经网络 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[算法-链表]]></title>
      <url>/2017/12/04/%E7%AE%97%E6%B3%95-%E9%93%BE%E8%A1%A8/</url>
      <content type="html"><![CDATA[<h1 id="链表">1. 链表</h1><p><strong>链表考点</strong></p>
<ul>
<li>会不会写程序 - 类、指针、引用等</li>
</ul>
<p><strong>知识点</strong></p>
<ul>
<li>链表中的Dummy Node</li>
<li>基本链表技能</li>
<li>链表的Two Pointers(Fast-slow pointers)</li>
</ul>
<p><strong>入门题</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</div><div class="line">  <span class="keyword">for</span>(ListNode node = head; node != <span class="keyword">null</span>; node = node.next)&#123;</div><div class="line">    System.out.print(node.val);</div><div class="line">    System.out.print(<span class="string">"-&gt;"</span>);</div><div class="line">  &#125;</div><div class="line">  System.out.println(<span class="string">"null"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">  ListNode node1 = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</div><div class="line">  ListNode node2 = <span class="keyword">new</span> ListNode(<span class="number">2</span>);</div><div class="line">  ListNode node3 = <span class="keyword">new</span> ListNode(<span class="number">3</span>);</div><div class="line">  </div><div class="line">  ListNode head = node1;</div><div class="line">  </div><div class="line">  node1.next = node2;</div><div class="line">  node2.next = node3;</div><div class="line">  </div><div class="line">  print(head); <span class="comment">// 输出啥？</span></div><div class="line">  </div><div class="line">  node1 = node2;</div><div class="line">  </div><div class="line">  print(head); <span class="comment">// 输出啥？</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>答案：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="keyword">null</span></div><div class="line"></div><div class="line"><span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="keyword">null</span></div></pre></td></tr></table></figure>
<p>思路：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">初始：</div><div class="line"></div><div class="line">  n1      n2        n3</div><div class="line">[<span class="number">1</span>,-]--&gt; [<span class="number">2</span>,-]--&gt; [<span class="number">3</span>,<span class="keyword">null</span>]</div><div class="line">===================================</div><div class="line">head = n1 : </div><div class="line"></div><div class="line"> head</div><div class="line">  n1      n2        n3</div><div class="line">[<span class="number">1</span>,-]--&gt; [<span class="number">2</span>,-]--&gt; [<span class="number">3</span>,<span class="keyword">null</span>]</div><div class="line"></div><div class="line">sizeof(head) = <span class="number">4</span> </div><div class="line">===================================</div><div class="line">n1 = n2 : </div><div class="line"></div><div class="line"> head     n1</div><div class="line">          n2        n3</div><div class="line">[<span class="number">1</span>,-]--&gt; [<span class="number">2</span>,-]--&gt; [<span class="number">3</span>,<span class="keyword">null</span>]</div></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="例题">2. 例题</h1><h2 id="例题1，Remove-Duplicates-from-Sorted-List">2.1. 例题1，Remove Duplicates from Sorted List</h2><p>将有序链表去重</p>
<h2 id="例题2，Remove-Duplicates-from-Sorted-List-II">2.2. 例题2，Remove Duplicates from Sorted List II</h2><p>将有序链表中的全部重复元素删除</p>
<p>思路：使用dummy node</p>
<p>当链表结构发生变化时，使用dummy node</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">套路：伪节点</div><div class="line"></div><div class="line"><span class="comment">// 伪节点</span></div><div class="line">          head</div><div class="line"> dummy     n1       n2         n3</div><div class="line"> [,-]--&gt; [<span class="number">1</span>,-]--&gt; [<span class="number">2</span>,-]--&gt; [<span class="number">3</span>,<span class="keyword">null</span>]</div><div class="line"></div><div class="line">ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">dummy.next = head;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">return</span> dummy.next;</div></pre></td></tr></table></figure>
<p>删除节点p方式：</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-04-20-24-02.png" alt=""> </p>
<p>开始写了！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">dummy.next = head;</div><div class="line"></div><div class="line"><span class="comment">// 前继节点和当前节点</span></div><div class="line">ListNode prev = dummy;</div><div class="line">ListNode curt = head;</div><div class="line"></div><div class="line"><span class="keyword">while</span>(<span class="keyword">null</span> != curt)&#123;</div><div class="line">  <span class="keyword">if</span>(<span class="keyword">null</span> != curt.next &amp;&amp; curt.val == curt.next.val)&#123;<span class="comment">// 如果重复了</span></div><div class="line">    <span class="keyword">int</span> val = curt.val;</div><div class="line">    <span class="keyword">while</span>(curt != <span class="keyword">null</span> &amp;&amp; curt.val == val)&#123;</div><div class="line">      curt = curt.next;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// curt == null or curt.val != val</span></div><div class="line">    prev.next = curt;</div><div class="line">  &#125;<span class="keyword">else</span>&#123; <span class="comment">// 如果不重复</span></div><div class="line">    prev = curt;</div><div class="line">    curt = curt.next;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> dummy.next; <span class="comment">// 这里需要注意一下</span></div></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(<span class="keyword">null</span> == head)<span class="keyword">return</span> head;</div><div class="line">  ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">  dummy.next = head;</div><div class="line"></div><div class="line">  ListNode prev = dummy;</div><div class="line">  ListNode curt = head;</div><div class="line">  <span class="keyword">while</span> (<span class="keyword">null</span> != curt)&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">null</span> != curt.next &amp;&amp; curt.val == curt.next.val)&#123;</div><div class="line">      <span class="keyword">int</span> temp = curt.val;</div><div class="line">      curt = curt.next;</div><div class="line">      <span class="keyword">while</span> (<span class="keyword">null</span> != curt &amp;&amp; curt.val == temp)&#123;</div><div class="line">        curt = curt.next;</div><div class="line">      &#125;</div><div class="line">      prev.next = curt;</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">      prev = curt;</div><div class="line">      curt = curt.next;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> dummy.next;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="例题，Remove-Linked-List-Elements">2.3. 例题，Remove Linked List Elements</h2><p>删除链表中的某个节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == head)<span class="keyword">return</span> head;</div><div class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        dummy.next = head;</div><div class="line"></div><div class="line">        ListNode prev = dummy;</div><div class="line">        ListNode curt = head;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != curt)&#123;</div><div class="line">            <span class="keyword">if</span>(curt.val == val)&#123;</div><div class="line">                curt = curt.next;</div><div class="line">                prev.next = curt;</div><div class="line">            &#125;<span class="keyword">else</span> &#123;</div><div class="line">                prev = curt;</div><div class="line">                curt = curt.next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dummy.next;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="例题3，Reverse-Linked-List">2.4. 例题3，Reverse Linked List</h2><p>将链表反转</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ListNode prev = <span class="keyword">null</span>;</div><div class="line">ListNode curt = head;</div><div class="line"></div><div class="line"><span class="keyword">while</span>( <span class="keyword">null</span> != curt)&#123;</div><div class="line">  ListNode temp = curt.next;</div><div class="line">  curt.next = prev;</div><div class="line">  prev = curt;</div><div class="line">  curt = temp;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">return</span> prev;</div></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(<span class="keyword">null</span> == head)&#123;<span class="keyword">return</span> head;&#125;</div><div class="line">  ListNode curt = head;</div><div class="line">  ListNode prev = <span class="keyword">null</span>;</div><div class="line">  ListNode temp;</div><div class="line">  <span class="keyword">while</span> (<span class="keyword">null</span> != curt)&#123;</div><div class="line">    temp = curt.next;</div><div class="line">    curt.next = prev;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">null</span> != temp) &#123;</div><div class="line">      prev = curt;</div><div class="line">      curt = temp;</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> curt; <span class="comment">// 如果这里返回prev的话就不用中间的判断temp是否为空了</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="例题4，Reverse-Linked-List-II">2.5. 例题4，Reverse Linked List II</h2><p>将一个链表的m到n反转</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">拆解问题</div><div class="line"></div><div class="line"><span class="number">1</span>. 寻找第m个点</div><div class="line"><span class="number">2</span>. 将m-n反转</div><div class="line"><span class="number">3</span>. 把整个链表连成一个链表！(如下图所示)</div></pre></td></tr></table></figure>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-04-22-53-44.png" alt=""> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(m &gt;= n || head == <span class="keyword">null</span>)&#123;</div><div class="line">  <span class="keyword">return</span> head;</div><div class="line">&#125;</div><div class="line"></div><div class="line">ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">dummy.next = head;</div><div class="line"></div><div class="line">ListNode prev = dummy;</div><div class="line"></div><div class="line"><span class="comment">//find m-th</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; m ; ++i)&#123;</div><div class="line"><span class="keyword">if</span>(<span class="keyword">null</span> == head)&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	&#125;<span class="keyword">else</span>&#123;</div><div class="line">	head = head.next;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">ListNode premNode = head;</div><div class="line"><span class="keyword">if</span>(<span class="keyword">null</span> == head)&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line">ListNode mNode = head.next;</div><div class="line"></div><div class="line"><span class="comment">// reverse m - n</span></div><div class="line">ListNode nNode = mNode, postnNode = mNode.next;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = m; i &lt; n; i++)&#123;</div><div class="line">  <span class="keyword">if</span>(<span class="keyword">null</span> == postnNode)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">  &#125;</div><div class="line">  ListNode temp = postnNode.next;</div><div class="line">  postnNODE.next = nNode;</div><div class="line">  nNode = postnNode;</div><div class="line">  postnNode = temp;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// connect m-1 -&gt; n, m - &gt; n+1</span></div><div class="line">mNode.next = postnNode;</div><div class="line">premNode.next = nNode;</div><div class="line"></div><div class="line"><span class="keyword">return</span> dummy.next;</div></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">  ListNode curt = head;</div><div class="line">  ListNode prev = <span class="keyword">null</span>;</div><div class="line">  <span class="comment">// find m</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; m ; ++i)&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">null</span> == curt.next) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    prev = curt;</div><div class="line">    curt = curt.next;</div><div class="line">  &#125;</div><div class="line">  ListNode mNodePrev = prev;</div><div class="line">  ListNode mNode = curt;</div><div class="line">  <span class="comment">// reverse m - n</span></div><div class="line">  ListNode next = curt.next;</div><div class="line">  n = n - m + <span class="number">1</span>;</div><div class="line">  <span class="keyword">while</span> (<span class="keyword">null</span> != curt &amp;&amp; n &gt; <span class="number">0</span>)&#123;</div><div class="line">    next = curt.next;</div><div class="line">    curt.next = prev;</div><div class="line">    prev = curt;</div><div class="line">    curt = next;</div><div class="line">    --n;</div><div class="line">  &#125;</div><div class="line">  ListNode nNode = prev;</div><div class="line">  mNode.next = next;</div><div class="line">  <span class="keyword">if</span>(<span class="keyword">null</span> == mNodePrev)&#123;</div><div class="line">    <span class="keyword">return</span> nNode;</div><div class="line">  &#125;</div><div class="line">  mNodePrev.next = nNode;</div><div class="line">  <span class="keyword">return</span> head;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="例题5，Reverse-Nodes-in-k-Group">2.6. 例题5，Reverse Nodes in k-Group</h2><p>将链表按照k大小的组，反转。如果最后不够k个，则保持原样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        dummy.next = head;</div><div class="line"></div><div class="line">        ListNode prev = dummy;</div><div class="line">        ListNode curt = head;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> c;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != curt) &#123;</div><div class="line">            c = k;</div><div class="line">            ListNode firstNodePrev = prev;</div><div class="line">            ListNode firstNode = curt;</div><div class="line">            <span class="keyword">if</span>(<span class="keyword">null</span> == curt) <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">while</span> (<span class="keyword">null</span> != curt &amp;&amp; c &gt; <span class="number">0</span>) &#123;</div><div class="line">                ListNode next = curt.next;</div><div class="line">                curt.next = prev;</div><div class="line">                prev = curt;</div><div class="line">                curt = next;</div><div class="line">                --c;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(c &gt; <span class="number">0</span>)&#123; <span class="comment">// 末尾保持原样</span></div><div class="line">                c = k - c;</div><div class="line">                <span class="keyword">while</span> (c &gt; <span class="number">0</span>)&#123;</div><div class="line">                    ListNode last = prev.next;</div><div class="line">                    prev.next = curt;</div><div class="line">                    curt = prev;</div><div class="line">                    prev = last;</div><div class="line">                    --c;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> dummy.next;</div><div class="line">            &#125;</div><div class="line">            firstNodePrev.next = prev;</div><div class="line">            firstNode.next = curt;</div><div class="line"></div><div class="line">            prev = firstNode;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dummy.next;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="例题6，Partition-List">2.7. 例题6，Partition List</h2><p>要求把小于x的元素放到链表前面</p>
<p>思路：排两个队，小的一队，大的一队</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(<span class="keyword">null</span> == head)&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">ListNode leftDummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">ListNode rightDummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">ListNode left = leftDummy, right = rightDummy; <span class="comment">// 左右队伍的尾巴</span></div><div class="line"></div><div class="line"><span class="keyword">while</span>(<span class="keyword">null</span> != head)&#123;</div><div class="line">  <span class="keyword">if</span>(head.val &lt; x)&#123;</div><div class="line">    left.next = head;</div><div class="line">    left = head;</div><div class="line">  &#125;<span class="keyword">else</span>&#123;</div><div class="line">    right.next = head;</div><div class="line">    right = head;</div><div class="line">  &#125;</div><div class="line">  head = head.next;</div><div class="line">&#125;</div><div class="line"></div><div class="line">right.next = <span class="keyword">null</span>;</div><div class="line">left.next = rightDummy.next;</div><div class="line"><span class="keyword">return</span> leftDummy.next;</div><div class="line"></div><div class="line">代码：</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">partition</span><span class="params">(ListNode head, <span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        ListNode leftTail = <span class="keyword">new</span> ListNode(<span class="number">0</span>),</div><div class="line">                rightTail = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line"></div><div class="line">        ListNode leftHead = leftTail, rightHead = rightTail;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != head)&#123;</div><div class="line">            <span class="keyword">if</span>(head.val &lt; x)&#123;</div><div class="line">                leftTail.next = head;</div><div class="line">                leftTail = leftTail.next;</div><div class="line">            &#125;<span class="keyword">else</span> &#123;</div><div class="line">                rightTail.next = head;</div><div class="line">                rightTail = rightTail.next;</div><div class="line">            &#125;</div><div class="line">            head = head.next;</div><div class="line">        &#125;</div><div class="line">        rightTail.next = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">// 合并</span></div><div class="line">        leftTail.next = rightHead.next;</div><div class="line">        <span class="keyword">return</span> leftHead.next;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h1 id="Basic-Skills-in-Linked-List">3. Basic Skills in Linked List</h1><p>增、删、反转、合并、中点</p>
<h1 id="Fast-slow-Pointers问题">4. Fast-slow Pointers问题</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">链表中点的骚操作</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">getMiddle</span><span class="params">(ListNode head)</span></span>&#123;</div><div class="line">        ListNode slow = head;</div><div class="line">        ListNode fast = head.next;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != fast &amp;&amp; <span class="keyword">null</span> != fast.next)&#123;</div><div class="line">            fast = fast.next.next;</div><div class="line">            slow = slow.next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> slow;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>应用场景：</p>
<ol>
<li>链表中点</li>
<li>移除倒数第N个元素</li>
<li>Linked List Cycle I，II</li>
<li>Rotate List</li>
</ol>
<h2 id="例题7，Sort-List">4.1. 例题7，Sort List</h2><p>用O(nlogn)的时间和空间复杂度排序链表</p>
<p>思路：n log n的排序 - 快速排序、归并排序、堆排序</p>
<table>
<thead>
<tr>
<th>排序</th>
<th>快速排序</th>
<th>归并排序</th>
</tr>
</thead>
<tbody>
<tr>
<td>思路</td>
<td>先整体有序，后局部（左右有序）有序</td>
<td>先局部（左右有序）有序，后整体有序</td>
</tr>
<tr>
<td></td>
<td>不稳定排序（原来在前面的不一定还在前面）</td>
<td>稳定排序-同样的key保持原来的顺序</td>
</tr>
<tr>
<td>时间</td>
<td>$O(nlogn — O(n^2))$</td>
<td>$O(nlogn)$</td>
</tr>
<tr>
<td>空间</td>
<td>O(1)</td>
<td>数组上O(n)，链表上$O(1)$</td>
</tr>
</tbody>
</table>
<p>这道题可以用快排，但其实归并排序更好写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">关键点：怎么取中点？</div><div class="line"></div><div class="line">取中点骚操作：</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">findMiddle</span><span class="params">(ListNode head)</span></span>&#123;</div><div class="line">	ListNode slow = head, fast = head.next;</div><div class="line">	<span class="comment">// 当fast走完的时候，slow就是中点</span></div><div class="line">    <span class="keyword">while</span>(<span class="keyword">null</span> != fast &amp;&amp; <span class="keyword">null</span> != fast.next)&#123;</div><div class="line">    	fast = fast.next.next;</div><div class="line">    	slow = slow.next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> slow;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">合并：</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">merge</span><span class="params">(ListNode head1, ListNode head2)</span></span>&#123;</div><div class="line">	ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">	ListNode tail = dummy;</div><div class="line">    <span class="keyword">while</span>(<span class="keyword">null</span> != head1 &amp;&amp; <span class="keyword">null</span> != head2)&#123;</div><div class="line">    	<span class="keyword">if</span>(head1.val &lt; head2.val)&#123;</div><div class="line">          tail.next = head1;</div><div class="line">          head1 = head1.next;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">          tail.next = head2;</div><div class="line">          head2 = head2.next;</div><div class="line">        &#125;</div><div class="line">        tail = tail.next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">null</span> != head1)&#123;</div><div class="line">      tail.next = head1;</div><div class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">null</span> != head2)&#123;</div><div class="line">      tail.next = head2;</div><div class="line">      &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> dummy.next;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">主函数</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(<span class="keyword">null</span> != head || <span class="keyword">null</span> != head.next)&#123;</div><div class="line">    <span class="keyword">return</span> head;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 找中点</span></div><div class="line">  ListNode mid = findMiddle(head);</div><div class="line"></div><div class="line">  <span class="comment">// 分解问题</span></div><div class="line">  ListNode right = sortList(mid.next);</div><div class="line">  mid.next = <span class="keyword">null</span>;</div><div class="line">  ListNode left = sortList(head);</div><div class="line"></div><div class="line">  <span class="comment">// 合并问题</span></div><div class="line">  <span class="keyword">return</span> merge(left,right);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">getMiddle</span><span class="params">(ListNode head)</span></span>&#123;</div><div class="line">        ListNode slow = head;</div><div class="line">        ListNode fast = head.next;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != fast &amp;&amp; <span class="keyword">null</span> != fast.next)&#123;</div><div class="line">            slow = slow.next;</div><div class="line">            fast = fast.next.next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> slow;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">merge</span><span class="params">(ListNode right, ListNode left)</span></span>&#123;</div><div class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        ListNode head = dummy;</div><div class="line">        dummy.next = head;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != right &amp;&amp; <span class="keyword">null</span> != left)&#123;</div><div class="line">            <span class="keyword">if</span>(right.val &lt; left.val)&#123;</div><div class="line">                head.next = right;</div><div class="line">                right = right.next;</div><div class="line">            &#125;<span class="keyword">else</span> &#123;</div><div class="line">                head.next = left;</div><div class="line">                left = left.next;</div><div class="line">            &#125;</div><div class="line">            head = head.next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> != right)&#123;</div><div class="line">            head.next = right;</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">null</span> != left)&#123;</div><div class="line">            head.next = left;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dummy.next;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">        <span class="comment">//归并排序</span></div><div class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == head) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == head.next) <span class="keyword">return</span> head;</div><div class="line">        <span class="comment">// 获取中值</span></div><div class="line">        ListNode mid = getMiddle(head);</div><div class="line">        <span class="comment">// 分解问题</span></div><div class="line">        ListNode right = sortList(mid.next);</div><div class="line">        mid.next = <span class="keyword">null</span>;</div><div class="line">        ListNode left = sortList(head);</div><div class="line">        <span class="comment">// 合并</span></div><div class="line">        <span class="keyword">return</span> merge(left,right);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="例题8，Reorder-List">4.2. 例题8，Reorder List</h2><p>将链表 <em>L</em>0→<em>L</em>1→…→<em>L</em>n-1→<em>L</em>n,  重排序为<em>L</em>0→<em>L**n</em>→<em>L</em>1→<em>L**n</em>-1→<em>L</em>2→<em>L**n</em>-2→…</p>
<p>思路：</p>
<ol>
<li>找中点</li>
<li>中点右半部分reverse</li>
<li>合并</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">getMiddle</span><span class="params">(ListNode head)</span></span>&#123;</div><div class="line">        ListNode slow = head;</div><div class="line">        ListNode fast = head.next;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != fast &amp;&amp; <span class="keyword">null</span> != fast.next)&#123;</div><div class="line">            fast = fast.next.next;</div><div class="line">            slow = slow.next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> slow;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span></span>&#123;</div><div class="line">        ListNode last = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != head)&#123;</div><div class="line">            ListNode temp = head.next;</div><div class="line">            head.next = last;</div><div class="line">            last = head;</div><div class="line">            head = temp;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> last;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == head || <span class="keyword">null</span> == head.next) <span class="keyword">return</span>;</div><div class="line">        <span class="comment">// 找中点</span></div><div class="line">        ListNode mid = getMiddle(head);</div><div class="line">        <span class="comment">// 反转 mid - end</span></div><div class="line">        ListNode right = reverse(mid.next);</div><div class="line">        mid.next = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">// 合并</span></div><div class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        dummy.next = head;</div><div class="line">        <span class="keyword">boolean</span> fromRight = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != head &amp;&amp; <span class="keyword">null</span> != right) &#123;</div><div class="line">            ListNode temp = head.next;</div><div class="line">            head.next = right;</div><div class="line">            right = right.next;</div><div class="line">            head.next.next = temp;</div><div class="line">            head = head.next.next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="例题9，Linked-List-Cycle">4.3. 例题9，Linked List Cycle</h2><p>判断链表里有没有环形</p>
<p>暴力方法：用hash表</p>
<p>骚操作：快指针和慢指针如果相遇了，就有环</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == head || <span class="keyword">null</span> == head.next) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        ListNode fast = head.next;</div><div class="line">        ListNode slow = head;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != fast &amp;&amp; <span class="keyword">null</span> != fast.next)&#123;</div><div class="line">            <span class="keyword">if</span>(fast == slow)&#123;<span class="keyword">return</span> <span class="keyword">true</span>;&#125;</div><div class="line">            fast = fast.next.next;</div><div class="line">            slow = slow.next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="例题10，Linked-List-Cycle-II">4.4. 例题10，Linked List Cycle II</h2><p>如果有环，找到环的入口</p>
<p>骚操作：快指针和慢指针如果相遇了，就有环。相遇之后，再让head和slow分别开始，每次走一步。相遇后一定是环入口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == head || <span class="keyword">null</span> == head.next) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        ListNode fast = head.next;</div><div class="line">        ListNode slow = head;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != fast &amp;&amp; <span class="keyword">null</span> != fast.next)&#123;</div><div class="line">            <span class="keyword">if</span>(fast == slow)&#123;</div><div class="line">                slow = slow.next;</div><div class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</div><div class="line">                    <span class="keyword">if</span>(slow == head)</div><div class="line">                        <span class="keyword">return</span> slow;</div><div class="line">                    slow = slow.next;</div><div class="line">                    head = head.next;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            fast = fast.next.next;</div><div class="line">            slow = slow.next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="例题11，Rotate-List">4.5. 例题11，Rotate List</h2><ol>
<li>循环移动</li>
<li>找到倒数第k个</li>
<li>断开连上就好</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">rotateRight</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">null</span> == head || <span class="keyword">null</span> == head.next) <span class="keyword">return</span> head;</div><div class="line">    <span class="keyword">int</span> n = getLength(head);</div><div class="line">    <span class="comment">// 寻找倒数第k个</span></div><div class="line">    k = k % n;</div><div class="line">    <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">return</span> head;</div><div class="line">    ListNode fast = head;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; k ; ++i)&#123;</div><div class="line">        fast = fast.next;</div><div class="line">    &#125;</div><div class="line">    ListNode slow = head;</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">null</span> != fast &amp;&amp; <span class="keyword">null</span> != fast.next)&#123;</div><div class="line">        slow = slow.next;</div><div class="line">        fast = fast.next;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 注意这里的技巧，此时fast = tail</span></div><div class="line">    ListNode right = slow.next;</div><div class="line">    slow.next = <span class="keyword">null</span>;</div><div class="line">    fast.next = head;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> right;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="例题12，Merge-k-Sorted-Lists">4.6. 例题12，Merge k Sorted Lists</h2><p>三种方法：</p>
<ol>
<li><p>堆，维护当前每个list的head。复杂度$Nlogk$</p>
</li>
<li><p>分治法。复杂度$Nlogk$–每个数都经过$logk$ 次合并</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">         *</div><div class="line">        / \</div><div class="line">      /     *</div><div class="line">    /      / \</div><div class="line">  *       /   *</div><div class="line"> / \     /   / \ </div><div class="line"><span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>   <span class="number">5</span></div><div class="line"></div><div class="line">将两个 k/<span class="number">2</span> 的链表组，合并为一个链表 </div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(lists.length == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> mergeHelper(lists, <span class="number">0</span>, lists.length - <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">mergeHelper</span><span class="params">(ListNode[] lists, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(end == start) <span class="keyword">return</span> lists[start];</div><div class="line">        <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</div><div class="line">        ListNode left = mergeHelper(lists, start, mid);</div><div class="line">        ListNode right = mergeHelper(lists,mid + <span class="number">1</span>, end);</div><div class="line">        <span class="keyword">return</span> mergeTwoLists(left,right);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span></span>&#123;</div><div class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        ListNode tail = dummy;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != list1 &amp;&amp; <span class="keyword">null</span> != list2)&#123;</div><div class="line">            <span class="keyword">if</span>(list1.val &lt; list2.val)&#123;</div><div class="line">                tail.next = list1;</div><div class="line">                list1 = list1.next;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                tail.next = list2;</div><div class="line">                list2 = list2.next;</div><div class="line">            &#125;</div><div class="line">            tail = tail.next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> != list1)&#123;</div><div class="line">            tail.next = list1;</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">null</span> != list2)&#123;</div><div class="line">            tail.next = list2;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dummy.next;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>两两合并，复杂度$Nlogk$</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">         <span class="number">9</span></div><div class="line">       /  \</div><div class="line">      <span class="number">8</span>    \</div><div class="line">    /   \   \</div><div class="line">  <span class="number">6</span>       <span class="number">7</span>  \</div><div class="line"> / \     / \   \ </div><div class="line"><span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>   <span class="number">5</span></div><div class="line">           </div><div class="line">           </div><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(List&lt;ListNode&gt; lists)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(lists.size() == <span class="number">0</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">while</span>(lists.size() &gt; <span class="number">1</span>)&#123;</div><div class="line">    List&lt;ListNode&gt; new_lists = <span class="keyword">new</span> ArrayList&lt;ListNode&gt;();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + <span class="number">1</span> &lt; lists.size(); i += <span class="number">2</span>) &#123;</div><div class="line">                ListNode merged_list = merge(lists.get(i), lists.get(i+<span class="number">1</span>));</div><div class="line">                new_lists.add(merged_list);</div><div class="line">     &#125;</div><div class="line">    <span class="keyword">if</span> (lists.size() % <span class="number">2</span> == <span class="number">1</span>) &#123;</div><div class="line">      new_lists.add(lists.get(lists.size() - <span class="number">1</span>));</div><div class="line">    &#125;</div><div class="line">    lists = new_lists;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> lists.get(<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">merge</span><span class="params">(ListNode list1, ListNode list2)</span></span>&#123;</div><div class="line">  ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">  ListNode tail = dummy;</div><div class="line">  <span class="keyword">while</span>(list1 != <span class="keyword">null</span> &amp;&amp; list2 != <span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">if</span>(list1.val &lt; list2.val)&#123;</div><div class="line">      tail.next = list1;</div><div class="line">      tail = list1;</div><div class="line">      list1 = list1.next;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">      tail.next = list2;</div><div class="line">      tail = list2;</div><div class="line">      list2 = list2.next;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (list1 != <span class="keyword">null</span>) &#123;</div><div class="line">            tail.next = list1;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    tail.next = list2;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> dummy.next;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="例题13，Copy-List-with-Random-Pointer">4.7. 例题13，Copy List with Random Pointer</h2><p>​</p>
<p><code>1 -&gt; 2 -&gt; 3 -&gt; 4...</code></p>
<p>然后每个点都有一个random指针，随机指</p>
<p>要求将这个random list 深拷贝一次</p>
<p>方法一，依次拷贝node.next,用一个哈希表存储每个[oldNode,newNode]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<p>方法二，骚操作，优化，用O(1)的空间复杂度</p>
<p>刚才我们存储的是映射关系，老节点-&gt;新节点，用巧妙的方式存储这个关系</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">3</span> -&gt; <span class="number">4</span> -&gt; <span class="keyword">null</span></div><div class="line"></div><div class="line">变成</div><div class="line">  </div><div class="line"><span class="number">1</span> -&gt; <span class="number">1</span>` -&gt; <span class="number">2</span> -&gt; <span class="number">2</span>` -&gt; <span class="number">3</span> -&gt; <span class="number">3</span>` -&gt; <span class="number">4</span> -&gt; <span class="number">4</span>` -&gt; <span class="keyword">null</span></div><div class="line">  </div><div class="line">a.next.next --&gt;保留了原来链表的关系</div><div class="line">a.next      --&gt;新的链表</div><div class="line"></div><div class="line">那么如果链表中有random指针，如下</div><div class="line"></div><div class="line">__            __________</div><div class="line">↑↓           ↑          ↓</div><div class="line"><span class="number">1</span>  -&gt;  <span class="number">1</span>` -&gt; <span class="number">2</span> -&gt; <span class="number">2</span>` -&gt; <span class="number">3</span> -&gt; <span class="number">3</span>` -&gt; <span class="number">4</span> -&gt; <span class="number">4</span>` -&gt; <span class="keyword">null</span></div><div class="line">  </div><div class="line">那么复制这个random关系即可！！</div><div class="line"></div><div class="line">然后再把这个链表拆开即可！</div><div class="line"></div><div class="line">总结：</div><div class="line"><span class="number">1</span>. copy next</div><div class="line"><span class="number">2</span>. copy random</div><div class="line"><span class="number">3</span>. split</div><div class="line"></div><div class="line">代码：</div><div class="line"><span class="function"><span class="keyword">public</span> RandomListNode <span class="title">copyRandomList</span><span class="params">(RandomListNode head)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == head) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        <span class="comment">// copy next</span></div><div class="line">        RandomListNode curr = head;</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != curr)&#123;</div><div class="line">            RandomListNode copy = <span class="keyword">new</span> RandomListNode(curr.label);</div><div class="line">            copy.next = curr.next;</div><div class="line">            curr.next = copy;</div><div class="line">            curr = curr.next.next;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// copy random</span></div><div class="line">        curr = head;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != curr)&#123;</div><div class="line">            <span class="keyword">if</span>(curr.random != <span class="keyword">null</span>)&#123;</div><div class="line">                curr.next.random = curr.random.next;</div><div class="line">            &#125;</div><div class="line">            curr = curr.next.next;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// split</span></div><div class="line">        RandomListNode dummy = head.next;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != head)&#123;</div><div class="line">            RandomListNode temp = head.next;</div><div class="line">            head.next = temp.next;</div><div class="line">            head = head.next;</div><div class="line">            <span class="keyword">if</span> (temp.next != <span class="keyword">null</span>) &#123;</div><div class="line">                temp.next = temp.next.next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dummy;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Swap-Nodes-in-Pairs">4.8. Swap Nodes in Pairs</h2><p>将链表两两反转</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(ListNode obj,ListNode prev)</span></span>&#123;</div><div class="line">        prev.next = obj.next;</div><div class="line">        obj.next = prev.next.next;</div><div class="line">        prev.next.next = obj;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == head || <span class="keyword">null</span> == head.next) <span class="keyword">return</span> head;</div><div class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        dummy.next = head;</div><div class="line">        ListNode prev = dummy;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != head &amp;&amp; <span class="keyword">null</span> != head.next)&#123;</div><div class="line">            swap(head,prev);</div><div class="line">            head = head.next;</div><div class="line">            prev = prev.next.next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dummy.next;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="Delete-Node-in-a-Linked-List">4.9. Delete Node in a Linked List</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(node != <span class="keyword">null</span> &amp;&amp; node.next != <span class="keyword">null</span>) &#123;</div><div class="line">            node.val = node.next.val;</div><div class="line">            node.next = node.next.next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="Palindrome-Linked-List">4.10. Palindrome Linked List</h2><p>判断一个list是不是回文串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">getMiddle</span><span class="params">(ListNode head)</span></span>&#123;</div><div class="line">    ListNode fast = head.next;</div><div class="line">    ListNode slow = head;</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">null</span> != fast &amp;&amp; <span class="keyword">null</span> != fast.next)&#123;</div><div class="line">        fast = fast.next.next;</div><div class="line">        slow = slow.next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> slow;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span></span>&#123;</div><div class="line">    ListNode last = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">null</span> != head)&#123;</div><div class="line">        ListNode temp = head.next;</div><div class="line">        head.next = last;</div><div class="line">        last = head;</div><div class="line">        head = temp;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> last;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">null</span> == head || <span class="keyword">null</span> == head.next) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="comment">// 找中点</span></div><div class="line">    ListNode middle = getMiddle(head);</div><div class="line">    ListNode right = middle.next;</div><div class="line">    middle.next = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">// 将right反转</span></div><div class="line">    right = reverse(right);</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">null</span> != right &amp;&amp; <span class="keyword">null</span> != head &amp;&amp; right.val == head.val)&#123;</div><div class="line">        right = right.next;</div><div class="line">        head = head.next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>((<span class="keyword">null</span> == head &amp;&amp; <span class="keyword">null</span> == right)||</div><div class="line">            (<span class="keyword">null</span> == head.next &amp;&amp; <span class="keyword">null</span> == right)||</div><div class="line">            (<span class="keyword">null</span> == right.next &amp;&amp; <span class="keyword">null</span> == head))&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Odd-Even-Linked-List">4.11. Odd Even Linked List</h2><p>将链表的奇数位放前面，偶数位放后面</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">oddEvenList</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">null</span> == head || <span class="keyword">null</span> == head.next) <span class="keyword">return</span> head;</div><div class="line">    ListNode oddDummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">    ListNode evenDummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">    oddDummy.next = head;</div><div class="line">    evenDummy.next = head.next;</div><div class="line">    ListNode odd = head;</div><div class="line">    ListNode even = head.next;</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">null</span> != even &amp;&amp; <span class="keyword">null</span> != even.next)&#123;</div><div class="line">        odd.next = even.next;</div><div class="line">        even.next = odd.next.next;</div><div class="line">        odd = odd.next;</div><div class="line">        even = even.next;</div><div class="line">    &#125;</div><div class="line">    odd.next = evenDummy.next;</div><div class="line">    <span class="keyword">return</span> oddDummy.next;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Split-Linked-List-in-Parts">4.12. Split Linked List in Parts</h2><p>很无聊的题。</p>
<p>将一个链表分为k个部分，每个部分的长度差不得超过1，且前面的长度不得小于后面的长度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(ListNode root)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> length = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">null</span> != root)&#123;</div><div class="line">        root = root.next;</div><div class="line">        ++length;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> length;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> ListNode[] splitListToParts(ListNode root, <span class="keyword">int</span> k) &#123;</div><div class="line">    <span class="keyword">int</span> length = getLength(root);</div><div class="line">    <span class="keyword">int</span> n = length/k;</div><div class="line">    <span class="keyword">int</span> m = length % k;</div><div class="line">    ListNode[] results = <span class="keyword">new</span> ListNode[k];</div><div class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">null</span> != root)&#123;</div><div class="line">        <span class="keyword">int</span> i = m &gt; <span class="number">0</span> ? n : n - <span class="number">1</span>;</div><div class="line">        m-=<span class="number">1</span>;</div><div class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        dummy.next = root;</div><div class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>)&#123;</div><div class="line">            root = root.next;</div><div class="line">            --i;</div><div class="line">        &#125;</div><div class="line">        ListNode temp = root.next;</div><div class="line">        root.next = <span class="keyword">null</span>;</div><div class="line">        root = temp;</div><div class="line">        results[pos] = dummy.next;</div><div class="line">        ++pos;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (pos &lt; k)&#123;</div><div class="line">        results[pos] = <span class="keyword">null</span>;</div><div class="line">        ++pos;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> results;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Insertion-Sort-List">4.13. Insertion Sort List</h2><p>实现链表的插入排序 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">insertionSortList</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == head || <span class="keyword">null</span> == head.next) <span class="keyword">return</span> head;</div><div class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        dummy.next = head;</div><div class="line">        ListNode curt = head;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != curt &amp;&amp; <span class="keyword">null</span> != curt.next)&#123;</div><div class="line">            <span class="keyword">if</span>(curt.next.val &gt;= curt.val)&#123;</div><div class="line">                curt = curt.next;</div><div class="line">            &#125;<span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 将curt.next插入到前面</span></div><div class="line">                ListNode prev = dummy.next;</div><div class="line">                ListNode insert = curt.next;</div><div class="line">                <span class="keyword">if</span>(dummy.next.val &gt;= insert.val)</div><div class="line">                    prev = dummy;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">while</span> (prev.next.val &lt; insert.val) &#123;</div><div class="line">                        prev = prev.next;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 将curt.next插到prev后面</span></div><div class="line">                curt.next = curt.next.next;</div><div class="line">                ListNode prevNext = prev.next;</div><div class="line">                prev.next = insert;</div><div class="line">                insert.next = prevNext;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dummy.next;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h1 id="总结">5. 总结</h1><ul>
<li>凡是链表结构发生变化的，都需要Dummy Node</li>
<li>链表常用基本功：<ul>
<li>反转 reverse</li>
<li>归并 merge</li>
<li>找中点 median</li>
<li>增删查改</li>
</ul>
</li>
<li>Linked List Cycle , 知道怎么做，理解</li>
<li>Linked List Cycle II，知道怎么做，课后分析一下为什么，背下程序</li>
<li>Copy List with Random Pointers<ul>
<li>能写出hash map方法</li>
<li>优化方法要能正确实现</li>
</ul>
</li>
<li>Merge k Sorted Arrays<ul>
<li>k路归并一定要掌握</li>
<li>三种方式分别实现，并熟练理解和掌握</li>
<li>顺便做一下merge k sorted arrays</li>
</ul>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[算法-二叉树与分治]]></title>
      <url>/2017/11/28/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      <content type="html"><![CDATA[<p> 一些题目 implement of ….</p>
<h1 id="时间复杂度训练">1. 时间复杂度训练</h1><p>复习：</p>
<p>$$T(n) = T(\frac{n}{2}) + O(1) → O(logn)$$</p>
<p>$$T(n) = T(\frac{n}{2}) + O(n) → O(n)$$</p>
<p><strong> 问题1</strong></p>
<p>通过O(1)的时间,把n的问题,变为了两个n/2的问题,复杂度是多少?</p>
<p>$$T(n) = 2T(\frac{n}{2}) + O(1) → O(n)$$</p>
<p>解决：树型分析法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">           n</div><div class="line">       /      \      --&gt;  本次拆分耗费了O(<span class="number">1</span>)的时间</div><div class="line">     n/<span class="number">2</span>       n/<span class="number">2</span></div><div class="line">    / \        / \   --&gt;  本次拆分耗费了O(<span class="number">2</span>)的时间</div><div class="line">n/<span class="number">4</span>   n/<span class="number">4</span>   n/<span class="number">4</span>   n/<span class="number">4</span></div><div class="line">.....................</div><div class="line">         第k+<span class="number">1</span>层       --&gt;  本次拆分耗费了O(<span class="number">2</span>^k)的时间</div><div class="line">.....................  --&gt;  本次拆分耗费了O(n/<span class="number">2</span>)的时间</div></pre></td></tr></table></figure>
<p>总复杂度：</p>
<p>$$O(1+2+4+….+2^k+…+\frac{n}{2})\tag{1}$$</p>
<p>设$2^m = \frac{n}{2}$，则$m=log(\frac{n}{2})=logn-log2=logn$</p>
<p>则公式（1）等于：</p>
<p>$$O(2^0+2^1+2^2+….+2^{logn})$$</p>
<p>$$=O(\frac{a_1(1-q^n)}{1-q})=O(\frac{1-2^{logn}}{2-1})=O(n)\tag{结果}$$</p>
<a id="more"></a>
<p><strong>问题2</strong></p>
<p>$$T(n) = 2T(\frac{n}{2}) + O(n) =?$$</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">           n</div><div class="line">       /      \      --&gt;  本次拆分耗费了O(n)的时间</div><div class="line">     n/<span class="number">2</span>       n/<span class="number">2</span></div><div class="line">    / \        / \   --&gt;  本次拆分耗费了O(n)的时间</div><div class="line">n/<span class="number">4</span>   n/<span class="number">4</span>   n/<span class="number">4</span>   n/<span class="number">4</span></div><div class="line">.....................</div><div class="line">         第k+<span class="number">1</span>层       --&gt;  本次拆分耗费了O(n)的时间</div><div class="line">.....................  --&gt;  本次拆分耗费了O(n)的时间</div></pre></td></tr></table></figure>
<p>总复杂度：</p>
<p>$$O(n+n+…+n)—-logn次 = O(nlog(n))\tag{结果}$$</p>
<p>样例问题：mergeSort，就是这个复杂度！</p>
<h1 id="二叉树的遍历">2. 二叉树的遍历</h1><ul>
<li><strong>前序遍历</strong> - 先root</li>
<li><strong>中序遍历</strong>-中间是root</li>
<li><strong>后续遍历</strong>-最后root</li>
</ul>
<p>二叉树的三种遍历，均由根节点开始，且路线是一样的，只不过节点访问的顺序不一样 .这条路线从根节点开始，沿着左子树深入下去，当深入到最左端，无法再深入下去返回 </p>
<p>刚才深入时遇到的节点，再逐一进入其右子树，进行如此的深入和返回，直到最后从根 的右子树的返回根节点为止 </p>
<p>在这一过程中，返回节点的顺序和进入节点的顺序相反，因此即先进入后返回，这一特 性正好符合栈后进先出的特点，因此三种遍历的非递归实现可以借助栈来实现： 在沿着左子树深入时，进入一个节点就将其压栈。</p>
<p>若是先序遍历，则在进栈之前访问之， 当沿左分支深入不下去时，则返回，即从栈中弹出前面压入的节点。</p>
<p>若为中序遍历，则 此时访问该节点，然后从该节点的右子树继续深入；若为后序遍历，则将此节点二次入 栈，然后从该节点的右子树继续深入，与前面类似，仍为进入一个节点入栈一个节点， 深入不下去时返回，直到第二次从栈里弹出该节点，才访问之 </p>
<h1 id="非递归实现">3. 非递归实现</h1><h2 id="整体思路">3.1. 整体思路</h2><p>因为要在遍历完节点的左子树后接着遍历节点的右子树，为了能找到该节点，需要使用<strong>栈</strong>来进行暂存。中序和后序也都涉及到回溯，所以都需要用到<strong>栈</strong>。</p>
<p>三道题的解决思路可统一，模板也极其相似：</p>
<ol>
<li>将二叉树分为“左”（包括一路向左，经过的所有实际左+根）、“右”（包括实际的右）两种节点</li>
<li>使用同样的顺序将“左”节点入栈</li>
<li>从下到上，以此访问其的右子树，同时把右子树看成一颗完整的树，重复上面的步骤</li>
</ol>
<p>比如{1,2,3}，当cur位于节点1时，1、2属于“左”节点，3属于“右”节点。DFS的非递归实现本质上是在协调入栈、出栈和访问，三种操作的顺序。上述统一使得我们不再需要关注入栈顺序，仅需要关注出栈和访问（第3点），随着更详细的分析，你将更加体会到这种简化带来的好处。</p>
<p>针对上述逻辑我们可以抽象出一个遍历规则，如下图所示：</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-11-29-20-24-21.png" alt=""> </p>
<p>即上面说到的三个步骤！</p>
<ol>
<li>将二叉树分为“左”（包括一路向左，经过的所有实际左+根）、“右”（包括实际的右）两种节点</li>
<li>使用同样的顺序将“左”节点入栈</li>
<li>从下到上，以此访问其的右子树，同时把右子树看成一颗完整的树，重复上面的步骤</li>
</ol>
<h2 id="前序">3.2. 前序</h2><p>先序和中序的情况是极其相似的。</p>
<ul>
<li>先序的实际顺序：【根左】【右】</li>
<li>中序的实际顺序：【左根】【右】</li>
</ul>
<p>使用上述思路，先序和中序的遍历顺序可统一为：【“左”“右”】。</p>
<p>给我们的直观感觉是代码也会比较相似。实际情况正是如此，先序与中序的区别只在于对“左”节点的访问上。</p>
<p><strong>前序：</strong></p>
<p>不需要入栈，每次遍历到“左”节点，立即输出即可。</p>
<p>需要注意的是，遍历到最左下的节点时，实际上输出的已经不再是实际的根节点，而是实际的左节点。这符合先序的定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</div><div class="line">    results.add(cur.val);</div><div class="line">    stack.push(cur);</div><div class="line">    cur = cur.left;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而后，因为我们已经访问过所有“左”节点，现在只需要将这些没用的节点出栈，然后转向到“右”节点。于是“右”节点也变成了“左”节点，后续处理同上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!stack.empty()) &#123;</div><div class="line">    cur = stack.pop();</div><div class="line">    <span class="comment">// 把右子树作为一颗树，重复上面的步骤</span></div><div class="line">    cur = cur.right;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>完整代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> List&lt;Integer&gt; <span class="title">dfsPreOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">    List&lt;Integer&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line"></div><div class="line">    TreeNode cur = root;</div><div class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.empty()) &#123;</div><div class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</div><div class="line">            results.add(cur.val);</div><div class="line">            stack.push(cur);</div><div class="line">            cur = cur.left;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (!stack.empty()) &#123;</div><div class="line">            cur = stack.pop();</div><div class="line">            <span class="comment">// 把右子树作为一颗树，重复上面的步骤</span></div><div class="line">            cur = cur.right;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> results;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="中序">3.3. 中序</h2><p>基于对先序的分析，<strong>先序与中序的区别只在于对“左”节点的处理上</strong>，我们调整一行代码即可完成中序遍历。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</div><div class="line">    stack.push(cur);</div><div class="line">    cur = cur.left;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (!stack.empty()) &#123;</div><div class="line">    cur = stack.pop();</div><div class="line">    results.add(cur.val); <span class="comment">// 仅调整该行代码</span></div><div class="line">    <span class="comment">// 把右子树作为一颗树，重复上面的步骤</span></div><div class="line">    cur = cur.right;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意，我们在出栈之后才访问这个节点。因为先序先访问实际根，后访问实际左，而中序恰好相反。相同的是，访问完根+左子树（先序）或左子树+根（中序）后，都需要转向到“右”节点，使“右”节点称为新的“左”节点。</p>
<p>完整代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> List&lt;Integer&gt; <span class="title">dfsInOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">     List&lt;Integer&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">     Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</div><div class="line"></div><div class="line">     TreeNode cur = root;</div><div class="line">     <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.empty()) &#123;</div><div class="line">         <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</div><div class="line">             stack.push(cur);</div><div class="line">             cur = cur.left;</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">if</span> (!stack.empty()) &#123;</div><div class="line">             cur = stack.pop();</div><div class="line">             results.add(cur.val);</div><div class="line">             <span class="comment">// 把右子树作为一颗树，重复上面的步骤</span></div><div class="line">             cur = cur.right;</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> results;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h2 id="后序">3.4. 后序</h2><p>后序的情况略有不同，但仍然十分简洁。</p>
<ul>
<li>后序的实际顺序：左右根</li>
</ul>
<p>入栈顺序不变，我们只需要考虑第3点的变化。出栈的对象一定都是“左”节点（“右”节点会在转向后称为“左”节点，然后入栈），也就是实际的左或根；实际的左可以当做左右子树都为null的根，所以我们只需要分析实际的根。</p>
<p>对于实际的根，需要保证先后访问了左子树、右子树之后，才能访问根。实际的右节点、左节点、根节点都会成为“左”节点入栈，所以我们只需要<strong>在出栈之前，将该节点视作实际的根节点，并检查其右子树是否已被访问</strong>即可。如果不存在右子树，或右子树已被访问了，那么可以访问根节点，出栈，并不需要转向；如果还没有访问，就转向，使其“右”节点成为“左”节点，等着它先被访问之后，再来访问根节点。</p>
<p>所以，我们需要增加一个标志，记录右子树的访问情况。由于访问根节点前，一定先紧挨着访问了其右子树，所以我们只需要一个标志位。</p>
<p>完整代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        <span class="keyword">if</span>( <span class="keyword">null</span> == root ) <span class="keyword">return</span> result;</div><div class="line">        Stack&lt;TreeNode&gt; helper = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        HashSet&lt;TreeNode&gt; flag = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">        <span class="keyword">while</span> (!helper.empty() || <span class="keyword">null</span> != root)&#123;</div><div class="line">            <span class="keyword">if</span>(<span class="keyword">null</span> != root &amp;&amp; !flag.contains(root))&#123;</div><div class="line">                helper.push(root);</div><div class="line">                root = root.left;</div><div class="line">            &#125;<span class="keyword">else</span> &#123;</div><div class="line">                root = helper.peek();</div><div class="line">                <span class="keyword">if</span>(flag.contains(root))&#123;</div><div class="line">                    helper.pop();</div><div class="line">                    result.add(root.val);</div><div class="line">                    root = <span class="keyword">null</span>; <span class="comment">// 表示不需要转向，继续弹栈</span></div><div class="line">                &#125;<span class="keyword">else</span> &#123;</div><div class="line">                    flag.add(root);</div><div class="line">                    <span class="keyword">if</span>(<span class="keyword">null</span> != root.right)&#123;</div><div class="line">                        root = root.right;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h1 id="前序递归实现">4. 前序递归实现</h1><h2 id="实现1，递归">4.1. 实现1，递归</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//调用主函数</span></div><div class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">  ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">  traverse(root,result);</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="comment">//递归定义：把root为根的preorder加入到result里</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; result)</span></span>&#123;</div><div class="line">  <span class="comment">//停止条件</span></div><div class="line">  <span class="keyword">if</span>( root == <span class="keyword">null</span> )&#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//拆分问题</span></div><div class="line">  result.add(root.val);</div><div class="line">  traverse(root.left,result);</div><div class="line">  traverse(root.right,result);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">递归</div><div class="line"></div><div class="line">定义： 把root为根的preorder加入到result里</div><div class="line"></div><div class="line">拆分问题： 放root,放left,放right</div><div class="line"></div><div class="line">停止条件： root == <span class="keyword">null</span></div></pre></td></tr></table></figure>
<h2 id="实现2，分治">4.2. 实现2，分治</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">  ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">  <span class="comment">// null or leaf</span></div><div class="line">  <span class="keyword">if</span>( <span class="keyword">null</span> == root )&#123;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//分解问题</span></div><div class="line">  ArrayList&lt;Integer&gt; left = preorderTraversal(root.left);</div><div class="line">  ArrayList&lt;Integer&gt; right = preorderTraversal(root.right);</div><div class="line">  </div><div class="line">  <span class="comment">//合并问题</span></div><div class="line">  result.add(root.val);</div><div class="line">  result.addAll(left);</div><div class="line">  result.addAll(right);</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>递归可能爆栈！</p>
<h1 id="DFS">5. DFS</h1><p>DFS有两种实现方式：</p>
<ul>
<li>非递归</li>
<li>递归 – 有两种选择：<ul>
<li>分治</li>
<li>遍历</li>
</ul>
</li>
</ul>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-11-28-16-49-04.png" alt=""> </p>
<p><strong>碰到二叉树问题，就想想整棵树上在该问题上的结果是什么，左右儿子在该问题上的结果之间的联系是什么</strong></p>
<h2 id="Symmetric-Tree">5.1. Symmetric Tree</h2><p>验证一个二叉树是否是镜像的</p>
<p>思路就是分成两路探索，一路左边，一路右边。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(TreeNode leftBranch, TreeNode rightBranch)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(leftBranch == <span class="keyword">null</span> &amp;&amp; rightBranch == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">if</span>(leftBranch == <span class="keyword">null</span> || rightBranch == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">return</span> (leftBranch.val == rightBranch.val) &amp;&amp;</div><div class="line">            helper(leftBranch.left, rightBranch.right)&amp;&amp;</div><div class="line">            helper(leftBranch.right, rightBranch.left);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">return</span> helper(root.left, root.right);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Path-Sum">5.2. Path Sum</h2><p>给一个二叉树和一个target。求二叉树的某个路径和是否完全等于target。</p>
<p>基础题：Binary Tree Paths，可以考虑先做这个基础题，然后在做这些</p>
<p>思路：递归就好</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(TreeNode node, <span class="keyword">int</span> sum, <span class="keyword">int</span> target)</span></span>&#123;</div><div class="line">       <span class="keyword">if</span>(node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>) <span class="keyword">return</span> sum == target;</div><div class="line">       <span class="keyword">return</span> (node.left != <span class="keyword">null</span> &amp;&amp; helper(node.left, sum + node.left.val, target) ||</div><div class="line">               node.right != <span class="keyword">null</span> &amp;&amp; helper(node.right, sum + node.right.val, target));</div><div class="line"></div><div class="line">   &#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">       <span class="keyword">return</span> helper( root, root.val, target);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h2 id="Path-Sum-II">5.3. Path Sum II</h2><p>给一个二叉树和一个target。求二叉树的路径和完全等于target的所有路径</p>
<p>还是递归哇</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode node, <span class="keyword">int</span> sum, List&lt;Integer&gt; list, <span class="keyword">int</span> target)</span></span>&#123;</div><div class="line">      <span class="keyword">if</span>(node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>)&#123;</div><div class="line">          <span class="keyword">if</span>(sum == target)&#123;result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));&#125;</div><div class="line">          <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</div><div class="line">          list.add(node.left.val);</div><div class="line">          helper(node.left, sum + node.left.val, list, target);</div><div class="line">          list.remove(list.size() - <span class="number">1</span>);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</div><div class="line">          list.add(node.right.val);</div><div class="line">          helper(node.right, sum + node.right.val, list, target);</div><div class="line">          list.remove(list.size() - <span class="number">1</span>);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> target) &#123;</div><div class="line">      <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</div><div class="line">          List&lt;Integer&gt; lists = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</div><div class="line">          lists.add(root.val);</div><div class="line">          helper(root, root.val,lists , target);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> result;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h2 id="Path-Sum-III">5.4. Path Sum III</h2><p>给一个二叉树和一个target。求二叉树某点到其的某个子节点的和等于target的个数。</p>
<p>思路：其实这道题类似于单条路径上的这道题：560. Subarray Sum Equals K</p>
<p>在dfs时，存储当前节点<code>i</code>路径下的所有父节点<code>j</code>到root的和。那么<code>sum[i,j] = sum[i] - sum[j]</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> counter = <span class="number">0</span>;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode node, <span class="keyword">int</span>[] sums, <span class="keyword">int</span> level, <span class="keyword">int</span> target)</span></span>&#123;</div><div class="line">    <span class="comment">// 先检查本节点是否存在于上面节点的和==target的情况</span></div><div class="line">    <span class="keyword">if</span>(sums[level] == target) ++counter;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; level; ++i)&#123;</div><div class="line">        <span class="comment">// System.out.println(i + "\t" + (sums[level] - sums[i]));</span></div><div class="line">        <span class="keyword">if</span>(sums[level] - sums[i] == target) ++counter;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// sum存储从根节点到本节点，每个节点的到root的和</span></div><div class="line">    <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</div><div class="line">        sums[level + <span class="number">1</span>] = sums[level] + node.left.val;</div><div class="line">        helper(node.left, sums, level + <span class="number">1</span>, target);</div><div class="line">        sums[level + <span class="number">1</span>] = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</div><div class="line">        sums[level + <span class="number">1</span>] = sums[level] + node.right.val;</div><div class="line">        helper(node.right, sums, level + <span class="number">1</span>, target);</div><div class="line">        sums[level + <span class="number">1</span>] = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span>[] sums = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1001</span>];</div><div class="line">    sums[<span class="number">0</span>] = root.val;</div><div class="line">    helper(root, sums, <span class="number">0</span>, target );</div><div class="line">    <span class="keyword">return</span> counter;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>优化：所有和还可以用hash表存储！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> counter = <span class="number">0</span>;</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode node, HashMap&lt;Integer, Integer&gt; sums, <span class="keyword">int</span> lastSum, <span class="keyword">int</span> target)</span></span>&#123;</div><div class="line">      <span class="comment">// 检查与根节点</span></div><div class="line">      <span class="keyword">int</span> thisSum = lastSum + node.val;</div><div class="line">      <span class="keyword">if</span>(thisSum == target) ++counter;</div><div class="line">      <span class="comment">//检查与其它节点</span></div><div class="line">      <span class="keyword">if</span>(sums.containsKey(thisSum - target)) &#123;</div><div class="line">          counter += sums.get(thisSum - target);</div><div class="line">      &#125;</div><div class="line">      <span class="comment">//将本节点加入</span></div><div class="line">      <span class="keyword">if</span>(sums.containsKey(thisSum))&#123;</div><div class="line">          sums.replace(thisSum, sums.get(thisSum) + <span class="number">1</span>);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span> sums.put(thisSum, <span class="number">1</span>);</div><div class="line">      <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</div><div class="line">          helper(node.left, sums,thisSum, target);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</div><div class="line">          helper(node.right, sums, thisSum, target);</div><div class="line">      &#125;</div><div class="line">      <span class="comment">//将本节点挪出</span></div><div class="line">      <span class="keyword">if</span>(sums.get(thisSum) &gt; <span class="number">1</span>) sums.replace(thisSum, sums.get(thisSum) - <span class="number">1</span>);</div><div class="line">      <span class="keyword">else</span> sums.remove(thisSum);</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">      HashMap&lt;Integer, Integer&gt; sums = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">      helper(root, sums, <span class="number">0</span>, target );</div><div class="line">      <span class="keyword">return</span> counter;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h2 id="Trim-a-Binary-Search-Tree">5.5. Trim a Binary Search Tree</h2><p>修剪二叉树，使得值在<code>[L,R]</code> 之间。修剪时，优先保留左子树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">trimBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> root;</div><div class="line">        <span class="keyword">if</span>(root.val &gt;= L &amp;&amp; root.val &lt;= R)&#123;</div><div class="line">            root.left = trimBST(root.left, L, R);</div><div class="line">            root.right = trimBST(root.right, L, R);</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            TreeNode left = trimBST(root.left, L, R);</div><div class="line">            <span class="keyword">if</span>(<span class="keyword">null</span> != left) root = left;</div><div class="line">            <span class="keyword">else</span> root = trimBST(root.right, L, R);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> root;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h1 id="BFS相关例题">6. BFS相关例题</h1><p>BFS最重要的两个数据结构：</p>
<ul>
<li>队列</li>
<li>哈希表</li>
</ul>
<h2 id="层序遍历">6.1. 层序遍历</h2><h2 id="例题1，Binary-Tree-Level-Order-Traversal">6.2. 例题1，Binary Tree Level Order Traversal</h2><p>队列！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</div><div class="line"><span class="keyword">if</span>(<span class="keyword">null</span> == root)&#123;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="comment">// interface</span></div><div class="line">Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">queue.offer(root);</div><div class="line"><span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">  <span class="keyword">int</span> size =queue.size();</div><div class="line">  ArrayList&lt;Integer&gt; currentLevel = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</div><div class="line">    TreeNode head = queue.poll();</div><div class="line">    currentLevel.add(head.val);</div><div class="line">    <span class="keyword">if</span>(head.left != <span class="keyword">null</span>)&#123;</div><div class="line">      queue.offer(head.left);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(head.right != <span class="keyword">null</span>)&#123;</div><div class="line">      queue.offer(head.right);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  result.add(currentLevel);</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> result;</div></pre></td></tr></table></figure>
<h2 id="Binary-Tree-Level-Order-Traversal-II">6.3. Binary Tree Level Order Traversal II</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;</div><div class="line">        LinkedList&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;(); </div><div class="line">        <span class="comment">// LinkedList是List接口的实现，所以可以直接使用</span></div><div class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == root) <span class="keyword">return</span> result;</div><div class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        queue.offer(root);</div><div class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</div><div class="line">            <span class="keyword">int</span> size = queue.size();</div><div class="line">            List&lt;Integer&gt; curResult = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">            <span class="keyword">while</span> (size &gt; <span class="number">0</span>)&#123;</div><div class="line">                TreeNode cur = queue.poll();</div><div class="line">                curResult.add(cur.val);</div><div class="line">                <span class="keyword">if</span>(<span class="keyword">null</span> != cur.left)&#123;</div><div class="line">                    queue.offer(cur.left);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(<span class="keyword">null</span> != cur.right)&#123;</div><div class="line">                    queue.offer(cur.right);</div><div class="line">                &#125;</div><div class="line">                --size;</div><div class="line">            &#125;</div><div class="line">            result.addFirst(curResult); <span class="comment">// 注意这个神奇的东西</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="Binary-Tree-Zigzag-Level-Order-Traversal">6.4. Binary Tree Zigzag Level Order Traversal</h2><p>输出二叉树的层序遍历，且需要隔层倒序。</p>
<p>思路：用一个linkedList就好啦</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</div><div class="line">  List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">  <span class="keyword">if</span>(<span class="keyword">null</span> == root) <span class="keyword">return</span> result;</div><div class="line">  Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">  queue.offer(root);</div><div class="line">  <span class="keyword">boolean</span> fromHead = <span class="keyword">false</span>;</div><div class="line">  <span class="keyword">while</span> (!queue.isEmpty())&#123;</div><div class="line">    <span class="keyword">int</span> size =queue.size();</div><div class="line">    LinkedList&lt;Integer&gt; oneResult = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">    <span class="keyword">while</span> (size &gt; <span class="number">0</span>)&#123;</div><div class="line">      TreeNode now = queue.poll();</div><div class="line">      <span class="keyword">if</span>(fromHead)&#123;</div><div class="line">        oneResult.addFirst(now.val);</div><div class="line">      &#125;<span class="keyword">else</span> &#123;</div><div class="line">        oneResult.addLast(now.val);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span>(<span class="keyword">null</span> != now.left) queue.offer(now.left);</div><div class="line">      <span class="keyword">if</span>(<span class="keyword">null</span> != now.right)queue.offer(now.right);</div><div class="line">      --size;</div><div class="line">    &#125;</div><div class="line">    fromHead = !fromHead;</div><div class="line">    result.add(oneResult);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>思路2：用两个栈，单数层先left后right，双数层先right后left</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</div><div class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// currLevel表示当前在处理的那一层的结点</span></div><div class="line">    <span class="comment">// nextLevel表示下一层要处理的结点</span></div><div class="line">    Stack&lt;TreeNode&gt; currLevel = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</div><div class="line">    Stack&lt;TreeNode&gt; nextLevel = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</div><div class="line">    Stack&lt;TreeNode&gt; tmp;</div><div class="line"></div><div class="line">    currLevel.push(root);</div><div class="line">    <span class="keyword">boolean</span> normalOrder = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (!currLevel.isEmpty()) &#123;</div><div class="line">        ArrayList&lt;Integer&gt; currLevelResult = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (!currLevel.isEmpty()) &#123;</div><div class="line">            TreeNode node = currLevel.pop();</div><div class="line">            currLevelResult.add(node.val);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (normalOrder) &#123;</div><div class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</div><div class="line">                    nextLevel.push(node.left);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</div><div class="line">                    nextLevel.push(node.right);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</div><div class="line">                    nextLevel.push(node.right);</div><div class="line">                &#125; </div><div class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</div><div class="line">                    nextLevel.push(node.left);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        result.add(currLevelResult);</div><div class="line">        <span class="comment">// 交换currLevel和nextLevel，currLevel代表将要处理的那一层结点</span></div><div class="line">        tmp = currLevel;</div><div class="line">        currLevel = nextLevel;</div><div class="line">        nextLevel = tmp;</div><div class="line"></div><div class="line">        normalOrder = !normalOrder;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Binary-Tree-Right-Side-View">6.5. Binary Tree Right Side View</h2><p>给一个二叉树。从最右边看去，能看到的数字都是几？</p>
<p>思路：层序遍历，输出每层的最后一个元素！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> result;</div><div class="line">    <span class="comment">// 层序遍历的最后一个</span></div><div class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">    queue.add(root);</div><div class="line">    <span class="keyword">while</span> (!queue.isEmpty())&#123;</div><div class="line">        <span class="keyword">int</span> size = queue.size();</div><div class="line">        TreeNode temp = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">while</span> (size &gt; <span class="number">0</span>)&#123;</div><div class="line">            temp = queue.poll();</div><div class="line">            <span class="keyword">if</span>(temp.left != <span class="keyword">null</span>) queue.add(temp.left);</div><div class="line">            <span class="keyword">if</span>(temp.right != <span class="keyword">null</span>) queue.add(temp.right);</div><div class="line">            --size;</div><div class="line">        &#125;</div><div class="line">        result.add(temp.val);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Populating-Next-Right-Pointers-in-Each-Node-I-和II">6.6. Populating Next Right Pointers in Each Node I 和II</h2><p>给一个二叉树，每个节点应该有一个兄弟节点，但输入前兄弟节点还是空的。完成一个函数实现它。</p>
<p><strong>思路一：层序遍历</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</div><div class="line">        Queue&lt;TreeLinkNode&gt; level = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        level.add(root);</div><div class="line">        <span class="keyword">while</span> (!level.isEmpty())&#123;</div><div class="line">            <span class="keyword">int</span> size = level.size();</div><div class="line">            TreeLinkNode last = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>)&#123;</div><div class="line">                TreeLinkNode curr = level.poll();</div><div class="line">                <span class="keyword">if</span>(curr.left != <span class="keyword">null</span>)level.add(curr.left);</div><div class="line">                <span class="keyword">if</span>(curr.right != <span class="keyword">null</span>)level.add(curr.right);</div><div class="line">                <span class="keyword">if</span>(last == <span class="keyword">null</span>)&#123;</div><div class="line">                    last = curr;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;<span class="keyword">else</span> &#123;</div><div class="line">                    last.next = curr;</div><div class="line">                    last = curr;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>思路2，骚操作</strong> —— 只适合I，不适合II</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"> 满二叉树！</div><div class="line">   node       next</div><div class="line">   /  \       / \</div><div class="line">left right left right</div><div class="line"></div><div class="line">node.right.next = node.next.left !!!!!</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode root)</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != root)&#123;</div><div class="line">            TreeLinkNode cur = root;</div><div class="line">            <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</div><div class="line">                <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>)cur.left.next = cur.right;</div><div class="line">                <span class="keyword">if</span>(cur.right != <span class="keyword">null</span> &amp;&amp; cur.next != <span class="keyword">null</span>) cur.right.next = cur.next.left;</div><div class="line">                cur = cur.next;</div><div class="line">            &#125;</div><div class="line">            root = root.left;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h1 id="二叉树的遍历-1">7. 二叉树的遍历</h1><h2 id="前序遍历">7.1. 前序遍历</h2><h2 id="Binary-Tree-Preorder-Traversal">7.2. Binary Tree Preorder Traversal</h2><p>实现二叉树的前序遍历</p>
<p>这道题除了以上说的递归和非递归的两种方式，还有另一种非递归的实现方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">  Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">  list&lt;Integer&gt; preorder = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">  <span class="keyword">if</span>( <span class="keyword">null</span> == root )&#123;</div><div class="line">    <span class="keyword">return</span> preorder;</div><div class="line">  &#125;</div><div class="line">  stack.push(root);</div><div class="line">  <span class="keyword">while</span>( !stack.empty() )&#123;</div><div class="line">    TreeNode node = stack.pop();</div><div class="line">    preorder.add( node.val );</div><div class="line">    <span class="keyword">if</span>( node.right != <span class="keyword">null</span> )&#123;</div><div class="line">      stack.push(node.right);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>( node.left != <span class="keyword">null</span> )&#123;</div><div class="line">      stack.push(node.left);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> preorder;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Flatten-Binary-Tree-to-Linked-List">7.3. Flatten Binary Tree to Linked List</h2><p>将二叉树按照前序遍历的顺序变为一颗只有右孩子的单链表</p>
<p><strong>方法1，栈</strong></p>
<p>思路：整体思路就是按照前序遍历的方式.</p>
<p>非递归：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</div><div class="line">        <span class="comment">// 其实就是前序遍历</span></div><div class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        TreeNode node = root;</div><div class="line">        <span class="comment">//stack.push(node);</span></div><div class="line">        TreeNode last = node;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (!stack.isEmpty() || node != <span class="keyword">null</span>)&#123;</div><div class="line"></div><div class="line">            <span class="keyword">while</span> (node != <span class="keyword">null</span>)&#123;</div><div class="line">                <span class="comment">//System.out.println(node.val);</span></div><div class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) &#123;</div><div class="line">                    stack.push(node.right); <span class="comment">// 这里只push进去node.right(因为后期只会使用到node.right)</span></div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) &#123;<span class="comment">// 将左孩子挪到右孩子上</span></div><div class="line">                    node.right = node.left;</div><div class="line">                    TreeNode left = node.left;</div><div class="line">                    node.left = <span class="keyword">null</span>;</div><div class="line">                    node = left;</div><div class="line">                &#125;<span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                last = node;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(stack.empty()) <span class="keyword">return</span>;</div><div class="line">            node = stack.pop();</div><div class="line">            last.right = node; <span class="comment">// 当前节点的右孩子应该是上一轮的最后一个孩子</span></div><div class="line">            last = node;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>递归的另一种实现</strong></p>
<p>自己写的实在是太糟糕了。我们看看九章的写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>. 分别将右子树、左子树入栈</div><div class="line"><span class="number">2</span>. 本节点的新right就是栈顶的东西哇</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</div><div class="line">        </div><div class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        stack.push(root);</div><div class="line">        </div><div class="line">        <span class="keyword">while</span> (!stack.empty())&#123;</div><div class="line">            TreeNode node = stack.pop();</div><div class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) stack.push(node.right);</div><div class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) stack.push(node.left);</div><div class="line">            </div><div class="line">            <span class="comment">// 连接</span></div><div class="line">            node.left = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">if</span>(stack.empty()) node.right = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">else</span> node.right = stack.peek();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>方法2，分治</strong></p>
<p>这道题的递归方式我是死活都没写出来。其实就是向右探到底那没想通。哎</p>
<p>假设某节点的左右子树T(root-&gt;left)和T(root-&gt;right)已经flatten成linked list了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">  1</div><div class="line">/   \</div><div class="line">2      5</div><div class="line">\       \</div><div class="line"> 3        6 &lt;- rightLast</div><div class="line">   \</div><div class="line">    4  &lt;- leftLast</div></pre></td></tr></table></figure>
<p>如何将root、T(root-&gt;left)、T(root-&gt;right) flatten成一整个linked list？显而易见：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">temp = root.right</div><div class="line">root.right  = root.left</div><div class="line">root.left = NULL</div><div class="line">leftTail.right = temp</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">    helper(root);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// flatten root and return the last node</span></div><div class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">helper</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    TreeNode leftLast = helper(root.left);</div><div class="line">    TreeNode rightLast = helper(root.right);</div><div class="line">    </div><div class="line">    <span class="comment">// connect leftLast to root.right</span></div><div class="line">    <span class="keyword">if</span> (leftLast != <span class="keyword">null</span>) &#123;</div><div class="line">        leftLast.right = root.right;</div><div class="line">        root.right = root.left;</div><div class="line">        root.left = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (rightLast != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> rightLast;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (leftLast != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> leftLast;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> root;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>参考<a href="http://www.cnblogs.com/grandyang/p/4293853.html" target="_blank" rel="external">Grandyang</a></p>
<h2 id="中序遍历">7.4. 中序遍历</h2><h2 id="Binary-Tree-Inorder-Traversal">7.5. Binary Tree Inorder Traversal</h2><p>实现二叉树的中序遍历</p>
<h2 id="Minimum-Absolute-Difference-in-BST">7.6. Minimum Absolute Difference in BST</h2><p>给一个二叉搜索树。求任意两个结点之间绝对值的最小值。</p>
<p>思路：中序遍历，用后面的减去前面的，找到最小。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> last = -<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</div><div class="line">        <span class="keyword">while</span> (!stack.isEmpty() || <span class="keyword">null</span> != root)&#123;</div><div class="line">            <span class="keyword">while</span> (<span class="keyword">null</span> != root) &#123;</div><div class="line">                stack.push(root);</div><div class="line">                root = root.left;</div><div class="line">            &#125;</div><div class="line">            root = stack.pop();</div><div class="line">            <span class="keyword">if</span>(last == -<span class="number">1</span>)&#123;last = root.val;&#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                min = Math.min(min,root.val - last);</div><div class="line">                last = root.val;</div><div class="line">            &#125;</div><div class="line">            root = root.right;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> min;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="Kth-Smallest-Element-in-a-BST">7.7. Kth Smallest Element in a BST</h2><p>输出搜索二叉树第k小的数</p>
<p>BST的中序遍历是从小到大的。因此只需要按照中序遍历输出第k个即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == root) <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (!stack.isEmpty() || <span class="keyword">null</span> != root)&#123;</div><div class="line">            <span class="keyword">while</span> (<span class="keyword">null</span> != root)&#123;</div><div class="line">                stack.push(root);</div><div class="line">                root = root.left;</div><div class="line">            &#125;</div><div class="line">            root = stack.pop();</div><div class="line">            i++;</div><div class="line">            <span class="keyword">if</span>(i == k)&#123;</div><div class="line">                <span class="keyword">return</span> root.val;</div><div class="line">            &#125;</div><div class="line">            root = root.right;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>递归写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> count=<span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> flag=<span class="number">0</span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode node,<span class="keyword">int</span> k)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(node==<span class="keyword">null</span>)&#123;</div><div class="line">        <span class="keyword">return</span> ;</div><div class="line">    &#125;</div><div class="line">    inorder(node.left,k);</div><div class="line">    count++;</div><div class="line">    ans=node.val;</div><div class="line">    <span class="keyword">if</span>(count==k)&#123;</div><div class="line">        flag=ans;</div><div class="line">    &#125;</div><div class="line">    inorder(node.right,k);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">   inorder(root,k);</div><div class="line">    <span class="keyword">return</span> flag;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="后序遍历">7.8. 后序遍历</h2><h2 id="Binary-Tree-Postorder-Traversal">7.9. Binary Tree Postorder Traversal</h2><p>实现二叉树的后序遍历</p>
<p>这道题除了以上说的递归和非递归的两种方式，还有一种更骚气的，利用双栈。</p>
<p>但实际上它做的是反向的先序遍历。亦即遍历的顺序是：节点 -&gt; 右子树 -&gt; 左子树。这生成的是后根遍历的逆序输出。使用第二个栈，再执行一次反向输出即可得到所要的结果。</p>
<p>下面是它的实现步骤：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">将根节点压入第一个栈</div><div class="line">从第一个栈中弹出一个元素，压入第二个栈</div><div class="line">然后分别将该节点的左右孩子压入第一个栈</div><div class="line">重复步骤<span class="number">2</span>和步骤<span class="number">3</span>直到第一个栈为空</div><div class="line">执行结束，第二个栈中就保存了所有节点的后序遍历输出结果。依次将元素从第二个栈中弹出即可。</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">  List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">  <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  Stack&lt;TreeNode&gt; tmp = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">  Stack&lt;TreeNode&gt; out = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line"></div><div class="line">  tmp.push(root);</div><div class="line"></div><div class="line">  <span class="keyword">while</span> (!tmp.isEmpty()) &#123;</div><div class="line">    TreeNode node = tmp.pop();</div><div class="line">    out.push(node);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</div><div class="line">      tmp.push(node.left);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</div><div class="line">      tmp.push(node.right);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">while</span> (!out.isEmpty()) &#123;</div><div class="line">    result.add(out.pop().val);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Subtree-of-Another-Tree">7.10. Subtree of Another Tree</h2><p>给两个二叉树s和t。判断t是否是s的子树</p>
<p>思路一，非递归</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(TreeNode s_in,TreeNode t_in)</span></span>&#123;</div><div class="line">        TreeNode t = t_in;</div><div class="line">        TreeNode s = s_in;</div><div class="line">        Stack&lt;TreeNode&gt; stack_t = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        Stack&lt;TreeNode&gt; stack_s = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        <span class="keyword">while</span> (!stack_t.isEmpty()|| <span class="keyword">null</span> != t)&#123;</div><div class="line">            <span class="keyword">while</span> (<span class="keyword">null</span> != t &amp;&amp; <span class="keyword">null</span> != s)&#123;</div><div class="line">                stack_t.push(t);</div><div class="line">                stack_s.push(s);</div><div class="line">                s = s.left;</div><div class="line">                t = t.left;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(!( (<span class="keyword">null</span> != t &amp;&amp; <span class="keyword">null</span> != s)||</div><div class="line">                    (<span class="keyword">null</span> == t &amp;&amp; <span class="keyword">null</span> == s)) ) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            t = stack_t.pop();</div><div class="line">            s = stack_s.pop();</div><div class="line">            <span class="keyword">if</span>(t.val != s.val)&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            s = s.right;</div><div class="line">            t = t.right;</div><div class="line">            <span class="keyword">if</span>(!( (<span class="keyword">null</span> != t &amp;&amp; <span class="keyword">null</span> != s)||</div><div class="line">                    (<span class="keyword">null</span> == t &amp;&amp; <span class="keyword">null</span> == s)) ) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</div><div class="line">        <span class="comment">// 从s里找t</span></div><div class="line">        <span class="comment">// 遍历s</span></div><div class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == t) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == s) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        <span class="keyword">while</span> (!stack.isEmpty() || <span class="keyword">null</span> != s)&#123;</div><div class="line">            <span class="keyword">while</span> (<span class="keyword">null</span> != s)&#123;</div><div class="line">                stack.push(s);</div><div class="line">                s = s.left;</div><div class="line">            &#125;</div><div class="line">            s = stack.pop();</div><div class="line">            <span class="keyword">if</span>(s.val == t.val)&#123;</div><div class="line">                <span class="keyword">if</span>(check(s,t)) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            s = s.right;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>思路二，递归</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(TreeNode s, TreeNode t)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(<span class="keyword">null</span> == s &amp;&amp; <span class="keyword">null</span> == t) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">  <span class="keyword">if</span>(<span class="keyword">null</span> == s || <span class="keyword">null</span> == t) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  <span class="keyword">if</span>(s.val == t.val)&#123;</div><div class="line">    <span class="keyword">return</span> check(s.left,t.left) &amp;&amp; check(s.right,t.right);</div><div class="line">  &#125;<span class="keyword">else</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</div><div class="line">  <span class="comment">// 从s里找t</span></div><div class="line">  <span class="comment">// 遍历s</span></div><div class="line">  <span class="keyword">if</span>(<span class="keyword">null</span> == t || <span class="keyword">null</span> == s) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  <span class="keyword">if</span>(s.val == t.val)&#123;</div><div class="line">    <span class="keyword">if</span>(check(s,t))<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> isSubtree(s.left,t) || isSubtree(s.right,t);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Minimum-Depth-of-Binary-Tree">7.11. Minimum Depth of Binary Tree</h2><p>返回二叉树叶子结点的最小的层数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(<span class="keyword">null</span> == root) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">  <span class="keyword">int</span> level = <span class="number">1</span>;</div><div class="line">  queue.offer(root);</div><div class="line">  <span class="keyword">while</span> (!queue.isEmpty())&#123;</div><div class="line">    <span class="keyword">int</span> size = queue.size();</div><div class="line">    <span class="keyword">while</span> (size &gt; <span class="number">0</span>)&#123;</div><div class="line">      TreeNode now = queue.poll();</div><div class="line">      <span class="keyword">if</span>(<span class="keyword">null</span> == now.right &amp;&amp; <span class="keyword">null</span> == now.left) <span class="keyword">return</span> level;</div><div class="line">      <span class="keyword">if</span>(<span class="keyword">null</span> != now.left) &#123;queue.offer(now.left);&#125;</div><div class="line">      <span class="keyword">if</span>(<span class="keyword">null</span> != now.right) &#123;queue.offer(now.right);&#125;</div><div class="line">      --size;</div><div class="line">    &#125;</div><div class="line">    ++level;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> level;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal">7.12. Construct Binary Tree from Preorder and Inorder Traversal</h2><p>用前序+中序恢复二叉树</p>
<h1 id="分治相关例题">8. 分治相关例题</h1><h2 id="例题1，Maximum-Depth-of-Binary-Tree">8.1. 例题1，Maximum Depth of Binary Tree</h2><p>求二叉树的最大深度</p>
<p><strong>方法一，遍历</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="comment">//从root出发,root当前深度是1</span></div><div class="line">helper(root,<span class="number">1</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, <span class="keyword">int</span> depth)</span></span>&#123;</div><div class="line">  <span class="comment">//走过头了</span></div><div class="line">  <span class="keyword">if</span>( root == <span class="keyword">null</span> )&#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  max = Math.max(max,depth);</div><div class="line">  helper(root.left, depth + <span class="number">1</span> );</div><div class="line">  helper(root.right, depth + <span class="number">1</span> )</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>方法2，分治</strong></p>
<p>没有全局变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>( root == <span class="keyword">null</span> )&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> leftDepth = maxDepth(root.left);</div><div class="line">  <span class="keyword">int</span> rightDepth = maxDepth(root.right);</div><div class="line">  </div><div class="line">  <span class="keyword">return</span> Math.max(leftDepth,rightDepth) + <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="例题2，Balanced-Binary-Tree">8.2. 例题2，Balanced Binary Tree</h2><p>判断一个树是不是平衡二叉树</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//当一个结果有多个参数决定时，定义一个class</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResultType</span></span>&#123;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">boolean</span> isBalanced;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">int</span> maxDepth;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ResultType</span><span class="params">(<span class="keyword">boolean</span> isBalanced, <span class="keyword">int</span> maxDepth)</span></span>&#123;</div><div class="line">    <span class="keyword">this</span>.isBalanced = isBalanced;</div><div class="line">    <span class="keyword">this</span>.maxDepth = maxDepth;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 主函数</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">  <span class="keyword">return</span> helper(root).isBalanced;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 分治</span></div><div class="line"><span class="function"><span class="keyword">private</span> ResultType <span class="title">helper</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(<span class="keyword">null</span> == root)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ResultType(<span class="keyword">true</span>,<span class="number">0</span>);</div><div class="line">  &#125;</div><div class="line">  ResultType left = helper(root.left);</div><div class="line">  ResultType right = helper(root.right);</div><div class="line">  </div><div class="line">  <span class="comment">// 子树不平衡</span></div><div class="line">  <span class="keyword">if</span>(!left.isBalanced || !right.isBalanced)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ResultType(<span class="keyword">false</span>,-<span class="number">1</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// root不平衡</span></div><div class="line">  <span class="keyword">if</span>(Math.abs(left.maxDepth - right.maxDepth) &gt; <span class="number">1</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ResultType(<span class="keyword">false</span>,-<span class="number">1</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ResultType(<span class="keyword">true</span>,Math.max(left.maxDepth , right.maxDepth) + <span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另一种解法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(<span class="keyword">null</span> == root) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> leftDepth = helper(root.left);</div><div class="line">  <span class="keyword">if</span>(leftDepth == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">  <span class="keyword">int</span> rightDepth = helper(root.right);</div><div class="line">  <span class="keyword">if</span>(rightDepth == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">  <span class="keyword">if</span>(Math.abs(leftDepth-rightDepth)&gt;<span class="number">1</span>)<span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">  <span class="keyword">return</span> Math.max(leftDepth,rightDepth) + <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> helper(root)!=-<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="例题3，Lowest-Common-Ancestor">8.3. 例题3，Lowest Common Ancestor</h2><p>求一颗二叉树中两个点a,b的最近公共祖先</p>
<p> 在root为根的二叉树中，从上到下寻找A,B的LCA:</p>
<ul>
<li>如果找到了就返回这个LCA</li>
<li>如果只碰到A，就返回A</li>
<li>如果只碰到B，就返回B</li>
<li>如果都没有，就返回null</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode nodel1, TreeNode node2)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(root == <span class="keyword">null</span> || root == node1 || root == node2)&#123;</div><div class="line">    <span class="keyword">return</span> root;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 分解问题</span></div><div class="line">  TreeNode left = lowestCommonAncestor(root.left, node1, node2);</div><div class="line">  TreeNode right = lowestCommonAncestor(root.right, node1, node2);</div><div class="line">  </div><div class="line">  <span class="comment">// 合并问题</span></div><div class="line">  <span class="keyword">if</span>(left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>)&#123; <span class="comment">// left中含有n1或n2,right也含有</span></div><div class="line">    <span class="keyword">return</span> root;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>(right != <span class="keyword">null</span>)&#123; <span class="comment">// right中含有n1或n2,left不含</span></div><div class="line">    <span class="keyword">return</span> right;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>(left != <span class="keyword">null</span>)&#123; <span class="comment">// left中含有n1或n2,right不含</span></div><div class="line">    <span class="keyword">return</span> left;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另一种思路，统计本节点的子节点中有几个命中节点<br>如果等于两个，则本节点是公共祖先！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">TreeNode result;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode root, TreeNode p,TreeNode q)</span></span>&#123;</div><div class="line">  <span class="keyword">int</span> counter = <span class="number">0</span>;</div><div class="line">  <span class="keyword">if</span>( <span class="keyword">null</span> == root || <span class="keyword">null</span> != result) <span class="keyword">return</span> counter;</div><div class="line">  <span class="keyword">if</span>( root == p ) &#123;</div><div class="line">    counter += <span class="number">1</span>;</div><div class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>( root == q ) &#123;</div><div class="line">    counter += <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>( counter == <span class="number">2</span> )&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">null</span> == result)result = root;</div><div class="line">    <span class="keyword">return</span> counter;</div><div class="line">  &#125;</div><div class="line">  counter += helper(root.right,p,q);</div><div class="line">  <span class="keyword">if</span>( counter == <span class="number">2</span> )&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">null</span> == result)result = root;</div><div class="line">    <span class="keyword">return</span> counter;</div><div class="line">  &#125;</div><div class="line">  counter += helper(root.left,p,q);</div><div class="line">  <span class="keyword">if</span>( counter == <span class="number">2</span> )&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">null</span> == result)result = root;</div><div class="line">    <span class="keyword">return</span> counter;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> counter;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">int</span> counter = helper(root,p,q);</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="例题4，Lowest-Common-Ancestor-II">8.4. 例题4，Lowest Common Ancestor II</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">在root为跟的二叉树中找n1,n2的LCA</div><div class="line">如果找到了就返回</div><div class="line">如果只碰到了n1,就返回n1</div><div class="line">如果只碰到了n2,就返回n2</div><div class="line">如果都没有，就返回Null</div></pre></td></tr></table></figure>
<h2 id="例题5，Binary-Tree-Maximum-Path-Sum-II">8.5. 例题5，Binary Tree Maximum Path Sum II</h2><p>给一个二叉树，找到从root的最大路径和。路径可以在任何地方被结束掉。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">   <span class="number">1</span></div><div class="line">  / \</div><div class="line"> <span class="number">2</span>   <span class="number">3</span></div><div class="line">      \</div><div class="line">       -<span class="number">1</span></div><div class="line"></div><div class="line"><span class="keyword">return</span> <span class="number">4</span></div><div class="line"></div><div class="line">思路：某个点的最大长度 = Math.max(<span class="number">0</span>,sum)</div></pre></td></tr></table></figure>
<h2 id="例题6，Binary-Tree-Maximum-Path-Sum">8.6. 例题6，Binary Tree Maximum Path Sum</h2><p>给一个二叉树，找到从any node 到 any node最大路径和。路径可以在任何地方被结束掉。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">  -<span class="number">1</span></div><div class="line">  / \</div><div class="line"> <span class="number">2</span>   <span class="number">3</span></div><div class="line">      \</div><div class="line">       -<span class="number">1</span></div><div class="line"></div><div class="line"><span class="keyword">return</span> <span class="number">3</span></div><div class="line"></div><div class="line">思路：两个分治</div><div class="line"></div><div class="line">要求整个二叉树的最长路径，先求左子树的最长路径，再求右子树的最长路径。</div><div class="line"></div><div class="line">整棵树的最长路径（以上图为例）：</div><div class="line"><span class="number">1</span>. 有可能全在左边（只有<span class="number">2</span>）</div><div class="line"><span class="number">2</span>. 有可能全在右边（只有<span class="number">3</span>）</div><div class="line"><span class="number">3</span>. 可能跨过root节点（有-<span class="number">1</span>、<span class="number">2</span>、<span class="number">3</span>）</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResultType</span></span>&#123;</div><div class="line"> <span class="keyword">int</span> root2This, any2This;</div><div class="line"> ResultType(<span class="keyword">int</span> root2This, <span class="keyword">int</span> any2This)&#123;</div><div class="line">   <span class="keyword">this</span>.root2This = root2This; </div><div class="line">   <span class="keyword">this</span>.any2This = any2This;</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> ResultType <span class="title">helper</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">  <span class="comment">// illegal</span></div><div class="line">  <span class="keyword">if</span>(<span class="keyword">null</span> == root)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ResultType(Integer.MIN_VALUE,Integer.MIN_VALUE);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 分解问题</span></div><div class="line">  ResultType left = helper(root.left);</div><div class="line">  ResultType right = helper(root.right);</div><div class="line">  </div><div class="line">  <span class="comment">// 合并问题</span></div><div class="line">  <span class="comment">// 为了方便之后的第3步计算（为了解决any2this，一定要算出root2this）</span></div><div class="line">  <span class="keyword">int</span> root2This = Math.max(<span class="number">0</span>,Math.max(left.root2This, right.root2This)) + root.val;</div><div class="line">  </div><div class="line">  <span class="comment">// 1、2. root到这个节点的最大sum</span></div><div class="line">  <span class="comment">// 全在左边或者全在右边（可以不包含root）</span></div><div class="line">  <span class="keyword">int</span> any2This = Math.max(left.any2This, right.any2This);</div><div class="line">  <span class="comment">// 3. any到这个节点的最大sum</span></div><div class="line">  <span class="comment">// 跨过了root点（一定是root到left或right的路径）</span></div><div class="line">  any2This = Math.max(any2This,</div><div class="line">                     Math.max(<span class="number">0</span>, left.root2This)</div><div class="line">                     + Math.max(<span class="number">0</span>, right.root2This)</div><div class="line">                     + root.val);</div><div class="line">                     </div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Result(root2This, any2This);</div><div class="line">&#125;</div><div class="line"></div><div class="line">代码：</div><div class="line"><span class="comment">// int[0] - &gt; any 2 any</span></div><div class="line"><span class="comment">// int[1] --&gt; end 2 this</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] helper(TreeNode node) &#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == node) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">9999999</span>,-<span class="number">9999999</span>&#125;;</div><div class="line">        <span class="keyword">int</span>[] left = helper(node.left);</div><div class="line">        <span class="keyword">int</span>[] right = helper(node.right);</div><div class="line">        <span class="comment">// 从本节点向下的某个节点截止</span></div><div class="line">        <span class="keyword">int</span> down2This = Math.max(</div><div class="line">                Math.max(left[<span class="number">1</span>] + node.val,</div><div class="line">                        right[<span class="number">1</span>] + node.val),</div><div class="line">                node.val</div><div class="line">        );</div><div class="line">        <span class="comment">// 跨越node节点</span></div><div class="line">        <span class="keyword">int</span> twoside = left[<span class="number">1</span>] + node.val + right[<span class="number">1</span>];</div><div class="line">        <span class="comment">// 全在左子树或全在右子树</span></div><div class="line">        <span class="keyword">int</span> oneside  = Math.max(left[<span class="number">0</span>],right[<span class="number">0</span>]);</div><div class="line">        <span class="comment">// 三者求最大</span></div><div class="line">        <span class="keyword">int</span> any2This = Math.max(down2This,Math.max(oneside,twoside));</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;any2This,down2This&#125;;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">     <span class="keyword">return</span> helper(root)[<span class="number">0</span>];</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>还有一种骚操作，只记录【本节点】到【下方节点】的最大和！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> max = Integer.MIN_VALUE; <span class="comment">// 全局最大</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  traverse(root);</div><div class="line">  <span class="keyword">return</span> max;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> left = traverse(root.left);</div><div class="line">  <span class="keyword">int</span> right = traverse(root.right);</div><div class="line">  max = Math.max(max, Math.max(left, <span class="number">0</span>) + Math.max(right, <span class="number">0</span>) + root.val);</div><div class="line">  <span class="keyword">return</span> Math.max(<span class="number">0</span>, Math.max(left, right)) + root.val;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="二叉搜索树">9. 二叉搜索树</h1><h2 id="BST定义">9.1. BST定义</h2><p><strong>定义</strong></p>
<ul>
<li>左子树比根节点小</li>
<li>右子树比根节点大<ul>
<li>如果有重复，可以全部放在左/右</li>
</ul>
</li>
</ul>
<p><strong>效果</strong></p>
<ul>
<li>中序遍历是升序序列</li>
</ul>
<p><strong>性质</strong></p>
<ul>
<li>如果一颗二叉树中序不是升序，则一定不是BST</li>
<li>如果一颗二叉树中序是升序，则不一定是BST</li>
</ul>
<h2 id="删除">9.2. 删除</h2><p>本节主要参考自：<a href="http://blog.csdn.net/cyp331203/article/details/42609387" target="_blank" rel="external">【算法导论】二叉搜索树的插入和删除</a></p>
<p>从一个二叉搜索树中删除一个结点，会有三种情况：</p>
<ul>
<li><p>如果z没有孩子节点，就直接删除，并修改它的父节点，用null作为它的孩子；</p>
</li>
<li><p>如果z只有一个孩子，就将这个孩子提升到树中z的位置上，并修改z的父节点，用z的孩子来替换z；</p>
</li>
<li><p>如果z有两个孩子，那么可以寻找节点的后继（中序遍历时的下一个结点）。删除方法如下：</p>
<ul>
<li>找到该节点的右子树中的最左孩子（也就是右子树中序遍历的第一个节点）</li>
<li>把它的值和要删除的节点的值进行交换</li>
<li>然后删除这个节点（其实就是用这个节点的右子树替换这个节点，因为这个节点此时已经肯定没有左子树了）</li>
</ul>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-11-14-07-43.png" alt=""> </p>
</li>
</ul>
<p>代码见后面的题- Delete Node in a BST</p>
<h2 id="Validate-Binary-Search-Tree">9.3. Validate Binary Search Tree</h2><p>验证一个二叉树是不是搜索二叉树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">BST有一个性质——如果一个二叉树的中序遍历是严格递增的，则这个二叉树一定是BST.</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">  Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">  <span class="keyword">long</span> last = Long.MIN_VALUE;</div><div class="line">  <span class="keyword">while</span> (!stack.isEmpty() || <span class="keyword">null</span> != root)&#123;</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">null</span> != root)&#123;</div><div class="line">      stack.push(root);</div><div class="line">      root = root.left;</div><div class="line">    &#125;</div><div class="line">    root = stack.pop();</div><div class="line">    <span class="keyword">if</span>(last &lt; root.val)&#123;</div><div class="line">      last = root.val;</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    root = root.right;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Binary-search-Tree-Iterator">9.4. Binary search Tree Iterator</h2><p>中序遍历。要一个给一个。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Definition for binary tree</div><div class="line"> * public class TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode left;</div><div class="line"> *     TreeNode right;</div><div class="line"> *     TreeNode(int x) &#123; val = x; &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> </span>&#123;</div><div class="line">    Stack&lt;TreeNode&gt; stack;</div><div class="line">    TreeNode root;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BSTIterator</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.root = root;</div><div class="line">        stack= <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** <span class="doctag">@return</span> whether we have a next smallest number */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span>!stack.isEmpty() || <span class="keyword">null</span> != root;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** <span class="doctag">@return</span> the next smallest number */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != root)&#123;</div><div class="line">            stack.push(root);</div><div class="line">            root = root.left;</div><div class="line">        &#125;</div><div class="line">        root = stack.pop();</div><div class="line">        <span class="keyword">int</span> result =root.val ;</div><div class="line">        root = root.right;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Your BSTIterator will be called like this:</div><div class="line"> * BSTIterator i = new BSTIterator(root);</div><div class="line"> * while (i.hasNext()) v[f()] = i.next();</div><div class="line"> */</div></pre></td></tr></table></figure>
<h2 id="Convert-Sorted-Array-to-Binary-Search-Tree">9.5. Convert Sorted Array to Binary Search Tree</h2><p>将有序数组转化为平衡二叉树</p>
<p>思路：平衡二叉树的root一定是有序数组的中点！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">       <span class="keyword">if</span>(end &lt; start) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"></div><div class="line">       <span class="keyword">int</span> mid = start + (end - start)/<span class="number">2</span>;</div><div class="line">       TreeNode root = <span class="keyword">new</span> TreeNode(nums[mid]);</div><div class="line">       root.left = helper(nums,start,mid - <span class="number">1</span>);</div><div class="line">       root.right = helper(nums,mid + <span class="number">1</span> ,end);</div><div class="line">       <span class="keyword">return</span> root;</div><div class="line">   &#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">       <span class="keyword">return</span> helper(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h2 id="Convert-Sorted-List-to-Binary-Search-Tree">9.6. Convert Sorted List to Binary Search Tree</h2><p>将有序链表转化为平衡二叉树</p>
<p>这道题思路实在是太骚气了</p>
<p>我们换一个思路可能就会简单很多，即如果是将一个排序二叉树转换成链表，无非是一个中序遍历。</p>
<p>那么，这里讲链表转换成二叉树也是一样的思路，即一个中序遍历，其具体思路如下。</p>
<p>按照中序遍历的思路，应该先生成左子树，然后是根节点，最后的右子树。以这样的顺序，每次新创建的节点都对应链表的顺序遍历中当前位置的节点。</p>
<p>很明显这是一个递归的结构。那么剩下的问题就是如何确定递归的终止条件。</p>
<p>因为在转换的过程中，需要计算各子链表的长度，那么这里就可以由此来终止递归，即当长度等于0时终止。下面我们来看代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(ListNode head)</span></span>&#123;</div><div class="line">       <span class="keyword">int</span> length = <span class="number">0</span>;</div><div class="line">       <span class="keyword">while</span> (<span class="keyword">null</span> != head)&#123;</div><div class="line">           head = head.next;</div><div class="line">           ++length;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> length;</div><div class="line">   &#125;</div><div class="line">   ListNode curr;</div><div class="line">   <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">       <span class="keyword">int</span> size = getLength(head);</div><div class="line">       curr = head;</div><div class="line">       <span class="keyword">return</span> helper(size);</div><div class="line">   &#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</div><div class="line">       <span class="keyword">if</span>(size == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">       TreeNode left = helper(size / <span class="number">2</span>);</div><div class="line">       TreeNode root = <span class="keyword">new</span> TreeNode(curr.val);</div><div class="line">       curr = curr.next;</div><div class="line">       root.left = left;</div><div class="line">       root.right = helper(size - size / <span class="number">2</span> - <span class="number">1</span>);</div><div class="line">       <span class="keyword">return</span>  root;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h2 id="Delete-Node-in-a-BST">9.7. Delete Node in a BST</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == root)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        TreeNode dummy = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</div><div class="line">        <span class="keyword">if</span>(root.val &lt; <span class="number">0</span>)&#123;dummy.left = root;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;dummy.right = root;&#125;</div><div class="line">        TreeNode parent = dummy;</div><div class="line">        TreeNode child = root;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != child)&#123;</div><div class="line">            <span class="keyword">if</span>(child.val == key)&#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(child.val &lt; key)&#123;</div><div class="line">                parent = child;</div><div class="line">                child = child.right;</div><div class="line">            &#125;<span class="keyword">else</span> &#123;</div><div class="line">                parent = child;</div><div class="line">                child = child.left;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == child)&#123;</div><div class="line">            <span class="keyword">return</span> root;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == child.left)&#123;</div><div class="line">            <span class="keyword">if</span>(child.val &lt; parent.val)&#123;</div><div class="line">                parent.left = child.right;</div><div class="line">            &#125;<span class="keyword">else</span> &#123;</div><div class="line">                parent.right = child.right;</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">null</span> == child.right)&#123;</div><div class="line">            <span class="keyword">if</span>(child.val &lt; parent.val)&#123;</div><div class="line">                parent.left = child.left;</div><div class="line">            &#125;<span class="keyword">else</span> &#123;</div><div class="line">                parent.right = child.left;</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">// 都不为空</span></div><div class="line">            <span class="comment">// 找到该节点的右子树中的最左孩子</span></div><div class="line">            TreeNode afterParent = child;</div><div class="line">            TreeNode after = child.right;</div><div class="line">            <span class="keyword">while</span> (<span class="keyword">null</span> != after.left)&#123;</div><div class="line">                afterParent = after;</div><div class="line">                after = after.left;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 把它的值与删除的节点的值进行交换</span></div><div class="line">            <span class="keyword">int</span> temp = after.val;</div><div class="line">            after.val = child.val;</div><div class="line">            child.val = temp;</div><div class="line">            <span class="comment">// 删除这个节点</span></div><div class="line">            <span class="keyword">if</span>(temp &lt; afterParent.val)&#123;</div><div class="line">                afterParent.left = after.right;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                afterParent.right = after.right;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> != dummy.left)&#123;</div><div class="line">            <span class="keyword">return</span> dummy.left;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">return</span> dummy.right;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>还有一种递归写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">       </div><div class="line">       <span class="keyword">if</span> (root.val &gt; key) &#123;</div><div class="line">           root.left = deleteNode(root.left, key);</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; key) &#123;</div><div class="line">           root.right = deleteNode(root.right, key);</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           <span class="keyword">if</span> (root.left == <span class="keyword">null</span>) <span class="keyword">return</span> root.right;</div><div class="line">           <span class="keyword">if</span> (root.right == <span class="keyword">null</span>) <span class="keyword">return</span> root.left;</div><div class="line">           </div><div class="line">           TreeNode rightSmallest = root.right;</div><div class="line">           <span class="keyword">while</span> (rightSmallest.left != <span class="keyword">null</span>) rightSmallest = rightSmallest.left;</div><div class="line">           rightSmallest.left = root.left;</div><div class="line">           <span class="keyword">return</span> root.right;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> root;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h2 id="Find-Mode-in-Binary-Search-Tree">9.8. Find Mode in Binary Search Tree</h2><p>给一个有重的BST。其中左子树小于等于本身，右子树大于本身。统计最多次数出现的数字。</p>
<p>思路：中序遍历计数即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> maxCount;</div><div class="line">    List&lt;Integer&gt; set;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findMode(TreeNode root) &#123;</div><div class="line">        maxCount = <span class="number">0</span>;</div><div class="line">        set = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> preVal = Integer.MAX_VALUE;</div><div class="line">        <span class="keyword">int</span> preCount = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (!stack.isEmpty() || <span class="keyword">null</span> != root)&#123;</div><div class="line">            <span class="keyword">while</span> (<span class="keyword">null</span> != root)&#123;</div><div class="line">                stack.push(root);</div><div class="line">                root = root.left;</div><div class="line">            &#125;</div><div class="line">            root = stack.pop();</div><div class="line">            <span class="keyword">if</span>(root.val == preVal)&#123;</div><div class="line">                ++preCount;</div><div class="line">            &#125;<span class="keyword">else</span> &#123;</div><div class="line">                preVal = root.val;</div><div class="line">                preCount = <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(preCount &gt; maxCount)&#123;</div><div class="line">                set.clear();</div><div class="line">                set.add(preVal);</div><div class="line">                maxCount = preCount;</div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(preCount == maxCount)&#123;</div><div class="line">                set.add(preVal);</div><div class="line">            &#125;</div><div class="line">            root = root.right;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[set.size()];</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> e : set)&#123;</div><div class="line">            res[i] = e;</div><div class="line">            ++i;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>还有很多相关题。</p>
<h1 id="参考文献">10. 参考文献</h1><ol>
<li><a href="https://juejin.im/post/59e3fde451882578c20858a5" target="_blank" rel="external">刷题】二叉树非递归遍历</a></li>
<li><a href="http://blog.csdn.net/u014787113/article/details/49717831" target="_blank" rel="external">二叉树前序，中序，后序遍历迭代实现详解</a></li>
<li><a href="http://blog.csdn.net/cyp331203/article/details/42609387" target="_blank" rel="external">【算法导论】二叉搜索树的插入和删除</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[算法-二分查找]]></title>
      <url>/2017/11/24/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      <content type="html"><![CDATA[<h1 id="二分查找">1. 二分查找</h1><p>给一个已排序的数组，找到target的位置（第一个出现的、最后一个出现的、任意的）位置。如果没有target，返回-1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">target = <span class="number">5</span></div><div class="line"></div><div class="line">    start                    end</div><div class="line">      ↓                       ↓</div><div class="line">index <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span></div><div class="line">nums  <span class="number">2</span>  <span class="number">3</span>  <span class="number">5</span>  <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span></div><div class="line">      </div><div class="line">======================================</div><div class="line"></div><div class="line">mid = [start + end ] / <span class="number">2</span> = <span class="number">8</span>/<span class="number">2</span> = <span class="number">4</span></div><div class="line">  </div><div class="line">    start        mid         end</div><div class="line">      ↓           ↓           ↓</div><div class="line">index <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span></div><div class="line">nums  <span class="number">2</span>  <span class="number">3</span>  <span class="number">5</span>  <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span></div><div class="line">  </div><div class="line">nums[mid] &gt; target  -&gt; target一定在左边 --&gt; end = mid</div><div class="line"></div><div class="line">======================================</div><div class="line"></div><div class="line">mid = [start + end ] / <span class="number">2</span> = <span class="number">4</span>/<span class="number">2</span> = <span class="number">2</span></div><div class="line">  </div><div class="line">    start  mid   end</div><div class="line">      ↓     ↓     ↓</div><div class="line">index <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span></div><div class="line">nums  <span class="number">2</span>  <span class="number">3</span>  <span class="number">5</span>  <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span></div><div class="line">  </div><div class="line">nums[mid] == target  -&gt;  got it ! </div><div class="line">  </div><div class="line">复杂度分析</div><div class="line"></div><div class="line">T(n) = T(n/<span class="number">2</span>) + O(<span class="number">1</span>)</div><div class="line"></div><div class="line">解得 T(n) = O(logn)</div></pre></td></tr></table></figure>
<a id="more"></a>
<p><strong>用递归还是用while？</strong></p>
<p>递归：好理解，耗费栈空间</p>
<p>while：不好写，但省栈空间，尽量写while</p>
<h1 id="例题">2. 例题</h1><h2 id="例题1，Binary-Search">2.1. 例题1，Binary Search</h2><p>给一个int[] nums,找到target第一次出现的index。没找到就返回-1.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">10</span>&#125;;</div><div class="line">target = <span class="number">3</span>;</div><div class="line"></div><div class="line"><span class="keyword">return</span> <span class="number">2</span>;</div><div class="line"></div><div class="line">模板：</div><div class="line"></div><div class="line"><span class="keyword">int</span> start = <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> end = nums.length - <span class="number">1</span>;</div><div class="line"><span class="keyword">int</span> mid;</div><div class="line"><span class="comment">// 注意while结束的判断</span></div><div class="line"><span class="comment">// start - end 小于两个数时</span></div><div class="line"><span class="keyword">while</span>( start + <span class="number">1</span> &lt; end )&#123;</div><div class="line">  mid = start + ( end - start )/<span class="number">2</span>; <span class="comment">// 这样防止Integer溢出</span></div><div class="line">  <span class="keyword">if</span>( nums[mid] == target )&#123;</div><div class="line">    end = mid;</div><div class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>( nums[mid] &lt; target )&#123;</div><div class="line">    start = mid;</div><div class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>( nums[mid] &gt; target )&#123;</div><div class="line">    end = mid;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span>( nums[start] == target )&#123;</div><div class="line">  <span class="keyword">return</span> start;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span>( nums[end] == target )&#123;</div><div class="line">  <span class="keyword">return</span> end;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> -<span class="number">1</span>;</div></pre></td></tr></table></figure>
<p>变体：输出最后一次index</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">mid = [start + end ] / <span class="number">2</span> = <span class="number">8</span>/<span class="number">2</span> = <span class="number">4</span></div><div class="line">  </div><div class="line">    start        mid         end</div><div class="line">      ↓           ↓           ↓</div><div class="line">index <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span></div><div class="line">nums  <span class="number">3</span>  <span class="number">3</span>  <span class="number">3</span>  <span class="number">3</span>  <span class="number">3</span>  <span class="number">3</span>  <span class="number">3</span>  <span class="number">3</span>  <span class="number">3</span></div><div class="line"></div><div class="line">由于需要last，所以把start 置为 <span class="function">mid</span></div><div class="line"></div><div class="line"><span class="title">while</span><span class="params">( start + <span class="number">1</span> &lt; end )</span>&#123;</div><div class="line">  mid = start + ( end - start )/<span class="number">2</span>; </div><div class="line">  <span class="keyword">if</span>( nums[mid] == target )&#123;</div><div class="line">    start = mid; <span class="comment">// 变</span></div><div class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>( nums[mid] &lt; target )&#123;</div><div class="line">    start = mid;</div><div class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>( nums[mid] &gt; target )&#123;</div><div class="line">    end = mid;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span>( nums[end] == target )&#123; <span class="comment">//先</span></div><div class="line">  <span class="keyword">return</span> end;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span>( nums[start] == target )&#123;</div><div class="line">  <span class="keyword">return</span> start;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">return</span> -<span class="number">1</span>;</div></pre></td></tr></table></figure>
<h2 id="例题2，Search-for-a-range">2.2. 例题2，Search for a range</h2><p>给一个int[] nums = {5,7,7,8,8,10],找到target=8出现的范围[3,4]。没找到就返回[-1,-1].</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line">思路一，写两个二分，搜两次。先搜start，再搜end</div><div class="line">时间复杂度:<span class="number">2l</span>og(n)</div><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</div><div class="line">        <span class="keyword">int</span>[] range = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</div><div class="line">        range[<span class="number">0</span>] = -<span class="number">1</span> ; range[<span class="number">1</span>] = -<span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span>( nums.length == <span class="number">0</span> ) <span class="keyword">return</span> range;</div><div class="line">        <span class="comment">//找first</span></div><div class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = nums.length - <span class="number">1</span> ,mid = -<span class="number">1</span>,foundIdx = -<span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> ( start + <span class="number">1</span> &lt; end )&#123;</div><div class="line">            mid = start + ( end - start )/<span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span>( nums[mid] &lt; target )&#123;</div><div class="line">                start = mid;</div><div class="line">            &#125;<span class="keyword">else</span> &#123;</div><div class="line">                end = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>( nums[start] == target )&#123;</div><div class="line">            foundIdx = start;</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>( nums[end] == target )&#123;</div><div class="line">            foundIdx = end;</div><div class="line">        &#125;</div><div class="line">        range[<span class="number">0</span>] = foundIdx;</div><div class="line">        <span class="comment">//找last</span></div><div class="line">        start = <span class="number">0</span>;end = nums.length - <span class="number">1</span>;mid = -<span class="number">1</span>;foundIdx = -<span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> ( start + <span class="number">1</span> &lt; end )&#123;</div><div class="line">            mid = start + ( end - start )/<span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span>( nums[mid] &lt;= target )&#123;</div><div class="line">                start = mid;</div><div class="line">            &#125;<span class="keyword">else</span> &#123;</div><div class="line">                end = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>( nums[end] == target )&#123;</div><div class="line">            foundIdx = end;</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>( nums[start] == target )&#123;</div><div class="line">            foundIdx = start;</div><div class="line">        &#125;</div><div class="line">        range[<span class="number">1</span>] = foundIdx;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> range;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">思路二，找到后++--</div><div class="line">复杂度O(logn) + O(L) </div><div class="line">最坏情况下O(logn) + O(n)</div><div class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</div><div class="line">        <span class="keyword">int</span>[] range = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</div><div class="line">        range[<span class="number">0</span>] = -<span class="number">1</span> ; range[<span class="number">1</span>] = -<span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span>( nums.length == <span class="number">0</span> ) <span class="keyword">return</span> range;</div><div class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = nums.length - <span class="number">1</span> ,mid = <span class="number">0</span>;</div><div class="line">        <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">while</span> ( start + <span class="number">1</span> &lt; end )&#123;</div><div class="line">            mid = start + ( end - start )/<span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span>( nums[mid] == target )&#123;</div><div class="line">                found = <span class="keyword">true</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>( nums[mid] &lt; target )&#123;</div><div class="line">                start = mid;</div><div class="line">            &#125;<span class="keyword">else</span> &#123;</div><div class="line">                end = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>( nums[start] == target )&#123;</div><div class="line">            found = <span class="keyword">true</span>;</div><div class="line">            mid = start;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>( nums[end] == target )&#123;</div><div class="line">            found = <span class="keyword">true</span>;</div><div class="line">            mid = end;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(found == <span class="keyword">true</span>) &#123; <span class="comment">//如果找到了</span></div><div class="line">            start = mid - <span class="number">1</span>;</div><div class="line">            end = mid + <span class="number">1</span>;</div><div class="line">            <span class="keyword">while</span> (start &gt;= <span class="number">0</span> &amp;&amp; nums[start] == target) &#123;</div><div class="line">                --start;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">while</span> (end &lt; nums.length &amp;&amp; nums[end] == target) &#123;</div><div class="line">                ++end;</div><div class="line">            &#125;</div><div class="line">            range[<span class="number">0</span>] = ++start;</div><div class="line">            range[<span class="number">1</span>] = --end;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> range;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="例题3，Search-Insert-Position">2.3. 例题3，Search Insert Position</h2><p>给一个有序无重数组nums = [1,3,5,6],把target=5插入，问插入的位置=2。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">插入位置 = 第一个大于或等于的位置 （较方便）</div><div class="line">	    = 最后一个比它小的位置</div><div class="line">	    </div><div class="line">方法一：</div><div class="line"><span class="keyword">while</span>( start + <span class="number">1</span> &lt; end )&#123;</div><div class="line">  mid = start + ( end - start )/<span class="number">2</span>; <span class="comment">// 这样防止Integer溢出</span></div><div class="line">  <span class="keyword">if</span>( nums[mid] == target )&#123;</div><div class="line">    <span class="keyword">return</span> mid;</div><div class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>( nums[mid] &lt; target )&#123;</div><div class="line">    start = mid;</div><div class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>( nums[mid] &gt; target )&#123;</div><div class="line">    end = mid;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span>( nums[start] &gt;= target )&#123;</div><div class="line">  <span class="keyword">return</span> start;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span>( nums[end] &gt;= target )&#123;</div><div class="line">  <span class="keyword">return</span> end;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> end + <span class="number">1</span>; <span class="comment">// 没有解 ，此时end = length</span></div><div class="line"></div><div class="line">代码：</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">        <span class="comment">//找到第一个大于或等于target的数</span></div><div class="line">        <span class="keyword">int</span> start = <span class="number">0</span> , end = nums.length - <span class="number">1</span>,mid;</div><div class="line">        <span class="keyword">while</span> ( start + <span class="number">1</span> &lt; end )&#123;</div><div class="line">            mid = start + ( end - start )/<span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span>( nums[mid] &lt; target )&#123;</div><div class="line">                start = mid;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                end = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>( target &lt;= nums[start] )&#123;<span class="comment">//[1,3] -&gt; 0 / 1</span></div><div class="line">            <span class="keyword">return</span> start;</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>( target &lt;= nums[end] )&#123;<span class="comment">//[1,3] -&gt; 2 / 3</span></div><div class="line">            <span class="keyword">return</span> end;</div><div class="line">        &#125;<span class="keyword">else</span> &#123;<span class="comment">//[1,3] -&gt; 4...</span></div><div class="line">            <span class="keyword">return</span> end+<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="例题4，Search-a-2D-Matrix">2.4. 例题4，Search a 2D Matrix</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">严格递增的Matrix</div><div class="line">[</div><div class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>],</div><div class="line">  [<span class="number">10</span>,<span class="number">11</span>,<span class="number">16</span>,<span class="number">20</span>],</div><div class="line">  [<span class="number">23</span>,<span class="number">30</span>,<span class="number">34</span>,<span class="number">50</span>]</div><div class="line">]</div><div class="line">give target = <span class="number">3</span> , <span class="keyword">return</span> <span class="keyword">true</span></div><div class="line">  </div><div class="line">思路一：先行后列</div><div class="line"></div><div class="line">思路二：看成一维的</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>( matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span> )&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> n = matrix.length;</div><div class="line">        <span class="keyword">int</span> m = matrix[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">int</span> start = <span class="number">0</span>,end = m * n -<span class="number">1</span>,mid,r,c;</div><div class="line">        <span class="keyword">while</span> ( start + <span class="number">1</span> &lt; end )&#123;</div><div class="line">            mid = start + ( end - start )/<span class="number">2</span>;</div><div class="line">            c = mid % m ;</div><div class="line">            r = mid / m ;</div><div class="line">            <span class="keyword">if</span>( matrix[r][c] == target )&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>( matrix[r][c] &gt; target )&#123;</div><div class="line">                end = mid;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                start = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>( matrix[start/m][start%m] == target )&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>( matrix[end/m][end%m] == target )&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="例题5，Search-a-2D-Matrix-II">2.5. 例题5，Search a 2D Matrix II</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">非严格递增</div><div class="line">[</div><div class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>],</div><div class="line">  [<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">8</span>],</div><div class="line">  [<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">10</span>]</div><div class="line">]</div><div class="line">target = <span class="number">3</span></div><div class="line"><span class="keyword">return</span> target出现的次数 = <span class="number">2</span></div></pre></td></tr></table></figure>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-11-24-15-24-37.png" alt=""> </p>
<ul>
<li>如果这个数比120小，就向右走</li>
<li>如果这个数比120大，就向上走</li>
</ul>
<h2 id="例题6，First-Bad-Version">2.6. 例题6，First Bad Version</h2><p>代码库的版本号是从 1 到 <em>n</em> 的整数。某一天，有人提交了错误版本的代码，因此造成自身及之后版本的代码在单元测试中均出错。请找出第一个错误的版本号。</p>
<p>你可以通过 <code>isBadVersion</code> 的接口来判断版本号 version 是否在单元测试中出错，具体接口详情和调用方法请见代码的注释部分。</p>
<p><strong>注意事项</strong></p>
<p>请阅读上述代码，对于不同的语言获取正确的调用 <em>isBadVersion</em> 的方法，比如java的调用方式是<code>SVNRepo.isBadVersion(v)</code></p>
<p><strong>样例</strong></p>
<p>给出 <code>n=5</code></p>
<p>调用<code>isBadVersion(3)</code>，得到<code>false</code></p>
<p>调用<code>isBadVersion(5)</code>，得到<code>true</code></p>
<p>调用<code>isBadVersion(4)</code>，得到<code>true</code></p>
<p>此时我们可以断定<code>4</code>是第一个错误的版本号</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> start = <span class="number">1</span>, end = n;</div><div class="line"><span class="keyword">while</span>( start + <span class="number">1</span> &lt; end )&#123;</div><div class="line">  <span class="keyword">int</span> mid = ( start + end ) / <span class="number">2</span>;</div><div class="line">  <span class="keyword">if</span>( VersionControl.isBadVersion(mid) )&#123;</div><div class="line">    end = mid;</div><div class="line">  &#125;<span class="keyword">else</span>&#123;</div><div class="line">    start = mid + <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span>( VersionControl.isBadVersion( start ) )&#123;</div><div class="line">  <span class="keyword">return</span> start;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> end;</div><div class="line"></div><div class="line">代码：</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> start = <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> end = n;</div><div class="line">        <span class="keyword">int</span> mid;</div><div class="line">        <span class="keyword">while</span>( start + <span class="number">1</span> &lt; end )&#123;</div><div class="line">            mid = start + ( end - start ) / <span class="number">2</span> ;</div><div class="line">            <span class="keyword">if</span>( isBadVersion(mid) )&#123;</div><div class="line">                end = mid;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                start = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>( isBadVersion(start) )&#123;</div><div class="line">            <span class="keyword">return</span> start;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>( isBadVersion(end) )&#123;</div><div class="line">            <span class="keyword">return</span> end;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="例题7，Find-Peak-Element">2.7. 例题7，Find Peak Element</h2><p>给一个数组。找峰值。相邻两个数都不一样。如果有多个峰值，就随便输出一个。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">6</span>] -&gt; <span class="keyword">return</span> index <span class="number">1</span> or <span class="number">6</span></div><div class="line"> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span></div><div class="line">  </div><div class="line">二分，确定一个mid，找到策略——怎样向左走，怎样向右走</div><div class="line"></div><div class="line">start - left - mid - right - end</div><div class="line"></div><div class="line"><span class="keyword">if</span> left &lt; mid &gt; right -&gt; mid 是峰值</div><div class="line"></div><div class="line"><span class="keyword">else</span> left &lt; mid &lt; right -&gt; 峰值在右边 , start = mid</div><div class="line"></div><div class="line"><span class="keyword">else</span> left &gt; mid &gt; right -&gt; 峰值在左边 , end = mid</div><div class="line"></div><div class="line"><span class="keyword">else</span> left &gt; mid &lt; right -&gt; 两边都有可能 , 随意了</div><div class="line"></div><div class="line">代码:</div><div class="line"><span class="keyword">int</span>[] nums;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getNums</span><span class="params">(<span class="keyword">int</span> idx)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>( idx &lt; <span class="number">0</span> ) <span class="keyword">return</span> -Integer.MAX_VALUE;</div><div class="line">  <span class="keyword">if</span>( idx == nums.length ) <span class="keyword">return</span> -Integer.MAX_VALUE;</div><div class="line">  <span class="keyword">return</span> nums[idx];</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">  <span class="keyword">this</span>.nums = nums;</div><div class="line">  <span class="keyword">int</span> start = <span class="number">0</span>, end = nums.length - <span class="number">1</span>,mid;</div><div class="line">  <span class="keyword">while</span> ( start + <span class="number">1</span> &lt; end )&#123;</div><div class="line">    mid = start + ( end - start ) / <span class="number">2</span>;</div><div class="line">    <span class="comment">//查看mid的导数</span></div><div class="line">    <span class="keyword">if</span>( getNums(mid) &gt; getNums(mid-<span class="number">1</span>))&#123;</div><div class="line">      <span class="keyword">if</span>( getNums(mid) &gt; getNums(mid+<span class="number">1</span>))&#123;</div><div class="line">        <span class="keyword">return</span> mid;</div><div class="line">      &#125;<span class="keyword">else</span> &#123;</div><div class="line">        start = mid;</div><div class="line">      &#125;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">      end = mid;</div><div class="line">      <span class="comment">//合并下面两步</span></div><div class="line">      <span class="comment">// if(getNums(mid) &lt; getNums(mid+1))&#123;</span></div><div class="line">      <span class="comment">//    end = mid;</span></div><div class="line">      <span class="comment">//  &#125;else &#123;</span></div><div class="line">      <span class="comment">//    end = mid;</span></div><div class="line">      <span class="comment">//  &#125;</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>( getNums(start) &gt; getNums(end) )&#123;</div><div class="line">    <span class="keyword">return</span> start;</div><div class="line">  &#125;<span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> end;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>思考：如果有相邻两个数一样？ 就只能$O(n)$</p>
<h2 id="例题8，Find-Minimum-in-rotated-sorted-array">2.8. 例题8，Find Minimum in rotated sorted array</h2><p>找有序旋转数组（首位相接）中的最小值。数组中不存在重复元素。</p>
<p>就是在两段上升区间, 找到第一个x。</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-11-27-15-50-02.png" alt=""> </p>
<p>假设mid在左边的某地方（例如5），那么问题转换为较小区间的原问题–&gt; start = mid</p>
<p>假设mid在右边的某地方（例如1），那么问题转换为较小区间的原问题–&gt; end = mid</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span></div><div class="line">          </div><div class="line">        |-<span class="number">5</span>-|</div><div class="line">    |-<span class="number">4</span>-|   |      </div><div class="line">|-<span class="number">3</span>-|   |   |       |-<span class="number">2</span>-|</div><div class="line">|   |   |   |   |-<span class="number">1</span>-|   |</div><div class="line">|   |   |   |-<span class="number">0</span>-|   |   |</div><div class="line">              ↑ </div><div class="line">             要它</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> start = <span class="number">0</span>, end = nums.length - <span class="number">1</span>,mid;</div><div class="line">  <span class="comment">//顺序情况</span></div><div class="line">  <span class="keyword">if</span>( nums[start] &lt; nums[end] )<span class="keyword">return</span> nums[start];</div><div class="line">  <span class="comment">//旋转情况</span></div><div class="line">  <span class="keyword">while</span> ( start + <span class="number">1</span> &lt; end )&#123;</div><div class="line">      mid = start + ( end - start ) / <span class="number">2</span>;</div><div class="line">      <span class="keyword">if</span>( nums[mid] &gt; nums[start] )&#123;</div><div class="line">          start = mid;</div><div class="line">      &#125;<span class="keyword">else</span>&#123;</div><div class="line">          end = mid;</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>( nums[start] &lt; nums[end] )&#123;</div><div class="line">      <span class="keyword">return</span> nums[start];</div><div class="line">  &#125;<span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> nums[end];</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="例题9，Find-Minimum-in-rotated-sorted-array-II">2.9. 例题9，Find Minimum in rotated sorted array II</h2><p>找有序旋转数组（首位相接）中的最小值。数组中可能存在重复元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="number">4</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span></div><div class="line"></div><div class="line">不可以用二分</div><div class="line"></div><div class="line">因为并不确定是向左还是向右走</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="comment">// 1,1,2,3,4,0,0</span></div><div class="line">        <span class="keyword">if</span>( nums.length == <span class="number">0</span> )&#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>( nums.length == <span class="number">1</span> )&#123;</div><div class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//顺序情况</span></div><div class="line">        <span class="keyword">if</span>( nums[<span class="number">0</span>] &lt; nums[nums.length-<span class="number">1</span>] )&#123;</div><div class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//旋转情况</span></div><div class="line">        <span class="keyword">int</span> i = nums.length - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i-<span class="number">1</span>] &lt;= nums[i] )&#123;</div><div class="line">            --i;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> nums[i];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">其实也可以用二分！</div></pre></td></tr></table></figure>
<h2 id="例题10，Search-in-Rotated-Sorted-Array">2.10. 例题10，Search in Rotated Sorted Array</h2><p>从有序旋转数组（首位相接）中找target。数组中不存在重复元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line"><span class="number">1</span>. mid在第一段上升区间</div><div class="line">  <span class="keyword">if</span> S &lt; T &lt; mid -&gt; end = mid</div><div class="line">  <span class="keyword">if</span> T &gt; M       -&gt; start = end 任然是一个rotated sorted array</div><div class="line">  ...</div><div class="line"><span class="number">2</span>. ....</div><div class="line">    </div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>( nums.length == <span class="number">0</span> ) <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, end = nums.length - <span class="number">1</span>,mid;</div><div class="line">    <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end)&#123;</div><div class="line">      mid = start + ( end - start ) / <span class="number">2</span>;</div><div class="line">      <span class="keyword">if</span>( nums[mid] == target ) <span class="keyword">return</span> mid;</div><div class="line">      <span class="keyword">if</span>( target &gt;= nums[<span class="number">0</span>] ) &#123; <span class="comment">// target在前半段</span></div><div class="line">        <span class="keyword">if</span>( nums[mid] &gt; nums[<span class="number">0</span>] )&#123;<span class="comment">//mid在前半段</span></div><div class="line">          <span class="keyword">if</span>( nums[mid] &gt; target )&#123;</div><div class="line">            end = mid;</div><div class="line">          &#125;<span class="keyword">else</span> &#123;</div><div class="line">            start = mid;</div><div class="line">          &#125;</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">          end = mid;</div><div class="line">        &#125;</div><div class="line">      &#125;<span class="keyword">else</span> &#123; <span class="comment">//target在后半段</span></div><div class="line">        <span class="keyword">if</span>( nums[mid] &lt; nums[<span class="number">0</span>] )&#123; <span class="comment">// mid在后半段</span></div><div class="line">          <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</div><div class="line">            end = mid;</div><div class="line">          &#125;<span class="keyword">else</span> &#123;</div><div class="line">            start = mid;</div><div class="line">          &#125;</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">          start = mid;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>( nums[start] == target )&#123;</div><div class="line">      <span class="keyword">return</span> start;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>( nums[end] == target )&#123;</div><div class="line">      <span class="keyword">return</span> end;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h2 id="例题11，Search-in-Rotated-Sorted-Array-II">2.11. 例题11，Search in Rotated Sorted Array II</h2><p>从有序旋转数组（首位相接）中找target。数组中可能存在重复元素。</p>
<p>只能for循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">这题最简单的就是暴力<span class="keyword">for</span>循环</div><div class="line">还有一种巧妙的二分法：</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span>( nums.length == <span class="number">0</span> ) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, end = nums.length - <span class="number">1</span>,mid;</div><div class="line">    <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end)&#123;</div><div class="line">    	mid = start + ( end - start ) / <span class="number">2</span>;</div><div class="line">        <span class="keyword">if</span>( nums[mid] == target || target == nums[start])</div><div class="line">        	<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">if</span>( nums[mid] == nums[start] )&#123;</div><div class="line">        	++start ;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// target在前半段、mid也在前半段</span></div><div class="line">        <span class="keyword">if</span>( target &gt; nums[<span class="number">0</span>] &amp;&amp; nums[mid] &gt; nums[<span class="number">0</span>] ||</div><div class="line">        <span class="comment">//target在后半段，mid也在后半段</span></div><div class="line">            target &lt; nums[<span class="number">0</span>]  &amp;&amp; nums[mid] &lt; nums[<span class="number">0</span>]) &#123;</div><div class="line">            	<span class="keyword">if</span>( nums[mid] &gt; target )&#123;</div><div class="line">                	end = mid;</div><div class="line">                 &#125;<span class="keyword">else</span> &#123;</div><div class="line">                 	start = mid;</div><div class="line">                 &#125;</div><div class="line">         &#125;</div><div class="line">         <span class="comment">//target在前半段，但mid在后半段</span></div><div class="line">         <span class="keyword">else</span> <span class="keyword">if</span>( target &gt; nums[<span class="number">0</span>] &amp;&amp; nums[mid] &lt; nums[<span class="number">0</span>])&#123;</div><div class="line">         	end = mid;</div><div class="line">         &#125;</div><div class="line">         <span class="comment">//target在后半段，但mid在前半段</span></div><div class="line">         <span class="keyword">else</span> <span class="keyword">if</span>(target &lt; nums[<span class="number">0</span>] &amp;&amp; nums[mid] &gt; nums[<span class="number">0</span>])&#123;</div><div class="line">             start = mid;</div><div class="line">         &#125;<span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span>( nums[start] == target || nums[end] == target)&#123;</div><div class="line">   	<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="例题12，Merge-Sorted-Array">2.12. 例题12，Merge Sorted Array</h2><p>给两个排序数组，将它两合并为一个排序数组。</p>
<h2 id="例题13，Merge-Sorted-Array-II">2.13. 例题13，Merge Sorted Array II</h2><p>给两个排序数组，A,B，将B合并进A。</p>
<p>思路：从大的入手。</p>
<h2 id="例题14，Median-of-two-Sorted-Arrays">2.14. 例题14，Median of two Sorted Arrays</h2><p>找到两个有序数组的中位数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">A = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>] , B = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]  -&gt; median = <span class="number">3.5</span></div><div class="line"></div><div class="line">A = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] , B = [<span class="number">4</span>,<span class="number">5</span>]  -&gt; median = <span class="number">3</span></div></pre></td></tr></table></figure>
<p>类似题：find Kth of two Sorted Arrays - 先解决这个</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div></pre></td><td class="code"><pre><div class="line">A = <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span></div><div class="line">B = <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span></div><div class="line">  </div><div class="line">最暴力：依次寻找，到K -&gt; O(K)</div><div class="line"></div><div class="line">优化：</div><div class="line"></div><div class="line">先找A的[k/<span class="number">2</span>]的数</div><div class="line">    B的[k/<span class="number">2</span>]的数</div><div class="line">    </div><div class="line"><span class="keyword">if</span> A[k/<span class="number">2</span>] &lt;= B[k/<span class="number">2</span>]</div><div class="line">	A的前k/<span class="number">2</span>个数都小于【合并后的前K个数】</div><div class="line">	既然如此，就从A[k/<span class="number">2</span> + <span class="number">1</span>] &amp; B[<span class="number">0</span>]开始找 ，从剩下的里找Top[k - k/<span class="number">2</span>]</div><div class="line">	</div><div class="line">O(logk) ! 震惊！</div><div class="line"></div><div class="line">代码非常复杂。。。</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findKthSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2,<span class="keyword">int</span> k,<span class="keyword">int</span> s_n1,<span class="keyword">int</span> s_n2)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span>( s_n1 &gt;= nums1.length )&#123;</div><div class="line">           <span class="keyword">return</span> nums2[s_n2 + k];</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span>( s_n2 &gt;= nums2.length )&#123;</div><div class="line">           <span class="keyword">return</span> nums1[s_n1 + k];</div><div class="line">       &#125;</div><div class="line">        <span class="keyword">if</span>( k == <span class="number">0</span> )&#123;</div><div class="line">           <span class="keyword">if</span>( nums1[s_n1] &gt; nums2[s_n2] )&#123;</div><div class="line">               <span class="keyword">return</span> nums2[s_n2];</div><div class="line">           &#125;<span class="keyword">else</span> &#123;</div><div class="line">               <span class="keyword">return</span> nums1[s_n1];</div><div class="line">           &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>( k == <span class="number">1</span> )&#123;</div><div class="line">            <span class="keyword">if</span>( nums1[s_n1] &lt; nums2[s_n2] )&#123;</div><div class="line">                <span class="keyword">return</span> findKthSortedArrays(nums1,nums2,<span class="number">0</span>,s_n1+<span class="number">1</span>,s_n2);</div><div class="line">            &#125;<span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> findKthSortedArrays(nums1,nums2,<span class="number">0</span>,s_n1,s_n2+<span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">         <span class="comment">// 全部溢出</span></div><div class="line">        <span class="keyword">if</span>( s_n1 + k/<span class="number">2</span> &gt;= nums1.length &amp;&amp; s_n2 + k/<span class="number">2</span> &gt;= nums2.length )&#123;</div><div class="line">            <span class="keyword">if</span>(nums1[nums1.length-<span class="number">1</span>] &lt; nums2[nums2.length - <span class="number">1</span>])&#123;</div><div class="line">                k -= nums1.length - s_n1;</div><div class="line">                s_n1 = nums1.length;</div><div class="line">            &#125;<span class="keyword">else</span> &#123;</div><div class="line">                k -= nums2.length - s_n2;</div><div class="line">                s_n2 = nums2.length;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">          <span class="comment">// 部分溢出</span></div><div class="line">            <span class="keyword">if</span> (s_n1 + k / <span class="number">2</span> &gt;= nums1.length) &#123;</div><div class="line">                <span class="keyword">if</span> (nums1[nums1.length - <span class="number">1</span>] &lt; nums2[s_n2 + k / <span class="number">2</span>]) &#123;</div><div class="line">                    k -= nums1.length - s_n1;</div><div class="line">                    s_n1 = nums1.length;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    s_n2 += k / <span class="number">2</span>;</div><div class="line">                    k -= k/<span class="number">2</span>;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s_n2 + k / <span class="number">2</span> &gt;= nums2.length) &#123;</div><div class="line">                <span class="keyword">if</span> (nums2[nums2.length - <span class="number">1</span>] &lt; nums1[s_n1 + k / <span class="number">2</span>]) &#123;</div><div class="line">                    k -= nums2.length - s_n2;</div><div class="line">                    s_n2 = nums2.length;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    s_n1 += k / <span class="number">2</span>;</div><div class="line">                    k -= k/<span class="number">2</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 正常情况</span></div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (nums1[s_n1 + k / <span class="number">2</span>] &gt; nums2[s_n2 + k / <span class="number">2</span>]) &#123;</div><div class="line">                    s_n2 += k / <span class="number">2</span>;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    s_n1 += k / <span class="number">2</span>;</div><div class="line">                &#125;</div><div class="line">                k -= k / <span class="number">2</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> findKthSortedArrays(nums1,nums2,k,s_n1,s_n2);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> s_n1 = <span class="number">0</span>,s_n2 = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> k = (nums1.length + nums2.length);</div><div class="line">        <span class="keyword">if</span>( k % <span class="number">2</span> == <span class="number">0</span> )&#123;</div><div class="line">            <span class="keyword">double</span> a = findKthSortedArrays(nums1,nums2,k/<span class="number">2</span>,s_n1,s_n2);</div><div class="line">            <span class="keyword">double</span> b = findKthSortedArrays(nums1,nums2,k/<span class="number">2</span>-<span class="number">1</span>,s_n1,s_n2);</div><div class="line">            <span class="keyword">return</span> (a+b)/<span class="number">2</span>;</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> findKthSortedArrays(nums1,nums2,k/<span class="number">2</span>,s_n1,s_n2);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[算法-DFS]]></title>
      <url>/2017/11/21/%E7%AE%97%E6%B3%95-DFS/</url>
      <content type="html"><![CDATA[<p> 记了点自己有问题的题目</p>
<a id="more"></a>
<h1 id="LeetCode题">1. LeetCode题</h1><h2 id="Word-Break-II">1.1. Word Break II</h2><p>给一个str s和一个str[] dict,输出所有s可能被dict拼接的组合。例如</p>
<p><em>s</em> = <code>&quot;catsanddog&quot;</code>,<br><em>dict</em> = <code>[&quot;cat&quot;, &quot;cats&quot;, &quot;and&quot;, &quot;sand&quot;, &quot;dog&quot;]</code>.</p>
<p>A solution is <code>[&quot;cats and dog&quot;, &quot;cat sand dog&quot;]</code>.</p>
<p>一开始我的想法是用DFS维护一个栈，再用Trie优化字符串检索。可惜这种方式会超时。看了别人的代码，就感觉自己宛如一个智障。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">用刀在字符串中切一刀。左边是i个字符，右边是len-i个字符。</div><div class="line"></div><div class="line">|=======前i个位置=======|</div><div class="line">  </div><div class="line">|----------|----------|</div><div class="line">|<span class="number">1</span>,<span class="number">2</span>,....,i|i+<span class="number">1</span>,..,len|</div><div class="line">|----------|----------|</div><div class="line"></div><div class="line">如果：左边是字典里的词，右边是可以wordbreak的，那么把左边的字符串加到右边算出来的List中，生成新的list返回。</div><div class="line"></div><div class="line">边界条件：</div><div class="line"><span class="number">1</span>. 当输入字符串为空的时候，应该给出一个空解。这个很重要，否则这个递归是不能运行的。</div><div class="line"><span class="number">2</span>. 递归时i应该从<span class="number">1</span>开始递归，因为我们要把这个问题分解为<span class="number">2</span>个部分，如果你左边给<span class="number">0</span>，那就是死循环。</div><div class="line"></div><div class="line">记忆：</div><div class="line">为了加快DFS的速度，我们应该添加记忆，也就是说，算过的字符串不要再重复计算。举例子：</div><div class="line">apple n feng</div><div class="line">app len feng</div><div class="line">如果存在以上<span class="number">2</span>种划分，那么feng这个字符串会被反复计算，在这里至少计算了<span class="number">2</span>次。我们使用一个Hashmap把对应字符串的解记下来，这样就能避免重复的计算。 否则这一道题目会超时。</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">wordBreak</span><span class="params">(String s, Set&lt;String&gt; wordDict)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> DFS(s, wordDict, <span class="keyword">new</span> HashMap&lt;String, LinkedList&lt;String&gt;&gt;());</div><div class="line">&#125;       </div><div class="line"></div><div class="line"><span class="comment">// DFS function returns an array including all substrings derived from s.</span></div><div class="line"><span class="function">List&lt;String&gt; <span class="title">DFS</span><span class="params">(String s, Set&lt;String&gt; wordDict, HashMap&lt;String, LinkedList&lt;String&gt;&gt;map)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (map.containsKey(s)) </div><div class="line">        <span class="keyword">return</span> map.get(s);</div><div class="line">        </div><div class="line">    LinkedList&lt;String&gt;res = <span class="keyword">new</span> LinkedList&lt;String&gt;();     </div><div class="line">    <span class="keyword">if</span> (s.length() == <span class="number">0</span>) &#123; <span class="comment">// 给出一个空解</span></div><div class="line">        res.add(<span class="string">""</span>);</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;               </div><div class="line">    <span class="keyword">for</span> (String word : wordDict) &#123;</div><div class="line">        <span class="keyword">if</span> (s.startsWith(word)) &#123;<span class="comment">//如果左边是字典里的词</span></div><div class="line">            List&lt;String&gt;sublist = DFS(s.substring(word.length()), wordDict, map);<span class="comment">//如果有返回值，就会加入res里</span></div><div class="line">            <span class="keyword">for</span> (String sub : sublist) </div><div class="line">                res.add(word + (sub.isEmpty() ? <span class="string">""</span> : <span class="string">" "</span>) + sub);               </div><div class="line">        &#125;</div><div class="line">    &#125;       </div><div class="line">    map.put(s, res);</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Palindrome-Partitioning">1.2. Palindrome Partitioning</h2><p>给一个str，输出它所有的可能的回文子串。</p>
<p>For example, given <em>s</em> = <code>&quot;aab&quot;</code>,Return</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  [&quot;aa&quot;,&quot;b&quot;],</div><div class="line">  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]</div><div class="line">]</div></pre></td></tr></table></figure>
<p>这道题我借鉴了上一题的解法，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line">用刀在字符串中切一刀。左边是i个字符，右边是len-i个字符。</div><div class="line"></div><div class="line">|=======前i个位置=======|</div><div class="line">  </div><div class="line">|----------|----------|</div><div class="line">|<span class="number">1</span>,<span class="number">2</span>,....,i|i+<span class="number">1</span>,..,len|</div><div class="line">|----------|----------|</div><div class="line"></div><div class="line">如果：左边是回文序列，那就先把左边的放着。先算右边。最后把左边的str加到右边list中的每个结果前，再返回即可。</div><div class="line"></div><div class="line">记忆：</div><div class="line">同时也保存了一个hash表，存储第i位置之后的所有回文组合方式。</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    HashMap&lt;Integer,List&lt;List&lt;String&gt;&gt;&gt; map;</div><div class="line">    <span class="keyword">boolean</span>[][] ifPalindrome; <span class="comment">//存储从i到j是否是回文序列</span></div><div class="line">    <span class="comment">//计算从i到j是否是回文序列</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[][] palindrome(<span class="keyword">char</span>[] c)&#123;</div><div class="line">        <span class="keyword">int</span> n = c.length;</div><div class="line">        <span class="keyword">boolean</span>[][] ifPalindrome = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</div><div class="line">        <span class="comment">// i 从n开始下降</span></div><div class="line">        <span class="comment">// j 从i开始到n</span></div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span> ; --i )&#123;</div><div class="line">            ifPalindrome[i][i] = <span class="keyword">true</span>;</div><div class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = i+<span class="number">1</span> ; j &lt; n ; ++j )&#123;</div><div class="line">                <span class="keyword">if</span>( c[i] == c[j] )&#123;</div><div class="line">                    ifPalindrome[i][j] = j == i + <span class="number">1</span> || j == i + <span class="number">2</span> || ifPalindrome[i+<span class="number">1</span>][j-<span class="number">1</span>];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        ifPalindrome[n-<span class="number">1</span>][n-<span class="number">1</span>] = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">return</span> ifPalindrome;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//深度优先遍历</span></div><div class="line">    <span class="keyword">private</span> List&lt;List&lt;String&gt;&gt; dfs(<span class="keyword">char</span>[] c,<span class="keyword">int</span> start,<span class="keyword">int</span> n)&#123;</div><div class="line">        List&lt;List&lt;String&gt;&gt; thisResult = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        <span class="keyword">if</span>( start == n ) <span class="keyword">return</span> thisResult;</div><div class="line">        <span class="keyword">if</span>( map.containsKey(start) )</div><div class="line">            <span class="keyword">return</span> map.get(start);</div><div class="line"></div><div class="line">        StringBuilder strBuilder = <span class="keyword">new</span> StringBuilder();</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = start  ; j &lt; n ; ++j )&#123;</div><div class="line">            strBuilder.append(c[j]);</div><div class="line">            <span class="comment">// start ,....,j,.....,end</span></div><div class="line">            <span class="comment">//如果从start到j是回文序列</span></div><div class="line">            <span class="keyword">if</span>( ifPalindrome[start][j] )&#123;</div><div class="line">                String preString = strBuilder.toString();<span class="comment">//start...j的str</span></div><div class="line">                List&lt;List&lt;String&gt;&gt; afterResult = dfs(c,j+<span class="number">1</span>,n);<span class="comment">//从j+1到n的所有回文串组合</span></div><div class="line">                <span class="keyword">if</span>( afterResult.size() == <span class="number">0</span> )&#123; <span class="comment">// preString是末尾元素，且它本身就是回文序列</span></div><div class="line">                        List&lt;String&gt; elementUnit = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">                        elementUnit.add(preString);</div><div class="line">                        thisResult.add(elementUnit);</div><div class="line">                        <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// preString是前缀，且它本身就是回文序列</span></div><div class="line">                <span class="keyword">for</span>( List&lt;String&gt; oneAfterResult : afterResult )&#123;</div><div class="line">                    List&lt;String&gt; unitResult = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">                    unitResult.add(preString);</div><div class="line">                    <span class="keyword">for</span>( String e : oneAfterResult )&#123;</div><div class="line">                        unitResult.add(e);</div><div class="line">                    &#125;</div><div class="line">                    thisResult.add(unitResult);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        map.put(start,thisResult);</div><div class="line">        <span class="keyword">return</span> thisResult;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="comment">//分割主函数</span></div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</div><div class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        ifPalindrome = palindrome(s.toCharArray());</div><div class="line">        List&lt;List&lt;String&gt;&gt; res =  dfs( s.toCharArray(), <span class="number">0</span>, s.length() );</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Minesweeper">1.3. Minesweeper</h2><p>扫雷题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">E : 没打开的地方</div><div class="line">M : 没打开的雷</div><div class="line">B : 打开了，周围没有雷</div><div class="line">数字<span class="number">1</span>-<span class="number">8</span> ： 打开了，周围有k个雷</div><div class="line">X: 打开了的雷</div></pre></td></tr></table></figure>
<p>规则：</p>
<ol>
<li>点击某点，如果此点为雷，那么将此点设为X，游戏结束</li>
<li>否则，自动探测周围的8个点，如果某点周围没有雷，则继续深入探测；如果某点周围有雷，则标记雷个数</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>[] dx = &#123;<span class="number">1</span>, <span class="number">1</span>,<span class="number">1</span>, <span class="number">0</span>,<span class="number">0</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>&#125;;</div><div class="line">    <span class="keyword">int</span>[] dy = &#123;<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">1</span>, <span class="number">1</span>,-<span class="number">1</span>,<span class="number">0</span> &#125;;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(x &gt;= board.length || x &lt; <span class="number">0</span> || y &gt;= board[x].length || y &lt; <span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">if</span>(board[x][y] == <span class="string">'M'</span>) <span class="keyword">return</span> ; <span class="comment">// 有雷</span></div><div class="line">        <span class="keyword">if</span>(board[x][y] == <span class="string">'E'</span>) &#123;</div><div class="line">            board[x][y] = <span class="string">'0'</span>;</div><div class="line">          <span class="comment">// 探测周围有没有雷</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dx.length; ++i) &#123;</div><div class="line">                <span class="keyword">int</span> x_neibor = x + dx[i], y_neibor = y + dy[i];</div><div class="line">                <span class="keyword">if</span>(x_neibor &gt;= board.length || x_neibor &lt; <span class="number">0</span> || y_neibor &gt;= board[x].length || y_neibor &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</div><div class="line">                <span class="keyword">if</span> (board[x_neibor][y_neibor] == <span class="string">'M'</span>) &#123;board[x][y] += <span class="number">1</span>;&#125;</div><div class="line">            &#125;</div><div class="line">          <span class="comment">// 对没有雷的地方继续递归探测</span></div><div class="line">            <span class="keyword">if</span>(board[x][y] == <span class="string">'0'</span>) &#123;</div><div class="line">                board[x][y] = <span class="string">'B'</span>;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dx.length; ++i)&#123;</div><div class="line">                    helper(board, x + dx[i], y + dy[i] );</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">char</span>[][] updateBoard(<span class="keyword">char</span>[][] board, <span class="keyword">int</span>[] click) &#123;</div><div class="line">        <span class="comment">/** E : 没打开的空地</span></div><div class="line">         *  M : 没打开的雷**/</div><div class="line">        <span class="keyword">if</span>(board[click[<span class="number">0</span>]][click[<span class="number">1</span>]] == <span class="string">'M'</span>) board[click[<span class="number">0</span>]][click[<span class="number">1</span>]] = <span class="string">'X'</span>;</div><div class="line">        <span class="keyword">else</span> helper(board, click[<span class="number">0</span>],click[<span class="number">1</span>]);</div><div class="line">        <span class="keyword">return</span> board;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="Remove-Invalid-Parentheses">1.4. Remove Invalid Parentheses</h2><p>删除尽量少的括号，使得一个字符串的括号符合要求</p>
<p>实在是没思路，到现在也没做上。先记一下套路吧</p>
<p><strong>方法1，DFS</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">removeInvalidParentheses</span><span class="params">(String s)</span></span>&#123;</div><div class="line">        <span class="comment">// 分别是多余的左括号和多余的右括号</span></div><div class="line">        <span class="keyword">int</span> rmL = <span class="number">0</span>, rmR = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i)&#123;</div><div class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">'('</span>)&#123;</div><div class="line">                ++rmL;</div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">')'</span>)&#123;</div><div class="line">                <span class="keyword">if</span>(rmL &gt; <span class="number">0</span>)&#123; <span class="comment">// 还有多余的左括号</span></div><div class="line">                    --rmL;</div><div class="line">                &#125;<span class="keyword">else</span> &#123; <span class="comment">// 没有多余的左括号了</span></div><div class="line">                    ++rmR;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        Set&lt;String&gt; res = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">        dfs(s, <span class="number">0</span>, res, <span class="keyword">new</span> StringBuilder(), rmL, rmR, <span class="number">0</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(res);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String s, <span class="keyword">int</span> i, Set&lt;String&gt; res, StringBuilder sb, <span class="keyword">int</span> rmL, <span class="keyword">int</span> rmR, <span class="keyword">int</span> open)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> len = sb.length();</div><div class="line">        <span class="comment">// rmL和rmR分别限制着最大的可变边界</span></div><div class="line">        <span class="keyword">if</span>(open &lt; <span class="number">0</span> || rmL &lt; <span class="number">0</span> || rmR &lt; <span class="number">0</span>)<span class="keyword">return</span>;</div><div class="line">        <span class="keyword">if</span>(i == s.length())&#123;</div><div class="line">            <span class="keyword">if</span>(open == <span class="number">0</span>)res.contains(sb.toString());</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">char</span> c = s.charAt(i);</div><div class="line">        <span class="keyword">if</span>(c == <span class="string">'('</span>)&#123;</div><div class="line">            dfs(s, i + <span class="number">1</span>, res, sb, rmL - <span class="number">1</span>,rmR, open); <span class="comment">// 尝试去除（</span></div><div class="line">            dfs(s, i + <span class="number">1</span>, res, sb.append(<span class="string">'('</span>), rmL, rmR, open - <span class="number">1</span>);<span class="comment">//不去除</span></div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">')'</span>)&#123;</div><div class="line">            dfs(s, i + <span class="number">1</span>, res, sb, rmL, rmR - <span class="number">1</span>, open);<span class="comment">//尝试去除 ）</span></div><div class="line">            dfs(s, i + <span class="number">1</span>, res, sb.append(<span class="string">')'</span>), rmL, rmR, open - <span class="number">1</span>);<span class="comment">//不去除</span></div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            dfs(s, i + <span class="number">1</span>,res, sb.append(c),rmL, rmR, open);</div><div class="line">        &#125;</div><div class="line">        sb.setLength(len); <span class="comment">//重置sb</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>方法2，套路</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(String s, List&lt;String&gt; ans, <span class="keyword">int</span> last_i, <span class="keyword">int</span> last_j, <span class="keyword">char</span>[] pair)</span></span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> stack = <span class="number">0</span>, i = last_i; i &lt; s.length(); ++i)&#123;</div><div class="line">            <span class="keyword">if</span>(s.charAt(i) == pair[<span class="number">0</span>])++stack;</div><div class="line">            <span class="keyword">if</span>(s.charAt(i) == pair[<span class="number">1</span>])--stack;</div><div class="line">            <span class="comment">//左括号多于右括号，那就继续循环</span></div><div class="line">            <span class="keyword">if</span>(stack &gt; <span class="number">0</span>)<span class="keyword">continue</span>;</div><div class="line">            <span class="comment">// 此时左括号少于右括号，一定是不合法的，那就尝试去除一个</span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = last_j; j &lt;= i; ++j)&#123;</div><div class="line">                <span class="comment">// j是右括号，且j的前一个不是右括号</span></div><div class="line"></div><div class="line">                <span class="keyword">if</span>(s.charAt(j) == pair[<span class="number">1</span>] &amp;&amp;(j == last_j || s.charAt(j-<span class="number">1</span>) != pair[<span class="number">1</span>]))&#123;</div><div class="line">                    remove(s.substring(<span class="number">0</span>,j) + s.substring(j + <span class="number">1</span>), ans, i, j, pair);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 因为之前我们只考虑了删除右括号。那么现在反过来，考虑试一试删除左括号</span></div><div class="line">            String reversed = <span class="keyword">new</span> StringBuilder(s).reverse().toString();</div><div class="line">            <span class="keyword">if</span> (pair[<span class="number">0</span>] == <span class="string">'('</span>) <span class="comment">// finished left to right</span></div><div class="line">                remove(reversed, ans, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">')'</span>, <span class="string">'('</span>&#125;);</div><div class="line">            <span class="keyword">else</span> <span class="comment">// finished right to left</span></div><div class="line">                ans.add(reversed);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="Decode-String">1.5. Decode String</h2><p>给一个字符串<code>3[a]2[bc]</code> 。数字表示后面括号里的字符重复次数。求解压之后的字符串。</p>
<p>这道题第一遍没想明白，第二遍重写的时候才一气呵成。其实就是dfs，当遇到数字时，就将数字后面的东西视为一个新的str，递归下去，遇到<code>]</code> 就跳出。跳出时需要携带跳出时的结束idx，因此我用了一个Node包装起来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">  以<span class="number">3</span>[a2[c]]为例</div><div class="line">  <span class="number">3</span> [ a <span class="number">2</span> [ c d ] ]</div><div class="line">  <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></div><div class="line">  idx = <span class="number">0</span>, 遇到<span class="number">3</span> --&gt; a2[cd]] , 跳过[</div><div class="line">  idx = <span class="number">2</span>, 遇到<span class="number">2</span> --&gt; cd]] ,将c、d分别加入sb,然后遇到了](idx = <span class="number">8</span>)，就跳出，返回到上层</div><div class="line">  idx = idxEnd = <span class="number">9</span>, 且将`cd`重复<span class="number">2</span>次变为cdcd，此时遇到](idx = <span class="number">9</span>)，再次跳出，返回上层</div><div class="line">  idx = idxEnd = <span class="number">10</span>, 且将cdcd加入到sb中，此时sb变成acbcd，跳出，返回上层</div><div class="line">  再将acbcd重复<span class="number">3</span>次</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</div><div class="line">       String str;</div><div class="line">       <span class="keyword">int</span> endIdx;</div><div class="line">       Node(String str, <span class="keyword">int</span> endIdx)&#123;</div><div class="line">           <span class="keyword">this</span>.str = str;</div><div class="line">           <span class="keyword">this</span>.endIdx = endIdx;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isLetter</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</div><div class="line">       <span class="keyword">return</span> (c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'z'</span>) || (c &gt;= <span class="string">'A'</span> &amp;&amp; c &lt;= <span class="string">'Z'</span>);</div><div class="line">   &#125;</div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isNum</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</div><div class="line">       <span class="keyword">return</span> c &gt;=<span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="function"><span class="keyword">private</span> Node <span class="title">helper</span><span class="params">(String s, <span class="keyword">int</span> idx)</span></span>&#123;</div><div class="line">       StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">       <span class="keyword">while</span> (idx &lt; s.length())&#123;</div><div class="line">           <span class="keyword">while</span> (idx &lt; s.length() &amp;&amp; isLetter(s.charAt(idx)))&#123;</div><div class="line">               sb.append(s.charAt(idx++));</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">int</span> numStart = idx;</div><div class="line">           <span class="keyword">while</span>(idx &lt; s.length() &amp;&amp; isNum(s.charAt(idx)))&#123;++idx;&#125;</div><div class="line">           <span class="keyword">int</span> repeat = <span class="number">0</span>;</div><div class="line">           <span class="keyword">if</span>(idx &gt; numStart)&#123;</div><div class="line">               repeat = Integer.valueOf(s.substring(numStart, idx));</div><div class="line">               Node next = helper(s, idx + <span class="number">1</span>);</div><div class="line">               <span class="keyword">while</span> (repeat-- &gt; <span class="number">0</span>)&#123;sb.append(next.str);&#125;</div><div class="line">               idx = next.endIdx;</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">if</span>(idx &lt; s.length() &amp;&amp; s.charAt(idx) == <span class="string">']'</span>)&#123;</div><div class="line">               <span class="keyword">return</span> <span class="keyword">new</span> Node(sb.toString(), idx + <span class="number">1</span>);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Node(sb.toString(), idx + <span class="number">1</span>);</div><div class="line">   &#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">decodeString</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> helper(s,<span class="number">0</span>).str;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>其实再思考了一下，idx完全可以设为全局变量！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isLetter</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> (c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'z'</span>) || (c &gt;= <span class="string">'A'</span> &amp;&amp; c &lt;= <span class="string">'Z'</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isNum</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> c &gt;=<span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">helper</span><span class="params">(String s)</span></span>&#123;</div><div class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">        <span class="keyword">while</span> (idx &lt; s.length())&#123;</div><div class="line">            <span class="keyword">while</span> (idx &lt; s.length() &amp;&amp; isLetter(s.charAt(idx)))&#123;</div><div class="line">                sb.append(s.charAt(idx++));</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">int</span> numStart = idx;</div><div class="line">            <span class="keyword">while</span>(idx &lt; s.length() &amp;&amp; isNum(s.charAt(idx)))&#123;++idx;&#125;</div><div class="line">            <span class="keyword">int</span> repeat = <span class="number">0</span>;</div><div class="line">            <span class="keyword">if</span>(idx &gt; numStart)&#123;</div><div class="line">                repeat = Integer.valueOf(s.substring(numStart, idx));</div><div class="line">                ++idx; <span class="comment">// 跳过[符号</span></div><div class="line">                String next = helper(s);</div><div class="line">                <span class="keyword">while</span> (repeat-- &gt; <span class="number">0</span>)&#123;sb.append(next);&#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(idx &lt; s.length() &amp;&amp; s.charAt(idx) == <span class="string">']'</span>)&#123;</div><div class="line">                ++idx;<span class="comment">//跳过]符号</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sb.toString();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decodeString</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> helper(s);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="Pacific-Atlantic-Water-Flow">1.6. Pacific Atlantic Water Flow</h2><p>给一个矩阵。左和上是太平洋，右和下是大西洋。求中间哪些点的水可以同时流到两个洋</p>
<p>思路：反向思考。从边界出发，寻找递增的方向。所有递增的都是能流到的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setVisited</span><span class="params">(<span class="keyword">int</span>[][] matrix,<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> val )</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(i &gt;= matrix.length || i &lt; <span class="number">0</span> || j &gt;= matrix[i].length || j &lt; <span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">if</span>(visited[i][j] != <span class="number">0</span> &amp;&amp; visited[i][j] != val)&#123;</div><div class="line">        result.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;);</div><div class="line">        visited[i][j] = <span class="number">3</span>;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        visited[i][j] = val;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//System.out.println(i + "\t"  + j + "\t" + visited[i][j] + val);</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> last, <span class="keyword">int</span> val)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(i &gt;= matrix.length || i &lt; <span class="number">0</span> || j &gt;= matrix[i].length || j &lt; <span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">if</span>(matrix[i][j] &lt; last || visited[i][j] == val || visited[i][j] == <span class="number">3</span>) <span class="keyword">return</span>;</div><div class="line">    setVisited(matrix,i, j, val );</div><div class="line">    <span class="comment">// 继续探测周围的点</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k)&#123;</div><div class="line">        dfs(matrix, i + di[k], j + dj[k], matrix[i][j], val);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">List&lt;<span class="keyword">int</span>[]&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line"><span class="keyword">int</span>[][] visited;</div><div class="line"><span class="keyword">int</span>[] di = &#123;<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>&#125;;</div><div class="line"><span class="keyword">int</span>[] dj = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</div><div class="line"><span class="keyword">public</span> List&lt;<span class="keyword">int</span>[]&gt; pacificAtlantic(<span class="keyword">int</span>[][] matrix) &#123;</div><div class="line">    <span class="keyword">if</span>(matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)<span class="keyword">return</span> result;</div><div class="line">    visited = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][matrix[<span class="number">0</span>].length];</div><div class="line">    <span class="comment">// pacific : i == 0 or j == 0</span></div><div class="line">    <span class="comment">// atlantic : i == matrix.length - 1 or j == matrix[i].length - 1</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; ++j)&#123;</div><div class="line">        dfs(matrix, <span class="number">0</span>, j, matrix[<span class="number">0</span>][j], <span class="number">1</span>);<span class="comment">// pacific</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; ++i)&#123;</div><div class="line">        dfs(matrix, i, <span class="number">0</span>,  matrix[i][<span class="number">0</span>], <span class="number">1</span>);<span class="comment">// pacific</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; ++j)&#123;</div><div class="line">        dfs(matrix, matrix.length - <span class="number">1</span>, j,matrix[matrix.length - <span class="number">1</span>][j], <span class="number">2</span>);<span class="comment">// atlantic</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; ++i)&#123;</div><div class="line">        dfs(matrix, i, matrix[i].length - <span class="number">1</span>,  matrix[i][matrix[i].length - <span class="number">1</span>], <span class="number">2</span>);<span class="comment">// atlantic</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[算法-DP]]></title>
      <url>/2017/11/17/%E7%AE%97%E6%B3%95-DP/</url>
      <content type="html"><![CDATA[<h1 id="理解动态规划">1. 理解动态规划</h1><p>引入例题：<strong>triangle</strong></p>
<p>给一个三角形，找到从上到下最短的路径：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">     [2],</div><div class="line">    [3,4],</div><div class="line">   [6,5,7],</div><div class="line">  [4,1,8,3]</div><div class="line">]</div></pre></td></tr></table></figure>
<p>最短路径是<code>11</code> (i.e., 2 + 3 + 5 + 1 = 11).</p>
<p>n = 三角形高度</p>
<p>我们用下面几种方法来思考这个题。</p>
<a id="more"></a>
<h2 id="方法1，DFS遍历">1.1. 方法1，DFS遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> n;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="keyword">int</span>[][] triangle)</span></span>&#123;</div><div class="line">  <span class="keyword">int</span> best = Integer.MAX_VALUE;</div><div class="line">  n = triangle.length;</div><div class="line">  dfs(triangle,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</div><div class="line">  <span class="keyword">return</span> best;</div><div class="line">&#125;</div><div class="line"><span class="comment">// sum = root -&gt; x,y ,不包含x,y的路径和</span></div><div class="line"><span class="function"><span class="keyword">public</span> vid <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] triangle,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> sum)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>( x == n )&#123;</div><div class="line">    best = Math.max(best,sum);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  dfs( triangle, x+<span class="number">1</span>, y, sum + triangle[x][y] );</div><div class="line">  dfs( triangle , x+<span class="number">1</span>, y+<span class="number">1</span>, sum + triangle[x][y] );</div><div class="line">  <span class="comment">/**坐标关系</span></div><div class="line">   [2]   -&gt;    [0,0]</div><div class="line">   [3,4]  -&gt;   [1,0],[1,1]</div><div class="line">  **/</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>复杂度：$O(2^n)$</p>
<h2 id="方法2，分治法">1.2. 方法2，分治法</h2><p>没有best全局变量，更好一些。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">divideConquer</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>( x == n )&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> A[x][y] + Math.min(</div><div class="line">    divideConquer(x+<span class="number">1</span>,y),</div><div class="line">  	divideConquer(x+<span class="number">1</span>,y+<span class="number">1</span>)</div><div class="line">    );</div><div class="line">&#125;</div><div class="line"></div><div class="line">divideConquer(<span class="number">0</span>,<span class="number">0</span>);</div></pre></td></tr></table></figure>
<p>我们分析一下这个分治的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**分治定义</span></div><div class="line"></div><div class="line">[x,y]表示从x,y出发，到底层的最短距离</div><div class="line"></div><div class="line">  [x,y]</div><div class="line">    ↓    ↘</div><div class="line">[x+1,y] [x+1,y+1]</div><div class="line"></div><div class="line">从[x,y]出发，有两条路：[x+1,y]和[x+1,y+1]，这其实是两个子问题</div><div class="line"></div><div class="line">而[x,y] = Math.min( [x+1,y],[x+1,y+1] ) + A[x,y]</div><div class="line"></div><div class="line">**/</div></pre></td></tr></table></figure>
<p>复杂度：$2^n$</p>
<h2 id="方法3，记忆化搜索">1.3. 方法3，记忆化搜索</h2><p>我们先回头看一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">  [x,y]</div><div class="line">    ↓    ↘</div><div class="line">[x+1,y] [x+1,y+1]</div><div class="line"></div><div class="line">   ↓      ↘ ↓       ↘</div><div class="line">[x+2,y] [x+2,y+1] [x+2,y+2]</div><div class="line"></div><div class="line">**/</div></pre></td></tr></table></figure>
<p>我们发现[x+2,y+1]被调用了两次！</p>
<p>就可以用一张哈希表来存储曾经计算过的[x,y]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">divideConquer</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(x == n)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//如果之前计算过，就直接返回</span></div><div class="line">  <span class="keyword">if</span>( hash[x][y] != Integer.MAX_VALUE )&#123;</div><div class="line">    <span class="keyword">return</span> hash[x][y];</div><div class="line">  &#125;</div><div class="line">  hash[x][y] =  A[x][y] + Math.min(</div><div class="line">    divideConquer(x+<span class="number">1</span>,y),</div><div class="line">  	divideConquer(x+<span class="number">1</span>,y+<span class="number">1</span>));</div><div class="line">  <span class="keyword">return</span> hash[x][y];</div><div class="line">&#125;</div><div class="line"></div><div class="line">initialize: hash[*][*] = Integer.MAX_VALUE;</div><div class="line">answser: divideConqure(<span class="number">0</span>,<span class="number">0</span>);</div></pre></td></tr></table></figure>
<p>复杂度:$n^2$</p>
<p>解决了重复计算的问题。</p>
<p>记忆化搜索是一种lazy loading模式，需要的时候再去算，算完了存下来。属于自顶向下的计算。</p>
<h2 id="方法4，多重循环">1.4. 方法4，多重循环</h2><p>这是一种很勤劳的模式。就是提前算好所需要的一切，然后再返回。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span></div><div class="line"><span class="number">2</span>,<span class="number">3</span></div><div class="line"><span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span></div></pre></td></tr></table></figure>
<p>有两种方式，一种是自顶向下，一种是自底向上。</p>
<h3 id="自顶向下">1.4.1. 自顶向下</h3><p>我们先看一下自顶向下。</p>
<p>我们先计算从1到2、3的最短路径，然后计算从1到4/5/6的最短路径。最后从4/5/6中挑一个最小的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">f[i][j]表示从顶出发，走到i,j的最小路径长度</div><div class="line"><span class="comment">//初始化</span></div><div class="line">f[<span class="number">0</span>][<span class="number">0</span>] = A[<span class="number">0</span>][<span class="number">0</span>]</div><div class="line"><span class="comment">//初始化三角形的左边和右边</span></div><div class="line"><span class="comment">//最左、右边的所有点，从1出发只有一条路径！</span></div><div class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; ++i)&#123;</div><div class="line">f[i][<span class="number">0</span>] = f[i-<span class="number">1</span>][<span class="number">0</span>] + A[i][<span class="number">0</span>];</div><div class="line">f[i][i] = f[i-<span class="number">1</span>][i-<span class="number">1</span>] + A[i][i];</div><div class="line">&#125;</div><div class="line"><span class="comment">//自顶向下</span></div><div class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++i )&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; i ; ++j )&#123;</div><div class="line">	f[i][j] = Math.min(f[i-<span class="number">1</span>][j],f[i-<span class="number">1</span>][j-<span class="number">1</span>]) + A[i][j];</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> Math.min(f[n-<span class="number">1</span>][<span class="number">0</span>],f[n-<span class="number">1</span>][<span class="number">1</span>],...);</div></pre></td></tr></table></figure>
<h3 id="自底向上">1.4.2. 自底向上</h3><p>接下来看一下自底向上的方式。</p>
<p>我们想要计算1到最底端的最小距离，那就需要知道2和3的。那么就要需要知道4,5,6的。那我们先从4,5,6计算起。属于自底向上的计算。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">A[][]</div><div class="line"></div><div class="line"><span class="comment">//状态定义</span></div><div class="line">f[i][j]表示从i,j出发走到最后一层的最小路径长度</div><div class="line"><span class="comment">//初始化,终点先有值</span></div><div class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; ++i )&#123;</div><div class="line">	f[n-<span class="number">1</span>][i] = A[n-<span class="number">1</span>][i];</div><div class="line">&#125;</div><div class="line"><span class="comment">//循环求解</span></div><div class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span> ; --i )&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= i ; ++j)&#123;</div><div class="line">	f[i][j] = Math.min(f[i+<span class="number">1</span>][j],f[i+<span class="number">1</span>][j+<span class="number">1</span>]) + A[i][j];</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">return</span> f[<span class="number">0</span>][<span class="number">0</span>]</div></pre></td></tr></table></figure>
<h1 id="什么时候用DP">2. 什么时候用DP</h1><p>三个条件满足其一即<strong>有可能</strong>是要用DP：</p>
<ul>
<li>求极值</li>
<li>判断是否可行</li>
<li>统计方案个数</li>
<li>擅长将$2^n-&gt;n^2$</li>
</ul>
<h1 id="什么时候不用DP">3. 什么时候不用DP</h1><p>三个条件满足其一即<strong>有可能</strong>是不用DP：</p>
<ul>
<li>求所有<strong>具体</strong>的方案（输出所有回文串）</li>
<li>输入是<strong>集合</strong>（是无序的），而不是序列（求最长连续序列），背包问题是例外</li>
<li>暴力方法的复杂度已经是多项式级别，不擅长$n^3-&gt;n^2$</li>
</ul>
<h1 id="DP四要素">4. DP四要素</h1><p><strong>状态</strong>：<code>f[][]</code>的含义，<strong>最难</strong>！</p>
<p><strong>方程</strong>：状态之间的联系，怎么用小状态算大状态</p>
<p><strong>初始化</strong>：最小状态是什么，起点</p>
<p><strong>答案</strong>：最大状态是什么，终点</p>
<p><strong>VS递归三要素</strong></p>
<ul>
<li><strong>定义</strong>（状态）<ul>
<li>接受了什么参数</li>
<li>做了什么事情</li>
<li>返回了什么值</li>
</ul>
</li>
<li><strong>拆解</strong>（方程）<ul>
<li>符合将参数变小</li>
</ul>
</li>
<li><strong>出口</strong>（初始化）<ul>
<li>什么时候可以直接return</li>
</ul>
</li>
</ul>
<h1 id="常见DP">5. 常见DP</h1><p><strong>坐标型 15%</strong></p>
<p><strong>序列型 30%</strong></p>
<p><strong>双序列 30%</strong></p>
<p>划分型 10%</p>
<p>背包型 10%</p>
<p>区间型 5%</p>
<h2 id="坐标型（矩阵）DP">5.1. 坐标型（矩阵）DP</h2><p>特点：小人在按照某种方向跳</p>
<p><strong>状态</strong>：</p>
<ul>
<li><code>f[x]</code>：从起点走到坐标x…</li>
<li><code>f[x][y]</code>：从起点走到坐标x,y…</li>
</ul>
<p><strong>方程</strong>：研究走到x,y这个点之前的这一步</p>
<p><strong>初始化</strong>：起点</p>
<p><strong>答案</strong>：重点</p>
<h3 id="例题1：Minimum-Path-Sum">5.1.1. 例题1：Minimum Path Sum</h3><p>题目：从左上走到右下最短距离。只能向右向下走。求最小路径</p>
<p><strong>状态：</strong><code>f[x][y]</code> : 从起点走到x,y的最短路径</p>
<p><strong>方程</strong>：<code>f[x][y] = Math.min(f[x-1][y],f[x][y-1]+A[x][y]</code></p>
<p><strong>初始化</strong>：边界</p>
<p><strong>答案</strong>：<code>f[n][m]</code></p>
<h3 id="例题2，Unique-Paths">5.1.2. 例题2，Unique Paths</h3><p>题目：从左上走到右下最短距离。只能向右向下走。求方案个数。</p>
<p><strong>状态</strong>：<code>f[x][y]</code>：从[0,0]出发，到[x,y]的方案总数</p>
<p><strong>方程</strong>：<code>f[x][y] = f[x-1][y] + f[x][y-1]</code>（需要强调的是，<code>[x-1,y]</code>和<code>[x,y-1]</code>两种方案不会重叠！）</p>
<p><strong>初始化</strong>：第0行、第0列的边界</p>
<p><strong>答案</strong>：<code>f[n][m]</code></p>
<h3 id="例题3，Unique-Paths-II">5.1.3. 例题3，Unique Paths II</h3><p>如果路上有障碍，求方案个数。</p>
<h3 id="例题4，Climbing-Stairs">5.1.4. 例题4，Climbing Stairs</h3><p>有一个楼梯，一步只能跨1/2步。问从0走到n层有多少层方案。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">f[i] -&gt; i位置有多少种</div><div class="line"></div><div class="line">f[i] = f[i-<span class="number">1</span>] + f[i-<span class="number">2</span>] <span class="comment">//要么从i-1来的，要么从i-2来的</span></div><div class="line"></div><div class="line"><span class="comment">//斐波那契数列！</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>( n &lt;= <span class="number">2</span> ) <span class="keyword">return</span> n;</div><div class="line">        <span class="comment">//f[i] : 有i个台阶时的方案个数</span></div><div class="line">        <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</div><div class="line">        f[<span class="number">1</span>] = <span class="number">1</span>;</div><div class="line">        f[<span class="number">2</span>] = <span class="number">2</span>;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n ; ++i )&#123;</div><div class="line">            f[i] = f[i-<span class="number">1</span>] + f[i-<span class="number">2</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> f[n];</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="例题5，Jump-Game">5.1.5. 例题5，Jump Game</h3><p>给一个数组A,<code>A[i]</code>表示在这里时最多可以跳<code>A[i]</code>步。只能向前跳。从数组A的第0位置出发，能不能跳到末尾。</p>
<p>这道题有两种解法，一种是DP，一种是贪心。DP会超时，但是思路非常好。</p>
<p>先介绍DP，这个复杂度是$O(n^2)$:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* f[i] -&gt; 从0到i是否可达</div><div class="line">*</div><div class="line">* 1,2,...,j,...i</div><div class="line">* </div><div class="line">* 如果j可达，且从j可以跳到i，则i可达，即：看看存不存在一个j，j满足以下两个条件：</div><div class="line">*  1. j可达 --&gt; f[j] == true</div><div class="line">*  2. 从j出发够得到i --&gt; i - j &lt;= A[j]</div><div class="line">**/</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>( nums.length == <span class="number">0</span> ) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">boolean</span>[] f = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</div><div class="line">        <span class="comment">//初始化</span></div><div class="line">        f[<span class="number">0</span>] = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">int</span> i,j;</div><div class="line">        <span class="keyword">for</span>( i = <span class="number">1</span> ; i &lt; nums.length ; ++i )&#123;</div><div class="line">            <span class="keyword">for</span>( j = <span class="number">0</span> ; j &lt; i ; ++j )&#123;</div><div class="line">                <span class="keyword">if</span>( f[j] &amp;&amp; i - j &lt;= nums[j] )&#123; <span class="comment">// j可达，且从j可以跳到i</span></div><div class="line">                    f[i] = <span class="keyword">true</span>;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> f[nums.length - <span class="number">1</span>];</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>再介绍贪心的思路，这个复杂度是$O(n)$</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">维护两个东西：</div><div class="line">	1. 到目前为止能跳到的最远距离（全局）</div><div class="line">	2. 从当前一步出发能跳到的最远距离（局部）</div><div class="line"></div><div class="line">全局最优 global = Math.max(global, local)</div><div class="line"></div><div class="line">局部最优 local = A[i]+i</div><div class="line"></div><div class="line">**/ </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</div><div class="line">  <span class="comment">// think it as merging n intervals</span></div><div class="line">  <span class="keyword">if</span> (A == <span class="keyword">null</span> || A.length == <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> global = A[<span class="number">0</span>];</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.length; i++) &#123;</div><div class="line">    <span class="keyword">if</span> (i &lt;= global &amp;&amp; A[i] + i &gt;= global) &#123;</div><div class="line">      global = A[i] + i;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> global &gt;= A.length - <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="例题6，Jump-Game-II">5.1.6. 例题6，Jump Game II</h3><p>给一个数组A,<code>A[i]</code>表示在这里时最多可以跳<code>A[i]</code>步。只能向前跳。从数组A的第0位置出发，问最少的跳的次数。</p>
<p>这道题还是有两个思路，一个DP，一个贪心。我们先介绍一下DP，虽然DP会超时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"></div><div class="line">f[i] : 从起点出发，跳到i最少需要几步</div><div class="line"></div><div class="line">          |---&gt;i-j&lt;---|</div><div class="line">1,3,.....,|j,.......,i|</div><div class="line"></div><div class="line">如果j可达i（即i - j &lt;= nums[j]），则 f[i] = min ( f[j] + 1 )</div><div class="line"></div><div class="line">**/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>( nums.length == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  <span class="comment">//状态：f[i] -&gt; 从0到i最少的跳跃次数</span></div><div class="line">  <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</div><div class="line">  <span class="comment">//初始化</span></div><div class="line">  f[<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> i,j;</div><div class="line">  <span class="keyword">for</span>( i = <span class="number">1</span> ; i &lt; nums.length ; ++i )&#123;</div><div class="line">    f[i] = Integer.MAX_VALUE;</div><div class="line">    <span class="keyword">for</span>( j = <span class="number">0</span> ; j &lt; i ; ++j )&#123;</div><div class="line">      <span class="keyword">if</span>( i - j &lt;= nums[j] )&#123;</div><div class="line">        f[i] = Math.min(f[i],f[j]+<span class="number">1</span>);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> f[nums.length - <span class="number">1</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第二种思路，贪心：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">思路：</div><div class="line"></div><div class="line">要记录</div><div class="line">最远能覆盖到的地方 -&gt; curr</div><div class="line">已经覆盖的地方 -&gt; last</div><div class="line">当前所使用跳数 -&gt; ret</div><div class="line"></div><div class="line">扫描以确定当前最远能覆盖的节点，放入curr。</div><div class="line">然后继续扫描，直到当前的路程超过了上一次算出的覆盖范围，那么更新覆盖范围，同时更新条数，因为我们是经过了多一跳才能继续前进的</div><div class="line"></div><div class="line">比如就是我们题目中的[2,3,1,1,4]。初始状态是这样的：cur表示最远能覆盖到的地方，用框里表示。last表示已经覆盖的地方。它们都指在第一个元素上。</div><div class="line">==============================================================</div><div class="line">cur</div><div class="line">-↓-</div><div class="line"> 2 |	3	1	1	4</div><div class="line">-↑-</div><div class="line">last</div><div class="line">==============================================================</div><div class="line"></div><div class="line">第一元素告诉cur，最远可以走两步，于是：</div><div class="line">            cur</div><div class="line">-------------↓-</div><div class="line"> 2     3     1 |	1	4</div><div class="line">-↑-------------</div><div class="line">last</div><div class="line">==============================================================</div><div class="line"></div><div class="line">下一循环中，i指向1（即上面的3）。发现i小于last能到的范围，于是更新last，步数ret+1，同时也要更新cur，因为我们发现更远的距离</div><div class="line">      i=1               cur</div><div class="line">-------↓-----------------↓-</div><div class="line"> 2     3     1     1	4 |</div><div class="line">-------------↑-------------</div><div class="line">           last</div><div class="line">==============================================================</div><div class="line"></div><div class="line">接下来i继续前进，发现i还在当前的实例范围内，无需更新last和步数ret，只需要更新curr</div><div class="line">            i=2         cur</div><div class="line">-------------↓-----------↓-</div><div class="line"> 2     3     1     1	4 |</div><div class="line">-------------↑-------------</div><div class="line">          last = 2</div><div class="line">==============================================================</div><div class="line"></div><div class="line">i继续前进，接下来发现超过当前势力范围，更新last和步数。cur已然最大了。</div><div class="line">                  i=3   cur</div><div class="line">-------------------↓-----↓-</div><div class="line"> 2     3     1     1	4 |</div><div class="line">-------------------------↑-</div><div class="line">                     last = 4</div><div class="line">==============================================================</div><div class="line"></div><div class="line">最后，i到最后一个元素，依然在last的势力范围内，遍历完成，返回ret。</div><div class="line">                     i=cur=4</div><div class="line">-------------------------↓-</div><div class="line"> 2     3     1     1	4 |</div><div class="line">-------------------------↑-</div><div class="line">                     last = 4</div><div class="line">==============================================================</div><div class="line">**/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> last = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</div><div class="line">          <span class="comment">//需要进行下次跳跃，则更新last和当执行的跳数ret</span></div><div class="line">            <span class="keyword">if</span> (i &gt; last) &#123;</div><div class="line">                last = curr;</div><div class="line">                ++ret;</div><div class="line">            &#125;</div><div class="line">          	<span class="comment">//最远能覆盖到的地方</span></div><div class="line">            curr = max(curr, i+A[i]);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="例题7，Longest-Increasing-Subsequence">5.1.7. 例题7，Longest Increasing Subsequence</h3><p>求最长严格递增的子序列（子序列：可以跳着选）</p>
<p>例如给<code>[5,4,1,2,3]</code>,最长的LIS就是<code>1,2,3</code></p>
<p>可以用DP——$n^2$，也可以用二分——$nlogn$。我们先介绍一下DP</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></div><div class="line">理解为：</div><div class="line">  <span class="number">5</span></div><div class="line">|---| <span class="number">4</span></div><div class="line">|   |---|         <span class="number">3</span></div><div class="line">|   |   |     <span class="number">2</span> |---|</div><div class="line">|   |   | <span class="number">1</span> |---|   |</div><div class="line">|   |   |---|   |   | </div><div class="line">  <span class="number">5</span>   <span class="number">4</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   的楼梯，目的是从某个木桩出发，从低到高，看能踩多少个木桩</div><div class="line"></div><div class="line">f[i] : （从任意某个木桩）跳到第i个木桩，最多能踩过多少个桩</div><div class="line"></div><div class="line">方程 ：f[i] = max&#123; f[j] + <span class="number">1</span> &#125; , j 必须满足 j &lt; i &amp;&amp; nums[j] &lt;= nums[i]</div><div class="line"></div><div class="line">初始化：f[i] = <span class="number">1</span> <span class="comment">//每个格子对于自己来说都可达</span></div><div class="line"></div><div class="line">答案： Max(f[<span class="number">0</span>],f[<span class="number">1</span>],...,[n-<span class="number">1</span>])</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">  <span class="comment">//f[i] -&gt; 跳到当前i时，最多可以跳的次数</span></div><div class="line">  <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</div><div class="line">  <span class="comment">//初始化</span></div><div class="line">  <span class="keyword">int</span> i,j;</div><div class="line">  <span class="comment">// 这个其实可以放到最后再+1</span></div><div class="line">  <span class="comment">//        for( i = 0 ; i &lt; nums.length ; ++i)&#123;</span></div><div class="line">  <span class="comment">//            f[i] = 1;</span></div><div class="line">  <span class="comment">//        &#125;</span></div><div class="line">  <span class="comment">//开始</span></div><div class="line">  <span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; nums.length ; ++i )&#123;</div><div class="line">    <span class="keyword">for</span>( j = <span class="number">0</span> ; j &lt; i ; ++j )&#123;</div><div class="line">      <span class="keyword">if</span>( nums[j] &lt; nums[i] ) &#123;</div><div class="line">        f[i] = Math.max(f[i],f[j]+<span class="number">1</span>);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//结果 j = max&#123;f[i]&#125;</span></div><div class="line">  j = -<span class="number">1</span>;</div><div class="line">  <span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; f.length ; ++i )&#123;</div><div class="line">    j = Math.max(j,f[i]);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> j+<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来我们看看二分这个骚操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">tail[i] -&gt; 长度为i+<span class="number">1</span>的LIS的【最小】末尾是tail[i]</div><div class="line">以nums = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>]为例：</div><div class="line"></div><div class="line">len = <span class="number">1</span>   :      [<span class="number">4</span>], [<span class="number">5</span>], [<span class="number">6</span>], [<span class="number">3</span>]   =&gt; tails[<span class="number">0</span>] = <span class="number">3</span></div><div class="line">len = <span class="number">2</span>   :      [<span class="number">4</span>, <span class="number">5</span>], [<span class="number">5</span>, <span class="number">6</span>]       =&gt; tails[<span class="number">1</span>] = <span class="number">5</span></div><div class="line">len = <span class="number">3</span>   :      [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]            =&gt; tails[<span class="number">2</span>] = <span class="number">6</span></div><div class="line"></div><div class="line">此时如果后面又来了一个x</div><div class="line"></div><div class="line">(<span class="number">1</span>) 如果x大于所有tails，那就把这个x放在这个里面，并把长度+<span class="number">1</span></div><div class="line">(<span class="number">2</span>) 如果tails[i-<span class="number">1</span>] &lt; x &lt;= tails[i], 更新 tails[i]</div><div class="line"></div><div class="line">size -&gt; 当前最长序列长度</div><div class="line">序[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</div><div class="line">以[<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">7</span>]为例：</div><div class="line"></div><div class="line"></div><div class="line">i = <span class="number">0</span> --&gt; x = <span class="number">2</span>, tail = [<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]  -&gt; size = <span class="number">1</span></div><div class="line">[<span class="number">2</span>]   --&gt; 子序列 <span class="number">2</span></div><div class="line">  </div><div class="line">i = <span class="number">1</span> --&gt; x = <span class="number">1</span>, tail = [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]  -&gt; size = <span class="number">1</span></div><div class="line">[<span class="number">2</span>,<span class="number">1</span>] --&gt; 子序列[<span class="number">1</span>]</div><div class="line"></div><div class="line">i = <span class="number">2</span>   --&gt; x = <span class="number">5</span>, tail = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]  -&gt; size = <span class="number">2</span></div><div class="line">[<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>] --&gt; 子序列[<span class="number">1</span>,<span class="number">5</span>]</div><div class="line"></div><div class="line">i = <span class="number">3</span>    --&gt; x = <span class="number">3</span>, tail = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]  -&gt; size = <span class="number">2</span></div><div class="line">[<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>] --&gt; 子序列[<span class="number">1</span>,<span class="number">3</span>]</div><div class="line"></div><div class="line">i = <span class="number">4</span>       --&gt; x = <span class="number">6</span>, tail = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]  -&gt; size = <span class="number">3</span></div><div class="line">[<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>] --&gt; 子序列[<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>]</div><div class="line"></div><div class="line">i = <span class="number">5</span>         --&gt; x = <span class="number">4</span>, tail = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]  -&gt; size = <span class="number">3</span></div><div class="line">[<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>] --&gt; 子序列[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>]</div><div class="line"></div><div class="line">i = <span class="number">6</span>           --&gt; x = <span class="number">8</span>, tail = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]  -&gt; size = <span class="number">4</span></div><div class="line">[<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">8</span>] --&gt; 子序列[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>]</div><div class="line"></div><div class="line">i = <span class="number">7</span>             --&gt; x = <span class="number">9</span>, tail = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]  -&gt; size = <span class="number">4</span></div><div class="line">[<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">9</span>] --&gt; 子序列[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">9</span>]</div><div class="line"></div><div class="line">i = <span class="number">8</span>               --&gt; x = <span class="number">7</span>, tail = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]  -&gt; size = <span class="number">4</span></div><div class="line">[<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">7</span>] --&gt; 子序列[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>]</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span>[] tails = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</div><div class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = size;</div><div class="line">        <span class="comment">//用二分在tails中寻找一个位置，将x安顿一下</span></div><div class="line">        <span class="keyword">while</span> (i != j) &#123;</div><div class="line">            <span class="keyword">int</span> m = (i + j) / <span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span> (tails[m] &lt; x)</div><div class="line">                i = m + <span class="number">1</span>;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                j = m;</div><div class="line">        &#125;</div><div class="line">        tails[i] = x;</div><div class="line">        <span class="keyword">if</span> (i == size) ++size;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> size;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Increasing-Subsequences">5.1.8. Increasing Subsequences</h3><p>求一个数组的所有递增子序列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">一开始的思路就是用递归</div><div class="line"></div><div class="line">定义&lt;List&lt;List&gt;&gt;result[i]为包含nums[i]的所有递增子序列</div><div class="line">    &lt;List&lt;List&gt;&gt;result[i+<span class="number">1</span>]为包含nums[i+<span class="number">1</span>]的所有递增子序列，那么</div><div class="line"></div><div class="line">对于&lt;List&lt;List&gt;&gt;result[i+<span class="number">1</span>]中的每个成员&lt;List&gt;element来说：</div><div class="line"></div><div class="line"><span class="number">1</span>. 如果 nums[i] &lt;= element.head , 那么 nums[i] + element 可以作为一个result[i]中的结果</div><div class="line"><span class="number">2</span>. element 本身也可以作为result[i]中的结果</div><div class="line"><span class="number">3</span>. nums[i]也可以作为result[i]中的结果</div><div class="line"></div><div class="line">需要注意的是，当生成到result[<span class="number">0</span>]时，我们只需要的是长度大于<span class="number">1</span>的结果。因此需要判断一下，如果以上三种情况的某种情况长度小于等于<span class="number">1</span>，那么就不加入result[i]</div><div class="line"></div><div class="line"></div><div class="line">然而这样下去的后果是，如果遇到重复元素，就会生成重复的结果。例如我输入nums = [<span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">7</span>]。那会得到：[[<span class="number">4</span>, <span class="number">7</span>], [<span class="number">4</span>, <span class="number">6</span>], [<span class="number">4</span>, <span class="number">7</span>], [<span class="number">7</span>, <span class="number">7</span>], [<span class="number">4</span>, <span class="number">7</span>, <span class="number">7</span>], [<span class="number">6</span>, <span class="number">7</span>], [<span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>]]</div><div class="line"></div><div class="line">生成了两个[<span class="number">4</span>,<span class="number">7</span>]</div><div class="line"></div><div class="line">这个问题想了一下午都没有解决。</div><div class="line"></div><div class="line">看了网上的解法，跟我的不是一个套路。哎。来日重刷此题！</div></pre></td></tr></table></figure>
<h3 id="Arithmetic-Slices">5.1.9. Arithmetic Slices</h3><p>给一个序列。求这个序列有多少个等差数列（至少三个元素才算等差数列）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// times[i] : 长度为i的等差序列可以构成多少个等差序列</span></div><div class="line"><span class="keyword">int</span>[] times;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getTimes</span><span class="params">( <span class="keyword">int</span> i )</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>( i &lt; <span class="number">2</span> ) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  <span class="keyword">if</span>( times[i] &gt; <span class="number">0</span> )&#123;</div><div class="line">    <span class="keyword">return</span> times[i];</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// function</span></div><div class="line">  times[i] = getTimes(i-<span class="number">1</span>) + i - <span class="number">2</span>;</div><div class="line">  <span class="keyword">return</span> times[i];</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> n = A.length;</div><div class="line">  <span class="keyword">if</span>( n &lt; <span class="number">3</span> )<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  times = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</div><div class="line">  times[<span class="number">3</span>] = <span class="number">1</span>;</div><div class="line">  <span class="keyword">int</span> last = A[<span class="number">1</span>] - A[<span class="number">0</span>],now;</div><div class="line">  <span class="keyword">int</span> result = <span class="number">0</span> ;</div><div class="line">  <span class="keyword">int</span> sameCount = <span class="number">2</span> ;</div><div class="line">  <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">2</span> ; i &lt; n ; ++i )&#123;</div><div class="line">    now = A[i] - A[i-<span class="number">1</span>];</div><div class="line">    <span class="keyword">if</span>( now == last )&#123;</div><div class="line">      ++sameCount;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">      <span class="keyword">if</span>( sameCount &gt;= <span class="number">3</span> )&#123;result += getTimes(sameCount);&#125;</div><div class="line">      sameCount = <span class="number">2</span>;</div><div class="line">      last = now;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>( sameCount &gt;= <span class="number">3</span> )&#123;result += getTimes(sameCount);&#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>###　Perfect Squares</p>
<p>给一个数字，求它被拆成平方和的最少平方和个数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">状态 f[i] : 数字i被拆成平方和的最少个数</div><div class="line"></div><div class="line"><span class="number">1</span>,.....,j*j,.....i</div><div class="line"></div><div class="line">方程：</div><div class="line">f[i] = min ( f[i-j^<span class="number">2</span>] + <span class="number">1</span> )</div><div class="line"></div><div class="line">代码：</div><div class="line"><span class="comment">// nums[i] : 数字i被拆成平方和的最少个数</span></div><div class="line"><span class="keyword">int</span>[] nums;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>( number &lt;= <span class="number">1</span> )&#123;</div><div class="line">    <span class="keyword">return</span> number;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span>( nums[number] &gt; <span class="number">0</span> )&#123;</div><div class="line">    <span class="keyword">return</span> nums[number];</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// a = n - i^2</span></div><div class="line">  <span class="keyword">int</span> a;</div><div class="line">  nums[number] = number;</div><div class="line">  <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; number ; ++i )&#123;</div><div class="line">    a = number - i*i;</div><div class="line">    <span class="keyword">if</span>(a &lt; <span class="number">0</span> )&#123; <span class="keyword">break</span>;&#125;</div><div class="line">    <span class="keyword">if</span>( a == <span class="number">0</span> )&#123;</div><div class="line">      nums[number] = <span class="number">1</span>;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// 方程</span></div><div class="line">      nums[number] = Math.min(nums[number], <span class="number">1</span> + dp(a));</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> nums[number];</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">  nums = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</div><div class="line">  nums[<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">  nums[<span class="number">1</span>] = <span class="number">1</span>;</div><div class="line">  <span class="keyword">return</span> dp(n);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Min-Cost-Climbing-Stairs">5.1.10. Min Cost Climbing Stairs</h3><p>给一个数组，<code>cost[i]</code> 代表从第i格跳到下一步的花费。每次可以跳1或两格。求从开始（可以从0或1起跳）跳到最后的最小花费。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>[] dp;</div><div class="line"><span class="comment">// dp[i] 从第i格跳到最后需要耗费的最小cost</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] cost, <span class="keyword">int</span> idx)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(idx &gt;= cost.length) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span>(dp[idx] &gt; <span class="number">0</span>)<span class="keyword">return</span> dp[idx];</div><div class="line">    dp[idx] = Math.min(helper(cost, idx + <span class="number">1</span>),</div><div class="line">            helper(cost,idx + <span class="number">2</span>)) + cost[idx];</div><div class="line">    <span class="keyword">return</span> dp[idx];</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">int</span>[] cost)</span> </span>&#123;</div><div class="line">    dp = <span class="keyword">new</span> <span class="keyword">int</span>[cost.length];</div><div class="line">    <span class="keyword">return</span> Math.min(helper(cost,<span class="number">0</span>),helper(cost,<span class="number">1</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Decode-Ways">5.1.11. Decode Ways</h3><p>给一串数字的字符串，其中1表示<code>A</code>, 2表示<code>B</code>… 求字符串可能的编码方式种类</p>
<p>思路：动态规划</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">dp[i + <span class="number">1</span>] : 字符串[<span class="number">0</span>,i]可能的编码方式</div><div class="line">初始化：</div><div class="line">dp[<span class="number">0</span>] = <span class="number">1</span> <span class="comment">// 空字符串，是个特例</span></div><div class="line">dp[<span class="number">1</span>] = s.charAt(<span class="number">0</span>) &lt;= <span class="string">'9'</span> ? <span class="number">1</span> : <span class="number">0</span> ; <span class="comment">// 如果首位小于10，则首位可以被单独编码</span></div><div class="line"></div><div class="line"></div><div class="line">[<span class="number">0</span>,<span class="number">1</span>,....,i-<span class="number">1</span>,i,i+<span class="number">1</span>]</div><div class="line"></div><div class="line">情况<span class="number">1</span>：只要字符[i+<span class="number">1</span>]不等于`<span class="number">0</span>`，那字符[i+<span class="number">1</span>]能够独自编码</div><div class="line">情况<span class="number">2</span>：只要字符[i,i+<span class="number">1</span>]小于<span class="string">'26'</span>且大于<span class="string">'09'</span>，那字符[i,i+<span class="number">1</span>]就能编码</div><div class="line"></div><div class="line">转移方程：</div><div class="line"></div><div class="line">dp[i+<span class="number">1</span>] = dp[i] + dp[i-<span class="number">1</span>];</div><div class="line">            ↑        ↑</div><div class="line">          情况<span class="number">1</span>成立  情况<span class="number">2</span>成立时</div><div class="line">          </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span>(s.charAt(<span class="number">0</span>) == <span class="string">'0'</span>)<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.length() + <span class="number">1</span>];</div><div class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">        dp[<span class="number">1</span>] = s.charAt(<span class="number">0</span>) &lt;= <span class="string">'9'</span> ? <span class="number">1</span> : <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); ++i)&#123;</div><div class="line">            <span class="comment">// 情况1</span></div><div class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">'0'</span>)&#123;</div><div class="line">                dp[i + <span class="number">1</span>] = <span class="number">0</span>;</div><div class="line">            &#125;<span class="keyword">else</span> &#123;</div><div class="line">                dp[i + <span class="number">1</span>] = dp[i];</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 情况2</span></div><div class="line">            <span class="keyword">if</span>(s.charAt(i-<span class="number">1</span>) &gt; <span class="string">'0'</span> &amp;&amp; (s.charAt(i-<span class="number">1</span>) &lt; <span class="string">'2'</span> || (s.charAt(i-<span class="number">1</span>)==<span class="string">'2'</span>&amp;&amp;s.charAt(i) &lt;= <span class="string">'6'</span>)))&#123;</div><div class="line">                dp[i + <span class="number">1</span>] += dp[i-<span class="number">1</span>];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(dp[i+<span class="number">1</span>] == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dp[s.length()];</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="Decode-Ways-II">5.1.12. Decode Ways II</h3><p>接上题，如果其中有字符<code>*</code>表示<code>1-9</code>。同求字符串可能的编码方式种类</p>
<p>思路：接上题的思路，只需要讨论<code>*</code>即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span>) <span class="keyword">return</span> s.length();</div><div class="line">        <span class="keyword">if</span>(s.charAt(<span class="number">0</span>) == <span class="string">'0'</span>)<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">long</span>[] dp = <span class="keyword">new</span> <span class="keyword">long</span>[s.length() + <span class="number">1</span>];</div><div class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span>(s.charAt(<span class="number">0</span>) == <span class="string">'*'</span>)</div><div class="line">            dp[<span class="number">1</span>] = <span class="number">9</span>;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            dp[<span class="number">1</span>] = s.charAt(<span class="number">0</span>) &lt;= <span class="string">'9'</span> ? <span class="number">1</span> : <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); ++i)&#123;</div><div class="line">            <span class="comment">// 情况1</span></div><div class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">'*'</span>)&#123;</div><div class="line">                dp[i + <span class="number">1</span>] = <span class="number">9</span>*dp[i];</div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">'0'</span>)&#123;</div><div class="line">                dp[i + <span class="number">1</span>] = <span class="number">0</span>;</div><div class="line">            &#125;<span class="keyword">else</span> &#123; <span class="comment">// 123456789</span></div><div class="line">                dp[i + <span class="number">1</span>] = dp[i];</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 情况2</span></div><div class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">'*'</span>)&#123;</div><div class="line">                <span class="keyword">if</span>(s.charAt(i-<span class="number">1</span>) == <span class="string">'*'</span>)&#123;</div><div class="line">                    dp[i + <span class="number">1</span>] += <span class="number">15</span>*dp[i-<span class="number">1</span>];</div><div class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i-<span class="number">1</span>)==<span class="string">'1'</span>)&#123;</div><div class="line">                    dp[i + <span class="number">1</span>] += <span class="number">9</span>*dp[i-<span class="number">1</span>];</div><div class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i-<span class="number">1</span>) == <span class="string">'2'</span>)&#123;</div><div class="line">                    dp[i + <span class="number">1</span>] += <span class="number">6</span>*dp[i-<span class="number">1</span>];</div><div class="line">                &#125;</div><div class="line">            &#125;<span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span>(s.charAt(i-<span class="number">1</span>) == <span class="string">'*'</span>)&#123;</div><div class="line">                    <span class="keyword">if</span>(s.charAt(i) != <span class="string">'0'</span> &amp;&amp; s.charAt(i) &gt; <span class="string">'6'</span>)&#123;</div><div class="line">                        dp[i + <span class="number">1</span>] += dp[i-<span class="number">1</span>];</div><div class="line">                    &#125;<span class="keyword">else</span>&#123; <span class="comment">//  if(s.charAt(i) &lt;= '6')</span></div><div class="line">                        dp[i + <span class="number">1</span>] += <span class="number">2</span>*dp[i-<span class="number">1</span>];</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                &#125;<span class="keyword">else</span>  <span class="keyword">if</span>(s.charAt(i-<span class="number">1</span>) &gt; <span class="string">'0'</span> &amp;&amp; (s.charAt(i-<span class="number">1</span>) &lt; <span class="string">'2'</span> || (s.charAt(i-<span class="number">1</span>)==<span class="string">'2'</span>&amp;&amp;s.charAt(i) &lt;= <span class="string">'6'</span>)))&#123;</div><div class="line">                    dp[i + <span class="number">1</span>] += dp[i-<span class="number">1</span>];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(dp[i+<span class="number">1</span>] == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">            dp[i+<span class="number">1</span>] = dp[i+<span class="number">1</span>]%<span class="number">1000000007</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(dp[s.length()]%<span class="number">1000000007</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="单序列型动态规划">5.2. 单序列型动态规划</h2><p><strong>状态</strong>：<code>f[i]</code>表示<strong>前i个</strong>位置/数字/字符，第i个…</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">   前i个位置</div><div class="line">|-------------|</div><div class="line">|<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,...,i|...,n</div><div class="line">|-------------|</div></pre></td></tr></table></figure>
<p><strong>方程</strong>：<code>f[i] = f[j]</code>…,j是i之前的一个位置</p>
<p><strong>初始化</strong>：<code>f[0]</code>…</p>
<p><strong>答案</strong>：<code>f[n]</code>…</p>
<p>一般answer是<code>f[n]</code>而不是<code>f[n-1]</code>：因为对于n个字符，包含前0个字符（空串）、前1个字符、…、前n个字符</p>
<p>因此<code>f[]</code>一般都要开<code>n+1</code>个</p>
<h3 id="例题1，Word-Break">5.2.1. 例题1，Word Break</h3><p>给一个词<code>lintcode</code>，和一个字典<code>dict=[&quot;lint&quot;,&quot;code&quot;]</code>，这个词能不能被词拆分成词典中的词→<code>lint code</code></p>
<p>暴力方法：递归搜索复杂度→$2^n$</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">状态：f[i]表示前i个字符能不能被切成dict中的词</div><div class="line">  </div><div class="line">^表示字符串开始</div><div class="line"></div><div class="line">idx → <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span></div><div class="line">f   → <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> ← <span class="number">1</span>=<span class="keyword">true</span>,<span class="number">0</span>=<span class="keyword">false</span></div><div class="line">s   → ^ l i n t c o d e</div><div class="line"></div><div class="line">计算步骤：</div><div class="line">i = <span class="number">4</span>,lint: </div><div class="line">lin + t -&gt; ×</div><div class="line">li  + nt -&gt; ×</div><div class="line">l   + <span class="keyword">int</span> -&gt; ×</div><div class="line"><span class="string">''</span>  + lint -&gt; √</div><div class="line"></div><div class="line">i = <span class="number">8</span>,lintcode：</div><div class="line">lintcod + e</div><div class="line">lintco + de</div><div class="line">lintc + ode</div><div class="line">lint + code -&gt; √</div><div class="line"></div><div class="line"></div><div class="line">f[<span class="number">0</span>] = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">|=======前i个位置=======|</div><div class="line">  </div><div class="line">|------------|---------|</div><div class="line">|<span class="number">1</span>,<span class="number">2</span>,......,j|j+<span class="number">1</span>,...,i|</div><div class="line">|------------|---------|</div><div class="line"> 在j位置切一刀，如果<span class="number">1</span>~j能被完美切分，那<span class="number">1</span>~i就取决于j+<span class="number">1</span>~j能不能被完美切分</div><div class="line"></div><div class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++i )&#123;</div><div class="line">  <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i ; ++j )&#123;</div><div class="line">  <span class="comment">// s[j~i]的操作是O(n)的！</span></div><div class="line">  <span class="comment">// in dict操作也是O(n)的！因为是单词的hash表，要依次比较的哇</span></div><div class="line">  <span class="keyword">if</span>(f[j] &amp;&amp; s[j~i] in dict )&#123;</div><div class="line">  		f[i] = <span class="keyword">true</span>;</div><div class="line">  		<span class="keyword">break</span>;</div><div class="line">  	&#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>时间复杂度：$O(n^3)$</p>
<p><strong>优化</strong></p>
<p>利用单词平均长度（单词不会很长）– L ,从后往前哇！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">i = <span class="number">4</span>,lint: </div><div class="line"><span class="string">''</span>  + lint -&gt; √</div><div class="line"></div><div class="line">i = <span class="number">8</span>,lintcode：</div><div class="line">l + intcode</div><div class="line">li + ntcode</div><div class="line">lin + tcode</div><div class="line">lint + code -&gt; √</div><div class="line"></div><div class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++i )&#123;</div><div class="line">  <span class="keyword">for</span>( <span class="keyword">int</span> j = i-<span class="number">1</span>; j &gt;= <span class="number">0</span> ; --j )&#123;</div><div class="line">  <span class="keyword">if</span>(f[j] &amp;&amp; s[j~i] in dict )&#123;</div><div class="line">  		f[i] = <span class="keyword">true</span>;</div><div class="line">  		<span class="keyword">break</span>;</div><div class="line">  	&#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">n：词长度</div><div class="line">m：词典单词个数</div><div class="line">L：单词平均长度</div></pre></td></tr></table></figure>
<p>时间复杂度：$O(n\times L^2 + m)$</p>
<p>最终我采用的方案是：用trie给dict建树，搜索时从后往前搜索</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</div><div class="line">        Node[] children;</div><div class="line">        <span class="keyword">boolean</span> hasWord;</div><div class="line">        Node()&#123;</div><div class="line">            children = <span class="keyword">new</span> Node[<span class="number">26</span>];</div><div class="line">            hasWord = <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span></span>&#123;</div><div class="line">  Node root;</div><div class="line">  Trie()&#123;</div><div class="line">    root = <span class="keyword">new</span> Node();</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 添加节点</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String s)</span></span>&#123;</div><div class="line">    Node r = <span class="keyword">this</span>.root;</div><div class="line">    <span class="keyword">int</span> index;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">char</span> c : s.toCharArray() )&#123;</div><div class="line">      index = c - <span class="string">'a'</span>;</div><div class="line">      <span class="keyword">if</span>(<span class="keyword">null</span> == r.children[index])&#123;</div><div class="line">        r.children[index] = <span class="keyword">new</span> Node();</div><div class="line">      &#125;</div><div class="line">      r = r.children[index];</div><div class="line">    &#125;</div><div class="line">    r.hasWord = <span class="keyword">true</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//优化后的搜索</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">char</span>[] s,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">    Node r = <span class="keyword">this</span>.root;</div><div class="line">    <span class="keyword">int</span> index,count = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start ; i &lt; end ; ++i )&#123;</div><div class="line">      index = s[i] - <span class="string">'a'</span>;</div><div class="line">      <span class="keyword">if</span>( <span class="keyword">null</span> == r.children[index] )&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">      &#125;<span class="keyword">else</span>&#123;</div><div class="line">        r = r.children[index];</div><div class="line">        ++count;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">boolean</span> res = count == end - start &amp;&amp; r.hasWord;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</div><div class="line">  <span class="keyword">char</span>[] c = s.toCharArray();</div><div class="line">  <span class="keyword">int</span> n = c.length;</div><div class="line">  <span class="comment">// 为wordDict建立trie树</span></div><div class="line">  Trie trie = <span class="keyword">new</span> Trie();</div><div class="line">  <span class="keyword">for</span>( String w : wordDict )&#123;</div><div class="line">    trie.add(w);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//状态f[i]:单词0~i是否能被break</span></div><div class="line">  <span class="keyword">boolean</span>[] f = <span class="keyword">new</span> <span class="keyword">boolean</span>[n+<span class="number">1</span>];</div><div class="line">  <span class="comment">//初始化</span></div><div class="line">  f[<span class="number">0</span>] = <span class="keyword">true</span>;</div><div class="line">  <span class="comment">//dp</span></div><div class="line">  <span class="keyword">int</span> i,j;</div><div class="line">  <span class="comment">//O(N*L*L)</span></div><div class="line">  <span class="keyword">for</span>( i = <span class="number">1</span> ; i &lt;= n ; ++i )&#123; <span class="comment">// O(N) </span></div><div class="line">    <span class="keyword">for</span>( j = i ; j &gt;= <span class="number">0</span> ; --j )&#123;<span class="comment">//从后往前搜索,O(L)</span></div><div class="line">      <span class="keyword">if</span>( f[j] &amp;&amp; trie.search(c,j,i) )&#123;<span class="comment">//O(L)</span></div><div class="line">        f[i] = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> f[n];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="例题2，Palindrome-Partitioning-II">5.2.2. 例题2，Palindrome Partitioning II</h3><p>一个str最少被切割几次可以切割为都是回文串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line">f[i]:前i个字母，最少被切割几次可以切割为都是回文串</div><div class="line"></div><div class="line">|=======前i个位置=======|</div><div class="line">  </div><div class="line">|------------|---------|</div><div class="line">|<span class="number">1</span>,<span class="number">2</span>,......,j|j+<span class="number">1</span>,...,i|</div><div class="line">|------------|---------|</div><div class="line"></div><div class="line"> 找到一个j，使得<span class="number">1</span>~j是回文串，且j+<span class="number">1</span>~i能被分割为回文串。则f[i] = f[j] + <span class="number">1</span></div><div class="line">  </div><div class="line"> 遍历j，使得f[i] = min( f[j] + <span class="number">1</span> ) </div><div class="line">  </div><div class="line">f[<span class="number">0</span>]  = -<span class="number">1</span> <span class="comment">// 原因，f[0]代表空串，为了抵消空串和真正串的1</span></div><div class="line"><span class="comment">// 例如"aba",被切成"aba"+""，即f[aba] = 1 + f[0]，但它应该等于0.所以我们定义f[0] = -1</span></div><div class="line"></div><div class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= s.length ; ++i )&#123;</div><div class="line">  f[i] = Integer.MAX_VALUE; <span class="comment">//其实也可以是i-1</span></div><div class="line">  <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; i ; ++j )&#123;</div><div class="line">    <span class="keyword">if</span>( s[j~i] is Palindrome )&#123;</div><div class="line">      f[i] = Math.min( f[i], f[j] + <span class="number">1</span> )</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">代码：</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span>[][] ifPalindrome;</div><div class="line">    <span class="keyword">int</span>[] min;</div><div class="line">    <span class="comment">//判断i~j是否是回文串</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Palindrome</span><span class="params">(<span class="keyword">char</span>[] c,<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>( ifPalindrome[i][j] &gt; <span class="number">0</span> ) &#123;</div><div class="line">            <span class="keyword">return</span> ifPalindrome[i][j];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>( i == j )&#123;</div><div class="line">            ifPalindrome[i][j] = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( c[i] == c[j] )&#123;</div><div class="line">            <span class="keyword">if</span>( j - i &lt; <span class="number">3</span> )&#123;</div><div class="line">                ifPalindrome[i][j] = <span class="number">1</span>;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                ifPalindrome[i][j] = ifPalindrome[i+<span class="number">1</span>][j-<span class="number">1</span>] ;</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            ifPalindrome[i][j] = <span class="number">2</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ifPalindrome[i][j];</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//dp递归</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cut</span><span class="params">(<span class="keyword">char</span>[] c,<span class="keyword">int</span> idx, <span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>( idx &gt;= n ) &#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</div><div class="line">        <span class="keyword">if</span>( min[idx] &gt; <span class="number">0</span> )&#123; <span class="keyword">return</span> min[idx];&#125;</div><div class="line">        <span class="comment">/** idx ....,j,....,n</span></div><div class="line">         * 如果idx~j是回文，则从j切一刀，[i~n] = 1 + [j~n]**/</div><div class="line">        min[idx] = n;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = idx ; j &lt; n ; ++j )&#123;</div><div class="line">            <span class="keyword">if</span>( Palindrome(c,idx,j) == <span class="number">1</span> )&#123;</div><div class="line">                min[idx] = Math.min( <span class="number">1</span> + cut( c, j+<span class="number">1</span>, n ), min[idx] );</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> min[idx];</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//主函数</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCut</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> n = s.length();</div><div class="line">        <span class="keyword">if</span>( n &lt;= <span class="number">1</span> ) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        min = <span class="keyword">new</span> <span class="keyword">int</span>[n];</div><div class="line">        ifPalindrome = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</div><div class="line">        <span class="keyword">char</span>[] c = s.toCharArray();</div><div class="line">        <span class="keyword">int</span> res =  cut(c,<span class="number">0</span>,n);</div><div class="line">        <span class="keyword">return</span> res-<span class="number">1</span>; <span class="comment">// 因为到末尾的时候也切了一刀，这一刀没有必要！</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>另一种思路</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">f[i] : 前i个字符，最少可以被切为几个回文串</div></pre></td></tr></table></figure>
<p><strong>优化</strong>：判断i~j是否是回文串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">i,i+<span class="number">1</span>.........,j-<span class="number">1</span>,j 是回文串，则</div><div class="line">i,i+<span class="number">1</span>,........,j-<span class="number">1</span>   是回文串</div><div class="line"></div><div class="line">这是一种区间型DP，或者说是一种递推</div></pre></td></tr></table></figure>
<h3 id="Palindromic-Substrings">5.2.3. Palindromic Substrings</h3><p>输出一个字符串所有的回文子串的个数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Input: &quot;aaa&quot;</div><div class="line">Output: 6</div><div class="line">Explanation: Six palindromic strings: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;.</div></pre></td></tr></table></figure>
<p>我的思路非常暴力：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>. str -&gt; <span class="keyword">char</span>[] c</div><div class="line"><span class="number">2</span>. 定义<span class="keyword">int</span>[][] ifPalindromic -&gt; ifPalindromic[i][j] = <span class="number">1</span>-&gt;是回文串，<span class="number">2</span>-&gt;不是</div><div class="line"><span class="number">3</span>. <span class="keyword">if</span> c[i] == c[j]&#123; <span class="comment">// i~j可能是回文串</span></div><div class="line">	ifPalindromic = Palindromic[i+<span class="number">1</span>][j-<span class="number">1</span>];</div><div class="line">&#125;</div><div class="line"><span class="number">4</span>. <span class="keyword">else</span>:</div><div class="line">	<span class="comment">//考察i~j-1和i+1~j</span></div><div class="line">   ifPalindromic[i+<span class="number">1</span>][j] = Palindromic(c,i+<span class="number">1</span>,j);</div><div class="line">   ifPalindromic[i][j-<span class="number">1</span>] = Palindromic(c,i,j-<span class="number">1</span>);</div><div class="line"></div><div class="line"></div><div class="line">代码：</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] ifPalindromic;</div><div class="line"><span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">//计数器</span></div><div class="line"></div><div class="line"><span class="comment">//判断start~end是不是回文串</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">Palindromic</span><span class="params">(<span class="keyword">char</span>[] c, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>( start &gt;= end )<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">  <span class="keyword">if</span>( ifPalindromic[start][end] &gt; <span class="number">0</span> )<span class="keyword">return</span> ifPalindromic[start][end];</div><div class="line">  <span class="keyword">if</span>( c[start] == c[end] )&#123;</div><div class="line">    ifPalindromic[start][end] = Palindromic(c,start+<span class="number">1</span>,end-<span class="number">1</span>);</div><div class="line">  &#125;<span class="keyword">else</span>&#123;</div><div class="line">    ifPalindromic[start][end] = <span class="number">2</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>(start+<span class="number">1</span>&lt;end)ifPalindromic[start+<span class="number">1</span>][end] = Palindromic(c,start+<span class="number">1</span>,end);</div><div class="line">  <span class="keyword">if</span>(start&lt;end-<span class="number">1</span>)ifPalindromic[start][end-<span class="number">1</span>] = Palindromic(c,start,end-<span class="number">1</span>);</div><div class="line">  <span class="keyword">if</span>( ifPalindromic[start][end] == <span class="number">1</span> )&#123;</div><div class="line">    ++count;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> ifPalindromic[start][end];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">char</span>[] c = s.toCharArray();</div><div class="line">  <span class="keyword">int</span> n = c.length;</div><div class="line">  <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</div><div class="line">  ifPalindromic = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</div><div class="line">  <span class="comment">// 1 -&gt; true</span></div><div class="line">  <span class="comment">// 2 -&gt; false</span></div><div class="line">  <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; ++i )&#123;</div><div class="line">    ifPalindromic[i][i] = <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">  Palindromic(c,<span class="number">0</span>,n-<span class="number">1</span>);</div><div class="line">  <span class="keyword">return</span> count+n;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这种思路用自底向上的方法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">若    ,i+<span class="number">1</span>,...,j-<span class="number">1</span>,     是回文串 , 且c[i] == c[j]</div><div class="line">则   i,...........,j    是回文串</div><div class="line"></div><div class="line">计算过程为</div><div class="line"></div><div class="line">i是从大到小的</div><div class="line">j是从i到n的</div><div class="line"></div><div class="line">因为[i+<span class="number">1</span>][...]已经算过了</div><div class="line">因此[i][j] = ...[i+<span class="number">1</span>][j-<span class="number">1</span>]肯定能算出来</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> n = s.length();</div><div class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</div><div class="line">            dp[i][j] = s.charAt(i) == s.charAt(j) &amp;&amp; (j - i &lt; <span class="number">3</span> || dp[i + <span class="number">1</span>][j - <span class="number">1</span>]);</div><div class="line">            <span class="keyword">if</span>(dp[i][j]) ++res;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实还有一种更暴力，更简单的解法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123; <span class="comment">// i是回文串的中点</span></div><div class="line">    extendPalindrome(s, i, i); <span class="comment">//奇数长度</span></div><div class="line">    extendPalindrome(s, i, i + <span class="number">1</span>); <span class="comment">//偶数长度</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> count;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">extendPalindrome</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</div><div class="line">  <span class="keyword">while</span> (left &gt;=<span class="number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;</div><div class="line">    count++; left--; right++;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="House-Robber">5.2.4. House Robber</h3><p>给一个数组<code>int[] nums</code>，表示每个商店的价值。要抢劫，但抢劫时必须至少隔一个商铺抢。问能抢到的最大价值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>( nums.length == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="comment">//状态f[i]：前i家最大价值</span></div><div class="line">        <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length+<span class="number">1</span>];</div><div class="line">        <span class="comment">//初始化</span></div><div class="line">        f[<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">        f[<span class="number">1</span>] = nums[<span class="number">0</span>];</div><div class="line">        <span class="comment">//DP</span></div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; nums.length ; ++i )&#123;</div><div class="line">            f[i+<span class="number">1</span>] = Math.max(f[i],f[i-<span class="number">1</span>]+nums[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> f[nums.length];</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="House-Robber-II">5.2.5. House Robber II</h3><p>给一个数组<code>int[] nums</code>，表示每个商店的价值。商店是成环的，即首尾相接。要抢劫，但抢劫时必须至少隔一个商铺抢。问能抢到的最大价值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>]</div><div class="line">其实成环的商店如果去掉首/尾某个的话，就不成环了，就变成了上一题。</div><div class="line">  <span class="number">1</span> <span class="number">3</span> 	</div><div class="line"><span class="number">5</span>     <span class="number">4</span></div><div class="line">  <span class="number">2</span> <span class="number">6</span></div><div class="line">  </div><div class="line">例如这个环，</div><div class="line">假设肯定不抢<span class="number">1</span>：变成了[<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>]</div><div class="line">假设肯定不抢<span class="number">5</span>：变成了[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>]</div></pre></td></tr></table></figure>
<h2 id="House-Robber-III">5.3. House Robber III</h2><p>商店变成了一个二叉树</p>
<p><strong>思路一，hash表</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">HashMap&lt;TreeNode, <span class="keyword">int</span>[]&gt; memo = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    <span class="comment">// key : 节点</span></div><div class="line">    <span class="comment">// value[0] = 不抢的max，value[1] = 抢的max</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">boolean</span> robed)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span>(!memo.containsKey(root))&#123;</div><div class="line">            memo.put(root, <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>]);</div><div class="line">            memo.get(root)[<span class="number">0</span>] = dfs(root.left, <span class="keyword">false</span>) + dfs(root.right, <span class="keyword">false</span>);</div><div class="line">            memo.get(root)[<span class="number">1</span>] = root.val + dfs(root.left, <span class="keyword">true</span>) + dfs(root.right, <span class="keyword">true</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(robed)&#123; <span class="comment">// 上一轮抢了,这一轮只能不抢</span></div><div class="line">            <span class="keyword">return</span> memo.get(root)[<span class="number">0</span>];</div><div class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//上一轮没抢，这次随意</span></div><div class="line">            <span class="keyword">return</span> Math.max(memo.get(root)[<span class="number">0</span>], memo.get(root)[<span class="number">1</span>]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> Math.max(dfs(root, <span class="keyword">true</span>), dfs(root, <span class="keyword">false</span>));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>思路2，优化</strong></p>
<p>其实只需要用到本状态和上一状态，并不需要hash表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span>[] result = help(root); <span class="comment">//return int[]&#123;with root, without root&#125;</span></div><div class="line">    <span class="keyword">return</span> Math.max(result[<span class="number">0</span>], result[<span class="number">1</span>]);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] help(TreeNode root) &#123;</div><div class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span>[] left = help(root.left);</div><div class="line">    <span class="keyword">int</span>[] right = help(root.right);</div><div class="line">    <span class="comment">//with root</span></div><div class="line">    <span class="keyword">int</span> with = root.val + left[<span class="number">1</span>] + right[<span class="number">1</span>];</div><div class="line">    <span class="keyword">int</span> without = left[<span class="number">0</span>] + right[<span class="number">0</span>];</div><div class="line">    with = Math.max(with, without);</div><div class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;with, without&#125;;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Maximal-Square">5.3.1. Maximal Square</h3><p>给一个0/1矩阵。找到最大全1方阵，返回方阵元素个数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1 0 1 0 0</div><div class="line">1 0 1 1 1</div><div class="line">1 1 1 1 1</div><div class="line">1 0 0 1 0  </div><div class="line"></div><div class="line">-&gt; return 4</div></pre></td></tr></table></figure>
<p>这道题我使用了一种较笨的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">count[i][j] : 当前格子的左上角有多少行/列全<span class="number">1</span>方阵</div><div class="line"></div><div class="line">[i,j]</div><div class="line">x x x x          x</div><div class="line">x x x x          x</div><div class="line">x x x x          x</div><div class="line">x x x c[i-<span class="number">1</span>,j-<span class="number">1</span>] x</div><div class="line">x x x x          <span class="number">1</span> &lt;- [i,j]</div><div class="line"></div><div class="line">如果 c[i-<span class="number">1</span>,j-<span class="number">1</span>] == <span class="number">1</span>，那必须是以下这样时，c[i,j] = <span class="number">1</span> + <span class="number">1</span> = <span class="number">1</span></div><div class="line">x x x x x</div><div class="line">x x x x x</div><div class="line">x x x x x</div><div class="line">x x x <span class="number">1</span> <span class="number">1</span></div><div class="line">x x x <span class="number">1</span> <span class="number">1</span> &lt;- [i,j]</div><div class="line"></div><div class="line">如果 c[i-<span class="number">1</span>,j-<span class="number">1</span>] == <span class="number">2</span>，那必须是以下这样时，c[i,j] = <span class="number">1</span> + <span class="number">2</span> = <span class="number">3</span></div><div class="line">x x x x x</div><div class="line">x x x x x</div><div class="line">x x x x <span class="number">1</span></div><div class="line">x x x <span class="number">1</span> <span class="number">1</span></div><div class="line">x x <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> &lt;- [i,j]</div><div class="line"></div><div class="line">或者这样，c[i,j] = <span class="number">1</span> + <span class="number">1</span> = <span class="number">1</span></div><div class="line">x x x x x</div><div class="line">x x x x x</div><div class="line">x x x x <span class="number">0</span></div><div class="line">x x x <span class="number">1</span> <span class="number">1</span></div><div class="line">x x <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> &lt;- [i,j]</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>( matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span> )<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> max = -<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span>[][] counter = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][matrix[<span class="number">0</span>].length];</div><div class="line">        <span class="keyword">int</span> i,j;</div><div class="line">        <span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; matrix.length ; ++i )&#123;</div><div class="line">            counter[i][<span class="number">0</span>] = (<span class="keyword">int</span>) matrix[i][<span class="number">0</span>] - <span class="number">48</span>;</div><div class="line">            max = Math.max(max,counter[i][<span class="number">0</span>]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>( j = <span class="number">0</span> ; j &lt; matrix[<span class="number">0</span>].length ; ++j )&#123;</div><div class="line">            counter[<span class="number">0</span>][j] = (<span class="keyword">int</span>) matrix[<span class="number">0</span>][j] - <span class="number">48</span>;</div><div class="line">            max = Math.max(max,counter[<span class="number">0</span>][j]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> k,q;</div><div class="line">        <span class="keyword">for</span>( i = <span class="number">1</span> ; i &lt; matrix.length ; ++i )&#123;</div><div class="line">            <span class="keyword">for</span>( j = <span class="number">1</span>; j &lt; matrix[i].length ; ++j )&#123;</div><div class="line">                <span class="keyword">if</span>( matrix[i][j] == <span class="string">'0'</span> ) <span class="keyword">continue</span>;</div><div class="line">                counter[i][j] = <span class="number">1</span>;</div><div class="line">                k = counter[i-<span class="number">1</span>][j-<span class="number">1</span>];</div><div class="line">                <span class="keyword">for</span>( q = <span class="number">1</span> ; q &lt;= k ; ++q )&#123;</div><div class="line">                    <span class="keyword">if</span>( matrix[i-q][j] != <span class="string">'1'</span> || matrix[i][j-q] !=<span class="string">'1'</span> )&#123;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;<span class="keyword">else</span>&#123;</div><div class="line">                        counter[i][j] += <span class="number">1</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                max = Math.max(max, counter[i][j]);</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> max*max;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>事实上，有一种非常非常机智的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="string">'1'</span>) &#123;</div><div class="line">                size[i][j] = min(size[i - <span class="number">1</span>][j - <span class="number">1</span>], min(size[i - <span class="number">1</span>][j], size[i][j - <span class="number">1</span>])) + <span class="number">1</span>;</div><div class="line">                maxsize = max(maxsize, size[i][j]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>还有一种更机智的方法。由于<code>f[i][j]</code>只和前3个结果相关</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">f[i - <span class="number">1</span>][j - <span class="number">1</span>]    f[i][j - <span class="number">1</span>]</div><div class="line">f[i - <span class="number">1</span>][j]        f[i][j]</div></pre></td></tr></table></figure>
<p>故只需要保留一个2行的数组！！！<br>列上不能优化，因为2重循环的时候 下列的时候依赖于上列的结果，上列的结果需要保存到计算下列的时候用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;  </div><div class="line">    <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;  </div><div class="line">        <span class="keyword">return</span> ans;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">int</span> n = <span class="number">2</span>;  </div><div class="line">    <span class="keyword">int</span> m = matrix[<span class="number">0</span>].length;  </div><div class="line">      </div><div class="line">    <span class="comment">// 状态  </span></div><div class="line">    <span class="keyword">int</span>[][] f = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];   <span class="comment">// 2行，m列</span></div><div class="line">    <span class="comment">// 初始化  </span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;  </div><div class="line">        f[i][<span class="number">0</span>] = matrix[i][<span class="number">0</span>];  </div><div class="line">        ans = Math.max(f[i][<span class="number">0</span>], ans);  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;  </div><div class="line">        f[<span class="number">0</span>][i] = matrix[<span class="number">0</span>][i];  </div><div class="line">        ans = Math.max(f[<span class="number">0</span>][i], ans);  </div><div class="line">    &#125;  </div><div class="line">    <span class="comment">// 方程  </span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; matrix.length; i++) &#123;  </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m; j++) &#123;  </div><div class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="number">1</span>) &#123;  </div><div class="line">                f[i%<span class="number">2</span>][j] = Math.min(Math.min(f[(i-<span class="number">1</span>)%<span class="number">2</span>][j-<span class="number">1</span>], f[i%<span class="number">2</span>][j-<span class="number">1</span>]), f[(i-<span class="number">1</span>)%<span class="number">2</span>][j]) + <span class="number">1</span>;  </div><div class="line">            &#125; <span class="keyword">else</span> &#123;  </div><div class="line">                f[i%<span class="number">2</span>][j] = <span class="number">0</span>;  </div><div class="line">            &#125;  </div><div class="line">            ans = Math.max(ans, f[i%<span class="number">2</span>][j]);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    <span class="comment">// 结果  </span></div><div class="line">    <span class="keyword">return</span> ans * ans;</div></pre></td></tr></table></figure>
<h3 id="Paint-House">5.3.2. Paint House</h3><p>给一个二维数组<code>cost[][]</code>，大小为n×3。其中<code>cost[i][q]</code>表示第i个房子涂上第q种颜色时的造价。一共有3种颜色。要求两个相邻房子不可以同色。求涂色最小造价</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="number">0</span>,<span class="number">1</span>,...,|i-<span class="number">1</span>| i |,.....</div><div class="line">        |   | g |</div><div class="line">        | r | b |</div><div class="line">        ---------</div><div class="line">        | g | r |</div><div class="line">        |   | b |</div><div class="line">        ---------</div><div class="line">        | b | r |</div><div class="line">        |   | g |</div><div class="line"></div><div class="line">如上图所示，涂第i个房子的时候，取决于第i-<span class="number">1</span>个房子是什么颜色</div><div class="line"></div><div class="line">而第<span class="number">0</span>~i个房子的总最小造价，一定是第i个房子涂r/g/b颜色时的最小值</div><div class="line"></div><div class="line">那我们可以假设我们已知第i-<span class="number">1</span>个房子涂r/g/b时最小造价，就可以推出第i个房子涂r/g/b时最小造价</div><div class="line"></div><div class="line">total[i][q] = Math.min(</div><div class="line">  				total[i-<span class="number">1</span>][<span class="number">0</span>] + cost[i][<span class="number">1</span>],</div><div class="line">  				total[i-<span class="number">1</span>][<span class="number">0</span>] + cost[i][<span class="number">2</span>],</div><div class="line">  </div><div class="line">  				total[i-<span class="number">1</span>][<span class="number">1</span>] + cost[i][<span class="number">2</span>],</div><div class="line">  				total[i-<span class="number">1</span>][<span class="number">1</span>] + cost[i][<span class="number">0</span>],</div><div class="line">  </div><div class="line">  				total[i-<span class="number">1</span>][<span class="number">2</span>] + cost[i][<span class="number">0</span>],</div><div class="line">  				total[i-<span class="number">1</span>][<span class="number">2</span>] + cost[i][<span class="number">1</span>]</div><div class="line">					)</div><div class="line">  </div><div class="line">将上面这个式子换一种形式：</div><div class="line">total[i][q] = Math.min(</div><div class="line">  Math.min(</div><div class="line">    total[i-<span class="number">1</span>][<span class="number">1</span>] + cost[i][<span class="number">0</span>], --&gt; 第i个房子颜色为<span class="number">0</span>的min</div><div class="line">  	total[i-<span class="number">1</span>][<span class="number">2</span>] + cost[i][<span class="number">0</span>]), </div><div class="line"></div><div class="line">  Math.min(</div><div class="line">    total[i-<span class="number">1</span>][<span class="number">0</span>] + cost[i][<span class="number">1</span>], --&gt; 第i个房子颜色为<span class="number">1</span>的min</div><div class="line">  	total[i-<span class="number">1</span>][<span class="number">2</span>] + cost[i][<span class="number">1</span>]), --&gt;</div><div class="line"></div><div class="line">  Math.min(</div><div class="line">    total[i-<span class="number">1</span>][<span class="number">0</span>] + cost[i][<span class="number">2</span>], --&gt; 第i个房子颜色为<span class="number">2</span>的min</div><div class="line">  	total[i-<span class="number">1</span>][<span class="number">1</span>] + cost[i][<span class="number">2</span>])  --&gt;</div><div class="line">					)</div><div class="line"></div><div class="line">  实现：</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCost</span><span class="params">(<span class="keyword">int</span>[][] costs)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>( costs.length == <span class="number">0</span> || costs[<span class="number">0</span>].length == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  <span class="comment">//状态total[i][q]表示第i个房子在涂第q种颜色时，前i个房子的的最小cost</span></div><div class="line">  <span class="comment">// 0 -&gt; red</span></div><div class="line">  <span class="comment">// 1 -&gt; blue</span></div><div class="line">  <span class="comment">// 2 -&gt; green</span></div><div class="line">  <span class="keyword">int</span> n = costs.length;</div><div class="line">  <span class="keyword">int</span>[][] total = <span class="keyword">new</span> <span class="keyword">int</span>[n][costs[<span class="number">0</span>].length];</div><div class="line"></div><div class="line">  <span class="comment">//初始化</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> q = <span class="number">0</span> ; q &lt; <span class="number">3</span> ; ++q )&#123;</div><div class="line">    total[<span class="number">0</span>][q] = costs[<span class="number">0</span>][q];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++i )&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> q = <span class="number">0</span> ; q &lt; <span class="number">3</span> ; ++q )&#123;</div><div class="line">      total[i][q] = Integer.MAX_VALUE;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//dp</span></div><div class="line">  <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++i )&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> q = <span class="number">0</span> ; q &lt; <span class="number">3</span> ; ++q )&#123;</div><div class="line">      total[i][q] = Math.min(total[i][q],costs[i][q] + total[i-<span class="number">1</span>][(q+<span class="number">1</span>)%<span class="number">3</span>]);</div><div class="line">      total[i][q] = Math.min(total[i][q],costs[i][q] + total[i-<span class="number">1</span>][(q+<span class="number">2</span>)%<span class="number">3</span>]);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  n -= <span class="number">1</span>;</div><div class="line">  <span class="keyword">int</span> res = Math.min(total[n][<span class="number">0</span>],total[n][<span class="number">1</span>]);</div><div class="line">  res =Math.min(res,total[n][<span class="number">2</span>]);</div><div class="line">  <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这个空间复杂度是$O(n)$,时间复杂度是$O(n)$。其实还有优化方法，将空间复杂度降为$O(1)$：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCost</span><span class="params">(<span class="keyword">int</span>[][] costs)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(costs==<span class="keyword">null</span>||costs.length==<span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;costs.length; i++)&#123;</div><div class="line">        costs[i][<span class="number">0</span>] += Math.min(costs[i-<span class="number">1</span>][<span class="number">1</span>],costs[i-<span class="number">1</span>][<span class="number">2</span>]);</div><div class="line">        costs[i][<span class="number">1</span>] += Math.min(costs[i-<span class="number">1</span>][<span class="number">0</span>],costs[i-<span class="number">1</span>][<span class="number">2</span>]);</div><div class="line">        costs[i][<span class="number">2</span>] += Math.min(costs[i-<span class="number">1</span>][<span class="number">1</span>],costs[i-<span class="number">1</span>][<span class="number">0</span>]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> n = costs.length-<span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> Math.min(Math.min(costs[n][<span class="number">0</span>], costs[n][<span class="number">1</span>]), costs[n][<span class="number">2</span>]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Target-Sum">5.4. Target Sum</h2><p>给一个数组和一个target。求数组的每个元素的正、负和等于target的个数。</p>
<p><strong>思路一，递归memo</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>[][] dp;</div><div class="line">	<span class="comment">// dp[idx][sum + 1000] : 前idx个数字的和为sum时，最终和为S的个数</span></div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> idx, <span class="keyword">int</span> S, <span class="keyword">int</span> sum)</span></span>&#123;</div><div class="line">       <span class="keyword">if</span>(idx == nums.length)&#123;</div><div class="line">           <span class="keyword">if</span>(S == sum) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">           <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span>(dp[idx][<span class="number">1000</span>+sum] &gt; <span class="number">0</span>) <span class="keyword">return</span> dp[idx][<span class="number">1000</span>+sum];</div><div class="line">       dp[idx][<span class="number">1000</span>+sum] = helper(nums, idx + <span class="number">1</span>, S, sum + nums[idx]) +</div><div class="line">               helper(nums, idx + <span class="number">1</span>, S, sum - nums[idx]);</div><div class="line">       <span class="keyword">return</span> dp[idx][<span class="number">1000</span>+sum];</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</div><div class="line">       dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length][<span class="number">2001</span>];</div><div class="line">       <span class="keyword">return</span> helper(nums, <span class="number">0</span>, S, <span class="number">0</span>);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p><strong>思路2，非递归memo</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</div><div class="line">    <span class="comment">// 如果S过大或过小，大于所有数字的和，或小于所有数字的最小和，那就gg</span></div><div class="line">    <span class="keyword">int</span> allSum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> e : nums) allSum += e;</div><div class="line">    <span class="keyword">if</span>(S &gt; allSum || S &lt; -allSum)<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>][<span class="number">2001</span>];</div><div class="line">    <span class="comment">// dp[idx][sum + 1000] : 前idx个数字(不含)的和为sum时，最终和为S的个数</span></div><div class="line">    <span class="comment">//初始化,0个数字时</span></div><div class="line">    dp[<span class="number">0</span>][<span class="number">1000</span> + <span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">    <span class="comment">//dp</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> idx = <span class="number">1</span>; idx &lt;= nums.length; ++idx )&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> sum = <span class="number">0</span>; sum &lt;<span class="number">2001</span>; ++sum)&#123; <span class="comment">// 这个循环我没想出来！</span></div><div class="line">            <span class="keyword">if</span>(dp[idx-<span class="number">1</span>][sum] != <span class="number">0</span> &amp;&amp;</div><div class="line">                sum + nums[idx-<span class="number">1</span>] &lt; <span class="number">2001</span> &amp;&amp;</div><div class="line">                sum - nums[idx-<span class="number">1</span>] &lt; <span class="number">2001</span>) &#123;</div><div class="line">                dp[idx][sum + nums[idx-<span class="number">1</span>]] += dp[idx - <span class="number">1</span>][sum];</div><div class="line">                dp[idx][sum - nums[idx-<span class="number">1</span>]] += dp[idx - <span class="number">1</span>][sum];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dp[nums.length][<span class="number">1000</span> + S];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>优化思路2</strong></p>
<p>由于只会用到前一状态的dp。因此可以简化维度：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</div><div class="line">        <span class="comment">// 如果S过大，大于所有数字的和，那就gg</span></div><div class="line">        <span class="keyword">int</span> allSum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> e : nums) allSum += e;</div><div class="line">        <span class="keyword">if</span>(S &gt; allSum || S &lt; -allSum)<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span>[] last = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2001</span>];</div><div class="line">        <span class="comment">//初始化,0个数字时</span></div><div class="line">        last[<span class="number">1000</span> + <span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">        <span class="comment">//dp</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> idx = <span class="number">1</span>; idx &lt;= nums.length; ++idx )&#123;</div><div class="line">            <span class="keyword">int</span>[] curr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2001</span>];</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> sum = <span class="number">0</span>; sum &lt;<span class="number">2001</span>; ++sum)&#123;</div><div class="line">                <span class="keyword">if</span>(last[sum] != <span class="number">0</span> &amp;&amp;</div><div class="line">                    sum + nums[idx-<span class="number">1</span>] &lt; <span class="number">2001</span> &amp;&amp;</div><div class="line">                    sum - nums[idx-<span class="number">1</span>] &lt; <span class="number">2001</span>) &#123;</div><div class="line">                    curr[sum + nums[idx-<span class="number">1</span>]] += last[sum];</div><div class="line">                    curr[sum - nums[idx-<span class="number">1</span>]] += last[sum];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            last = curr;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> last[<span class="number">1000</span> + S];</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="双序列动态规划">5.5. 双序列动态规划</h2><p>给了两个串，研究两个串之间的关系</p>
<p><strong>状态</strong>：<code>f[i][j]</code>代表第一个sequence的前i个数字/字符，配上第二个sequence的前j个…</p>
<p><strong>方程</strong>：<code>f[i][j]</code>=研究第i和第j之间的匹配关系</p>
<p><strong>初始化</strong>：<code>f[i][0]</code>和<code>f[0][i]</code></p>
<p><strong>答案</strong>：<code>f[n][m]</code></p>
<p>n = s1.length()</p>
<p>m = s2.length()</p>
<h3 id="例题1，Longest-Common-Subsequence">5.5.1. 例题1，Longest Common Subsequence</h3><p>最长公共子序列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">子问题的概念</div><div class="line"></div><div class="line">例如刚才的longest increasing subsequence问题，先求leet，再求leetcode</div><div class="line"></div><div class="line">这个问题，可以这么考虑：</div><div class="line"></div><div class="line">s1 = abcd</div><div class="line">s2 = acde</div><div class="line"></div><div class="line">ab</div><div class="line">ac</div><div class="line"></div><div class="line">ab</div><div class="line">acd</div><div class="line"></div><div class="line">ab</div><div class="line">acde</div><div class="line"></div><div class="line">abc</div><div class="line">acd</div><div class="line"></div><div class="line">abc</div><div class="line">acde</div><div class="line"></div><div class="line">abcd</div><div class="line">acde</div><div class="line"></div><div class="line">最后要求的是f[abcd][acde] = ?  --&gt; f[<span class="number">4</span>][<span class="number">4</span>] = ?</div><div class="line">    </div><div class="line">   i</div><div class="line">   ↓</div><div class="line">abcd...</div><div class="line">acde...</div><div class="line">   ↑</div><div class="line">   j</div><div class="line">   </div><div class="line">想要计算f[i][j] -&gt; 字符串<span class="number">0</span>~i配上字符串<span class="number">0</span>~j的LCS是多少？</div><div class="line"></div><div class="line">如果最后一个字符一样，和另一种不一样，是两种情况。</div><div class="line"></div><div class="line"><span class="number">1</span>. 如果不一样，当然不能都扔了。考虑扔掉一个试试。即考虑f[i][j-<span class="number">1</span>]或f[i-<span class="number">1</span>][j]。即：</div><div class="line">  <span class="keyword">if</span> a[i-<span class="number">1</span>]!=b[j-<span class="number">1</span>]</div><div class="line">      f[i][j] = Math.max(</div><div class="line">    	f[i-<span class="number">1</span>][j],<span class="comment">//i不在LCS里</span></div><div class="line">    	f[i][j-<span class="number">1</span>],<span class="comment">//j不在LCS里</span></div><div class="line">  		f[i-<span class="number">1</span>][j-<span class="number">1</span>])<span class="comment">//都不在 (其实这个已经包含在前两个里)</span></div><div class="line"><span class="number">2</span>. 如果一样：就把两个都去掉试试(其实也可以去掉一个试试)</div><div class="line">  <span class="keyword">else</span>:</div><div class="line">      f[i][j] = Math.max(</div><div class="line">      	f[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>,<span class="comment">//都不在</span></div><div class="line">        f[i][j-<span class="number">1</span>],<span class="comment">//j不在LCS里(其实这个已经在第一个里了，这是一种贪心的思路)</span></div><div class="line">        f[i-<span class="number">1</span>][j]<span class="comment">//i不在LCS里(其实这个已经在第一个里了)</span></div><div class="line">      	)</div><div class="line"><span class="keyword">return</span> f[n][m]</div></pre></td></tr></table></figure>
<h3 id="例题2，Edit-Distance">5.5.2. 例题2，Edit Distance</h3><p>将第一个字符串最少改动，变成第二个字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line">s1 = <span class="string">"mart"</span>;</div><div class="line">s2 = <span class="string">"karma"</span>;</div><div class="line"><span class="keyword">return</span> <span class="number">3</span></div><div class="line"></div><div class="line">f[i][j] ： s1的前i个字符配上s2的前j个字符的LCS长度</div><div class="line">  </div><div class="line"><span class="keyword">if</span> 最后一个字符不等：</div><div class="line">	f[i][j] = Math.min(</div><div class="line">      <span class="comment">//直接把不等的这一位替换 -&gt; 将s1[i]替换为s2[j]</span></div><div class="line">      <span class="comment">// s1 =  mart -&gt;  mar|a</span></div><div class="line">      <span class="comment">// s2 = karma -&gt; karm|a</span></div><div class="line">      f[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>, <span class="comment">//+1指替换这个字符的操作</span></div><div class="line">      </div><div class="line">      <span class="comment">//给s1添加一个s2[j]，并将s2错一位 -&gt; 在s1的i位置插入s2[j]</span></div><div class="line">      <span class="comment">// s1 =  mart -&gt; mart |a</span></div><div class="line">      <span class="comment">// s2 = karma -&gt; karm |a</span></div><div class="line">      f[i][j-<span class="number">1</span>] + <span class="number">1</span> ,</div><div class="line">      </div><div class="line">      <span class="comment">// 将s1错一位  -&gt; 删除s1[i]</span></div><div class="line">      <span class="comment">// s1 =  mart -&gt;   mar |t</span></div><div class="line">      <span class="comment">// s2 = karma -&gt; karma</span></div><div class="line">      f[i-<span class="number">1</span>][j] + <span class="number">1</span>)</div><div class="line"><span class="keyword">else</span>:</div><div class="line">      f[i][j] = Math.min(</div><div class="line">      <span class="comment">//将相等的这一位保留</span></div><div class="line">      <span class="comment">// s1 =  mart -&gt;  mar|t</span></div><div class="line">      <span class="comment">// s2 =  kart -&gt;  kar|t</span></div><div class="line">      f[i][j] = f[i-<span class="number">1</span>][j-<span class="number">1</span>],</div><div class="line">        </div><div class="line">      <span class="comment">//将相等的一位放弃，并在之后插入一个与之一样的(其实已经包含在第一种)</span></div><div class="line">      <span class="comment">// s1 =  mart -&gt;  martt</span></div><div class="line">      <span class="comment">// s2 =  kart -&gt;   kart</span></div><div class="line">      f[i][j] = f[i][j-<span class="number">1</span>] + <span class="number">1</span>,</div><div class="line">        </div><div class="line">      <span class="comment">//将相等的一位删除(其实已经包含在第一种)</span></div><div class="line">      <span class="comment">// s1 =  mart -&gt;   mar</span></div><div class="line">      <span class="comment">// s2 =  kart -&gt;  kart</span></div><div class="line">      f[i][j] = f[i-<span class="number">1</span>][j] + <span class="number">1</span></div><div class="line">      )</div><div class="line">      </div><div class="line">初始化：</div><div class="line"></div><div class="line">f[i][<span class="number">0</span>] = <span class="number">0</span>, f[<span class="number">0</span>][j] = <span class="number">0</span></div><div class="line">     </div><div class="line">        </div><div class="line">答案：</div><div class="line">f[n][m]</div><div class="line"></div><div class="line">代码</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</div><div class="line">        <span class="keyword">char</span>[] c1 = word1.toCharArray();</div><div class="line">        <span class="keyword">char</span>[] c2 = word2.toCharArray();</div><div class="line">        <span class="keyword">int</span> n1 = c1.length;</div><div class="line">        <span class="keyword">int</span> n2 = c2.length;</div><div class="line">        <span class="comment">//min[i][j] ： s1的前i个字符配上s2的前j个字符的最少改动次数</span></div><div class="line">        ++n1;</div><div class="line">        ++n2;</div><div class="line">        <span class="keyword">int</span>[][] min = <span class="keyword">new</span> <span class="keyword">int</span>[n1][n2];</div><div class="line">        <span class="comment">//初始化</span></div><div class="line">        min[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n1 ; ++i )&#123;</div><div class="line">            min[i][<span class="number">0</span>] = i;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; n2; ++j )&#123;</div><div class="line">            min[<span class="number">0</span>][j] = j;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//dp</span></div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n1 ; ++i )&#123;</div><div class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; n2 ; ++j )&#123;</div><div class="line">                min[i][j] = n2;</div><div class="line">                <span class="keyword">if</span>( c1[i-<span class="number">1</span>] == c2[j-<span class="number">1</span>] )&#123;</div><div class="line">                    <span class="comment">//s1 = "...t"</span></div><div class="line">                    <span class="comment">//s2 = "...t"</span></div><div class="line">                    min[i][j] = Math.min( min[i-<span class="number">1</span>][j-<span class="number">1</span>] , <span class="comment">//相等</span></div><div class="line">                                Math.min(min[i][j-<span class="number">1</span>] + <span class="number">1</span>, <span class="comment">// 在s1[i]后添加s2[j]</span></div><div class="line">                                         min[i-<span class="number">1</span>][j] + <span class="number">1</span>) );  <span class="comment">// 删s1[i]</span></div><div class="line">                &#125;<span class="keyword">else</span>&#123;</div><div class="line">                    <span class="comment">// s1 = "....a"</span></div><div class="line">                    <span class="comment">// s2 = "....b"</span></div><div class="line">                    min[i][j] = Math.min(min[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>, <span class="comment">// 用s2[j]替换s1[i]</span></div><div class="line">                                Math.min(min[i][j-<span class="number">1</span>] + <span class="number">1</span>,  <span class="comment">// 在s1后添加s[j]</span></div><div class="line">                                         min[i-<span class="number">1</span>][j] + <span class="number">1</span>));   <span class="comment">// 删s1[i]</span></div><div class="line"></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> min[n1-<span class="number">1</span>][n2-<span class="number">1</span>];</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="例题3，Distinct-Subsequences">5.5.3. 例题3，Distinct Subsequences</h3><p>从S=”rabbbit”挑出T = “rabbit”有几种挑法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">状态：f[i][j]</div><div class="line">	S的“前i”个字符中选取T的前j个字符，有多少种方案</div><div class="line"></div><div class="line">方程：</div><div class="line"></div><div class="line">最后一位相等：</div><div class="line">S = rabb  ---- i</div><div class="line">T =  rab  ---- j</div><div class="line">f[i][j] = 有几种方案 ：</div><div class="line"><span class="number">1</span>. f[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>  <span class="comment">// 匹配上i和j</span></div><div class="line">  S = rab | b</div><div class="line">  T =  ra | b</div><div class="line"><span class="number">2</span>. f[i-<span class="number">1</span>][j]   <span class="comment">//不要i</span></div><div class="line">  S = rab | b</div><div class="line">  T = rab</div><div class="line">  </div><div class="line">  </div><div class="line">最后一位不等：</div><div class="line">S = rabbbi  ---- i</div><div class="line">T = rab     ---- j</div><div class="line">直接扔掉S最后一位f[i][j] = f[i-<span class="number">1</span>][j]</div><div class="line"></div><div class="line"></div><div class="line">初始化：</div><div class="line"></div><div class="line">f[i][<span class="number">0</span>] = <span class="number">1</span> <span class="comment">// 空串</span></div><div class="line">f[<span class="number">0</span>][j] = <span class="number">0</span>,j&gt;<span class="number">0</span></div><div class="line"></div><div class="line">答案：f[n][m]</div><div class="line"></div><div class="line">代码：</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(String s, String t)</span> </span>&#123;</div><div class="line">        <span class="keyword">char</span>[] cS = s.toCharArray();</div><div class="line">        <span class="keyword">char</span>[] cT = t.toCharArray();</div><div class="line">        <span class="keyword">int</span> nS = cS.length + <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> nT = cT.length + <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span>( nS == <span class="number">1</span> &amp;&amp; nT &gt; <span class="number">1</span> ) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span>( nT == <span class="number">1</span> ) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        <span class="comment">// num[i][j] S的前i个字符，和T的前j个字符，T被S组成的可能的数目</span></div><div class="line">        <span class="keyword">int</span>[][] num = <span class="keyword">new</span> <span class="keyword">int</span>[nS][nT];</div><div class="line">        <span class="comment">//初始化</span></div><div class="line">        num[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; nS; ++i )&#123;</div><div class="line">            num[i][<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; nT ; ++j )&#123;</div><div class="line">            num[<span class="number">0</span>][j] = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// dp</span></div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; nS ; ++i )&#123;</div><div class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; nT ; ++j )&#123;</div><div class="line">                <span class="keyword">if</span>( cS[i-<span class="number">1</span>] == cT[j-<span class="number">1</span>] )&#123;</div><div class="line">                    num[i][j] = num[i-<span class="number">1</span>][j-<span class="number">1</span>]+ num[i-<span class="number">1</span>][j]; <span class="comment">// 相等</span></div><div class="line">                &#125;<span class="keyword">else</span>&#123;</div><div class="line">                    num[i][j] = num[i-<span class="number">1</span>][j];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> num[nS-<span class="number">1</span>][nT-<span class="number">1</span>];</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="例题4，Interleaving-String">5.5.4. 例题4，Interleaving String</h3><p>可行性问题</p>
<p>给了三个字符串s1,s2,s3.判断s3是否是由s1和s2交替组成（按顺序，且可交替着挑）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line">s1 = <span class="string">"aabcc"</span>,s2 = <span class="string">"dbbca"</span></div><div class="line">s3 = <span class="string">"aadbbcbcac"</span> - &gt; <span class="keyword">true</span></div><div class="line">s3 = <span class="string">"aadbbbaccc"</span> -&gt; <span class="keyword">false</span></div><div class="line">  </div><div class="line">直观想法</div><div class="line">f[i][j][k] -- s1的前i个和s2的前j个 能不能交替组成s3的前k个</div><div class="line">k=i+j</div><div class="line"></div><div class="line">即f[i][j][i+j]  --&gt; f[i][j]</div><div class="line"></div><div class="line">倒过来看</div><div class="line"></div><div class="line">s1 = ab......i</div><div class="line">s2 = db......j</div><div class="line">s3 = aa......k</div><div class="line"></div><div class="line">f[i][j] = </div><div class="line"></div><div class="line">如果s1[i]不等于s3[i+j]：</div><div class="line"></div><div class="line"> f[i-<span class="number">1</span>][j] &amp;&amp; s1[i-<span class="number">1</span>] == s3[i+j-<span class="number">1</span>]</div><div class="line"> </div><div class="line">  或者</div><div class="line">  </div><div class="line">如果s2[j]不等于s3[i+j]:</div><div class="line">  </div><div class="line"> f[i][j-<span class="number">1</span>] &amp;&amp; s2[j-<span class="number">1</span>] == s3[i+j-<span class="number">1</span>]</div><div class="line"> </div><div class="line">否则的话，就不行了！</div><div class="line"></div><div class="line"></div><div class="line">初始化：</div><div class="line"></div><div class="line">f[i][<span class="number">0</span>] = ( s[<span class="number">0</span>....i-<span class="number">1</span>] == s3[<span class="number">0</span>...i-<span class="number">1</span>] ) <span class="comment">// 前i段只用s1</span></div><div class="line">f[<span class="number">0</span>][j] = ( s2[<span class="number">0</span>...j-<span class="number">1</span>] == s3[<span class="number">0</span>...j-<span class="number">1</span>] ) <span class="comment">// 前j段只用s2</span></div><div class="line"></div><div class="line">答案：</div><div class="line"></div><div class="line">f[n][m]</div><div class="line"></div><div class="line">n = s1.size</div><div class="line">m = s2.size</div><div class="line"></div><div class="line">代码：</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</div><div class="line">        <span class="keyword">char</span>[] c1 = s1.toCharArray(), c2 = s2.toCharArray(), c3 = s3.toCharArray();</div><div class="line">        <span class="keyword">int</span> n1 = c1.length, n2 = c2.length, n3 = c3.length;</div><div class="line">        <span class="keyword">if</span>( n3 != n1 + n2 ) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        ++n1;++n2;++n3;</div><div class="line">        <span class="comment">//dp[i][j] : c1[0~i]和c2[0~j]能否交替组成c3[i+j]</span></div><div class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n1][n2];</div><div class="line">        <span class="comment">//初始化</span></div><div class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n1 ; ++i )&#123;</div><div class="line">            dp[i][<span class="number">0</span>] = c1[i-<span class="number">1</span>] == c3[i-<span class="number">1</span>] &amp;&amp; dp[i-<span class="number">1</span>][<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; n2 ; ++j )&#123;</div><div class="line">            dp[<span class="number">0</span>][j] = c2[j-<span class="number">1</span>] == c3[j-<span class="number">1</span>] &amp;&amp; dp[<span class="number">0</span>][j-<span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//dp</span></div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n1 ; ++i )&#123;</div><div class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n2; ++j )&#123;</div><div class="line">                <span class="keyword">if</span>( c1[i-<span class="number">1</span>] == c3[i + j - <span class="number">1</span>] )&#123;</div><div class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j];</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>( c2[j-<span class="number">1</span>] == c3[i + j - <span class="number">1</span>] )&#123;</div><div class="line">                    dp[i][j] = dp[i][j-<span class="number">1</span>] || dp[i][j];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dp[n1-<span class="number">1</span>][n2-<span class="number">1</span>];</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="Dungeon-Game">5.5.5. Dungeon Game</h3><p>英雄救美：给一个矩阵<code>int[][] dungegon</code>，每个格子正数代表能量加成，负数代表减弱能量。英雄要从左上走到右下，要求每一时刻英雄的能量不低于1.问英雄初始时最少需要多少能量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">go</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span>[] direct, <span class="keyword">int</span>[][] dungeon,<span class="keyword">int</span>[][] init)</span></span>&#123;</div><div class="line">  <span class="keyword">int</span> initNow;</div><div class="line">  <span class="keyword">if</span>(dungeon[i][j] &gt; init[i+direct[<span class="number">0</span>]][j+direct[<span class="number">1</span>]])&#123;</div><div class="line">    <span class="comment">// 此处能量加成，进入此处前至少具有1的能量</span></div><div class="line">    initNow = <span class="number">1</span>;</div><div class="line">  &#125;<span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// 此处减弱能量，进入此处前必须满足下一步的能量，且至少具有1的能量</span></div><div class="line">    initNow = init[i+direct[<span class="number">0</span>]][j+direct[<span class="number">1</span>]] - dungeon[i][j];</div><div class="line">    initNow = Math.max(initNow,<span class="number">1</span>); </div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> initNow;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateMinimumHP</span><span class="params">(<span class="keyword">int</span>[][] dungeon)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(dungeon.length == <span class="number">0</span> || dungeon[<span class="number">0</span>].length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> n = dungeon.length;<span class="keyword">int</span> m = dungeon[<span class="number">0</span>].length;</div><div class="line">  <span class="comment">// init[i][j] : 进入[i,j]前最少需要的能量</span></div><div class="line">  <span class="keyword">int</span>[][] init = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</div><div class="line">  <span class="comment">// 初始化</span></div><div class="line">  <span class="keyword">if</span>(dungeon[n-<span class="number">1</span>][m-<span class="number">1</span>] &gt; <span class="number">0</span>)&#123;</div><div class="line">    init[n-<span class="number">1</span>][m-<span class="number">1</span>] = <span class="number">1</span>;</div><div class="line">  &#125;<span class="keyword">else</span> &#123;</div><div class="line">    init[n-<span class="number">1</span>][m-<span class="number">1</span>] = -dungeon[n-<span class="number">1</span>][m-<span class="number">1</span>] + <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span>[] right = &#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</div><div class="line">  <span class="keyword">int</span>[] down = &#123;<span class="number">1</span>,<span class="number">0</span>&#125;;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">2</span> ; i &gt;= <span class="number">0</span> ; --i)&#123;</div><div class="line">    init[i][m-<span class="number">1</span>] = go(i,m-<span class="number">1</span>,down,dungeon,init);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j = m - <span class="number">2</span> ; j &gt;= <span class="number">0</span> ; --j)&#123;</div><div class="line">    init[n-<span class="number">1</span>][j] = go(n-<span class="number">1</span>,j,right,dungeon,init);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// dp</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">2</span> ; i &gt;= <span class="number">0</span> ; --i)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = m - <span class="number">2</span> ; j &gt;= <span class="number">0</span> ; --j)&#123;</div><div class="line">      <span class="keyword">int</span> rightInit = go(i,j,right,dungeon,init);</div><div class="line">      <span class="keyword">int</span> downInit = go(i,j,down,dungeon,init);</div><div class="line">      init[i][j] = Math.min(rightInit,downInit);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> init[<span class="number">0</span>][<span class="number">0</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Maximum-Length-of-Repeated-Subarray">5.6. Maximum Length of Repeated Subarray</h2><p>求两个数字的最大连续子数组长度</p>
<p>思路：动态规划</p>
<p>一开始想多了，用了一种非常绕弯的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>[][] dp;</div><div class="line"><span class="comment">// dp[i][j] :从A[i]和B[j]开始的最大子数组长度</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(i &gt;= A.length || j &gt;= B.length) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span>(dp[i][j] &gt; <span class="number">0</span>) <span class="keyword">return</span> dp[i][j];</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(A[i] == B[j])</div><div class="line">        dp[i][j] =  <span class="number">1</span> + helper(A, B, i + <span class="number">1</span>, j + <span class="number">1</span>);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        dp[i][j] = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> dp[i][j];</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(A.length == <span class="number">0</span> || B.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    dp = <span class="keyword">new</span> <span class="keyword">int</span>[A.length][B.length];</div><div class="line"></div><div class="line">    <span class="keyword">int</span> globalMAX = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; ++i)&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; B.length; ++j)&#123;</div><div class="line">            <span class="keyword">if</span>(A[i] == B[j])&#123;</div><div class="line">                globalMAX = Math.max(globalMAX, helper(A, B, i ,j));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> globalMAX;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际上，我写的实在是太绕了。我们看一下正确的DP打开方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(A.length == <span class="number">0</span> || B.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[A.length][B.length];</div><div class="line">        <span class="comment">// dp[i][j]是以A[i]和B[j]结尾的最大子数组长度</span></div><div class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = A[<span class="number">0</span>] == B[<span class="number">0</span>] ? <span class="number">1</span> : <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.length; ++i)&#123;</div><div class="line">            dp[i][<span class="number">0</span>] = A[i] == B[<span class="number">0</span>] ? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">// 初始化边界</span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; B.length; ++j)&#123;</div><div class="line">                dp[<span class="number">0</span>][j] = A[<span class="number">0</span>] == B[j] ? <span class="number">1</span> : <span class="number">0</span>;<span class="comment">// 初始化边界</span></div><div class="line">                <span class="keyword">if</span> (A[i] == B[j]) &#123;</div><div class="line">                    dp[i][j] = <span class="number">1</span> + dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</div><div class="line">                    max = Math.max(dp[i][j], max);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>然而这并不是最快的。</p>
<p>我们看一下骚操作：</p>
<p>其实就是把<code>dp[][]</code>压缩到了一维。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;  </div><div class="line">        <span class="comment">//给定两个数组，找出两者公共的最长子串  </span></div><div class="line">        <span class="comment">//要求：两个子串的长度均小于1000，元素的范围0-99  </span></div><div class="line">          </div><div class="line">        <span class="comment">//参考：动态规划问题DP,采用一个长度为m+1的一维数组来记录各个位置最长匹配的长度  </span></div><div class="line">        <span class="keyword">int</span> n=A.length,m=B.length;  </div><div class="line">        <span class="keyword">int</span> [] dp=<span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>];  </div><div class="line">        <span class="keyword">int</span> max=<span class="number">0</span>;  </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;  </div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;<span class="number">0</span>;j--)&#123;  </div><div class="line">                <span class="keyword">if</span>(A[i-<span class="number">1</span>]==B[j-<span class="number">1</span>])&#123;  </div><div class="line">                    <span class="comment">//存在相同的,更新动态数组  </span></div><div class="line">                    dp[j]=dp[j-<span class="number">1</span>]+<span class="number">1</span>;  </div><div class="line">                    max=Math.max(max,dp[j]);  </div><div class="line">                &#125;<span class="keyword">else</span>&#123;  </div><div class="line">                    <span class="comment">//不存在相同，置0  </span></div><div class="line">                    dp[j]=<span class="number">0</span>;  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">return</span> max;  </div><div class="line">          </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h1 id="相关Leetcode题">6. 相关Leetcode题</h1><h2 id="Ugly-Number">6.1. Ugly Number</h2><p>给一个数num，判断它是不是ugly数——它的质因数只能说是2、3、5。</p>
<p>这道题一开始想复杂了，居然先列出了所有比num小的$2^i3^j5^k$的数。以至于代码变成了这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span>[] k2;</div><div class="line">    <span class="keyword">int</span>[] k3;</div><div class="line">    <span class="keyword">int</span>[] k5;</div><div class="line">    <span class="keyword">int</span> k2_num;</div><div class="line">    <span class="keyword">int</span> k3_num;</div><div class="line">    <span class="keyword">int</span> k5_num;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] setK(<span class="keyword">int</span> k_num,<span class="keyword">double</span> loge)&#123;</div><div class="line">        <span class="keyword">int</span> size = (<span class="keyword">int</span>)(loge/Math.log(k_num))+<span class="number">2</span>;</div><div class="line">        <span class="keyword">if</span>(k_num==<span class="number">2</span>)&#123;</div><div class="line">            k2_num = size;</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k_num==<span class="number">3</span>)&#123;</div><div class="line">            k3_num = size;</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k_num==<span class="number">5</span>)&#123;</div><div class="line">            k5_num = size;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[] k = <span class="keyword">new</span> <span class="keyword">int</span>[size];</div><div class="line">        k[<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> i;</div><div class="line">        <span class="keyword">for</span>( i = <span class="number">1</span>; i &lt; k.length ; ++i )&#123;</div><div class="line">            k[i] = k[i-<span class="number">1</span>]*k_num;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> k;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> i2,i3,i5;</div><div class="line">        <span class="keyword">long</span> re1,re2;</div><div class="line">        <span class="keyword">for</span>( i2 = <span class="number">0</span> ; i2 &lt; k2_num ; ++i2 )&#123;</div><div class="line">            <span class="keyword">for</span>( i3 = <span class="number">0</span> ; i3 &lt; k3_num ; ++i3 )&#123;</div><div class="line">                re1 = k2[i2] * k3[i3];</div><div class="line">                <span class="keyword">if</span>( re1 &gt; num )<span class="keyword">continue</span>;</div><div class="line">                <span class="keyword">for</span>( i5 = <span class="number">0</span> ; i5 &lt; k5_num ; ++i5 )&#123;</div><div class="line">                    re2 = re1 * k5[i5];</div><div class="line">                    <span class="keyword">if</span>( re2 &gt; num )<span class="keyword">continue</span>;</div><div class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(re2 == num)&#123;</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(num == <span class="number">0</span> )<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">double</span> loge = Math.log(num);</div><div class="line">        k2 = setK(<span class="number">2</span>,loge);</div><div class="line">        k3 = setK(<span class="number">3</span>,loge);</div><div class="line">        k5 = setK(<span class="number">5</span>,loge);</div><div class="line">        <span class="keyword">return</span> dp(num);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是！其实我只需要判断它能不能被2、3、5整除！！！！！！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (num&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">if</span>(num==<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">if</span>(num%<span class="number">2</span>==<span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> isUgly(num/<span class="number">2</span>);</div><div class="line">        <span class="keyword">if</span>(num%<span class="number">3</span>==<span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> isUgly(num/<span class="number">3</span>);</div><div class="line">        <span class="keyword">if</span>(num%<span class="number">5</span>==<span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> isUgly(num/<span class="number">5</span>);</div><div class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java-Map]]></title>
      <url>/2017/11/17/Java-Map/</url>
      <content type="html"><![CDATA[<p> 首先介绍一下HashMap的一些常见操作。然后再了解一下其他的Map。</p>
<a id="more"></a>
<h1 id="HashMap">1. HashMap</h1><h2 id="HashMap的排序">1.1. HashMap的排序</h2><p>按照value排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapUtil</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V extends Comparable&lt;? <span class="keyword">super</span> V&gt;&gt; <span class="function">Map&lt;K, V&gt; </span></div><div class="line">        <span class="title">sortByValue</span><span class="params">(Map&lt;K, V&gt; map)</span> &#123;</div><div class="line">       	<span class="comment">// 获取键值对的list</span></div><div class="line">        List&lt;Map.Entry&lt;K, V&gt;&gt; list = <span class="keyword">new</span> LinkedList&lt;Map.Entry&lt;K, V&gt;&gt;(map.entrySet());</div><div class="line">       <span class="comment">// 定义并调用sort接口</span></div><div class="line">        Collections.sort( list, <span class="keyword">new</span> Comparator&lt;Map.Entry&lt;K, V&gt;&gt;() &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Map.Entry&lt;K, V&gt; o1, Map.Entry&lt;K, V&gt; o2)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> (o1.getValue()).compareTo( o2.getValue() );</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">	  <span class="comment">// 依次输出已排序的结果</span></div><div class="line">        Map&lt;K, V&gt; result = <span class="keyword">new</span> LinkedHashMap&lt;K, V&gt;();</div><div class="line">        <span class="keyword">for</span> (Map.Entry&lt;K, V&gt; entry : list) &#123;</div><div class="line">            result.put(entry.getKey(), entry.getValue());</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试用例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"><span class="keyword">import</span> org.junit.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapUtilTest</span> </span>&#123;</div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSortByValue</span><span class="params">()</span> </span>&#123;</div><div class="line">        Random random = <span class="keyword">new</span> Random(System.currentTimeMillis());</div><div class="line">        Map&lt;String, Integer&gt; testMap = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;(<span class="number">1000</span>);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</div><div class="line">            testMap.put( <span class="string">"SomeString"</span> + random.nextInt(), random.nextInt());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        testMap = MapUtil.sortByValue(testMap);</div><div class="line">        Assert.assertEquals(<span class="number">1000</span>, testMap.size());</div><div class="line"></div><div class="line">        Integer previous = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">for</span>(Map.Entry&lt;String, Integer&gt; entry : testMap.entrySet()) &#123;</div><div class="line">            Assert.assertNotNull(entry.getValue());</div><div class="line">            <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</div><div class="line">                Assert.assertTrue(entry.getValue() &gt;= previous);</div><div class="line">            &#125;</div><div class="line">            previous = entry.getValue();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="相关leetcode题">2. 相关leetcode题</h1><h2 id="Sort-Characters-By-Frequency">2.1. Sort Characters By Frequency</h2><p>题意：给一个字符串”tree”，按照字母频率输出“eetr”或”eert”</p>
<p>思路：直接用hashMap统计每个字符的次数，然后按照次数排序并输出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">frequencySort</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        HashMap&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">char</span> c : s.toCharArray() )&#123;</div><div class="line">            <span class="keyword">if</span>( map.containsKey(c) )&#123;</div><div class="line">                map.replace(c,map.get(c)+<span class="number">1</span>);</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                map.put(c,<span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        List&lt;Map.Entry&lt;Character,Integer&gt;&gt; list = <span class="keyword">new</span> LinkedList&lt;Map.Entry&lt;Character,Integer&gt;&gt;(map.entrySet());</div><div class="line">        Collections.sort( list, <span class="keyword">new</span> Comparator&lt;Map.Entry&lt;Character,Integer&gt;&gt;() &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Map.Entry&lt;Character,Integer&gt; o1, Map.Entry&lt;Character,Integer&gt; o2)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> (o2.getValue()).compareTo( o1.getValue() );</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        <span class="keyword">int</span> times;</div><div class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder(s.length());</div><div class="line">        <span class="keyword">for</span> (Map.Entry&lt;Character,Integer&gt; entry : list) &#123;</div><div class="line">            times = entry.getValue();</div><div class="line">            <span class="keyword">while</span> (times&gt;<span class="number">0</span>)&#123;</div><div class="line">                result.append(entry.getKey());</div><div class="line">                --times;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这道题还有另一种精妙的O(n)思路，只是有点浪费空间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">frequencySort</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</div><div class="line">            <span class="keyword">if</span> (map.containsKey(c)) &#123;</div><div class="line">                map.put(c, map.get(c) + <span class="number">1</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                map.put(c, <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        List&lt;Character&gt; [] bucket = <span class="keyword">new</span> List[s.length() + <span class="number">1</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> key : map.keySet()) &#123;</div><div class="line">            <span class="keyword">int</span> frequency = map.get(key);</div><div class="line">            <span class="keyword">if</span> (bucket[frequency] == <span class="keyword">null</span>) &#123;</div><div class="line">                bucket[frequency] = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            &#125;</div><div class="line">            bucket[frequency].add(key);</div><div class="line">        &#125;</div><div class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> pos = bucket.length - <span class="number">1</span>; pos &gt;=<span class="number">0</span>; pos--) &#123;</div><div class="line">            <span class="keyword">if</span> (bucket[pos] != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">char</span> num : bucket[pos]) &#123;</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; map.get(num); i++) &#123;</div><div class="line">                        sb.append(num);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sb.toString();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Java-abstract和interface]]></title>
      <url>/2017/11/17/Java-abstract%E5%92%8Cinterface/</url>
      <content type="html"><![CDATA[<p> 首先我们看一下抽象类abstract。它是普通类与接口之间的一种中庸之道。然后我们介绍一下接口。</p>
<a id="more"></a>
<h1 id="抽象类和抽象方法">1. 抽象类和抽象方法</h1><p>Demo：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">====================================================================</div><div class="line">继承关系：</div><div class="line"><span class="keyword">abstract</span> Instrument</div><div class="line">                ↳	Wind</div><div class="line">====================================================================</div><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> net.minview.util.Print.*;</div><div class="line"><span class="comment">/**乐器抽象类**/</span></div><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Instrument</span></span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> i ;</div><div class="line">  <span class="comment">// 抽象方法</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span></span>;</div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">what</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="string">"Instrument"</span>;&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**某个乐器的具体类**/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wind</span> <span class="keyword">extends</span> <span class="title">Instrument</span></span>&#123;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">void</span> play&#123;Note n&#125;&#123;</div><div class="line">    print(<span class="string">"Wind.play()"</span> + n);</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">what</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="string">"Wind"</span>;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>抽象类不能有对象</li>
<li>如果一个类包含抽象方法，则该类必须被限定为抽象的</li>
<li>抽象类的子类必须定义所有抽象方法</li>
</ul>
<h1 id="接口">2. 接口</h1><p>接口并不是一个类，而是一个极度抽象的类。要让一个类成为一个接口的“子类”，必须用<code>implements</code>关键字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">====================================================================</div><div class="line">关系：</div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Instrument</span></span></div><div class="line">	<span class="keyword">implements</span> ↳ <span class="title">Wind</span></div><div class="line">		   <span class="keyword">extends</span>  ↳  <span class="title">Woodwind</span>		</div><div class="line">====================================================================</div><div class="line"><span class="comment">/**乐器抽象接口**/</span></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Instrument</span></span>&#123;</div><div class="line">  <span class="keyword">int</span> i = <span class="number">5</span> ; <span class="comment">// static &amp; final</span></div><div class="line">  <span class="comment">// 接口方法</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span></span>; <span class="comment">// 不可以有任何实现</span></div><div class="line">&#125;</div><div class="line"><span class="comment">/**某个乐器的具体类**/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wind</span> <span class="keyword">implements</span> <span class="title">Instrument</span></span>&#123;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">void</span> play&#123;Note n&#125;&#123;</div><div class="line">    print(<span class="string">"Wind.play()"</span> + n);</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">what</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="string">"Wind"</span>;&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**一个正常的类**/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Woodwind</span> <span class="keyword">extends</span> <span class="title">Wind</span></span>&#123;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Queue接口">3. Queue接口</h1><p>Java集合类库将接口和实现进行了分离。以队列（Queue）为例。一个队列接口如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt;</span>&#123;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span></span>;</div><div class="line">  <span class="function">E <span class="title">remove</span><span class="params">()</span></span>;</div><div class="line">  <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">| <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> |</div><div class="line">  ↑           ↑</div><div class="line"> 队头        队尾</div></pre></td></tr></table></figure>
<p>这个接口并没有说明队列是如何实现的。队列实现有两种方式：循环数组、链表。</p>
<p>循环数组实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircularArrayQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt;</span>&#123;</div><div class="line">  CircularArrayQueue(<span class="keyword">int</span> capacity)&#123;...&#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span></span>&#123;...&#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span></span>&#123;...&#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;...&#125;</div><div class="line">  <span class="keyword">private</span> E[] elements;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> head;</div><div class="line">  <span class="keyword">private</span> tail;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>链表实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedListQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt;</span>&#123;</div><div class="line">  LinkedListQueue()&#123;...&#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span></span>&#123;...&#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">reove</span><span class="params">()</span></span>&#123;...&#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;...&#125;</div><div class="line">  </div><div class="line">  <span class="keyword">private</span> Link head;</div><div class="line">  <span class="keyword">private</span> Link tail;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="完全解耦">4. 完全解耦</h1><p>为了解释接口的解耦功能，我们先引入一个例子：</p>
<p>程序员甲写了一个Node1，并且写了一个两个Node1的排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node1</span></span>&#123;</div><div class="line">  <span class="keyword">int</span> val;</div><div class="line">  <span class="keyword">int</span> count;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CompareTo</span><span class="params">(Node1 o)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.val - o.val;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node1[] sort(Node1 a,Node1 b)&#123;</div><div class="line">  <span class="keyword">if</span>( a.CompareTo(b) &gt; <span class="number">0</span> )&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Node1[]&#123;a,b&#125;;</div><div class="line">  &#125;<span class="keyword">else</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node1[]&#123;b,a&#125;;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">  Node1 a = <span class="keyword">new</span> Node1();<span class="comment">//此处省略</span></div><div class="line">  Node1 b = <span class="keyword">new</span> Node1();</div><div class="line">  sort(a,b);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>程序员乙写了一个Node2，也写了一个两个Node2的排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node2</span></span>&#123;</div><div class="line">  String key;</div><div class="line">  <span class="keyword">int</span> val;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CompareTo</span><span class="params">(Node2 o)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.val - o.val;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node2[] sort(Node2 a,Node2 b)&#123;</div><div class="line">  <span class="keyword">if</span>( a.CompareTo(b) &gt; <span class="number">0</span> )&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Node2[]&#123;a,b&#125;;</div><div class="line">  &#125;<span class="keyword">else</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node2[]&#123;b,a&#125;;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">  Node2 a = <span class="keyword">new</span> Node2();<span class="comment">//此处省略</span></div><div class="line">  Node2 b = <span class="keyword">new</span> Node2();</div><div class="line">  sort(a,b);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是由于Node1和Node2不是继承自同一个基类，因此代码不能通用。我们通过接口的方式来改进：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">int</span> <span class="title">CompareTo</span><span class="params">(Object o)</span></span>&#123;&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node1</span> <span class="keyword">implements</span> <span class="title">Compareble</span></span>&#123;</div><div class="line">  <span class="keyword">int</span> val;</div><div class="line">  <span class="keyword">int</span> count;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CompareTo</span><span class="params">(Node1 o)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.val - o.val;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node2</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</div><div class="line">  String key;</div><div class="line">  <span class="keyword">int</span> val;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CompareTo</span><span class="params">(Node2 o)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.val - o.val;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//接下来我们利用多态提供通用的sort方法（这个东西类似于Array.sort()）</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Compareble[] sort(Comparable a,Comparable b)&#123;</div><div class="line">  <span class="keyword">return</span> a.CompareTo(b);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">  <span class="comment">//Node1</span></div><div class="line">  Node1 a = <span class="keyword">new</span> Node1();</div><div class="line">  Node1 b = <span class="keyword">new</span> Node1();</div><div class="line">  sort(a,b);</div><div class="line">  </div><div class="line">  <span class="comment">//Node2</span></div><div class="line">  Node2 c = <span class="keyword">new</span> Node2();</div><div class="line">  Node2 d = <span class="keyword">new</span> Node2();</div><div class="line">  sort(c,d);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样一来，只要继承自Comparable接口的类，都可以使用sort()方法了！</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Java-String]]></title>
      <url>/2017/11/16/Java-String/</url>
      <content type="html"><![CDATA[<p> 首先我们来看一些String的特性。</p>
<ul>
<li>String对象不可变！</li>
<li>在函数的参数传递中，String传进去时是一种拷贝</li>
<li>String之间用+号非常不好！（+号内部用的是StringBuilder）</li>
</ul>
<a id="more"></a>
<h1 id="StringBuilder">1. StringBuilder</h1><p>如果想实现将String[] words连接成一个String，那最土的方法就是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">String result = <span class="string">""</span>;</div><div class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; words.length ; ++i )&#123;</div><div class="line">  result += words[i];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但由于每个+都调用了一次StringBuilder，这无疑增加了很多负担。较好的方式是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</div><div class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; words.length ; ++i )&#123;</div><div class="line">  stringBuilder.append(words[i]);</div><div class="line">&#125;</div><div class="line">String result = stringBuilder.toString();</div></pre></td></tr></table></figure>
<h1 id="遍历String的元素">2. 遍历String的元素</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">String a = <span class="string">"abc"</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">char</span> c : a.toCharArray())&#123;</div><div class="line">  <span class="comment">//c</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="一些操作">3. 一些操作</h1><h2 id="B-indexOf">3.1. B.indexOf(...)</h2><p><code>B.indexOf(A)</code> : 从B的头看是查找是否存在A</p>
<p><code>B.indexOf(A, idx)</code> : 从B的第idx个字符开始查找是否存在A</p>
<h2 id="B-startWith-A">3.2. B.startWith(A)</h2><p>判断B是否以A开头</p>
<h2 id="B-contains-A">3.3. B.contains(A)</h2><p>A是否是B的子串</p>
<h2 id="B-trim">3.4. B.trim()</h2><p>trim()方法返回调用字符串对象的一个副本，但是所有起始和结尾的空格都被删除了</p>
<h1 id="相关题">4. 相关题</h1><h2 id="Valid-Palindrome">4.1. Valid Palindrome</h2><p>判断给定字符串（字符或数字，字母不分大小写）是否是回文（字符串中包含的其它字符可以跳过）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">ifAlpha</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> !((c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'z'</span>) || (c - <span class="string">'0'</span> &gt;= <span class="number">0</span> &amp;&amp; c - <span class="string">'0'</span> &lt; <span class="number">10</span>));</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(String s, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">boolean</span> deleted)</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (low &lt; high)&#123;</div><div class="line">        <span class="keyword">if</span>(ifAlpha(s.charAt(low)))&#123;</div><div class="line">            ++low;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(ifAlpha(s.charAt(high)))&#123;</div><div class="line">            --high;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(s.charAt(low) == s.charAt(high))&#123;</div><div class="line">            ++low;</div><div class="line">            --high;</div><div class="line">        &#125; <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(s.length() &lt;= <span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">return</span> helper(s.toLowerCase(), <span class="number">0</span>, s.length() - <span class="number">1</span>,<span class="keyword">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Valid-Palindrome-II">4.2. Valid Palindrome II</h2><p>判断给定字符串（只有字母）至多去掉一个后，是否是回文</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(String s, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">boolean</span> deleted)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(high &gt;= s.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">while</span> (low &lt; high)&#123;</div><div class="line">        <span class="keyword">if</span>(s.charAt(low) == s.charAt(high))&#123;</div><div class="line">            ++low;</div><div class="line">            --high;</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!deleted)&#123;</div><div class="line">            <span class="keyword">return</span> helper(s, low + <span class="number">1</span>, high, <span class="keyword">true</span>)||</div><div class="line">                    helper(s, low, high - <span class="number">1</span>, <span class="keyword">true</span>);</div><div class="line">        &#125;<span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validPalindrome</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(s.length() &lt;= <span class="number">2</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">return</span> helper(s, <span class="number">0</span>, s.length() - <span class="number">1</span>,<span class="keyword">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Shortest-Palindrome">4.3. Shortest Palindrome</h2><p>给一个字符串，如果在前面加一些字符，使它变成回文串。求最短的回文串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">暴力</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(String left, String right)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> l = left.length() - <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> r = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; left.charAt(l) == right.charAt(r))&#123;</div><div class="line">            l--;</div><div class="line">            r++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> l == -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">shortestPalindrome</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(s.length() &lt;= <span class="number">1</span>) <span class="keyword">return</span> s;</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s.length() / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)&#123;</div><div class="line">            <span class="keyword">if</span>(<span class="number">2</span>*i + <span class="number">2</span> &lt;= s.length() &amp;&amp; s.charAt(i) == s.charAt( i + <span class="number">1</span>))&#123;</div><div class="line">                <span class="comment">// [0,i],[i+1,2*i + 1]</span></div><div class="line">                <span class="comment">// String left = s.substring(0, i + 1);</span></div><div class="line">                <span class="comment">// String right = s.substring(i + 1, 2*i + 2);</span></div><div class="line">                <span class="keyword">if</span>(helper(s.substring(<span class="number">0</span>, i + <span class="number">1</span>), s.substring(i + <span class="number">1</span>, <span class="number">2</span>*i + <span class="number">2</span>)))&#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder(s.substring(<span class="number">2</span>*i + <span class="number">2</span>, s.length())).reverse().toString() + s;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; <span class="number">2</span>*i + <span class="number">1</span> &lt;= s.length() &amp;&amp; s.charAt(i-<span class="number">1</span>) == s.charAt(i+<span class="number">1</span>))&#123;</div><div class="line">                <span class="comment">//[0,i-1],[i],[i+1,2*i]</span></div><div class="line">                <span class="comment">// String left = s.substring(0,i);</span></div><div class="line">                <span class="comment">// String right = s.substring(i + 1,2*i + 1);</span></div><div class="line">                <span class="keyword">if</span>(helper(s.substring(<span class="number">0</span>,i), s.substring(i + <span class="number">1</span>,<span class="number">2</span>*i + <span class="number">1</span>)))&#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder(s.substring(<span class="number">2</span>*i + <span class="number">1</span>, s.length())).reverse().toString() + s;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder(s.substring(<span class="number">1</span>, s.length())).reverse().toString() + s;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="Largest-Palindrome-Product">4.4. Largest Palindrome Product</h2><p>给一个n，判断两个n位数的乘积最大的回文数，输出回文数mod 1337。</p>
<p>对我来说这并不一道easy的题。我自己写了程序，但不知道为什么不对！还超时！气炸了！</p>
<p>先贴上我的<strong>错误的</strong> 代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">ifPalindrome</span><span class="params">(String s, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(low &gt;= high) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">return</span> s.charAt(low) == s.charAt(high) &amp;&amp; ifPalindrome(s, low + <span class="number">1</span>, high - <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestPalindrome</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> max = (<span class="keyword">int</span>)Math.pow(<span class="number">10</span>,n) - <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> min = (<span class="keyword">int</span>)Math.pow(<span class="number">10</span>, n - <span class="number">1</span>);</div><div class="line">        <span class="keyword">int</span> n1 = max,n2 = max;</div><div class="line">        <span class="keyword">while</span> (n1 &gt;= min)&#123;</div><div class="line">            n2 = n1;</div><div class="line">            <span class="keyword">while</span> (n2 &gt;= min)&#123;</div><div class="line">                BigInteger bigInteger = BigInteger.valueOf(n1).multiply(BigInteger.valueOf(n2));</div><div class="line">                <span class="keyword">if</span>(ifPalindrome(bigInteger.toString(),<span class="number">0</span>, bigInteger.toString().length() - <span class="number">1</span>))</div><div class="line">                    <span class="keyword">return</span> bigInteger.mod(BigInteger.valueOf(<span class="number">1337</span>)).intValue();</div><div class="line">                --n2;</div><div class="line">            &#125;</div><div class="line">            --n1;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>看一下</p>
<p><strong>正确的思路</strong>：</p>
<p>定理：输入范围<code>n∈[1, 8]</code>，除<code>n = 1</code>以外，其余n值最大回文数palindrome的位数均为偶数个，可以拆分为<code>half</code>与<code>reversed(half)</code>左右两半</p>
<p>思路：从上界<code>high = pow(10, n) - 1</code>向下界<code>low = pow(10, n - 1)</code>枚举half，构造回文，检查是否存在两个n位数的除数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestPalindrome</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">9</span>;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> high = (<span class="keyword">int</span>) Math.pow(<span class="number">10</span>, n) - <span class="number">1</span>, low = high / <span class="number">10</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = high; i &gt; low; i--) &#123;</div><div class="line">            <span class="keyword">long</span> palindrome = createPalindrome(i);</div><div class="line">            <span class="comment">// 探测palindrome是否可以被整除，且除数和结果都在(low,high]之间</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> j = high; j &gt; low; j--) &#123;</div><div class="line">                <span class="keyword">if</span> (palindrome / j &gt; high)  <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">if</span> (palindrome % j == <span class="number">0</span>) <span class="keyword">return</span> (<span class="keyword">int</span>) (palindrome % <span class="number">1337</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">createPalindrome</span><span class="params">(<span class="keyword">long</span> num)</span></span>&#123;</div><div class="line">        <span class="comment">// 构造 num + mun 的字符串</span></div><div class="line">        String str = num + <span class="keyword">new</span> StringBuilder(Long.toString(num)).reverse().toString();</div><div class="line">        <span class="keyword">return</span> Long.parseLong(str);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>优化</strong></p>
<p>当然了，以上操作还可以优化！</p>
<p>就是在探索时，只需要探索一半啊我曹！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">long</span> j = high; j &gt; low; j--) 这里！</div><div class="line"></div><div class="line">改成！</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">long</span> j = high; j*j &gt; palindrome; j--)</div></pre></td></tr></table></figure>
<p>速度提升了二倍啊！</p>
<p><strong>骚操作</strong></p>
<p>当然了，这些都没啥。下面这个骚操作，能把人气死。呵呵哒</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestPalindrome</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">switch</span>(n)&#123;</div><div class="line">            <span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">                <span class="keyword">return</span> <span class="number">9</span>;</div><div class="line">            <span class="keyword">case</span> <span class="number">2</span>:</div><div class="line">                <span class="keyword">return</span> <span class="number">987</span>;</div><div class="line">            <span class="keyword">case</span> <span class="number">3</span>:</div><div class="line">                <span class="keyword">return</span> <span class="number">123</span>;</div><div class="line">            <span class="keyword">case</span> <span class="number">4</span>:</div><div class="line">                <span class="keyword">return</span> <span class="number">597</span>;</div><div class="line">            <span class="keyword">case</span> <span class="number">5</span>:</div><div class="line">                <span class="keyword">return</span> <span class="number">677</span>;</div><div class="line">            <span class="keyword">case</span> <span class="number">6</span>:</div><div class="line">                <span class="keyword">return</span> <span class="number">1218</span>;</div><div class="line">            <span class="keyword">case</span> <span class="number">7</span>:</div><div class="line">                <span class="keyword">return</span> <span class="number">877</span>;</div><div class="line">            <span class="keyword">case</span> <span class="number">8</span>:</div><div class="line">                <span class="keyword">return</span> <span class="number">475</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="String-to-Integer-atoi">4.5. String to Integer (atoi)</h2><p>这道题题意实在是太不明朗了！</p>
<p>大原则：将str转化为int</p>
<p>小原则：</p>
<ol>
<li>忽略开始的空格</li>
<li>可能有正负号</li>
<li>如果出现了一个异常字符，就丢弃这个异常字符及其之后的东西</li>
<li>如果没有解，就返回0</li>
<li>如果正数溢出，就返回正整数<code>INT_MAX (2147483647)</code> ；如果负数溢出，就返回负整数<code>INT_MIN (-2147483648)</code></li>
</ol>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">    <span class="comment">// 丢弃空白</span></div><div class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (start &lt; str.length() &amp;&amp; str.charAt(start) == <span class="string">' '</span>) ++start;</div><div class="line">    <span class="keyword">if</span>(start &gt;= str.length()) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="comment">// 判断符号</span></div><div class="line">    <span class="keyword">int</span> sig = <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span>(str.charAt(start) == <span class="string">'+'</span>)&#123;++start;sig = <span class="number">1</span>;&#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(str.charAt(start) == <span class="string">'-'</span>)&#123;++start; sig = -<span class="number">1</span>;&#125;</div><div class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">    <span class="comment">// 开始字符</span></div><div class="line">    <span class="keyword">while</span> (start &lt; str.length())&#123;</div><div class="line">        <span class="keyword">int</span> num = str.charAt(start) - <span class="string">'0'</span>;</div><div class="line">        <span class="keyword">if</span>(num &gt;= <span class="number">0</span> &amp;&amp; num &lt; <span class="number">10</span>)&#123;</div><div class="line">            sb.append(str.charAt(start));</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        ++start;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 如果没有解，就返回0</span></div><div class="line">    <span class="keyword">if</span>(sb.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="comment">// 如果溢出，就...</span></div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">return</span> sig * Integer.valueOf(sb.toString());</div><div class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</div><div class="line">        <span class="keyword">if</span>(sig &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">2147483647</span>;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">2147483648</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Roman-to-Integer">4.6. Roman to Integer</h2><p>将罗马数字转化为整数</p>
<p>罗马数字的规则：</p>
<ol>
<li>罗马数字共有7个，即Ⅰ（1）、Ⅴ（5）、Ⅹ（10）、Ⅼ（50）、Ⅽ（100）、Ⅾ（500）和Ⅿ（1000）</li>
<li>重复数次：一个罗马数字重复几次，就表示这个数的几倍</li>
<li>右加左减：<ol>
<li>在较大的罗马数字的右边记上较小的罗马数字，表示大数字加小数字。</li>
<li>在较大的罗马数字的左边（只能有一位）记上较小的罗马数字，表示大数字减小数字。</li>
</ol>
</li>
</ol>
<p>思路：输入一个数后，我们可以来遍历这个数，用sum来总计和，比较i和i+1，如果，i+1比i小的话，直接相加，如果i大于i+1的话，则将总和sum减去i这个地方数的两倍，同时加上i+1<br>就相当于后边的数比左边的数大，则用右边的数减左边的数。但因为之前已经加过一次了，所以减两次</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//罗马数字共有7个，即Ⅰ（1）、Ⅴ（5）、Ⅹ（10）、Ⅼ（50）、</span></div><div class="line">    <span class="comment">// Ⅽ（100）、Ⅾ（500）和Ⅿ（1000）</span></div><div class="line">    <span class="keyword">int</span>[] nums = &#123;<span class="number">1000</span>,<span class="number">500</span>,<span class="number">100</span>,<span class="number">50</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">1</span>&#125;;</div><div class="line">    <span class="keyword">char</span>[] chars = &#123;<span class="string">'M'</span>,<span class="string">'D'</span>,<span class="string">'C'</span>,<span class="string">'L'</span>,<span class="string">'X'</span>,<span class="string">'V'</span>,<span class="string">'I'</span>&#125;;</div><div class="line">    HashMap&lt;Character, Integer&gt; roman = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; ++i)&#123;</div><div class="line">            roman.put(chars[i], nums[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> sum = roman.get(s.charAt(<span class="number">0</span>));</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); ++i)&#123;</div><div class="line">            sum += roman.get(s.charAt(i));</div><div class="line">            <span class="keyword">if</span>(roman.get(s.charAt(i)) &gt; roman.get(s.charAt(i-<span class="number">1</span>)))&#123;</div><div class="line">                sum -= <span class="number">2</span>*roman.get(s.charAt(i-<span class="number">1</span>));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="Integer-to-Roman">4.7. Integer to Roman</h2><p>将整数转化为罗马数字</p>
<p>罗马数字规律：</p>
<ul>
<li>大部分时候用字符相叠加来表示数字。I是1， II是2， III是3。VI是6（挨个看来，是“5 和 1”的组合），VII是7，VIII是8。</li>
<li>含有10的字符（I，X，C和M）最多可以重复出现三个。为了表示4，必须用同一位数的下一个更大的数字5来减去一。不能用IIII来表示4，而应该是IV（意思是比5小1）。40写做XL（比50小10），41写做XLI，42写做XLII，43写做XLIII，44写做XLIV（比50小10并且比5小1）。</li>
<li>有些时候表示方法恰恰相反。为了表示一个中间的数字，需要从一个最终的值来减。比如：9需要从10来减：8是VIII，但9确是IX（比10小1），并不是VIII（I字符不能重复4次）。90是XC，900是CM。</li>
<li>表示5的字符不能在一个数字中重复出现。10只能用X表示，不能用VV表示。100只能用C表示，而不是LL。</li>
<li>罗马数字是从左到右来计算，因此字符的顺序非常重要。DC表示600，而CD完全是另一个数字400（比500小100）。CI是101，IC不是一个罗马数字（因为你不能从100减1，你只能写成XCIX，表示比100小10，且比10小1）。</li>
</ul>
<p>有了以上规则，按照规则挨个位置计算就好啦</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line">    <span class="keyword">char</span>[][] roman = &#123;</div><div class="line">            &#123;<span class="string">'M'</span>,<span class="string">'D'</span>,<span class="string">'C'</span>&#125;,</div><div class="line">            &#123;<span class="string">'C'</span>,<span class="string">'L'</span>,<span class="string">'X'</span>&#125;,</div><div class="line">            &#123;<span class="string">'X'</span>,<span class="string">'V'</span>,<span class="string">'I'</span>&#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">    <span class="comment">//千分位</span></div><div class="line">    <span class="keyword">int</span> digit = num/<span class="number">1000</span>;</div><div class="line">    num -= digit*<span class="number">1000</span>;</div><div class="line">    <span class="keyword">while</span> (digit &gt; <span class="number">0</span>)&#123;</div><div class="line">        sb.append(<span class="string">'M'</span>);</div><div class="line">        --digit;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span>[] divisor = &#123;<span class="number">100</span>,<span class="number">10</span>,<span class="number">1</span>&#125;;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</div><div class="line">        <span class="comment">// 500/100分位</span></div><div class="line">        digit = num / divisor[i];</div><div class="line">        num -= digit * divisor[i];</div><div class="line">        <span class="comment">// 900 -&gt; digit = 9 -&gt; CM</span></div><div class="line">        <span class="keyword">if</span> (digit == <span class="number">9</span>) &#123;</div><div class="line">            <span class="comment">//sb.append("CM");</span></div><div class="line">            sb.append(roman[i][<span class="number">2</span>]);</div><div class="line">            sb.append(roman[i][<span class="number">0</span>]);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 700 -&gt; digit = 7 -&gt; DCC</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (digit &gt;= <span class="number">5</span>) &#123;</div><div class="line">            <span class="comment">//sb.append("D");</span></div><div class="line">            sb.append(roman[i][<span class="number">1</span>]);</div><div class="line">            digit--;</div><div class="line">            <span class="keyword">while</span> (digit &gt;= <span class="number">5</span>) &#123;</div><div class="line">                <span class="comment">//sb.append("C");</span></div><div class="line">                sb.append(roman[i][<span class="number">2</span>]);</div><div class="line">                digit--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 400 -&gt; digit = 4 -&gt; CD</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (digit == <span class="number">4</span>) &#123;</div><div class="line">            <span class="comment">//sb.append("CD");</span></div><div class="line">            sb.append(roman[i][<span class="number">2</span>]);</div><div class="line">            sb.append(roman[i][<span class="number">1</span>]);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 300 -&gt; digit = 3 -&gt; CCC</span></div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">while</span> (digit &gt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">//sb.append("C");</span></div><div class="line">                sb.append(roman[i][<span class="number">2</span>]);</div><div class="line">                digit--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sb.toString();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Group-Anagrams">4.8. Group Anagrams</h2><p>给<code>str[]</code> ，将同一排列组合的str分为一组。</p>
<p>一开始想多了，其实挺简单的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> String <span class="title">toHash</span><span class="params">(String s)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span>[] hash = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i)&#123;</div><div class="line">        ++hash[s.charAt(i) - <span class="string">'a'</span>];</div><div class="line">    &#125;</div><div class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i : hash)sb.append(i);</div><div class="line">    <span class="keyword">return</span> sb.toString();</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</div><div class="line">    <span class="keyword">if</span>(strs.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span>  LinkedList&lt;List&lt;String&gt;&gt;();</div><div class="line">    HashMap&lt;String, List&lt;String&gt;&gt; set = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    <span class="keyword">for</span>(String s:strs)&#123;</div><div class="line">        String hash = toHash(s);</div><div class="line">        <span class="keyword">if</span>(set.containsKey(hash))&#123;</div><div class="line">            set.get(hash).add(s);</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            List&lt;String&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">            list.add(s);</div><div class="line">            set.put(hash,list);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;List&lt;String&gt;&gt;(set.values());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Mini-Parser">4.9. Mini Parser</h2><p>好复杂的一题。将括号的lists反序列化。很复杂！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</div><div class="line">        NestedInteger nestedInteger;</div><div class="line">        <span class="keyword">int</span> end;</div><div class="line">        Node(NestedInteger nestedInteger, <span class="keyword">int</span> end)&#123;</div><div class="line">            <span class="keyword">this</span>.nestedInteger = nestedInteger;</div><div class="line">            <span class="keyword">this</span>.end = end;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">helper</span><span class="params">(String s, <span class="keyword">int</span> idx)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(idx == s.length()) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        <span class="comment">//System.out.println(idx);</span></div><div class="line">        NestedInteger obj = <span class="keyword">new</span> NestedInteger();</div><div class="line">        <span class="keyword">int</span> start = idx;</div><div class="line">        <span class="keyword">int</span> addCounter = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> i = idx;</div><div class="line">        <span class="keyword">for</span>(i = idx; i &lt; s.length(); ++i)&#123;</div><div class="line">            <span class="comment">//System.out.println(idx + "\t" + s.charAt(i));</span></div><div class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">','</span>)&#123;</div><div class="line">                addCounter+= <span class="number">1</span>;</div><div class="line">                <span class="keyword">if</span>(start &lt; i)obj.add(<span class="keyword">new</span> NestedInteger(Integer.valueOf(s.substring(start, i))));</div><div class="line">                start = i + <span class="number">1</span>;</div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">'['</span>)&#123;</div><div class="line">                Node next = helper(s, i + <span class="number">1</span>);</div><div class="line"></div><div class="line">                <span class="keyword">if</span>(next != <span class="keyword">null</span>) &#123;</div><div class="line">                    obj.add(next.nestedInteger);</div><div class="line">                    addCounter+= <span class="number">1</span>;</div><div class="line">                    i = next.end;</div><div class="line">                    <span class="keyword">if</span>(i &lt; s.length())--i;<span class="comment">//因为for循环会+1</span></div><div class="line">                    start = next.end + <span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i)== <span class="string">']'</span>)&#123;</div><div class="line">                addCounter+= <span class="number">1</span>;</div><div class="line">                <span class="keyword">if</span>(start &lt; i)obj.add(<span class="keyword">new</span> NestedInteger(Integer.valueOf(s.substring(start, i))));</div><div class="line">                ++i;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">         <span class="comment">// if(addCounter == 0)</span></div><div class="line">         <span class="comment">//     obj.setInteger(Integer.valueOf(s.substring(0, s.length())));</span></div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node(obj, i);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> NestedInteger <span class="title">deserialize</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span>) <span class="keyword">return</span>  <span class="keyword">new</span> NestedInteger();</div><div class="line">        <span class="keyword">if</span>(s.length() == <span class="number">1</span> || s.charAt(<span class="number">0</span>) != <span class="string">'['</span>) <span class="keyword">return</span> <span class="keyword">new</span> NestedInteger(Integer.valueOf(s));</div><div class="line">        <span class="keyword">return</span> helper(s,<span class="number">1</span>).nestedInteger;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="Validate-IP-Address">4.10. Validate IP Address</h2><p>验证给定字符串是否是IPV4或IPV6地址</p>
<p>这道题实在是太心酸了。主要有以下几个注意点：</p>
<ol>
<li><code>split</code>操作会忽略最后一个字符为分隔符的情况</li>
<li>IPv4 ：<ol>
<li>长度必须为4</li>
<li>每个字符不可有有前导0</li>
<li>第一个字符不可以为0</li>
<li>不可以出现其他字符</li>
<li>值不可以大于255</li>
</ol>
</li>
<li>IPv6：<ol>
<li>长度要么为8，要么 只存在一个<code>::</code> 。（通过使用双冒号（::）替换一系列零来指定 IPv6 地址。例如，IPv6 地址 ff06:0:0:0:0:0:0:c3 可写作 ff06::c3。一个 IP 地址中只可使用一次双冒号。</li>
<li>可以有前导零</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> String <span class="title">validIPv4</span><span class="params">(String[] ipv4)</span></span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ipv4.length; ++i)&#123;</div><div class="line">                <span class="comment">// 空字符，错误</span></div><div class="line">                <span class="keyword">if</span>(ipv4[i].length() == <span class="number">0</span>)<span class="keyword">return</span> <span class="string">"Neither"</span>;</div><div class="line">                <span class="comment">// 前导零，错误</span></div><div class="line">                <span class="keyword">if</span>(ipv4[i].length() &gt; <span class="number">1</span> &amp;&amp; ipv4[i].charAt(<span class="number">0</span>) == <span class="string">'0'</span>)<span class="keyword">return</span> <span class="string">"Neither"</span>;</div><div class="line">                <span class="comment">// 有其他字符，错误</span></div><div class="line">                <span class="keyword">for</span>(<span class="keyword">char</span> c : ipv4[i].toCharArray()) <span class="keyword">if</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) <span class="keyword">return</span> <span class="string">"Neither"</span>;</div><div class="line">                <span class="keyword">int</span> val = Integer.valueOf(ipv4[i]);</div><div class="line">                <span class="comment">// 第一个字符为0，错误</span></div><div class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; val == <span class="number">0</span>)<span class="keyword">return</span> <span class="string">"Neither"</span>;</div><div class="line">                <span class="comment">// 值错误</span></div><div class="line">                <span class="keyword">if</span>(val &lt; <span class="number">0</span> || val &gt;= <span class="number">256</span>) <span class="keyword">return</span> <span class="string">"Neither"</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="string">"IPv4"</span>;</div><div class="line">        &#125;<span class="keyword">catch</span> (NumberFormatException e)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">"Neither"</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">validIPv6</span><span class="params">(String[] IPv6)</span></span>&#123;</div><div class="line">        <span class="keyword">boolean</span> lenOK = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; IPv6.length; ++i)&#123;</div><div class="line">            <span class="keyword">if</span>(IPv6[i].length()==<span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">if</span>(lenOK) <span class="keyword">return</span>  <span class="string">"Neither"</span>;</div><div class="line">                lenOK = <span class="keyword">true</span>;</div><div class="line">                <span class="comment">//检查左边是否存在0</span></div><div class="line">                <span class="keyword">if</span>(i &gt; <span class="number">0</span>)&#123;</div><div class="line">                    <span class="comment">//IPv6[i-1]</span></div><div class="line">                    <span class="keyword">if</span>(IPv6[i-<span class="number">1</span>].length() == <span class="number">0</span>)<span class="keyword">return</span> <span class="string">"Neither"</span>;</div><div class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(IPv6[i-<span class="number">1</span>].length() == <span class="number">1</span>) &#123;</div><div class="line">                        <span class="keyword">if</span> (IPv6[i - <span class="number">1</span>].equals(<span class="string">"0"</span>)) <span class="keyword">return</span> <span class="string">"Neither"</span>;</div><div class="line">                    &#125;<span class="keyword">else</span>&#123; <span class="comment">// 长度大于0</span></div><div class="line">                        <span class="keyword">boolean</span> allZero = <span class="keyword">true</span>;</div><div class="line">                        <span class="keyword">for</span>(<span class="keyword">char</span> c : IPv6[i - <span class="number">1</span>].toCharArray())&#123;</div><div class="line">                            <span class="keyword">if</span>(c != <span class="string">'0'</span>)&#123;</div><div class="line">                                allZero = <span class="keyword">false</span>;</div><div class="line">                                <span class="keyword">break</span>;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">if</span>(allZero)<span class="keyword">return</span> <span class="string">"Neither"</span>;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(IPv6[i].length() &gt; <span class="number">4</span>)<span class="keyword">return</span> <span class="string">"Neither"</span>;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> c : IPv6[i].toCharArray())&#123;</div><div class="line">                <span class="keyword">if</span>((c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'f'</span>)||</div><div class="line">                    (c &gt;=<span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>)||</div><div class="line">                    (c &gt;= <span class="string">'A'</span> &amp;&amp; c &lt;= <span class="string">'F'</span>))&#123;</div><div class="line">                    <span class="comment">// 合法</span></div><div class="line">                &#125;<span class="keyword">else</span>&#123;</div><div class="line">                    <span class="keyword">return</span> <span class="string">"Neither"</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>((lenOK &amp;&amp; IPv6.length &lt; <span class="number">8</span>) || IPv6.length == <span class="number">8</span>) <span class="keyword">return</span> <span class="string">"IPv6"</span>;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span>  <span class="string">"Neither"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">validIPAddress</span><span class="params">(String IP)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(IP.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">"Neither"</span>;</div><div class="line">        <span class="comment">// 因为split操作检测不到最后一个.或者：</span></div><div class="line">        <span class="keyword">char</span> last = IP.charAt(IP.length() - <span class="number">1</span>);</div><div class="line">        <span class="keyword">if</span>(!((last &gt;= <span class="string">'a'</span> &amp;&amp; last &lt;= <span class="string">'f'</span>)||</div><div class="line">            (last &gt;=<span class="string">'0'</span> &amp;&amp; last &lt;= <span class="string">'9'</span>)||</div><div class="line">            (last &gt;= <span class="string">'A'</span> &amp;&amp; last &lt;= <span class="string">'F'</span>)))&#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">"Neither"</span>;</div><div class="line">        &#125;</div><div class="line">        String[] ipv4 = IP.split(<span class="string">"\\."</span>); <span class="comment">// .是转义字符，必须用\\.</span></div><div class="line">        <span class="keyword">if</span>(ipv4.length == <span class="number">4</span>)&#123;</div><div class="line">            <span class="keyword">return</span>  validIPv4(ipv4);</div><div class="line">        &#125;</div><div class="line">        String[] IPv6 = IP.split(<span class="string">":"</span>);</div><div class="line">        <span class="keyword">if</span>(IPv6.length &gt; <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> validIPv6(IPv6);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>  <span class="string">"Neither"</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>自己写的代码好乱，学习一下别人的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">validIPAddress</span><span class="params">(String IP)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (IP.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">"Neither"</span>;</div><div class="line">        <span class="keyword">int</span> lastChar = IP.charAt(IP.length() - <span class="number">1</span>);</div><div class="line">        <span class="keyword">if</span> (lastChar == <span class="string">':'</span> || lastChar == <span class="string">'.'</span>) <span class="keyword">return</span> <span class="string">"Neither"</span>;</div><div class="line">        String[] groups = IP.split(<span class="string">"\\."</span>);</div><div class="line">        <span class="keyword">if</span> (groups.length == <span class="number">1</span>) &#123;</div><div class="line">            groups = IP.split(<span class="string">":"</span>);</div><div class="line">            <span class="keyword">if</span> (validateIPv6(groups)) <span class="keyword">return</span> <span class="string">"IPv6"</span>;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">"Neither"</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (validateIPv4(groups)) <span class="keyword">return</span> <span class="string">"IPv4"</span>;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">"Neither"</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 验证v4单个组</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validateIPv4Group</span><span class="params">(String group)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (group.length() &gt; <span class="number">3</span> || group.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">if</span> (group.length() &gt; <span class="number">1</span> &amp;&amp; group.charAt(<span class="number">0</span>) == <span class="string">'0'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; group.length(); i++) &#123;</div><div class="line">            <span class="keyword">char</span> c = group.charAt(i);</div><div class="line">            <span class="keyword">if</span> (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) res = res * <span class="number">10</span> + c - <span class="string">'0'</span>;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res &lt; <span class="number">256</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 验证v4整个组</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validateIPv4</span><span class="params">(String[] groups)</span> </span>&#123;</div><div class="line">        <span class="comment">//System.out.println(Arrays.toString(groups));</span></div><div class="line">        <span class="keyword">if</span> (groups.length != <span class="number">4</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; groups.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (!validateIPv4Group(groups[i])) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">     <span class="comment">// 验证v6单个组</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validateIPv6Group</span><span class="params">(String group)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (group.length() &gt; <span class="number">4</span> || group.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; group.length(); i++) &#123;</div><div class="line">            <span class="keyword">char</span> c = Character.toLowerCase(group.charAt(i));</div><div class="line">            <span class="keyword">if</span> ((c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) || (c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'f'</span>)) <span class="keyword">continue</span>;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 验证v6整个组</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validateIPv6</span><span class="params">(String[] groups)</span> </span>&#123;</div><div class="line">        <span class="comment">//System.out.println(Arrays.toString(groups));</span></div><div class="line">        <span class="keyword">if</span> (groups.length != <span class="number">8</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (!validateIPv6Group(groups[i])) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> String </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java-LinkedList]]></title>
      <url>/2017/11/15/Java-LinkedList/</url>
      <content type="html"><![CDATA[<h1 id="LinkedList简介">1. LinkedList简介</h1><p><strong>LinkedList简介</strong></p>
<p>LinkedList 是一个继承于AbstractSequentialList的双向链表。它也可以被当作堆栈、队列或双端队列进行操作。</p>
<ul>
<li><p>LinkedList 实现 Queue  接口，能对它进行队列操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">queue.offer(<span class="number">1</span>);</div><div class="line">queue.poll();</div></pre></td></tr></table></figure>
</li>
<li><p>LinkedList 实现 Deque 接口，即能将LinkedList当作双端队列使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">Deque&lt;Integer&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line"></div><div class="line">Deque接口的方法：</div><div class="line"><span class="comment">// 从头增</span></div><div class="line">addFirst(element);</div><div class="line">offerFirst(element):如果增加成功，返回<span class="function"><span class="keyword">true</span></span></div><div class="line"><span class="title">push</span><span class="params">(element)</span>;</div><div class="line"></div><div class="line"><span class="comment">// 从尾增</span></div><div class="line">add(element);</div><div class="line">addLast(element);</div><div class="line">offer(element) ;  如果增加成功，返回<span class="function"><span class="keyword">true</span></span></div><div class="line"><span class="title">offerLast</span><span class="params">(element)</span>; 如果增加成功，返回<span class="keyword">true</span></div><div class="line"></div><div class="line"><span class="comment">// 迭代</span></div><div class="line">iterator();</div><div class="line">descendingIterator();: 逆序迭代</div><div class="line"></div><div class="line"><span class="comment">// 从头删</span></div><div class="line">pop(element) ; 返回删除的元素</div><div class="line">removeFirst();</div><div class="line"></div><div class="line"><span class="comment">// 从尾删</span></div><div class="line">removeLast();</div><div class="line"></div><div class="line"><span class="comment">// 需要注意的是</span></div><div class="line">Collection--&gt;Queue--&gt;Deque--实现--&gt;LinkedList(实现类)</div><div class="line">  </div><div class="line">- Deque接口继承了Queue接口,而Queue接口继承了Collection接口,</div><div class="line">- LinkedList实现了Deque接口</div><div class="line"></div><div class="line"><span class="comment">// 一个值得注意的现象：</span></div><div class="line"></div><div class="line">LinkedList&lt;Integer&gt; test = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">test.addFirst(<span class="number">1</span>);</div><div class="line"></div><div class="line">List&lt;Integer&gt; ret = test;</div><div class="line">ret.addFirst(<span class="number">1</span>);<span class="comment">// 非法操作！</span></div></pre></td></tr></table></figure>
</li>
<li><p>LinkedList 实现了Cloneable接口，即覆盖了函数clone()，能克隆。</p>
</li>
<li><p>LinkedList 实现java.io.Serializable接口，这意味着LinkedList支持序列化，能通过序列化去传输。</p>
</li>
<li><p>LinkedList 是非同步的。</p>
</li>
</ul>
<a id="more"></a>
<p><strong>LinkedList构造函数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 默认构造函数</span></div><div class="line">LinkedList()</div><div class="line"></div><div class="line"><span class="comment">// 创建一个LinkedList，保护Collection中的全部元素。</span></div><div class="line">LinkedList(Collection&lt;? extends E&gt; collection)</div></pre></td></tr></table></figure>
<p><strong>LinkedList的API</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">LinkedList的<span class="function">API</span></div><div class="line"><span class="keyword">boolean</span>       <span class="title">add</span><span class="params">(E object)</span></div><div class="line"><span class="keyword">void</span>          <span class="title">add</span><span class="params">(<span class="keyword">int</span> location, E object)</span></div><div class="line"><span class="keyword">boolean</span>       <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; collection)</span></div><div class="line"><span class="keyword">boolean</span>       <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> location, Collection&lt;? extends E&gt; collection)</span></div><div class="line"><span class="keyword">void</span>          <span class="title">addFirst</span><span class="params">(E object)</span></div><div class="line"><span class="keyword">void</span>          <span class="title">addLast</span><span class="params">(E object)</span></div><div class="line"><span class="keyword">void</span>          <span class="title">clear</span><span class="params">()</span></div><div class="line">Object        <span class="title">clone</span><span class="params">()</span></div><div class="line"><span class="keyword">boolean</span>       <span class="title">contains</span><span class="params">(Object object)</span></div><div class="line">Iterator&lt;E&gt;   <span class="title">descendingIterator</span><span class="params">()</span></div><div class="line">E             <span class="title">element</span><span class="params">()</span></div><div class="line">E             <span class="title">get</span><span class="params">(<span class="keyword">int</span> location)</span></div><div class="line">E             <span class="title">getFirst</span><span class="params">()</span></div><div class="line">E             <span class="title">getLast</span><span class="params">()</span></div><div class="line"><span class="keyword">int</span>           <span class="title">indexOf</span><span class="params">(Object object)</span></div><div class="line"><span class="keyword">int</span>           <span class="title">lastIndexOf</span><span class="params">(Object object)</span></div><div class="line">ListIterator&lt;E&gt;     <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> location)</span></div><div class="line"><span class="keyword">boolean</span>       <span class="title">offer</span><span class="params">(E o)</span></div><div class="line"><span class="keyword">boolean</span>       <span class="title">offerFirst</span><span class="params">(E e)</span></div><div class="line"><span class="keyword">boolean</span>       <span class="title">offerLast</span><span class="params">(E e)</span></div><div class="line">E             <span class="title">peek</span><span class="params">()</span></div><div class="line">E             <span class="title">peekFirst</span><span class="params">()</span></div><div class="line">E             <span class="title">peekLast</span><span class="params">()</span></div><div class="line">E             <span class="title">poll</span><span class="params">()</span></div><div class="line">E             <span class="title">pollFirst</span><span class="params">()</span></div><div class="line">E             <span class="title">pollLast</span><span class="params">()</span></div><div class="line">E             <span class="title">pop</span><span class="params">()</span></div><div class="line"><span class="keyword">void</span>          <span class="title">push</span><span class="params">(E e)</span></div><div class="line">E             <span class="title">remove</span><span class="params">()</span></div><div class="line">E             <span class="title">remove</span><span class="params">(<span class="keyword">int</span> location)</span></div><div class="line"><span class="keyword">boolean</span>       <span class="title">remove</span><span class="params">(Object object)</span></div><div class="line">E             <span class="title">removeFirst</span><span class="params">()</span></div><div class="line"><span class="keyword">boolean</span>       <span class="title">removeFirstOccurrence</span><span class="params">(Object o)</span></div><div class="line">E             <span class="title">removeLast</span><span class="params">()</span></div><div class="line"><span class="keyword">boolean</span>       <span class="title">removeLastOccurrence</span><span class="params">(Object o)</span></div><div class="line">E             <span class="title">set</span><span class="params">(<span class="keyword">int</span> location, E object)</span></div><div class="line"><span class="keyword">int</span>           <span class="title">size</span><span class="params">()</span></div><div class="line">&lt;T&gt; T[]       <span class="title">toArray</span><span class="params">(T[] contents)</span></div><div class="line">Object[]     <span class="title">toArray</span><span class="params">()</span></div></pre></td></tr></table></figure>
<p><strong>AbstractSequentialList简介</strong></p>
<p>在介绍LinkedList的源码之前，先介绍一下AbstractSequentialList。毕竟，LinkedList是AbstractSequentialList的子类。</p>
<p>AbstractSequentialList 实现了get(int index)、set(int index, E element)、add(int index, E element) 和 remove(int index)这些函数。<strong>这些接口都是随机访问List的</strong>，LinkedList是双向链表；既然它继承于AbstractSequentialList，就相当于已经实现了“get(int index)这些接口”。</p>
<p>此外，我们若需要通过AbstractSequentialList自己实现一个列表，只需要扩展此类，并提供 listIterator() 和 size() 方法的实现即可。若要实现不可修改的列表，则需要实现列表迭代器的 hasNext、next、hasPrevious、previous 和 index 方法即可。</p>
<p>#LinkedList数据结构</p>
<p> <strong>LinkedList的继承关系</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">java.lang.Object</div><div class="line">   ↳     java.util.AbstractCollection&lt;E&gt;</div><div class="line">         ↳     java.util.AbstractList&lt;E&gt;</div><div class="line">               ↳     java.util.AbstractSequentialList&lt;E&gt;</div><div class="line">                     ↳     java.util.LinkedList&lt;E&gt;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</div><div class="line">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> &#123;&#125;</div></pre></td></tr></table></figure>
<p><strong>LinkedList与Collection的关系图</strong></p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-11-15-19-53-26.png" alt=""> </p>
<p>LinkedList的本质是双向链表。<br>(01) LinkedList继承于AbstractSequentialList，并且实现了Dequeue接口。<br>(02) LinkedList包含两个重要的成员：header 和 size。<br>　　header是双向链表的表头，它是双向链表节点所对应的类Entry的实例。Entry中包含成员变量： previous, next, element。其中，previous是该节点的上一个节点，next是该节点的下一个节点，element是该节点所包含的值。<br>　　size是双向链表中节点的个数。</p>
<h1 id="参考文献">2. 参考文献</h1><ol>
<li><a href="http://www.cnblogs.com/skywang12345/p/3308807.html" target="_blank" rel="external">Java 集合系列05之 LinkedList详细介绍(源码解析)和使用示例</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[leetcode刷题总结]]></title>
      <url>/2017/11/15/%E7%AE%97%E6%B3%95-leetcode%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>主要总结自己做过的题的知识点。</p>
<p>解释：</p>
<p>★：需要再次看</p>
<p>❤：做了很久</p>
<p>▲：没做出来</p>
<p><strong>相关文章</strong>：</p>
<ol>
<li><a href="/2017/11/16/Java-String/" title="Java-String">Java-String</a></li>
<li><a href="/2017/11/13/算法-Trie树/" title="算法-Trie树">算法-Trie树</a></li>
<li><a href="/2017/11/05/算法-并查集/" title="算法-并查集">算法-并查集</a></li>
<li><a href="/2017/11/03/算法-堆/" title="算法-堆">算法-堆</a></li>
<li><a href="/2017/11/17/算法-DP/" title="算法-DP">算法-DP</a></li>
<li><a href="/2017/11/17/Java-Map/" title="Java-Map">Java-Map</a></li>
<li><a href="/2017/11/21/算法-DFS/" title="算法-DFS">算法-DFS</a></li>
<li><a href="/2017/11/24/算法-二分查找/" title="算法-二分查找">算法-二分查找</a></li>
<li></li>
<li><a href="/2017/12/04/算法-链表/" title="算法-链表">算法-链表</a>
</li>
</ol>
<a id="more"></a>
<table>
<thead>
<tr>
<th>题</th>
<th>题意</th>
<th>知识点</th>
</tr>
</thead>
<tbody>
<tr>
<td>Implement Trie (Prefix Tree)</td>
<td>实现 Trie的insert、search、prefix（判断是否是前缀）</td>
<td>Trie</td>
</tr>
<tr>
<td>Add and Search Word - Data structure design</td>
<td>实现str的add与search，其中str’.’代表任意字符</td>
<td>Trie</td>
</tr>
<tr>
<td>Top K Frequent Words</td>
<td>给一组str[]，统计频率最高的k个str</td>
<td>Trie+HashHeap</td>
</tr>
<tr>
<td>Map Sum Pairs</td>
<td>实现insert(str,val)和sum(str)，使得sum(str)能输出以str为前缀的所有单词的价值和</td>
<td>Trie</td>
</tr>
<tr>
<td>Word Search</td>
<td>给<code>char[][] board</code>和str word。判断word是否被包含在board中</td>
<td>DFS</td>
</tr>
<tr>
<td>Word Search II</td>
<td>给<code>char[][] board</code>和str[] words。从words中找到被包含在board中的单词</td>
<td>Trie+DFS</td>
</tr>
<tr>
<td>Replace Words</td>
<td>给一个词根表<code>str[] dict = [&quot;cat&quot;, &quot;bat&quot;, &quot;rat&quot;]</code> ，和sentence = “the cattle was rattled by the battery”<code>。替换句子为</code>“the cat was rat by the bat”`</td>
<td>Trie+String的操作</td>
</tr>
<tr>
<td>Number of Islands</td>
<td>给一个二维数组，元素为1/0。判断岛屿的个数</td>
<td>并查集/dfs</td>
</tr>
<tr>
<td>Number of Islands II</td>
<td>上题二维数据改成动态的</td>
<td>并查集</td>
</tr>
<tr>
<td>Graph Valid Tree</td>
<td>给一个无向连通图，判断是不是一棵树</td>
<td>并查集</td>
</tr>
<tr>
<td>Number of Connected Components in an Undirected Graph</td>
<td>给一个无向连通图，判断有几个联通块</td>
<td>并查集</td>
</tr>
<tr>
<td>Friend Circles</td>
<td>有n个人，矩阵M表示n个人互相的关系。求这n个人一共有多少个朋友圈</td>
<td>并查集</td>
</tr>
<tr>
<td>Surrounded Regions</td>
<td>给一个矩阵，里面元素是X或O。如果一个O的连通块被X完全围住，就将O全部改成X。输出改之后的矩阵</td>
<td>并查集/dfs</td>
</tr>
<tr>
<td>Redundant Connection</td>
<td>给一个无向连通图。要从中取出一条边，使得它成为一棵树。 如果有多个解，输出input中最后一个出现的边</td>
<td>并查集</td>
</tr>
<tr>
<td>Longest Consecutive Sequence</td>
<td>给一个数组int[] nums = {100,4,200,1,3,2}，输出连续数字的最大个数——4</td>
<td>并查集/先sort后遍历</td>
</tr>
<tr>
<td>Top K Frequent Elements</td>
<td>给一个int[],输出频率最高的k个数字</td>
<td>堆</td>
</tr>
<tr>
<td>★Kth Smallest Element in a Sorted Matrix</td>
<td>给一个 <em>n</em> x <em>n</em>的数组，行列都有序（即<code>A[i][j]&lt;A[i+1][j]且A[i][j]&lt;A[i][j+1]</code>）。找到第K小的元素</td>
<td>堆/二分</td>
</tr>
<tr>
<td>Find K Pairs with Smallest Sums</td>
<td>给定两个数组nums1和nums2，找到nums1[i] + nums2[i] 的从最小到第k小的对(i,j)</td>
<td>堆</td>
</tr>
<tr>
<td>★Merge k Sorted Lists</td>
<td>给了k个链表ListNode[k] lists。每个链表都已排序。将这k个链表merge为一个有序链表</td>
<td>堆（注意将listNode视为整体的技巧）/ 链表分治</td>
</tr>
<tr>
<td>Design Twitter</td>
<td>设计一个twitter类，实现发微博、关注、取关，拉取关注好友列表的最近10条信息流</td>
<td>堆（与上一题一个技巧）</td>
</tr>
<tr>
<td>❤Split Array into Consecutive Subsequences</td>
<td>给一个数组<code>[1,2,3,3,4,5]</code>，问它能不能分成多个长度大于3的连续子数组[1,2,3]和[3,4,5]</td>
<td>HashMap+堆</td>
</tr>
<tr>
<td>▲The Skyline Problem</td>
<td>题意：给一些大楼<code>int[][] build</code>，每个楼是三元组[left,right,h]。求这些大楼的关键点</td>
<td>堆</td>
</tr>
<tr>
<td>Trapping Rain Water</td>
<td>Given <code>[0,1,0,2,1,0,1,3,2,1,2,1]</code>,输出它能乘的最大雨水数量 <code>6</code></td>
<td>双指针</td>
</tr>
<tr>
<td>Trapping Rain Water II</td>
<td>给一个二维数组，假设这是一个台子。边界没有挡板。求问这个台子最多能乘多少雨水</td>
<td>堆</td>
</tr>
<tr>
<td>★Sort Characters By Frequency</td>
<td>给一个字符串”tree”，按照字母频率输出“eetr”或”eert”</td>
<td>HashMap的排序/<strong>桶排序</strong>/堆</td>
</tr>
<tr>
<td>★Maximum Subarray</td>
<td>输出数组的连续子数组的最大和</td>
<td>DP</td>
</tr>
<tr>
<td>Triangle</td>
<td>给一个三角形，找到从上到下最短路径和</td>
<td>坐标DP</td>
</tr>
<tr>
<td>Climbing Stairs</td>
<td>有一个楼梯，一步只能跨1/2步。问从0走到n层有多少层方案</td>
<td>坐标DP</td>
</tr>
<tr>
<td>Unique Paths</td>
<td>m×n格子，从左上走到右下，有多少种走法（只能向下或向右走）</td>
<td>坐标DP</td>
</tr>
<tr>
<td>Unique Paths II</td>
<td>格子里可能有障碍物，还有多少种走法</td>
<td>坐标DP</td>
</tr>
<tr>
<td>Minimum Path Sum</td>
<td>找到路径权重最小的路</td>
<td>坐标DP</td>
</tr>
<tr>
<td>Jump Game</td>
<td>给一个数组A,<code>A[i]</code>表示在这里时最多可以跳<code>A[i]</code>步。只能向前跳。从数组A的第0位置出发，能不能跳到末尾</td>
<td>坐标DP/贪心</td>
</tr>
<tr>
<td>Jump Game II</td>
<td>给一个数组A,<code>A[i]</code>表示在这里时最多可以跳<code>A[i]</code>步。只能向前跳。从数组A的第0位置出发，问最少的跳的次数。</td>
<td>坐标DP/贪心</td>
</tr>
<tr>
<td>Longest Increasing Subsequence</td>
<td>求最长严格递增的子序列（子序列：可以跳着选）</td>
<td>坐标DP/二分</td>
</tr>
<tr>
<td>Arithmetic Slices</td>
<td>给一个序列。求这个序列有多少个等差数列（至少三个元素才算等差数列）</td>
<td>坐标DP</td>
</tr>
<tr>
<td>Perfect Squares</td>
<td>给一个数字，求它被拆成平方和的最少平方和个数</td>
<td>坐标DP</td>
</tr>
<tr>
<td>★Maximal Square</td>
<td>给一个0/1矩阵。找到最大全1方阵，返回方阵元素个数</td>
<td>单序列DP</td>
</tr>
<tr>
<td>★Best Time to Buy and Sell Stock</td>
<td>给一个int[] prices表示股票价格。求出最好的买卖方式的钱</td>
<td>DP</td>
</tr>
<tr>
<td>★Word Break</td>
<td>给一个str s和一个str[] dict，判断s是否能被dict中的单词组成</td>
<td>单序列DP</td>
</tr>
<tr>
<td>Palindrome Partitioning II</td>
<td>一个str最少被切割几次可以切割为都是回文串</td>
<td>单序列DP</td>
</tr>
<tr>
<td>House Robber</td>
<td>给一个数组<code>int[] nums</code>，表示每个商店的价值。要抢劫，但抢劫时必须至少隔一个商铺抢。问能抢到的最大价值</td>
<td>单序列DP</td>
</tr>
<tr>
<td>House Robber II</td>
<td>给一个数组<code>int[] nums</code>，表示每个商店的价值。商店是成环的，即首尾相接。要抢劫，但抢劫时必须至少隔一个商铺抢。问能抢到的最大价值。</td>
<td>单序列DP</td>
</tr>
<tr>
<td>Paint House</td>
<td>给一个二维数组<code>cost[][]</code>，大小为n×3。其中<code>cost[i][q]</code>表示第i个房子涂上第q种颜色时的造价。一共有3种颜色。要求两个相邻房子不可以同色。求涂色最小造价</td>
<td>单序列DP</td>
</tr>
<tr>
<td>Longest Common Subsequence</td>
<td>最长公共子序列</td>
<td>双序列DP</td>
</tr>
<tr>
<td>Edit Distance</td>
<td>将第一个字符串最少改动，变成第二个字符串</td>
<td>双序列DP</td>
</tr>
<tr>
<td>Distinct Subsequences</td>
<td>从S=”rabbbit”挑出T = “rabbit”有几种挑法</td>
<td>双序列DP</td>
</tr>
<tr>
<td>Interleaving String</td>
<td>给了三个字符串s1,s2,s3.判断s3是否是由s1和s2交替组成（按顺序，且可交替着挑）</td>
<td>双序列DP</td>
</tr>
<tr>
<td>Dungeon Game</td>
<td>英雄救美：给一个矩阵<code>int[][] dungegon</code>，每个格子正数代表能量加成，负数代表减弱能量。英雄要从左上走到右下，要求每一时刻英雄的能量不低于1.问英雄初始时最少需要多少能量</td>
<td>双序列DP</td>
</tr>
<tr>
<td>▲<strong>Paint Fence</strong></td>
<td><a href="https://segmentfault.com/a/1190000003790650" target="_blank" rel="external">https://segmentfault.com/a/1190000003790650</a></td>
<td></td>
</tr>
<tr>
<td>▲Ugly Number</td>
<td>给一个数num，判断它是不是ugly数——它的质因数只能说是2、3、5</td>
<td>DP</td>
</tr>
<tr>
<td>★Range Sum Query - Immutable</td>
<td>给一个数组，输出指定i，j之间的和</td>
<td>DP</td>
</tr>
<tr>
<td>▲Word Break  II</td>
<td>给一个str s和一个str[] dict,输出所有s可能被dict拼接的组合</td>
<td>DFS</td>
</tr>
<tr>
<td>Binary Tree Preorder Traversal</td>
<td>实现二叉树的前序遍历</td>
<td>递归/栈</td>
</tr>
<tr>
<td>Binary Tree Inorder Traversal</td>
<td>实现二叉树的中序遍历</td>
<td>递归/栈</td>
</tr>
<tr>
<td>Validate Binary Search Tree</td>
<td>验证一个二叉树是不是搜索二叉树</td>
<td>中序遍历</td>
</tr>
<tr>
<td>Find Mode in Binary Search Tree</td>
<td>给一个有重的BST。其中左子树小于等于本身，右子树大于本身。统计最多次数出现的数字</td>
<td>BST + 中序遍历</td>
</tr>
<tr>
<td>Binary search Tree Iterator</td>
<td>按照中序遍历方式将二叉树元素一个一个输出（要一个给一个）</td>
<td>栈的中序遍历</td>
</tr>
<tr>
<td>Convert Sorted List to Binary Search Tree</td>
<td>将有序链表转化为平衡BST</td>
<td>中序+递归+BST</td>
</tr>
<tr>
<td>Convert Sorted Array to Binary Search Tree</td>
<td>将有序数组转化为平衡BST</td>
<td>中序+二分+BST</td>
</tr>
<tr>
<td>Kth Smallest Element in a BST</td>
<td>BST中第K小的数</td>
<td>中序+BST</td>
</tr>
<tr>
<td>Delete Node in a BST</td>
<td>删除BST中某个节点</td>
<td>BST</td>
</tr>
<tr>
<td>Binary Tree Postorder Traversal</td>
<td>实现二叉树的后序遍历</td>
<td>递归/栈/双栈</td>
</tr>
<tr>
<td>Maximum Depth of Binary Tree</td>
<td>求二叉树的最大深度</td>
<td>递归+分治</td>
</tr>
<tr>
<td>Binary Tree Maximum Path Sum</td>
<td>给一个二叉树，找到从any node 到 any node最大路径和。路径可以在任何地方被结束掉</td>
<td>递归+分治</td>
</tr>
<tr>
<td>Balanced Binary Tree</td>
<td>判断一个树是不是平衡二叉树</td>
<td>递归+分治</td>
</tr>
<tr>
<td>Lowest Common Ancestor</td>
<td>求一颗二叉树中两个点a,b的最近公共祖先</td>
<td>递归+分治</td>
</tr>
<tr>
<td>Binary Tree Level Order Traversal</td>
<td>输出二叉树的层序遍历</td>
<td>队列</td>
</tr>
<tr>
<td>Binary Tree Level Order Traversal II</td>
<td>输出二叉树的层序遍历，要从下往上输出</td>
<td>队列+LinkedList</td>
</tr>
<tr>
<td>Binary Search</td>
<td>给一个int[] nums,找到target第一次出现的index。没找到就返回-1.</td>
<td>二分</td>
</tr>
<tr>
<td>Search for a range</td>
<td>给一个int[] nums = {5,7,7,8,8,10],找到target=8出现的范围[3,4]。没找到就返回[-1,-1].</td>
<td>二分</td>
</tr>
<tr>
<td>Search Insert Position</td>
<td>给一个有序无重数组nums = [1,3,5,6],把target=5插入，问插入的位置=2</td>
<td>二分</td>
</tr>
<tr>
<td>Search a 2D Matrix</td>
<td>给一个严格递增的矩阵，寻找是否存在target</td>
<td>二分</td>
</tr>
<tr>
<td>Search a 2D Matrix II</td>
<td>给一个非严格递增的矩阵，寻找是否存在target</td>
<td>巧妙的遍历</td>
</tr>
<tr>
<td>First Bad Version</td>
<td>代码库的版本号是从 1 到 <em>n</em> 的整数。某一天，有人提交了错误版本的代码，因此造成自身及之后版本的代码在单元测试中均出错。请找出第一个错误的版本号</td>
<td>二分</td>
</tr>
<tr>
<td>Find Peak Element</td>
<td>给一个数组。找峰值。相邻两个数都不一样。如果有多个峰值，就随便输出一个</td>
<td>二分</td>
</tr>
<tr>
<td>Find Minimum in rotated sorted array</td>
<td>找有序旋转数组（首位相接）中的最小值。数组中不存在重复元素</td>
<td>二分</td>
</tr>
<tr>
<td>Find Minimum in rotated sorted array II</td>
<td>找有序旋转数组（首位相接）中的最小值。数组中可能存在重复元素</td>
<td>遍历/二分</td>
</tr>
<tr>
<td>Search in Rotated Sorted Array</td>
<td>从有序旋转数组（首位相接）中找target。数组中不存在重复元素</td>
<td>二分</td>
</tr>
<tr>
<td>Search in Rotated Sorted Array II</td>
<td>从有序旋转数组（首位相接）中找target。数组中可能存在重复元素。</td>
<td>遍历/二分</td>
</tr>
<tr>
<td>Median of two Sorted Arrays</td>
<td>找到两个有序数组的中位数</td>
<td>二分</td>
</tr>
<tr>
<td>Remove Duplicates from Sorted List</td>
<td>将有序链表去重</td>
<td>链表</td>
</tr>
<tr>
<td>Remove Duplicates from Sorted List II</td>
<td>将有序链表中的全部重复元素删除</td>
<td>链表+dummy</td>
</tr>
<tr>
<td>Remove Linked List Elements</td>
<td>删除链表中的某个节点</td>
<td>链表+dummy</td>
</tr>
<tr>
<td>Reverse Linked List</td>
<td>将链表反转</td>
<td>链表</td>
</tr>
<tr>
<td>Reverse Linked List II</td>
<td>将一个链表的m到n反转</td>
<td>链表+dummy</td>
</tr>
<tr>
<td>Reverse Nodes in k-Group</td>
<td>将链表按照k大小的组，反转。如果最后不够k个，则保持原样</td>
<td>链表+dummy</td>
</tr>
<tr>
<td>Partition List</td>
<td>要求把小于x的元素放到链表前面</td>
<td>链表+dummy</td>
</tr>
<tr>
<td>Sort List</td>
<td>用O(nlogn)的时间和空间复杂度排序链表</td>
<td>链表+取中点+快排/归并</td>
</tr>
<tr>
<td>Reorder List</td>
<td>将链表 <em>L</em>0→<em>L</em>1→…→<em>L</em>n-1→<em>L</em>n, 重排序为<em>L</em>0→<em>L**n</em>→<em>L</em>1→<em>L**n</em>-1→<em>L</em>2→<em>L**n</em>-2→…</td>
<td>链表+取中点+反转</td>
</tr>
<tr>
<td>Linked List Cycle</td>
<td>判断链表里有没有环形</td>
<td>链表+fast-slow</td>
</tr>
<tr>
<td>Linked List Cycle II</td>
<td>如果有环，找到环的入口</td>
<td>链表+fast-slow</td>
</tr>
<tr>
<td>Rotate List</td>
<td>将链表循环移动k个</td>
<td>链表+fast-slow</td>
</tr>
<tr>
<td>Merge k Sorted Lists</td>
<td>将k个有序链表合并</td>
<td>堆+链表</td>
</tr>
<tr>
<td>Delete Node in a Linked List</td>
<td>从链表中删除某个Node</td>
<td>神奇的后移</td>
</tr>
<tr>
<td>Palindrome Linked List</td>
<td>判断一个list是不是回文串</td>
<td>链表反转</td>
</tr>
<tr>
<td>Odd Even Linked List</td>
<td>将链表的奇数位放前面，偶数位放后面</td>
<td>链表</td>
</tr>
<tr>
<td>Split Linked List in Parts</td>
<td>将一个链表分为k个部分，每个部分的长度差不得超过1，且前面的长度不得小于后面的长度</td>
<td>链表</td>
</tr>
<tr>
<td>Insertion Sort List</td>
<td>实现链表的插入排序</td>
<td>链表</td>
</tr>
<tr>
<td>Copy List with Random Pointer</td>
<td>深拷贝一个带有random指针的链表</td>
<td>链表+三步走</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[算法-九章模板总结]]></title>
      <url>/2017/11/14/%E7%AE%97%E6%B3%95-%E4%B9%9D%E7%AB%A0%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<ol>
<li><a href="http://www.jiuzhang.com/solutions/implement-trie/" target="_blank" rel="external">Trie树</a></li>
<li><a href="https://www.jiuzhang.com/solution/heapify/" target="_blank" rel="external">堆</a></li>
<li><a href="https://www.jiuzhang.com/solution/hashheap/" target="_blank" rel="external">hash堆</a></li>
<li><a href="http://www.jiuzhang.com/solution/number-of-islands/" target="_blank" rel="external">并查集</a></li>
<li><a href="http://www.jiuzhang.com/solution/number-of-airplanes-in-the-sky/" target="_blank" rel="external">扫描线</a></li>
<li><a href="http://www.jiuzhang.com/solutions/?search=" target="_blank" rel="external">leetcode题解模板</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Java-Comparable接口]]></title>
      <url>/2017/11/13/Java-Compareable%E6%8E%A5%E5%8F%A3/</url>
      <content type="html"><![CDATA[<p>Arrays类中的sort方法可以对对象数组进行排序。但前提是对象所属的类必须实现了Comparable接口。</p>
<p><strong>接口代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object other)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了让某个类实现以上Comparable接口，通常需要以下两个步骤：</p>
<ol>
<li>将类声明为实现给定的接口；</li>
<li>对接口中的所有方法进行定义。</li>
</ol>
<a id="more"></a>
<p><strong>例子</strong></p>
<p>这个Node内有两个变量：key和count。如果我们想通过count来定义大小的话，我们这么写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt;</span>&#123;</div><div class="line">  <span class="keyword">int</span> key;</div><div class="line">  <span class="keyword">int</span> count;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node o)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.count &gt; o.count)&#123;</div><div class="line">      <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.count == o.count)&#123;</div><div class="line">      <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="String-的compareTo">1. String 的compareTo</h1><p>如果要比较字符串的字典顺序，那就使用： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">s1 = <span class="string">"ab"</span>;</div><div class="line">s2 = <span class="string">"ac"</span>;</div><div class="line">s1.compareTo(s2); <span class="comment">//return -1,s1在s2前</span></div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Comparable </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[算法-Trie树]]></title>
      <url>/2017/11/13/%E7%AE%97%E6%B3%95-Trie%E6%A0%91/</url>
      <content type="html"><![CDATA[<p>Trie树，即字典树/前缀树，又称单词查找树或键树，是一种树形结构。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是最大限度地减少无谓的字符串比较，查询效率比较高。</p>
<p>Trie的核心思想是空间换时间，利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。</p>
<p>例如有abc,abcd,abd,b,bcd,efg,hii这7个单词，我们构建的树如下所示：</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-11-13-09-44-44.png" alt="">  </p>
<p>如上图所示，对于每一个节点，从根遍历到他的过程就是一个单词，如果这个节点被标记为红色，就表示这个单词存在，否则不存在。</p>
<a id="more"></a>
<p>​    那么，对于一个单词，我只要顺着他从根走到对应的节点，再看这个节点是否被标记为红色就可以知道它是否出现过了。把这个节点标记为红色，就相当于插入了这个单词。</p>
<p>​    这样一来我们<strong>查询和插入可以一起完成</strong>（重点体会这个查询和插入是如何一起完成的，稍后，下文具体解释），所用时间仅仅为单词长度，在这一个样例，便是10。<br>​    我们可以看到，trie树每一层的节点数是26^i级别的。所以为了节省空间。我们用动态链表，或者用数组来模拟动态。空间的花费，不会超过单词数×单词长度。</p>
<p>它有3个基本性质：</p>
<ol>
<li>根节点不包含字符，除根节点外每一个节点都只包含一个字符。</li>
<li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。</li>
<li>每个节点的所有子节点包含的字符都不相同。</li>
</ol>
<h1 id="实现">1. 实现</h1><h2 id="HashMap方式">1.1. HashMap方式</h2><p>这是总容易想到的方式。每个TrieNode节点的形状如表所示：</p>
<table>
<thead>
<tr>
<th>boolean</th>
<th>HashMap<char,trienode></char,trienode></th>
</tr>
</thead>
<tbody>
<tr>
<td>hasWord</td>
<td>children</td>
</tr>
</tbody>
</table>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">HashMap&lt;Character,Trie&gt; children ;</div><div class="line"><span class="keyword">boolean</span> hasWord;</div><div class="line"><span class="comment">/*初始化*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span></span>&#123;</div><div class="line">  children = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">  hasWord = <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*插入一个词*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span></span>&#123;</div><div class="line">  <span class="keyword">int</span> length = word.length();</div><div class="line">  Trie root = <span class="keyword">this</span>;</div><div class="line">  <span class="keyword">char</span> c;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; length ; i += <span class="number">1</span>)&#123;</div><div class="line">    c = word.charAt(i);</div><div class="line">    <span class="keyword">if</span>(!root.children.containsKey(c))&#123;</div><div class="line">      root.children.put(c,<span class="keyword">new</span> Trie());</div><div class="line">    &#125;</div><div class="line">    root = root.children.get(c);</div><div class="line">  &#125;</div><div class="line">  root.hasWord = <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*查找*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span></span>&#123;</div><div class="line">  <span class="keyword">int</span> length = word.length();</div><div class="line">  Trie root = <span class="keyword">this</span>;</div><div class="line">  <span class="keyword">char</span> c;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; length ; i += <span class="number">1</span>)&#123;</div><div class="line">    c = word.charAt(i);</div><div class="line">    <span class="keyword">if</span>(root.children.containsKey(c))&#123;</div><div class="line">      root = root.children.get(c);</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>(root.hasWord)<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*返回prefix是否是树中某个单词的前缀*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span></span>&#123;</div><div class="line">  <span class="keyword">int</span> length = prefix.length();</div><div class="line">  Trie root = <span class="keyword">this</span>;</div><div class="line">  <span class="keyword">char</span> c;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; length ; i += <span class="number">1</span>)&#123;</div><div class="line">    c = prefix.charAt(i);</div><div class="line">    <span class="keyword">if</span>(root.children.containsKey(c))&#123;</div><div class="line">      root = root.children.get(c);</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="数组方式">1.2. 数组方式</h2><p>由于字母一共就26个。所以可以映射的方式将字母映射到长度为26的数组上，而下标就是字母。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</div><div class="line">        TrieNode[] next;</div><div class="line">        <span class="keyword">boolean</span> isWord;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.next = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</div><div class="line">            <span class="keyword">this</span>.isWord = <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    TrieNode root;</div><div class="line">    </div><div class="line">    <span class="comment">/** Initialize your data structure here. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.root = <span class="keyword">new</span> TrieNode();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/** Inserts a word into the trie. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</div><div class="line">        TrieNode cur = <span class="keyword">this</span>.root;</div><div class="line">        <span class="keyword">char</span>[] w = word.toCharArray(); <span class="comment">// 这是个骚操作，将str转化为char[]</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; word.length(); i++) &#123;</div><div class="line">            <span class="keyword">if</span>(cur.next[w[i]-<span class="string">'a'</span>]==<span class="keyword">null</span>) &#123;</div><div class="line">                cur.next[w[i]-<span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode();</div><div class="line">            &#125;</div><div class="line">            cur = cur.next[w[i]-<span class="string">'a'</span>];</div><div class="line">        &#125;</div><div class="line">        cur.isWord = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</div><div class="line">        <span class="comment">// return startsWith(word) &amp;&amp; </span></div><div class="line">        <span class="keyword">char</span>[] w = word.toCharArray();</div><div class="line">        TrieNode cur = root;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; word.length(); i++) &#123;</div><div class="line">            <span class="keyword">if</span>(cur.next[w[i]-<span class="string">'a'</span>]==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            cur = cur.next[w[i]-<span class="string">'a'</span>];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> cur.isWord;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(prefix.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">char</span>[] word = prefix.toCharArray();</div><div class="line">        TrieNode cur = root;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; prefix.length(); i++) &#123;</div><div class="line">            <span class="keyword">if</span>(cur.next[word[i]-<span class="string">'a'</span>]==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            cur = cur.next[word[i]-<span class="string">'a'</span>];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h1 id="问题实例">2. 问题实例</h1><p><strong>1、一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析</strong></p>
<p><strong>提示</strong>：用trie树统计每个词出现的次数，时间复杂度是O(n<em>le)（le表示单词的平均长度），然后是找出出现最频繁的前10个词。当然，也可以用堆来实现，时间复杂度是O(n</em>lg10)。所以总的时间复杂度，是O(n<em>le)与O(n</em>lg10)中较大的哪一个。</p>
<p><strong>2、寻找热门查询</strong></p>
<p><strong>原题</strong>：搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录，这些查询串的重复读比较高，虽然总数是1千万，但是如果去除重复和，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就越热门。请你统计最热门的10个查询串，要求使用的内存不能超过1G。</p>
<p><strong>提示</strong>：利用trie树，关键字域存该查询串出现的次数，没有出现为0。最后用10个元素的最小推来对出现频率进行排序。</p>
<h1 id="相关leetcode题">3. 相关leetcode题</h1><h2 id="Implement-Trie-Prefix-Tree">3.1. Implement Trie (Prefix Tree)</h2><p>实现Trie树即可。如上代码所示。不做过多介绍。</p>
<h2 id="Add-and-Search-Word-Data-structure-design">3.2. Add and Search Word - Data structure design</h2><p>实现如下接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">addWord</span><span class="params">(word)</span></span></div><div class="line">bool <span class="title">search</span><span class="params">(word)</span></div><div class="line">例如：</div><div class="line"><span class="title">addWord</span><span class="params">(<span class="string">"bad"</span>)</span></div><div class="line"><span class="title">addWord</span><span class="params">(<span class="string">"dad"</span>)</span></div><div class="line"><span class="title">addWord</span><span class="params">(<span class="string">"mad"</span>)</span></div><div class="line"><span class="title">search</span><span class="params">(<span class="string">"pad"</span>)</span> -&gt; <span class="keyword">false</span></div><div class="line"><span class="title">search</span><span class="params">(<span class="string">"bad"</span>)</span> -&gt; <span class="keyword">true</span></div><div class="line"><span class="title">search</span><span class="params">(<span class="string">".ad"</span>)</span> -&gt; <span class="keyword">true</span></div><div class="line"><span class="title">search</span><span class="params">(<span class="string">"b.."</span>)</span> -&gt; <span class="keyword">true</span></div></pre></td></tr></table></figure>
<p>即，添加字符串。当查找时，’.’可作为通配符。</p>
<p>思路：用Trie树即可。需要注意通配符的使用，需要进行依次遍历。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by jiayi on 2017/11/13.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordDictionary</span> </span>&#123;</div><div class="line">    WordDictionary[] children;</div><div class="line">    <span class="keyword">boolean</span> hasWord;</div><div class="line">    <span class="comment">/*初始化*/</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WordDictionary</span><span class="params">()</span></span>&#123;</div><div class="line">        children = <span class="keyword">new</span> WordDictionary[<span class="number">27</span>];</div><div class="line">        hasWord = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/*插入一个词*/</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWord</span><span class="params">(String word)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> length = word.length();</div><div class="line">        WordDictionary root = <span class="keyword">this</span>;</div><div class="line">        <span class="keyword">int</span> pos;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; length ; i += <span class="number">1</span>)&#123;</div><div class="line">            pos = word.charAt(i) - <span class="string">'a'</span>;</div><div class="line">            <span class="keyword">if</span>(<span class="keyword">null</span> == root.children[pos])&#123;</div><div class="line">                root.children[pos] = <span class="keyword">new</span> WordDictionary();</div><div class="line">            &#125;</div><div class="line">            root = root.children[pos];</div><div class="line">        &#125;</div><div class="line">        root.hasWord = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/*查找*/</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(String word, <span class="keyword">int</span> index,WordDictionary root)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> length = word.length();</div><div class="line">        <span class="keyword">int</span> pos;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index ; i &lt; length ; i += <span class="number">1</span>)&#123;</div><div class="line">            pos = word.charAt(i) - <span class="string">'a'</span>;</div><div class="line">            <span class="keyword">if</span>( pos == -<span class="number">51</span> )&#123;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">26</span> ; j += <span class="number">1</span>)&#123;</div><div class="line">                    <span class="keyword">if</span>(<span class="keyword">null</span> != root.children &amp;&amp; dfs(word,i+<span class="number">1</span>,root.children[j]))&#123;</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">null</span> != root.children[pos])&#123;</div><div class="line">                root = root.children[pos];</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> root.hasWord;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> dfs(word,<span class="number">0</span>,<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        WordDictionary obj = <span class="keyword">new</span> WordDictionary();</div><div class="line">        obj.addWord(<span class="string">"at"</span>);</div><div class="line">        obj.addWord(<span class="string">"and"</span>);</div><div class="line">        obj.addWord(<span class="string">"add"</span>);</div><div class="line">        obj.addWord(<span class="string">"a"</span>);</div><div class="line">        obj.addWord(<span class="string">"bat"</span>);</div><div class="line">        System.out.println(obj.search(<span class="string">"a.d."</span>));</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Top-K-Frequent-Words">3.3. Top K Frequent Words</h2><p>给一组str[]，统计频率最高的k个str，并输出</p>
<p>如果两个str频率一样，则字典顺序低的str优先输出</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Input: [&quot;i&quot;, &quot;love&quot;, &quot;leetcode&quot;, &quot;i&quot;, &quot;love&quot;, &quot;coding&quot;], k = 2</div><div class="line">Output: [&quot;i&quot;, &quot;love&quot;]</div><div class="line">i和love是频率最高的两个str，且频率都是2。i在love前面，因为i的字典顺序靠前</div></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: [&quot;the&quot;, &quot;day&quot;, &quot;is&quot;, &quot;sunny&quot;, &quot;the&quot;, &quot;the&quot;, &quot;the&quot;, &quot;sunny&quot;, &quot;is&quot;, &quot;is&quot;], k = 4</div><div class="line">Output: [&quot;the&quot;, &quot;is&quot;, &quot;sunny&quot;, &quot;day&quot;]</div></pre></td></tr></table></figure>
<p>思路：这道题先用trie树进行统计，然后用一个最大堆来维护当前每个str的次数。当统计结束时，从堆顶输出k次即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt;</span>&#123;</div><div class="line">            String s;</div><div class="line">            <span class="keyword">int</span> count;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node o)</span> </span>&#123;</div><div class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.count &gt; o.count)&#123;</div><div class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.count == o.count)&#123;</div><div class="line">                    <span class="keyword">if</span>(<span class="keyword">this</span>.s.compareTo(o.s)&gt;<span class="number">0</span>)&#123;</div><div class="line">                        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">                    &#125;<span class="keyword">else</span>&#123;</div><div class="line">                        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;<span class="keyword">else</span>&#123;</div><div class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            Node(String s,<span class="keyword">int</span> count)&#123;</div><div class="line">                <span class="keyword">this</span>.s = s;</div><div class="line">                <span class="keyword">this</span>.count = count;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">HashHeap</span></span>&#123;</div><div class="line">        Node[] E;</div><div class="line">        HashMap&lt;String,Integer&gt; map;</div><div class="line">        <span class="keyword">int</span> heapSize;</div><div class="line">        <span class="keyword">int</span> k;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">HashHeap</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">            E = <span class="keyword">new</span> Node[k+<span class="number">1</span>];</div><div class="line">            heapSize = <span class="number">0</span>;</div><div class="line">            map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">            <span class="keyword">this</span>.k = k ;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">left</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="number">2</span> * i;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">right</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">father</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</div><div class="line">            <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</div><div class="line">                <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> i/<span class="number">2</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">brother</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</div><div class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</div><div class="line">                <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</div><div class="line">                <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(i==<span class="number">2</span>)&#123;</div><div class="line">                <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</div><div class="line">                <span class="keyword">return</span> i+<span class="number">1</span>;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                <span class="keyword">return</span> i-<span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</div><div class="line">            <span class="keyword">int</span> indexq = map.get(E[q].s);</div><div class="line">            map.replace(E[q].s,map.get(E[p].s));</div><div class="line">            map.replace(E[p].s,indexq);</div><div class="line">            Node temp = E[p];</div><div class="line">            E[p] = E[q];</div><div class="line">            E[q] = temp;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Push</span><span class="params">(Node e)</span></span>&#123;</div><div class="line">    <span class="comment">//        while(heapSize &gt;= k)&#123;</span></div><div class="line">    <span class="comment">//            this.Pop();</span></div><div class="line">    <span class="comment">//        &#125;</span></div><div class="line">            E[heapSize] = e;</div><div class="line">            heapSize+=<span class="number">1</span>;</div><div class="line">            map.put(e.s,heapSize-<span class="number">1</span>);</div><div class="line">            FixUP(heapSize-<span class="number">1</span>);</div><div class="line">    </div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">FixUP</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</div><div class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)<span class="keyword">return</span>;</div><div class="line">            <span class="keyword">int</span> father = father(i);</div><div class="line">            <span class="keyword">if</span>(E[father].compareTo(E[i])&gt;<span class="number">0</span>) &#123;</div><div class="line">                swap(i, father);</div><div class="line">            &#125;</div><div class="line">            FixUP(father);</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">private</span> Node <span class="title">Pop</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">if</span>(heapSize==<span class="number">0</span>)&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">            swap(<span class="number">0</span>,heapSize-<span class="number">1</span>);</div><div class="line">            heapSize-=<span class="number">1</span>;</div><div class="line">            FixDown(<span class="number">0</span>);</div><div class="line">            <span class="keyword">return</span> E[heapSize];</div><div class="line">    </div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">FixDown</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">            <span class="keyword">int</span> l = left(i);</div><div class="line">            <span class="keyword">int</span> r = right(i);</div><div class="line">            <span class="keyword">int</span> min = -<span class="number">1</span>;</div><div class="line">            <span class="keyword">if</span> (l &lt; <span class="keyword">this</span>.heapSize &amp;&amp; E[l].compareTo(E[i])&lt;<span class="number">0</span>)&#123;</div><div class="line">                min = l;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                min = i;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>( r &lt; <span class="keyword">this</span>.heapSize &amp;&amp; E[r].compareTo(E[min])&lt;<span class="number">0</span> )&#123;</div><div class="line">                min = r;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>( min != i )&#123;</div><div class="line">                swap(i,min);</div><div class="line">                FixDown(min);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">count_add1</span><span class="params">(String s)</span></span>&#123;</div><div class="line">            <span class="keyword">int</span> index = map.get(s);</div><div class="line">            E[index].count+=<span class="number">1</span>;</div><div class="line">            FixUP(index);</div><div class="line">        &#125;</div><div class="line">    </div><div class="line">    &#125;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</div><div class="line">        Trie[] children;</div><div class="line">        <span class="keyword">int</span> wordCount;</div><div class="line">        <span class="comment">/*初始化*/</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span></span>&#123;</div><div class="line">            children = <span class="keyword">new</span> Trie[<span class="number">26</span>];</div><div class="line">            wordCount = <span class="number">0</span>;</div><div class="line">    </div><div class="line">        &#125;</div><div class="line">        <span class="comment">/*插入一个词*/</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWord</span><span class="params">(String word)</span></span>&#123;</div><div class="line">            <span class="keyword">int</span> length = word.length();</div><div class="line">            Trie root = <span class="keyword">this</span>;</div><div class="line">            <span class="keyword">int</span> pos;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; length ; i += <span class="number">1</span>)&#123;</div><div class="line">                pos = word.charAt(i) - <span class="string">'a'</span>;</div><div class="line">                <span class="keyword">if</span>(<span class="keyword">null</span> == root.children[pos])&#123;</div><div class="line">                    root.children[pos] = <span class="keyword">new</span> Trie();</div><div class="line">                &#125;</div><div class="line">                root = root.children[pos];</div><div class="line">            &#125;</div><div class="line">            root.wordCount += <span class="number">1</span>;</div><div class="line">          <span class="comment">// 这里维护一个hashheap</span></div><div class="line">            <span class="keyword">if</span>(root.wordCount==<span class="number">1</span>)&#123;</div><div class="line">                heap.Push(<span class="keyword">new</span> Node(word,<span class="number">1</span>));</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                heap.count_add1(word);</div><div class="line">            &#125;</div><div class="line">         </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    HashHeap heap ;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">topKFrequent</span><span class="params">(String[] words, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        Trie trie = <span class="keyword">new</span> Trie();</div><div class="line">        heap = <span class="keyword">new</span> HashHeap(words.length);</div><div class="line">        <span class="keyword">for</span>(String w : words)&#123;</div><div class="line">            trie.addWord(w);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; k ; i +=<span class="number">1</span> )&#123;</div><div class="line">            ans.add(heap.Pop().s);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> ans;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Map-Sum-Pairs">3.4. Map Sum Pairs</h2><p>实现如下接口：</p>
<p>insert(String s,int val)   — s是关键字，val是价值</p>
<p>sum(String prefix)  — 输出以prefix为前缀的所有单词的价值和。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Input: insert(&quot;apple&quot;, 3), Output: Null</div><div class="line">Input: sum(&quot;ap&quot;), Output: 3</div><div class="line">Input: insert(&quot;app&quot;, 2), Output: Null</div><div class="line">Input: sum(&quot;ap&quot;), Output: 5</div></pre></td></tr></table></figure>
<p>思路：用Trie树保存insert之后的str，并给每一个节点保存一个val值。如果这个节点不是单词，val就为0。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by jiayi on 2017/11/14.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapSum</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</div><div class="line">        Node[] children;</div><div class="line">        <span class="keyword">int</span> Val;</div><div class="line">        Node()&#123;</div><div class="line">            children = <span class="keyword">new</span> Node[<span class="number">26</span>];</div><div class="line">            Val = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetVal</span><span class="params">(<span class="keyword">int</span> Val)</span></span>&#123;</div><div class="line">            <span class="keyword">this</span>.Val = Val;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/*初始化*/</span></div><div class="line">    Node root;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapSum</span><span class="params">()</span> </span>&#123;</div><div class="line">        root = <span class="keyword">new</span> Node();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/*插入*/</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String key, <span class="keyword">int</span> val)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> index;</div><div class="line">        Node e = root;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; key.length() ; i += <span class="number">1</span>)&#123;</div><div class="line">            index = key.charAt(i) - <span class="string">'a'</span>;</div><div class="line">            <span class="keyword">if</span>(<span class="keyword">null</span> == e.children[index])&#123;</div><div class="line">                e.children[index] = <span class="keyword">new</span> Node();</div><div class="line">            &#125;</div><div class="line">            e = e.children[index];</div><div class="line">        &#125;</div><div class="line">        e.SetVal(val);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/*前缀尾prefix的单词的权重和*/</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(String prefix)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> index;</div><div class="line">        Node e = <span class="keyword">this</span>.root;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; prefix.length() ; i += <span class="number">1</span> )&#123;</div><div class="line">            index = prefix.charAt(i) - <span class="string">'a'</span>;</div><div class="line">            <span class="keyword">if</span>( <span class="keyword">null</span> != e.children[index] )&#123;</div><div class="line">                e = e.children[index];</div><div class="line">            &#125;<span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// e停留在前缀末尾</span></div><div class="line">        <span class="keyword">return</span> dfs(e);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(Node root)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> val = root.Val;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">26</span>; i += <span class="number">1</span> )&#123;</div><div class="line">            <span class="keyword">if</span>( <span class="keyword">null</span> == root.children[i] )&#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            val += dfs(root.children[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> val;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        MapSum t = <span class="keyword">new</span> MapSum();</div><div class="line">        t.insert(<span class="string">"a"</span>,<span class="number">3</span>);</div><div class="line">        System.out.println(t.sum(<span class="string">"ap"</span>));</div><div class="line">        t.insert(<span class="string">"b"</span>,<span class="number">2</span>);</div><div class="line">        System.out.println(t.sum(<span class="string">"a"</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Word-Search-II">3.5. Word Search II</h2><p>给一个<code>char[][] board</code>，和一个String[] words。从words中找到被包含在board中的单词。</p>
<p><strong>words</strong> = <code>[&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;]</code> and <strong>board</strong> =</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  [&apos;o&apos;,&apos;a&apos;,&apos;a&apos;,&apos;n&apos;],</div><div class="line">  [&apos;e&apos;,&apos;t&apos;,&apos;a&apos;,&apos;e&apos;],</div><div class="line">  [&apos;i&apos;,&apos;h&apos;,&apos;k&apos;,&apos;r&apos;],</div><div class="line">  [&apos;i&apos;,&apos;f&apos;,&apos;l&apos;,&apos;v&apos;]</div><div class="line">]</div></pre></td></tr></table></figure>
<p>Return </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[&quot;eat&quot;,&quot;oath&quot;]</div></pre></td></tr></table></figure>
<p>.思路：给words建立一个trie树。然后依次对board中每个点进行dfs，查看组成的单词在不在trie树中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</div><div class="line">        Node[] children;</div><div class="line">        <span class="keyword">boolean</span> hasword;</div><div class="line">        Node()&#123;</div><div class="line">            children = <span class="keyword">new</span> Node[<span class="number">26</span>];</div><div class="line">            hasword = <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    Node root;</div><div class="line">    <span class="keyword">boolean</span>[][] flag;</div><div class="line">    List&lt;String&gt; ans;</div><div class="line">    <span class="comment">/*插入*/</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> index;</div><div class="line">        Node e = root;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; key.length() ; i += <span class="number">1</span>)&#123;</div><div class="line">            index = key.charAt(i) - <span class="string">'a'</span>;</div><div class="line">            <span class="keyword">if</span>(<span class="keyword">null</span> == e.children[index])&#123;</div><div class="line">                e.children[index] = <span class="keyword">new</span> Node();</div><div class="line">            &#125;</div><div class="line">            e = e.children[index];</div><div class="line">        &#125;</div><div class="line">        e.hasword = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/*对board进行dfs遍历*/</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board,<span class="keyword">int</span> i, <span class="keyword">int</span> j , Node e,String w)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(flag[i][j])<span class="keyword">return</span>;</div><div class="line">        <span class="keyword">int</span> index = board[i][j] - <span class="string">'a'</span>;</div><div class="line">        <span class="keyword">if</span>( <span class="keyword">null</span> == e.children[index] )&#123;<span class="keyword">return</span>;&#125;</div><div class="line">        w = w+board[i][j];</div><div class="line">        <span class="keyword">if</span>( e.children[index].hasword )&#123;</div><div class="line">            ans.add(w);</div><div class="line">            e.children[index].hasword = <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        flag[i][j] = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">int</span>[] dx = &#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</div><div class="line">        <span class="keyword">int</span>[] dy = &#123;<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</div><div class="line">        <span class="keyword">int</span> x,y;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> q = <span class="number">0</span> ; q &lt; dx.length ;  q+=<span class="number">1</span>)&#123;</div><div class="line">            x = i + dx[q];</div><div class="line">            y = j + dy[q];</div><div class="line">            <span class="keyword">if</span>(  x &lt; <span class="number">0</span> ||  x &gt;= board.length)<span class="keyword">continue</span>;</div><div class="line">            <span class="keyword">if</span>(  y &lt; <span class="number">0</span> ||  y &gt;= board[i].length )<span class="keyword">continue</span>;</div><div class="line">            dfs(board,x,y,e.children[index],w);</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        flag[i][j] = <span class="keyword">false</span>;</div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findWords</span><span class="params">(<span class="keyword">char</span>[][] board, String[] words)</span> </span>&#123;</div><div class="line">        ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">if</span>(board.length == <span class="number">0</span> || board[<span class="number">0</span>].length == <span class="number">0</span> || words.length==<span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> ans;</div><div class="line">        &#125;</div><div class="line">        root = <span class="keyword">new</span> Node();</div><div class="line">        flag = <span class="keyword">new</span> <span class="keyword">boolean</span>[board.length][board[<span class="number">0</span>].length];</div><div class="line">        <span class="keyword">for</span>(String s : words)&#123;</div><div class="line">            insert(s);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; board.length ; i += <span class="number">1</span> )&#123;</div><div class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; board[i].length ; j += <span class="number">1</span> )&#123;</div><div class="line">                dfs(board,i,j,<span class="keyword">this</span>.root,<span class="string">""</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> ans;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Replace-Words">3.6. Replace Words</h2><p>给一个词根表<code>str[] dict = [&quot;cat&quot;, &quot;bat&quot;, &quot;rat&quot;]</code> ，和一个句子<code>sentence = &quot;the cattle was rattled by the battery&quot;</code>。用词根替换句子为<code>&quot;the cat was rat by the bat&quot;</code></p>
<p>思路：这道题我一开始是用dfs来做的。但是测试样例太变态了，好长的字符串，导致超时了。这道题只能用循环来做！</p>
<p>这道题有String的两个骚操作：</p>
<ol>
<li><p>对String s 的循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>( <span class="keyword">char</span> s : s.toCharArray() )&#123;</div><div class="line">  System.out.println(s);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>对多个str的concat：<code>StringBuilder</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</div><div class="line"><span class="keyword">for</span>( String e : strs )&#123;</div><div class="line">  stringBuilder.append(e);</div><div class="line">&#125;</div><div class="line">String concatResult = stringBuilder.toString();</div></pre></td></tr></table></figure>
<p>代码：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by jiayi on 2017/11/13.</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieTree</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Trie</span></span>&#123;</div><div class="line">        <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span></span>&#123;</div><div class="line">            TrieNode[] children;</div><div class="line">            <span class="keyword">boolean</span> hasWord;</div><div class="line">            TrieNode()&#123;</div><div class="line">                children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</div><div class="line">                hasWord = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        TrieNode root;</div><div class="line">        Trie()&#123;</div><div class="line">            root = <span class="keyword">new</span> TrieNode();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span></span>&#123;</div><div class="line">            TrieNode r = <span class="keyword">this</span>.root;</div><div class="line">            <span class="keyword">int</span> index;</div><div class="line">            <span class="keyword">for</span>( <span class="keyword">char</span> c: word.toCharArray() )&#123;</div><div class="line">                index = c-<span class="string">'a'</span>;</div><div class="line">                <span class="keyword">if</span>( <span class="keyword">null</span> == r.children[index] )&#123;</div><div class="line">                    r.children[index] = <span class="keyword">new</span> TrieNode();</div><div class="line">                &#125;</div><div class="line">                r = r.children[index];</div><div class="line">            &#125;</div><div class="line">            r.hasWord = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 判断树中有没有word的前缀</span></div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">prefix</span><span class="params">(String word)</span></span>&#123;</div><div class="line">            StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</div><div class="line">            TrieNode r = <span class="keyword">this</span>.root;</div><div class="line">            <span class="keyword">int</span> idx;</div><div class="line">            <span class="keyword">for</span>( <span class="keyword">char</span> c : word.toCharArray() )&#123;</div><div class="line">                idx = c - <span class="string">'a'</span>;</div><div class="line">                <span class="keyword">if</span>( <span class="keyword">null</span> != r.children[idx] )&#123;</div><div class="line">                    stringBuilder.append(c);</div><div class="line">                    <span class="keyword">if</span>(r.children[idx].hasWord)&#123;</div><div class="line">                        <span class="keyword">return</span> stringBuilder.toString();</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span>&#123;</div><div class="line">                        r = r.children[idx];</div><div class="line">                    &#125;</div><div class="line">                &#125;<span class="keyword">else</span>&#123;</div><div class="line">                    <span class="keyword">return</span> word;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> word;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceWords</span><span class="params">(List&lt;String&gt; dict, String sentence)</span> </span>&#123;</div><div class="line">        Trie trie = <span class="keyword">new</span> Trie();</div><div class="line">        <span class="keyword">for</span>(String word : dict)&#123;</div><div class="line">            trie.insert(word);</div><div class="line">        &#125;</div><div class="line">        String[] words = sentence.split(<span class="string">" "</span>);</div><div class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</div><div class="line">        <span class="keyword">for</span>( String word : words )&#123;</div><div class="line">            stringBuilder.append(trie.prefix(word));</div><div class="line">            stringBuilder.append(<span class="string">" "</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> stringBuilder.toString().substring(<span class="number">0</span>,stringBuilder.length()-<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        String sentence = <span class="string">"a aa a aaaa aaa aaa aaa aaaaaa bbb baba ababa"</span>;</div><div class="line">        String[] d = &#123;<span class="string">"a"</span>, <span class="string">"aa"</span>, <span class="string">"aaa"</span>, <span class="string">"aaaa"</span>&#125;;</div><div class="line">        ArrayList&lt;String&gt; dict = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">for</span>(String e : d)&#123;</div><div class="line">            dict.add(e);</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="keyword">new</span> TrieTree().replaceWords(dict,sentence));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Concatenated-Words">3.7. Concatenated Words</h2><p>给一个str数组。找到其中某些能被其它字符concat而成的单词</p>
<p>用了trie树，beats 93%.简直美滋滋</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span></span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</div><div class="line">        <span class="keyword">boolean</span> hasWord = <span class="keyword">false</span>;</div><div class="line">        Node[] children = <span class="keyword">new</span> Node[<span class="number">26</span>];</div><div class="line">    &#125;</div><div class="line">    Node root = <span class="keyword">new</span> Node();</div><div class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">newNode</span><span class="params">(Node root, <span class="keyword">char</span> c)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(root.children[c - <span class="string">'a'</span>] == <span class="keyword">null</span>)</div><div class="line">            root.children[c - <span class="string">'a'</span>] = <span class="keyword">new</span> Node();</div><div class="line">        <span class="keyword">return</span> root.children[c - <span class="string">'a'</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String s)</span></span>&#123;</div><div class="line">        Node e = newNode(root, s.charAt(<span class="number">0</span>));</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); ++i)&#123;</div><div class="line">            e = newNode(e, s.charAt(i));</div><div class="line">        &#125;</div><div class="line">        e.hasWord = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">canBeConcat</span><span class="params">(String s, <span class="keyword">int</span> idx)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(idx &gt;= s.length())<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        Node e = root;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = idx; i &lt; s.length(); ++i)&#123;</div><div class="line">            <span class="keyword">char</span> c = s.charAt(i);</div><div class="line">            <span class="keyword">if</span>(e.children[c - <span class="string">'a'</span>] == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">            <span class="keyword">if</span>(e.children[c -<span class="string">'a'</span>].hasWord) &#123;</div><div class="line">                <span class="keyword">if</span>(i == s.length() - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">                <span class="keyword">int</span> next = canBeConcat(s, i + <span class="number">1</span>);</div><div class="line">                <span class="keyword">if</span> (next &gt; <span class="number">0</span>) <span class="keyword">return</span> next + <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">            e = e.children[c-<span class="string">'a'</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findAllConcatenatedWordsInADict</span><span class="params">(String[] words)</span> </span>&#123;</div><div class="line">    Trie trie = <span class="keyword">new</span> Trie();</div><div class="line">    <span class="keyword">for</span>(String str : words)&#123;</div><div class="line">        <span class="keyword">if</span>(str.length() == <span class="number">0</span>)<span class="keyword">continue</span>;</div><div class="line">        trie.add(str);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 查看每个单词是否能被组合</span></div><div class="line">    List&lt;String&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">    <span class="keyword">for</span>(String str : words)&#123;</div><div class="line">        <span class="keyword">if</span>(str.length() == <span class="number">0</span>)<span class="keyword">continue</span>;</div><div class="line">        <span class="keyword">if</span>(trie.canBeConcat(str, <span class="number">0</span>) &gt;= <span class="number">2</span>)result.add(str);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="参考文献">4. 参考文献</h1><ol>
<li><a href="https://wizardforcel.gitbooks.io/the-art-of-programming-by-july/content/06.09.html" target="_blank" rel="external">编程之法</a></li>
<li><a href="http://blog.csdn.net/v_july_v/article/details/6897097" target="_blank" rel="external">July, 从Trie树（字典树）谈到后缀树</a></li>
<li><a href="http://www.jiuzhang.com/solutions/implement-trie/" target="_blank" rel="external">九章算法模板</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Trie </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[算法-并查集]]></title>
      <url>/2017/11/05/%E7%AE%97%E6%B3%95-%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      <content type="html"><![CDATA[<h1 id="关于动态连通性">1. 关于动态连通性</h1><p>我们看一张图来了解一下什么是动态连通性</p>
<p><img src="https://i.loli.net/2017/11/05/59ff21287f5d9.png" alt=""> </p>
<p>假设我们输入了一组整数对，即上图中的(4, 3) (3, 8)等等，每对整数代表这两个points/sites是连通的。那么随着数据的不断输入，整个图的连通性也会发生变化，从上图中可以很清晰的发现这一点。同时，对于已经处于连通状态的points/sites，直接忽略，比如上图中的(8,9)。</p>
<a id="more"></a>
<p><strong>动态连通性的应用场景：</strong></p>
<ul>
<li>网络连接判断：<br>如果每个pair中的两个整数分别代表一个网络节点，那么该pair就是用来表示这两个节点是需要连通的。那么为所有的pairs建立了动态连通图后，就能够尽可能少的减少布线的需要，因为已经连通的两个节点会被直接忽略掉。</li>
<li>变量名等同性(类似于指针的概念)：<br>在程序中，可以声明多个引用来指向同一对象，这个时候就可以通过为程序中声明的引用和实际对象建立动态连通图来判断哪些引用实际上是指向同一对象。</li>
</ul>
<p><strong>对问题建模：</strong></p>
<p>在对问题进行建模的时候，我们应该尽量想清楚需要解决的问题是什么。因为模型中选择的数据结构和算法显然会根据问题的不同而不同，就动态连通性这个场景而言，我们需要解决的问题可能是：</p>
<ul>
<li>给出两个节点，判断它们是否连通，如果连通，不需要给出具体的路径</li>
<li>给出两个节点，判断它们是否连通，如果连通，需要给出具体的路径</li>
</ul>
<p>就上面两种问题而言，虽然只有是否能够给出具体路径的区别，但是这个区别导致了选择算法的不同，本文主要介绍的是第一种情况，即不需要给出具体路径的Union-Find算法，而第二种情况可以使用基于DFS的算法。</p>
<h1 id="并查集">2. 并查集</h1><p> 并查集是若干个不相交的集合，能较快地合并和判断元素所在的集合。</p>
<h2 id="数据结构">2.1. 数据结构</h2><p>并查集的每个元素都是由它和它的父节点（集合内的一个代表）组成，如下表所示：</p>
<table>
<thead>
<tr>
<th>key</th>
<th>value</th>
</tr>
</thead>
<tbody>
<tr>
<td>element</td>
<td>parent</td>
</tr>
</tbody>
</table>
<p>简单的并查集只需要存储在一个hash表中，key是它本身，value就是它的父节点的值。</p>
<p><img src="https://i.loli.net/2017/11/05/59ff249bb6d17.png" alt=""> </p>
<p>如上图的左边两个集合所示，左边的集合表示为：</p>
<table>
<thead>
<tr>
<th style="text-align:center">c</th>
<th>h</th>
<th>e</th>
<th>b</th>
<th>f</th>
<th>d</th>
<th>g</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">c</td>
<td>c</td>
<td>c</td>
<td>h</td>
<td>f</td>
<td>f</td>
<td>d</td>
</tr>
</tbody>
</table>
<h2 id="初始化">2.2. 初始化</h2><p>初始化后每一个元素的父亲节点是它本身，即自己是自己的大哥:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">HashMap&lt;Integer,Integer&gt; father;</div><div class="line">    UnionFind(<span class="keyword">int</span>[] element)&#123;</div><div class="line">        father = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        Initialization(element);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Initialization</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="comment">// initialize your data structure here.</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i)</div><div class="line">            father.put(nums[i],nums[i]);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="查找">2.3. 查找</h2><p>查找一个元素所在的集合，其精髓是找到这个元素的终极大boss！这个才是并查集判断和合并的最终依据。<br>判断两个元素是否属于同一集合，只要看他们是不是最终都归一个终极大boss管, 模板如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</div><div class="line">  <span class="keyword">int</span> key_father = key;</div><div class="line">  <span class="keyword">while</span>(key_father != father.get(key_father))&#123;</div><div class="line">    key_father = father.get(key_father);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> key_father;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然而，这样的最坏情况下的时间复杂度是$O(n)$，例如这个例子：</p>
<p>a→ b→ x→ y→ w</p>
<p>修正的方法就是在find()之后进行路径压缩：</p>
<p><img src="https://i.loli.net/2017/11/05/59ff337e15b12.png" alt=""> </p>
<p>于是就变为：</p>
<p><img src="https://i.loli.net/2017/11/05/59ff33bd936a0.png" alt=""> </p>
<p>代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> key_father = key;</div><div class="line">    <span class="keyword">while</span>(key_father != father.get(key_father))&#123;</div><div class="line">        key_father = father.get(key_father);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> temp = key;</div><div class="line">    <span class="keyword">int</span> temp_father;</div><div class="line">    <span class="keyword">while</span>(temp != key_father)&#123;</div><div class="line">        temp_father = father.get(temp);</div><div class="line">        father.replace(temp,key_father);</div><div class="line">        temp = temp_father;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> key_father;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>时间复杂度第一次是O(n), 但是多次下来是log*n (见<a href="https://en.wikipedia.org/wiki/Iterated_logarithm" target="_blank" rel="external">https://en.wikipedia.org/wiki/Iterated_logarithm</a>), 证明略</p>
<p><img src="https://i.loli.net/2017/11/05/59ff345251520.png" alt=""> </p>
<p>因为1-5都很小, 所以find基本上是O(1)的操作.</p>
<h2 id="合并">2.4. 合并</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public void union(int x,int y)&#123;</div><div class="line">    int fa_x = find(x);</div><div class="line">    int fa_y = find(y);</div><div class="line">    if( fa_x != fa_y )&#123;</div><div class="line">        father.put(fa_x,fa_y);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="模板">3. 模板</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.HashMap;</div><div class="line"><span class="keyword">import</span> java.util.HashSet;</div><div class="line"><span class="keyword">import</span> java.util.Iterator;</div><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by jiayi on 2017/11/5.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</div><div class="line">    HashMap&lt;Integer,Integer&gt; father;</div><div class="line">    UnionFind()&#123;</div><div class="line">        father = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> key,<span class="keyword">int</span> fa)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(father.containsKey(key))<span class="keyword">return</span>;</div><div class="line">        father.put(key,fa);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Initialization</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="comment">// initialize your data structure here.</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i)</div><div class="line">            father.put(nums[i],nums[i]);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> key_father = key;</div><div class="line">        <span class="keyword">while</span>(key_father != father.get(key_father))&#123;</div><div class="line">            key_father = father.get(key_father);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> temp = key;</div><div class="line">        <span class="keyword">int</span> temp_father;</div><div class="line">        <span class="keyword">while</span>(temp != key_father)&#123;</div><div class="line">            temp_father = father.get(temp);</div><div class="line">            father.replace(temp,key_father);</div><div class="line">            temp = temp_father;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> key_father;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> fa_x = find(x);</div><div class="line">        <span class="keyword">int</span> fa_y = find(y);</div><div class="line">        <span class="keyword">if</span>( fa_x != fa_y )&#123;</div><div class="line">            father.put(fa_x,fa_y);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">setNum</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">//输出集合个数</span></div><div class="line">        Iterator iter = father.entrySet().iterator();</div><div class="line">        <span class="keyword">while</span> (iter.hasNext()) &#123;</div><div class="line">            Object key = ((Map.Entry) iter.next()).getKey();</div><div class="line">            find((Integer) key);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 对所有val去重</span></div><div class="line">        iter = father.entrySet().iterator();</div><div class="line">        HashSet&lt;Integer&gt; counter = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (iter.hasNext()) &#123;</div><div class="line">            Integer val = (Integer)(((Map.Entry) iter.next()).getValue());</div><div class="line">            <span class="keyword">if</span>(counter.contains(val))&#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                counter.add(val);</div><div class="line">                num+=<span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> num;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="并查集相关leetcode题">4. 并查集相关leetcode题</h1><h2 id="Number-of-Islands">4.1. Number of Islands</h2><p>给定一个二维数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">11110</div><div class="line">11010</div><div class="line">11000</div><div class="line">00000</div></pre></td></tr></table></figure>
<p>其中1为岛屿，0为海洋。如果上下左右相邻，则为同一个岛屿。判断其中有多少个岛屿。</p>
<p>这个题可以用并查集来做。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> n = grid.length, m = grid[<span class="number">0</span>].length;</div><div class="line">    UnionFind set = <span class="keyword">new</span> UnionFind();</div><div class="line">    <span class="keyword">int</span> index,fa_1,fa_2;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i+=<span class="number">1</span> )&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; m ; j+=<span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(grid[i][j]==<span class="string">'1'</span>)&#123;</div><div class="line">                System.out.println(set.father);</div><div class="line">                index = i*m + j;</div><div class="line">                set.add(index,index);</div><div class="line">                <span class="keyword">if</span>( i&gt;<span class="number">0</span> &amp;&amp; grid[i-<span class="number">1</span>][j]==<span class="string">'1'</span>)&#123;</div><div class="line">                    fa_1 = set.find((index - m));</div><div class="line">                    fa_2 = set.find(index);</div><div class="line">                    set.union(fa_1,fa_2);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(j &gt; <span class="number">0</span> &amp;&amp; grid[i][j-<span class="number">1</span>] == <span class="string">'1'</span>)&#123;</div><div class="line">                    fa_1 = set.find(index - <span class="number">1</span>);</div><div class="line">                    fa_2 = set.find(index);</div><div class="line">                    set.union(fa_1,fa_2);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 返回有几个岛屿</span></div><div class="line"><span class="keyword">return</span> set.setNum();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个题是并查集的入门题。但其实并查集更适用于动态变化的集合。这个题有一个更简单的方式，就是dfs:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span> grid,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</div><div class="line">	<span class="keyword">if</span>( x&lt;<span class="number">0</span> || y&lt;<span class="number">0</span> || x&gt;= grid.length || y &gt;= grid[<span class="number">0</span>].length || grid[x][y]==<span class="string">'0'</span>)&#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(grid[x][y]==<span class="string">'1'</span>)&#123;</div><div class="line">        grid[x][y]=<span class="string">'0'</span>;</div><div class="line">        dfs(grid,x+<span class="number">1</span>,y);</div><div class="line">        dfs(grid,x,y+<span class="number">1</span>);</div><div class="line">        dfs(grid,x-<span class="number">1</span>,y);</div><div class="line">        dfs(grid,x,y-<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> i,j;</div><div class="line">    <span class="keyword">int</span> nums = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; grid.length ; i+=<span class="number">1</span> )&#123;</div><div class="line">        <span class="keyword">for</span>(j = <span class="number">0</span> ; j &lt; grid[i].length ; j+=<span class="number">1</span> )&#123;</div><div class="line">            <span class="keyword">if</span>(grid[i][j]==<span class="string">'1'</span>) &#123;</div><div class="line">                dfs(grid, i, j);</div><div class="line">                nums += <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> nums;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Number-of-Islands-II">4.2. Number of Islands II</h2><p>这道题是上道题的升级版——动态变化的连通图。很明显用并查集是最好的。</p>
<p> 需要注意的是，不像上一题，遍历时只需要遍历左下。这一题的岛屿状态是动态的，因此必须同时遍历上下左右四个方向才行。</p>
<p>此处是这道题的解答：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">numIslands2</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span>[][] positions)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (positions == <span class="keyword">null</span> || positions.length == <span class="number">0</span> || m == <span class="number">0</span> || n == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[] island = <span class="keyword">new</span> <span class="keyword">int</span>[m * n + <span class="number">1</span>];</div><div class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> current = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] position : positions) &#123;</div><div class="line">            <span class="keyword">int</span> x = position[<span class="number">0</span>];</div><div class="line">            <span class="keyword">int</span> y = position[<span class="number">1</span>];</div><div class="line">            <span class="keyword">int</span> index = x * n + y + <span class="number">1</span>;</div><div class="line">            current++;</div><div class="line">            island[index] = index;</div><div class="line">            <span class="keyword">if</span> (x != m - <span class="number">1</span> &amp;&amp; island[index + n] != <span class="number">0</span> &amp;&amp; union(index, index + n, island)) &#123;</div><div class="line">                current--;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (x != <span class="number">0</span> &amp;&amp; island[index - n] != <span class="number">0</span> &amp;&amp; union(index, index - n, island)) &#123;</div><div class="line">                current--;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (y != n - <span class="number">1</span> &amp;&amp; island[index + <span class="number">1</span>] != <span class="number">0</span> &amp;&amp; union(index, index + <span class="number">1</span>, island)) &#123;</div><div class="line">                current--;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (y != <span class="number">0</span> &amp;&amp; island[index - <span class="number">1</span>] != <span class="number">0</span> &amp;&amp; union(index, index - <span class="number">1</span>, island)) &#123;</div><div class="line">                current--;</div><div class="line">            &#125;</div><div class="line">            result.add(current);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> fa_a = find(a, array);</div><div class="line">        <span class="keyword">int</span> fa_b = find(b, array);</div><div class="line">        <span class="keyword">if</span> (fa_a == fa_b) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        array[fa_a] = fa_b;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> fa = array[i];</div><div class="line">        <span class="keyword">while</span>(array[fa] != fa) &#123;</div><div class="line">            fa = array[fa];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> next = array[i];</div><div class="line">        <span class="keyword">while</span> (next != fa) &#123;</div><div class="line">            array[i] = fa;</div><div class="line">            i = next;</div><div class="line">            next = array[next];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> fa;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Graph-Valid-Tree">4.3. Graph Valid Tree</h2><p>给一个无向连通图，判断是不是一棵树。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">输入：n = 5` 和边集 edges = [[0, 1], [0, 2], [0, 3], [1, 4]]</div><div class="line">输出：true</div></pre></td></tr></table></figure>
<p>用连通图，每遍历到一条边前，先判断两点是不是属于一个集合。如果属于同一个集合，那就会变成环形，就不能是树了。</p>
<p>需要注意的是，如果最后整个网络变成了森林，也不行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validTree</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>( n == <span class="number">0</span> )<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    UnionFind set = <span class="keyword">new</span> UnionFind();</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i+=<span class="number">1</span>)&#123;</div><div class="line">        set.add(i);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] e : edges)&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>( set.find(e[<span class="number">0</span>]) == set.find(e[<span class="number">1</span>]) )&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            set.union(e[<span class="number">0</span>],e[<span class="number">1</span>]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(set.setNums==<span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Number-of-Connected-Components-in-an-Undirected-Graph">4.4. Number of Connected Components in an Undirected Graph</h2><p>给一个无向连通图，判断有几个联通块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">输入：n = 5` 和边集 edges = [[0, 1], [1, 2], [2, 3], [3, 4]]</div><div class="line">输出：1</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">int</span> <span class="title">countComponents</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>( n == <span class="number">0</span> )<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span>( edges.length ==<span class="number">0</span>  )<span class="keyword">return</span> n;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    UnionFind set = <span class="keyword">new</span> UnionFind();</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i+=<span class="number">1</span>)&#123;</div><div class="line">        set.add(i);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] e : edges)&#123;</div><div class="line">        set.union(e[<span class="number">0</span>],e[<span class="number">1</span>]);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> set.setNums;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Friend-Circles">4.5. Friend Circles</h2><p>有n个人，给出一个矩阵M表示n个人互相的关系。求这n个人一共有多少个朋友圈。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">输入：</div><div class="line">[[1,1,0],</div><div class="line"> [1,1,0],</div><div class="line"> [0,0,1]]</div><div class="line">输出: 2</div></pre></td></tr></table></figure>
<p>这道题直接用联通图做就好了。输出集合的个数即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] M)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>( M.length == <span class="number">0</span> || M[<span class="number">0</span>].length == <span class="number">0</span> )<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> n = M.length;</div><div class="line">    <span class="keyword">int</span> i,j;</div><div class="line">    UnionFind set = <span class="keyword">new</span> UnionFind();</div><div class="line">    <span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; n ; i += <span class="number">1</span> )&#123;</div><div class="line">        set.add(i);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; n ; i+=<span class="number">1</span> )&#123;</div><div class="line">        <span class="keyword">for</span>( j = i + <span class="number">1</span> ; j &lt; n ; j += <span class="number">1</span> )&#123;</div><div class="line">            <span class="keyword">if</span>( M[i][j] == <span class="number">1</span> )&#123;</div><div class="line">                set.union(i,j);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> set.setNums;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实这道题与 200.Number of Islands 是一样的，也可以用dfs来做。此处省略。</p>
<h2 id="Surrounded-Regions">4.6. Surrounded Regions</h2><p>给一个矩阵，里面元素是X或O。如果一个O的连通块被X完全围住，就将O全部改成X。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">输入：</div><div class="line">X X X X</div><div class="line">X O O X</div><div class="line">X X O X</div><div class="line">X O X X</div><div class="line">输出：</div><div class="line">X X X X</div><div class="line">X X X X</div><div class="line">X X X X</div><div class="line">X O X X</div></pre></td></tr></table></figure>
<p>这道题也可以用并查集来做。我们只需要稍微改一下并查集，在并或查的时候加入一个boolean 的flag，来表示这个连通块是否在于边界处相连即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</div><div class="line">        HashMap&lt;Integer,Integer&gt; father;</div><div class="line">        HashMap&lt;Integer,Boolean&gt; hash;<span class="comment">//用来记录这个块是否在边界</span></div><div class="line">        <span class="keyword">int</span> setNums;</div><div class="line">        UnionFind()&#123;</div><div class="line">            father = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">            hash = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">            setNums = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> key,<span class="keyword">boolean</span> hash)</span></span>&#123;</div><div class="line">            <span class="keyword">if</span>(father.containsKey(key))<span class="keyword">return</span>;</div><div class="line">            father.put(key,key);</div><div class="line">            <span class="keyword">this</span>.hash.put(key,hash);</div><div class="line">            setNums+=<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Initialization</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">            <span class="comment">// initialize your data structure here.</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i)</div><div class="line">                father.put(nums[i],nums[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</div><div class="line">            <span class="keyword">int</span> key_father = key;</div><div class="line">            <span class="keyword">while</span>(key_father != father.get(key_father))&#123;</div><div class="line">                key_father = father.get(key_father);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">int</span> temp = key;</div><div class="line">            <span class="keyword">int</span> temp_father;</div><div class="line">            <span class="keyword">while</span>(temp != key_father)&#123;</div><div class="line">                temp_father = father.get(temp);</div><div class="line">                <span class="keyword">if</span>(hash.get(temp))&#123;</div><div class="line">                    hash.replace(temp_father,<span class="keyword">true</span>);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(hash.get(temp_father))&#123;</div><div class="line">                    hash.replace(temp,<span class="keyword">true</span>);</div><div class="line">                &#125;</div><div class="line">                father.replace(temp,key_father);</div><div class="line"></div><div class="line">                temp = temp_father;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> key_father;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</div><div class="line">            <span class="keyword">int</span> fa_x = find(x);</div><div class="line">            <span class="keyword">int</span> fa_y = find(y);</div><div class="line">            <span class="keyword">if</span>( fa_x != fa_y )&#123;</div><div class="line">                <span class="keyword">if</span>(hash.get(fa_x))&#123;</div><div class="line">                    hash.replace(fa_y,<span class="keyword">true</span>);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(hash.get(fa_y))&#123;</div><div class="line">                    hash.replace(fa_x,<span class="keyword">true</span>);</div><div class="line">                &#125;</div><div class="line">                father.put(fa_x,fa_y);</div><div class="line">                setNums-=<span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(board.length ==<span class="number">0</span> || board[<span class="number">0</span>].length == <span class="number">0</span> )<span class="keyword">return</span>;</div><div class="line">        <span class="keyword">int</span> i,j,index;</div><div class="line">        <span class="keyword">int</span> n = board.length ;</div><div class="line">        <span class="keyword">int</span> m = board[<span class="number">0</span>].length ;</div><div class="line">        UnionFind set = <span class="keyword">new</span> UnionFind();</div><div class="line">        <span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; n ; i+=<span class="number">1</span> )&#123;</div><div class="line">            <span class="keyword">for</span>( j = <span class="number">0</span> ; j &lt; m ; j += <span class="number">1</span> )&#123;</div><div class="line">                <span class="keyword">if</span>(  board[i][j] == <span class="string">'O'</span> )&#123;</div><div class="line">                    index = i * m + j;</div><div class="line">                    <span class="keyword">if</span>( i == <span class="number">0</span> || i == n - <span class="number">1</span> || j == <span class="number">0</span> || j == m - <span class="number">1</span> )&#123;</div><div class="line">                        set.add(index,<span class="keyword">true</span>);</div><div class="line">                    &#125;<span class="keyword">else</span>&#123;</div><div class="line">                        set.add(index,<span class="keyword">false</span>);</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span>( i &gt; <span class="number">0</span> &amp;&amp; board[i-<span class="number">1</span>][j] == <span class="string">'O'</span>)&#123;<span class="comment">//上</span></div><div class="line">                        set.union(index,index - m);</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span>(j &gt; <span class="number">0</span> &amp;&amp; board[i][j-<span class="number">1</span>] == <span class="string">'O'</span>)&#123;<span class="comment">//左</span></div><div class="line">                        set.union(index,index-<span class="number">1</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; n ; i+=<span class="number">1</span> )&#123;</div><div class="line">            <span class="keyword">for</span>( j = <span class="number">0</span> ; j &lt; m ; j += <span class="number">1</span> )&#123;</div><div class="line">                <span class="keyword">if</span>(  board[i][j] == <span class="string">'O'</span>)&#123;</div><div class="line">                    index = i * m + j;</div><div class="line">                    <span class="keyword">if</span>(!set.hash.get(set.find(index)))&#123;</div><div class="line">                        board[i][j] = <span class="string">'X'</span>;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但因为这道题不是一个“动态连通”图。并不适用于并查集。其实用DFS就已经很好做了。首先遍历边界，如果边界上有O，就进行DFS，然后把这些与外界接触的O连通图的flag弄为true。这样所有被围起来的O就是fause。到最后统一置为X即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">boolean</span>[] hash, <span class="keyword">int</span> i , <span class="keyword">int</span> j, <span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</div><div class="line">       <span class="keyword">int</span>[][] dir = &#123;&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;&#125;;</div><div class="line">       <span class="keyword">int</span> i1,j1;</div><div class="line">       <span class="keyword">for</span>(<span class="keyword">int</span>[] d : dir)&#123;</div><div class="line">           i1 = i + d[<span class="number">0</span>];</div><div class="line">           j1 = j + d[<span class="number">1</span>];</div><div class="line">           <span class="keyword">if</span>( i1&lt; <span class="number">0</span> || i1 &gt;= n || j1 &lt; <span class="number">0</span> || j1 &gt;= m )&#123;</div><div class="line">               <span class="keyword">continue</span>;</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">if</span>( !hash[i1 * m + j1] &amp;&amp; board[i1][j1] == <span class="string">'O'</span>)&#123;</div><div class="line">               hash[i1 * m + j1] = <span class="keyword">true</span>;</div><div class="line">               dfs(board,hash,i1,j1,n,m);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span>( board.length == <span class="number">0</span> || board[<span class="number">0</span>].length == <span class="number">0</span> )<span class="keyword">return</span>;</div><div class="line">       <span class="keyword">int</span> i,j;</div><div class="line">       <span class="keyword">int</span> n = board.length;</div><div class="line">       <span class="keyword">int</span> m = board[<span class="number">0</span>].length;</div><div class="line">       <span class="keyword">boolean</span>[] hash = <span class="keyword">new</span> <span class="keyword">boolean</span>[n*m];</div><div class="line">       <span class="comment">//遍历边界</span></div><div class="line">       <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; n ; i +=<span class="number">1</span> )&#123;</div><div class="line">           <span class="keyword">if</span>(!hash[i * m ] &amp;&amp;board[i][<span class="number">0</span>] == <span class="string">'O'</span>)&#123;</div><div class="line">               hash[i * m ] = <span class="keyword">true</span>;</div><div class="line">               dfs(board,hash,i,<span class="number">0</span>,n,m);</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">if</span>(!hash[i * m + m - <span class="number">1</span>] &amp;&amp;board[i][m-<span class="number">1</span>] == <span class="string">'O'</span>)&#123;</div><div class="line">               hash[i * m + m - <span class="number">1</span> ] = <span class="keyword">true</span>;</div><div class="line">               dfs(board,hash,i,m-<span class="number">1</span>,n,m);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">for</span>(j = <span class="number">0</span> ; j &lt; m ; j +=<span class="number">1</span> )&#123;</div><div class="line">           <span class="keyword">if</span>(!hash[j] &amp;&amp;board[<span class="number">0</span>][j] == <span class="string">'O'</span>)&#123;</div><div class="line">               hash[j] = <span class="keyword">true</span>;</div><div class="line">               dfs(board,hash,<span class="number">0</span>,j,n,m);</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">if</span>(!hash[(n-<span class="number">1</span>)*m + j] &amp;&amp;board[n-<span class="number">1</span>][j] == <span class="string">'O'</span>)&#123;</div><div class="line">               hash[(n-<span class="number">1</span>)*m + j] = <span class="keyword">true</span>;</div><div class="line">               dfs(board,hash,n-<span class="number">1</span>,j,n,m);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; n ; i+=<span class="number">1</span> )&#123;</div><div class="line">           <span class="keyword">for</span>( j = <span class="number">0</span> ; j &lt; m ; j+=<span class="number">1</span> )&#123;</div><div class="line">               <span class="keyword">if</span>(board[i][j] == <span class="string">'O'</span> &amp;&amp; !hash[ i*m + j ])&#123;</div><div class="line">                   board[i][j] = <span class="string">'X'</span>;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h2 id="Redundant-Connection">4.7. Redundant Connection</h2><p>这道题给了一个无向连通图。要从中取出一条边，使得它成为一棵树。如果有多个解，输出input中最后一个出现的边。</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Input: [[1,2], [1,3], [2,3]]</div><div class="line">Output: [2,3]</div><div class="line">Explanation: The given undirected graph will be like this:</div><div class="line">  1</div><div class="line"> / \</div><div class="line">2 - 3</div></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Input: [[1,2], [2,3], [3,4], [1,4], [1,5]]</div><div class="line">Output: [1,4]</div><div class="line">Explanation: The given undirected graph will be like this:</div><div class="line">5 - 1 - 2</div><div class="line">    |   |</div><div class="line">    4 - 3</div></pre></td></tr></table></figure>
<p>思路：这道题还是直接用并查集就可以。需要记录哪条边的加入使得树出现了环，即判断哪两个点在加入这条边之前就属于同一个集合。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] findRedundantConnection(<span class="keyword">int</span>[][] edges) &#123;</div><div class="line">    <span class="keyword">int</span> j,i=<span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> result_i = -<span class="number">1</span>;</div><div class="line">    <span class="keyword">boolean</span> flag;</div><div class="line">    UnionFind set = <span class="keyword">new</span> UnionFind();</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] e : edges)&#123;</div><div class="line">        flag = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">for</span>( j = <span class="number">0</span> ; j &lt; <span class="number">2</span> ; j += <span class="number">1</span> )&#123;</div><div class="line">            <span class="keyword">if</span>(!set.father.containsKey(e[j]))&#123;</div><div class="line">                flag = <span class="keyword">true</span>;</div><div class="line">                set.add(e[j]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(!flag &amp;&amp; (set.find(e[<span class="number">0</span>]) == set.find(e[<span class="number">1</span>])))&#123;</div><div class="line">            result_i = i;</div><div class="line">        &#125;</div><div class="line">        set.union(e[<span class="number">0</span>],e[<span class="number">1</span>]);</div><div class="line">        i+=<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(result_i==-<span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> edges[result_i];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Longest-Consecutive-Sequence">4.8. Longest Consecutive Sequence</h2><p>这道题给了一个数组int[] nums = {100,4,200,1,3,2}，要输出连续数字的最大个数4。</p>
<p>当然了可以用并查集来做，需要改动一下并查集，让它支持对每个set里的元素个数计数。最后输出最多元素的set的元素个数即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</div><div class="line">        HashMap&lt;Integer,Integer&gt; father;</div><div class="line">        HashMap&lt;Integer,Integer&gt; eleNums;</div><div class="line">        <span class="keyword">int</span> setNums;</div><div class="line">        UnionFind()&#123;</div><div class="line">            father = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">            eleNums = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">            setNums = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</div><div class="line">            <span class="keyword">if</span>(father.containsKey(key))<span class="keyword">return</span>;</div><div class="line">            father.put(key,key);</div><div class="line">            eleNums.put(key,<span class="number">1</span>);</div><div class="line">            setNums+=<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Initialization</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">            <span class="comment">// initialize your data structure here.</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i)</div><div class="line">                father.put(nums[i],nums[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</div><div class="line">            <span class="keyword">int</span> key_father = key;</div><div class="line">            <span class="keyword">while</span>(key_father != father.get(key_father))&#123;</div><div class="line">                key_father = father.get(key_father);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">int</span> temp = key;</div><div class="line">            <span class="keyword">int</span> temp_father;</div><div class="line">            <span class="keyword">while</span>(temp != key_father)&#123;</div><div class="line">                temp_father = father.get(temp);</div><div class="line"></div><div class="line">                eleNums.replace(key_father,eleNums.get(key_father)+eleNums.get(temp));</div><div class="line">                eleNums.replace(temp,<span class="number">0</span>);</div><div class="line">                father.replace(temp,key_father);</div><div class="line"></div><div class="line">                temp = temp_father;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> key_father;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</div><div class="line">            <span class="keyword">int</span> fa_x = find(x);</div><div class="line">            <span class="keyword">int</span> fa_y = find(y);</div><div class="line">            <span class="keyword">if</span>( fa_x != fa_y )&#123;</div><div class="line">                father.put(fa_x,fa_y);</div><div class="line">                eleNums.replace(fa_y,eleNums.get(fa_y)+eleNums.get(fa_x));</div><div class="line">                eleNums.replace(fa_x,<span class="number">0</span>);</div><div class="line">                setNums-=<span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(nums.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</div><div class="line">        UnionFind set = <span class="keyword">new</span> UnionFind();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> e : nums)&#123;</div><div class="line">            set.add(e);</div><div class="line">            <span class="keyword">if</span>(set.father.containsKey(e-<span class="number">1</span>))&#123;</div><div class="line">                set.union(e,e-<span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(set.father.containsKey(e+<span class="number">1</span>))&#123;</div><div class="line">                set.union(e,e+<span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> e:nums)&#123;</div><div class="line">          <span class="keyword">if</span>(ans &lt; set.eleNums.get(e))&#123;</div><div class="line">              ans = set.eleNums.get(e);</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ans;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但其实我一开始就被并查集给限制死了。这道题其实有更快的做法，就是先对数组排序！代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        Arrays.sort(nums);</div><div class="line">        <span class="keyword">int</span> longest = <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> l = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (nums[i] - nums[i - <span class="number">1</span>] == <span class="number">1</span>) &#123;</div><div class="line">                l++;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == nums[i - <span class="number">1</span>]) &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                longest = Math.max(l, longest);</div><div class="line">                l = <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        longest = Math.max(l,longest);</div><div class="line">        <span class="keyword">return</span> longest;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="Accounts-Merge">4.9. Accounts Merge</h2><p>给了一个accouts的list。list当中的每个元素accounts[i]是一个string list：<code>accounts[i][0]</code>代表名字，剩下的就是这个人的邮箱。</p>
<p>我们的目标是合并这些list：</p>
<ol>
<li>输出每个人的账号列表accounts[j]</li>
<li>如果两个人名相同，但账号不同，这可能是人重名了</li>
<li>一个人最初可以拥有任意数量的账号，但所有这些账号都归属于同一个人</li>
</ol>
<p>输出：</p>
<ol>
<li>[人名，账号列表]，账号列表要排序</li>
</ol>
<p>样例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Input: </div><div class="line">accounts = [</div><div class="line">[&quot;John&quot;, &quot;johnsmith@mail.com&quot;, &quot;john00@mail.com&quot;], </div><div class="line">[&quot;John&quot;, &quot;johnnybravo@mail.com&quot;], </div><div class="line">[&quot;John&quot;, &quot;johnsmith@mail.com&quot;, &quot;john_newyork@mail.com&quot;], </div><div class="line">[&quot;Mary&quot;, &quot;mary@mail.com&quot;]]</div><div class="line"></div><div class="line">Output: [</div><div class="line">[&quot;John&quot;, &apos;john00@mail.com&apos;, &apos;john_newyork@mail.com&apos;, &apos;johnsmith@mail.com&apos;],  </div><div class="line">[&quot;John&quot;, &quot;johnnybravo@mail.com&quot;], </div><div class="line">[&quot;Mary&quot;, &quot;mary@mail.com&quot;]]</div></pre></td></tr></table></figure>
<p>我们可以看到，第1、5行的John一定是同一个人；但不一定与第4行的人是同一人，因此这两个人不能合并</p>
<h1 id="参考资料">5. 参考资料</h1><ol>
<li><a href="https://stomachache007.wordpress.com/2017/10/23/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E9%AB%98%E7%BA%A7%E7%8F%AD%E7%AC%94%E8%AE%B02-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/" target="_blank" rel="external">九章算法高级班笔记2.数据结构（上）</a></li>
<li><a href="http://blog.csdn.net/dm_vincent/article/details/7655764" target="_blank" rel="external">并查集(Union-Find)算法介绍</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[算法-DP-最长公共子序列]]></title>
      <url>/2017/11/05/%E7%AE%97%E6%B3%95-DP-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      <content type="html"><![CDATA[<p><strong>子序列</strong>：</p>
<p>有序列$X=<x_1,x_2,...,x_m>$，另一个子序列$Z=<z_1,z_2,...,z_k>$，且Z是按顺序从X中挑出来的。可以跳着挑。</z_1,z_2,...,z_k></x_1,x_2,...,x_m></p>
<p><strong>最长公共子序列</strong>(LCS)</p>
<p>从两个序列X和Y中，找到最长的公共子序列。</p>
<p><strong>思路</strong></p>
<p>这道题有一个非常巧妙的办法。我们先定义$c[i,j]表示X_i和Y_j$的最长公共子序列的长度，那么：</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-11-06-14-01-29.png" alt=""> </p>
<a id="more"></a>
<p>公式没显示出来。截成图了。<br>$$<br>c[i,j] = \left{<br>\begin{array}{c}<br>0  \text{………………………………}若x=0 或 j=0\ <br>c[i-1,j-1]+1 \text{………………}若x_i==y_j \ <br>max(c[i,j-1],c[i-1,j])\text{…….} 若x_i!=y_j<br>\end{array}<br>\right.<br>$$</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LCS</span><span class="params">(String[] s1,String [] s2)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> i,j;</div><div class="line">    <span class="keyword">int</span> n = s1.length, m  = s2.length;</div><div class="line">    <span class="keyword">int</span>[][] c = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</div><div class="line">    <span class="keyword">if</span>(s1[<span class="number">0</span>] == s2[<span class="number">0</span>])&#123;c[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;&#125;</div><div class="line">    <span class="keyword">for</span>( i = <span class="number">1</span> ; i &lt; n ; i+=<span class="number">1</span> )&#123;</div><div class="line">        <span class="keyword">if</span>(s1[i] == s2[<span class="number">0</span>])&#123;c[i][<span class="number">0</span>] = c[i-<span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>; &#125;</div><div class="line">        <span class="keyword">else</span>&#123;c[i][<span class="number">0</span>] =  c[i-<span class="number">1</span>][<span class="number">0</span>];&#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>( j = <span class="number">1</span> ; j &lt; m ; j+=<span class="number">1</span> )&#123;</div><div class="line">        <span class="keyword">if</span>(s1[<span class="number">0</span>] == s2[j])&#123;c[<span class="number">0</span>][j] = c[<span class="number">0</span>][j-<span class="number">1</span>] + <span class="number">1</span>; &#125;</div><div class="line">        <span class="keyword">else</span>&#123;c[<span class="number">0</span>][j] =  c[<span class="number">0</span>][j-<span class="number">1</span>];&#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>( i = <span class="number">1</span> ; i &lt; n ; i+=<span class="number">1</span> )&#123;</div><div class="line">        <span class="keyword">for</span>( j = <span class="number">1</span> ; j &lt; m ; j+=<span class="number">1</span> )&#123;</div><div class="line">            <span class="keyword">if</span>( s1[i]==s2[j] )&#123;</div><div class="line">                c[i][j] = c[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                c[i][j] = Math.max( c[i-<span class="number">1</span>][j] , c[i][j-<span class="number">1</span>] );</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> c[n-<span class="number">1</span>][m-<span class="number">1</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> DP </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[进阶-ladder]]></title>
      <url>/2017/11/05/%E7%AE%97%E6%B3%95-%E8%BF%9B%E9%98%B6Ladder/</url>
      <content type="html"><![CDATA[<script src="/crypto-js.js"></script><script src="/mcommon.js"></script><h3 id="encrypt-message">Please enter the password to read the blog.</h3><link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css"> <link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap-theme.min.css"> <script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <script src="//cdn.bootcss.com/bootstrap/3.3.5/js/bootstrap.min.js"></script> <div id="security"> <div> <div class="input-group"> <input type="text" class="form-control" aria-label="Enter the password." id="pass"/> <div class="input-group-btn"> <button type="button" class="btn btn-default" onclick="decryptAES()">Decrypt</button> </div> </div> </div> </div> <div id="encrypt-blog" style="display:none"> U2FsdGVkX19n4n0VUtPD5cmNwpkKMc3wNuqAVoP7ZlEoP6W7s6USKb2IE4cR5Tf+Z2zLW22/PxAVXs51FOOmdOeKoIr5h3i6aLc4zizFXpXqlHlpVxIupo4dxwWs59pTsSsTceX5lK21t+3rqBJABpMPm+ByzuSTJfwX8ZT60JktAqGRs2r3+kAyXo5w/CshHsgdLHLJz0/TLkIVCVG+z+VVdv8P2xm1ajly/NyS3e9JDCJUsItdoIQMhL9a98n1ZoKAgc6qqhspkoDbuVEUx0P4xt/AcYJouNOFKmZVoSLPr9hAYD9m2iY5XRmIU6qL+H8Eiwi5t4Co3i0vOEopvXuu1aGAzHFP6SgGQg4ma2wIbW9PIIBTNX44/AmC4qyyYJXs879F1qJ5SlOEUf+QoUz7ZabX4x4bErlb/CyRXclot6IQWUctEXbvxKxWl8+/so1/J3SnicSGiRIbbODtNLAgkN5Xi1VxI/NGbGvlP2YV/9WR90612UXgMEiQwC5qy+Ci00liEwFR3ERKyygtg5XY6NL1ZTwpLKzW4r0sQkQjpXGncPSt1EPcus1NcVIyDOXoo6Zhc5o3/AFB3r9FeVoy4l53FqMDP8ft97Nw3XPzMBB6+JnpCq5KqSdo5Hp1guuxlxGq7CqRXi+CkJypJUFsck+Piz5dyZSdRCsqDteqsVhvZjJ6YFiqk/tLYT914CuPZ2libS2reZgo8cXpRPHWw/mh+m3Z+bEnGTxeG+gnHxGecpna6Ds4wBHHDrCY6K8giWkry4n9Hun43JUejUjgmd0zyfjcSozqpHDG8fPJFV78n/4XdcegIwcX9JyKoQ5Ax4qksODsiVlpLvHJfLRsNutt6NFQwHK0REd1ssgW1O6zhzxqtUTExZ9iCsrRr5DKYA1AnzWB7hQKzvzl7t+Y3xfpBGf/ttBFR9CBqtoIRBj9PUCL71gsG+sPrHi4m3VYzvRyQri+vZDYcRLfzZFu/w9IgbuHTaOAt7Aq/Ryzl3K6O67PHOMda9xmcTNwpg7xa7KXJTir51+VyYoqIUgkz6o7E21cgqgrqoY5etrQbK+8wlGm3q55CdsTafHxoO8OEpJ0IZs4sZ7jZwyYX9aq1J65M0UtBmtH61zVuwXWwAAIB4N0Sp7gkh+aC8Sm3vWiJAN7gzTtaPvUvXAJXUP33wnb6mcrt6z8mVAw9UozvqqR0w1yotQ4FQqP0AQXnqGmEKZj2h+uHgErDT9yFXJ/XG16VnK6xhUL/vkakNf2UtF8tj+XbTBq5fWSlCmoAQJXzoQtu3o7/0KbG4vBBt6NM8qG24gfrSG+zov84vT2IQt7honcSTvDTK8rDRrCdy/BRTel05fwt/jLYx9db4pQRtCB077/zEO4QwsoiGDAOQvJhTJ8US5CTq+/wRIaDCFC2sBXqUFnGdZe8tQoyXcSkoFVvfqlvk40q7njx6OtsaK5MpMNL7qy1utQykHhrCCU61mnB/RYmeErPG0YFHCbzN+aWReKWD3yCrr8Inl+dW/mE3t103a30tNAK0OcZGeMYBuP3Za19ePf6nB5VpIxxZEscZJr3oeUrfq/mFnmQs6TnRMEzbqJAVOvXs5LxiZoqYUX81EzT8mkr5fvnN8U9/T11cLHS19wwBdo2LzmcQI3L3jSUyfVTPaciSqzNAOzzT3ISfRlVQj9Zx6YhjXLPdv07lH4/6gxD950j6VEh+GKPD/Yibdb6f63iOsfOnnhHbqL+KPCeb3Ov1U1w8VCMDVkoKesPxLZZOp24eCRcrUmkdLrk0/b03gQ/AMJGYBOpqUJZF+Znw/57VkibZk63X4ibanfq9NuCC/EEUZYzUseOhxliS5+rILzYdE4Y3ieyMdmqf+5cLcL01q+v+9RkWcIJW0pvATGNOSPg2XYkrqHMdw3pwEczsGiFIhkdKeSvuQDRD6lG6S/l1EomIr5MV4RnE/oVOoJxcnYlHBjwf3BPhNbqspCS0eF3ugoDunW46F/ccMKvt/aVAGJsuNF5f5a3m5NQPk7WFBQRfA6mKGBFLUOL5759NECUCx/N2bD4JMn56SHseLdFIAGRMI9AbFW+8KZYNZSPmpsMqBU2yNRLLQLQiGR3rto/AcOBJJo9DW1557/VSl4NHiV10Fs6AUqD6uXQ3VfZy3sRsfe8SPJ6RPH4tMMrxsdU+kST8UEUpl84s5AtDnIwJ+LCimQAX5zxOUT/bCRh7H2w9+5Z7tDrU69tpOWyn6neT5wsRW0uEl58c+bqKDc/Tn1AKQktMohfKkdo0+AuIRNyfwmT2GbwjT7IF/wqaO4SA0v6kTDzsNOkEDJAbsifBHU7qD7AY4a3wSkBItNJuwlMx+jWAgfDfXoL+eYMORn+6euvQuZ5v/4w9EPAA/sqaDq5M1EdOzno45F9ctYqhHVwEfnuox/dalKUJQwNMf8EfANuVbYWUa85Z6TqnOS4pB4Cu0WqUnF40oMsLFIB1XcxrHqOBN518fOXoGbFp2DCzk+50Jgs5OWVCLmRa8sBYsWAo9wKCiPVWOfb9isU38jUnZ/e/2tNRc8yOpWM5OCjBONcUQD6Uscl3OUUj7Fu83nd3dZ4kKhiIS+S1rnzj0vut+hMLURVMajOJqD/zR9ezMXPneNug33/r1WMkzO+2Lr0cLaXnhQY6w67Sh3YbVKUEcyn2Bns6VvH70JNOB8ca3DM5DtdN5SAGHZmClJCTDcaYyZjBJAuR6nWmTzkb6QCH+u+yxtY35jPOxmgnOvtD5JM6dG/4Z0vP57QgmN5H0AjxVew4enS1KsYL5RBVToJiCJYq0/QlBO5MXVJnfM6iUgFCH6rEY07wlRItVuSLiIKE2QWp9l2nO/Coa4/VzWvmBZF0ypm4Mk3aBqp8agV4Rrb0zvZvoon1Zlt6xRDmrk6n4lX7g60lMSDZGR5NT4QPm3pdtNwyXMTZWD9xvhcHw680oTEvJZCPAlE05u0foyxVkYdpp+rAPw/hnSAyDSzwAE2WFSqeJUoGy2zv7NqPnztJ9zA4LoCbwthIMJGd9TQlHzbLsvdQv7WuPBY3qruzzXnAI4cQVG71gRobuznY0jxNyBQMKrzYkjoonbQj24A63d6xpUelevu0rijZqJh2h/mx3zN7g9I5nwBp5lh8fJzBb+3zW0KWi9soBU0iDNde9jTqOGvRcvTIp0q2bNuZmEvYZvXE/TeTt3sZKKlcjkrQpZb/VWIe5pHcwWXfwC2/NTEh202rKmI8L0SQKIHmq0KBetN2qnPErODxT6T0wPU4DU7JNSHrj01awnRvGXWP/oNvRAwDraWvWNKPsdXqDtxdHaBB25AXOFA40AOzwf1STxthHnVbYTaHwNo2nG2u/mETcsI+rOcl9hRQjqrliZyARJKNUeEflQpaNINMAIHaB8HG/+NTzMflHSy3+ZUg6FXrfzOu/TcnSsfhC7hD9vxg4Uznl/LfzrFDdEJmLCOgw8YKO3ew5MxL6KglqRZOCxPWRQTbaW0v46BtavlAHUEGtKn6zDCcfV2uOQeFrFNYcKbPajcJK3dvtUX/8M6JSmdVVyk97Qk6qDCUD70P6VZLRN5dkiPacWETMR4zjZDe/owIdVU0SIpQ/lQAlyAkouNJQngpNzK/aM3oZPW3xxX7tLrMdv5BP202Nms4S5lHhhDLGm1x/iH/C180E1drCneEjV+AA7n4e4YVrgkWo3FJHK7DGZeo3AuLoegrHH+fU7QTXu5j+/NE+X+3kV/yQdZvYqSh9P6RLbfd3oJkIyMOE5vurIrbpwCfm5uoQEucXMnHZGhJ/u9WGgGM/ukPmdap0GiBiawc7YcWIFtZdQ6kQsB+a4TYQxy22mirWO3aH+vZTkvu2/swxhB+d2ibSc0g2oNfvoHxeQEk6N6CNRVP+Xtj0O/V0bBOmlOoK3L8LMGLDUYfBUK9FWJVcEvUokO/GT1QSQCBCCe+pBXRt8pA5G/sgzLuSXKUAVrYrDzFvThHk9mJK0pRkL9qEpRXhsUckcX8E7bZz+Uz+3TU/is0AR4RuftN45OZEHbmc/dEiyVpVqUd3J//9abiuBzGajHepppUBc9VdyrksubRlSCbY7JRifk3T531TmL3WuYIbKECYf80cuE4QWVlOGxd+SG4PuEDuuiABDV7cx47zSOg1J3tO2nUV5vfHI9iK4z0TFdrMNrPqWvglQLzQJL9zP9BCY19/oV9Zav9XLe6ojXp+Ei6hrzgqwZ1DBCgFvH64zJ+R3+evMbDqHA123YUl7ljMwrGdEYzZorxf3tDfdCXUMH2KsrfoHmkwsMvLp2WPUYgPJshnlkpUKKBkXr1naFZ4mkPE5mwjH+HrpmpomNYFZxgbMzG8GqMx5HPeqXlWLUxr80cFb5fMt/TL1vt5oRb5Wuthosgi1Euu4JhJRpMc6KAWIp+TtI+hCPH8uLzsNLD8IcM91gYemFu9SeFqKekJlsp4KXxi1gWrX6ZdmFsqIsetz0YSZdsytROxCK825etaPPk4azydkL4TFyZIweoFk2kDdAUX0put8Qk3b4caG2vvp21QxxOioB9Ovsf+8ktNnrEtGPGfJmdJ5AsVZvz9zTKZxdQ10mgHQyFleCwbPNlxqJ6LI2OydDEk4i+IFAtfejUULJfjVzOcB7PMGeyr4um3n1Jp7yvRVmdpE0lhal7pB6Mz0x5F31D+Cdm422qfJX+fjBed250BcHHggVA6RAu785azdEtRNhlhRnV12bfL6pBjOiZBAXQ/9FEdccf4VGyLE1zWhVipBN6II4TfpEULZ0rd4/yGOc05Ez8VTaf21aOuY8MnTcFStwhZmDstTE0z52PL/CKdqORC4W3yBowJqn+cwM0pFyejQKkq3SLSycGgrxJI5Rt6unsW0+SbcuFXyDxfbCZvWE9L/fPPNVda7dY9l1lNbQoCVl/IbNvqj7ltcRTYAXPGQhuIMpyehud6p6DogZyE8QyDFYoCywieC3CAODVtbsD6s8Oy0PxlJ1WJbmY56PwQaCtM/pWMYsVrj+ZDBVIJmCKGv3ZEGLuFPXKXVhy5lxOyCxGyMJbxQp6dpK/kyfOZTKjr+hQVRbvBzmL+nPDwV0Wkdx2OfPNIqeBXfsnLKxPk4xN4wdVh4HKh9eVEhbMNd6FuGLzs+BuB1iEd9msalUQULuWZJSaAm8RrM1m5t2r1NudsDHbqsTJaoAwBUQjsgmnNMLgFTXtr0nXOmjHYUXho8Qmx92Ls8mgWwYwwTykFoqj92KqLUXiwWGNCk3lj/3yM6QGGZW2HKTgQb+AMxFrJq8NEjV9wS+2dlkYUJ2RZrtiTJBPIPlzHDmvp/NjxL+274pI2VG2YgdLSzeWIVW4iM9zqxB3Ji1/4BAz6JsvSWdf6EXcmhQjNc3gTV5yvCOQq5KDwK6iUrwVc8hQSSvMTwEfSBDBYeh9IkIO2SnhQh1LBM8YfA/BkLo9llcscMOeUqTygX3Efd2y3ytidhuz8Ughx+n91sWcyU+kPjTIVMqstI5rwMVAywHA3/bTSIBEqw3W3EzPBHTCqd7/5d6//qnctqOA15IunkXN669MMp8V+3UqSdzyABTF26Fs+yjC9zrxy+uxRG5+N2NBCKLJWGyvBVaR7/h9TwkzOFqV2loaukHF+ARJGmzkI4PLaHt8F/bIf1MUAgD9wT0RD8uEESMz5NrTQKOWmuqYNjqBYEKCf+c4c00VGo9ki4e+UiVE8EcbsrAH+Y2G4cfnml8iUMEoEIQBLNyLeqHQ04D0NgT5k0PQpMX/PKB6L6VjbZEuPrc+yshhE/HNAbp2dABFs+FIzovz6kH5SN3RnpRQUPkkP8v3d/JbJoScTcxL7RAR2sdvO40qilGcjS6fwrvOxiIRLdTf5GvvhTfEFP7FJJrchdjXOZaixybftSMSyM8Ch1BW1N65J9GGrLSFERnt9LaM6k/W/58NFssZNRU8Phy11xRFFXxt2APw+giBSiDeE/mBQF2Dpt7qSK3Ze4MeObKpsspPrHZckFrdwZcNkM/0/GltYCao/6WiQNStrHEjAV7BEdtYOHDLpo/uPlIqQcKIb7rPKQQ/VVFcT+cQoYCc4I7siLQQa/PVyU2xIdG9OIdBPgw/C4gFa0AKrnP9Wy2w8XryIoJ+rvz9tdI7sUM3uo5Z2aAyS6Lw41voacOrKQVLEdIfmU+pwJR5HHIoUHpc+adooemk/1nMqLeCwTT0MK34exwHV0xCZE+gEZSu0VeDoX7O7BUos3U+bvmqGbYMOJ3G72pLffnqAZDoY5a8I7htidm7mCJ0UiI/0+BrlfrZTrl9ldiYnWg4vAQlLrt/ntPWacEP+ZP8XJCMCiQDKuZgwZaJtKCe7EJFwj65YcRdyyXjkdHyr5+JRVG4nAj6JjuFaL9ZDFnUwU5UwGK91laE38NYF7lnH9KNWuhOsbpLMy9eBHlNrlFcWqg7PMey87rWvPy5RtkDRWcOXcA3EeRRPq37epJ99+pPS9cEBEauldaOB4+097bEynJDvuCYidJ+KctN1vkXD4CjQ9mgBoZC9sG8V+l4EIVNKN/srV275NNi202vE9uQyVY3zcKC4/klgHbJrdzFtyyBg/Yy1XTAImuZs6xEU74gtThGk/UwLh+ZSI+p+JV8mUMYPnQ/SVx5C1nC5L3+ERH8VSbnX2tiCXKo5xHTbaX7+Nph8vU8i02lFaJo2SnJwMQ3JRbmztI9/fpIBgOgekSjgKh7j1ocC/1HEtfo4u9wBr1fkjZmKdrFWk+J9ban6/swt/JSf4GpulyLQ7fh5xrqTD9ypvpohxRtRqbBdEwuX9OTKs3ScXdSDHTMP3qDSTEGiOmLgEDv5i5w17+3g4Hevgq0iT4dikaraHmCqSEijJXDqtb7zuZgxwqq2KpdpJaBT3h1bSLtf4+ldNzqhDhBhJ+sf36ZDosL7Ji+Yv/yyPqZLjqgurnqok8j7uULqyUi3JR2dHQnrsLYMUs1pLL8hSHcArLwVBEZHSP/FSAdWBV1aASDoqFYEygG8EpMrSLjzWGtKUOSRoKSOE5FdeNit+qRAt2E6PNCxEFmQOH/44DAeW8jw9dxnqqqniHkk0OCs0Fres9tFga8iiIGFEX7ye27GJNpd2nRyniw02yPiH9bRSKJsQLIW8l2BS1xrzFI/0YxY6OWbZhbocZJzu00e8CI/uGw7V/oUTr4k8vofZKQFUCnmGEZsdDVZCLRU/g3cZAm/B0xuIe+c7+lgWItPAQWj/1bz5rn2lIs90Jkp5wc9zwxLtFN4KhHwY3btls6WcZFIfvk8ySOpCH5tg3IEHO/slPeyJVLe9ZX2h/1bvQXT9FiuXuuuBmE6Kd4/Ajgzxo4LXvEpjvHJgVaXhyBzFPbZRxQsgC46dm0J17JkwvdY683fqsMLHdLQoBYZbtYP/3ddyb44b2i1Mske4aWOMw5IrH12irWF2Tuax8BWrN0Iiy1p4dQz1kghs94dJiwrqlYfmshVZjrKDPBkYrI51iXNpX5KGvzYKRrBSLAVkEZM6ZoF8vsmK/YtlXktF0po/8YGtPAlCwQr3PUZVF3xAinlDE1rRgAnM91XAjEIm8TMKbaIPemaqr8hhSXkKFxxaJw1XQC786xDXm12GAZY9Dy4Jnq86RA3KxBHhjGKL+3yyUiokSmJSnCrJYiB6JrbWFrn76mvGN5tA1I0w4unaHBe8gf1PGGX86L9qGOregy9bQteYSRz8CH606DzCNfNH/R4cRzCZ3FF/JrXJy/NMP8wePDEsnvdreS8lHGpaGCbB5jPSmEmxf1tIXP5WTQbP+SF4/DZ/97fLXDQiFkDE2IbaH49mmP5ME+WPUVoS6s/SGFssG6NQ8oXQG9HZs2WhscM7tT/5tEV4Jj/FHYfPmoIHNeb/zzhRRk/7UG7XRBhL6ssxBglLcI8XMI7ok9IMXt+RKzn3fy1NaeJOMOh387Od1o2HcaghLQdKONoKlpVCGvXcluqsdLS+mlh1vdzjpImvKz6IKaQp+n1xikbM+N7VkGsm0bnPHt5iB3J52/z2A7EmKAeQkvw91Yg1IycdjqsZqPsEqa1DfbmVmtSvoId7L/fRRzacqB4gHmgqJPtcvLqksGyzKIwULkY3c2m2OQ514YmM4H27ObrTUJISa+Fn/mnw9sh++bMtpfWZ25IxswWq6gJVtVGOgm+kbJ8iTCXtKMeM4W3ISNkMno9XCcWf9rZJFzQozAESqj2Mo0i4+Eazi8XwDgiHXlHRE8Rqd1JIjj6X/s9YPcTDCGHBmGWOzU67xg4Cwk2Zp/ZBxsO/KKrKMz0VxDFwXReRYqCDxKp5zRXx8Gm6avKpX996wuLEA4hbJZCdUq059wp4xf6HqaaGqhp5qIryDflCn4mA0TxXrvliye4CpiIS0vpzZKUQiMMGY7+U90tm3vYr4z29jojGNiqq/jDu0a8Wq6PTllsYFmhv9veTAt4oDdcfFpslXRcsCBXO2inDzPNOjDzu87iPdN3LkC/duuTfrEfyq80WlAhWVeS3nTKahUtFZy7yd0pzXeRHOxi7+fp1HGABPblOal5/0Vmt9hrGe7qkLkvpsLPHw5nwhosQdhbJ+y89NUehhSDq/lUDIgDBVx5wJF6Rw6d4gQ3eOmuqgJOf0pYRZgmOQ1wyFAovaVajI/RiS0CzvmRF79zQ/X++Dec/QwuhCxf4SoYmcQghwWLhbHZ82J7XZlOqTplwD7lEGlfDL4C6Wu1wrAiXNNmrNlqOYzVD+hQmseCxjei3s8GYWjGt+7TQ9f142lHqdXrdiT5QppPcLbSQR8r1QqYZP/b5ylz2wTkgII7wakw4x6uHaujoymYNmDFEMLiAX5LM/f2azEcR0zKgwAM5jZA9akettmuKGE9hKuXiavmzBFkExJufgootAOUWmNVNVTLIpX8rvThWwIYnARplC1UL9oeLC448Fr5+i89/pXQ8dX3RzWphp1l8+NE/odVIMNpmfhAG1haxqLQTN7MquQZlD+dEXcKRcrX8NQjgWLXAefHnVyLt0chW7csSJ7LemDPdjrqXRITfg6V7aCl6U8+I45guPGRYg2d0pflY/NH9Yh3okY9YnytKysxxK8uWydT6q3/1BAbUWPs//lgf6Z/PO/CctTXBYE/flHlNddt7LNUe5GxO4J36AlyHagkTjhezVqT96bgOfu5rGM0RFvgdjKuNWMze1dIUeoH52peVxs5AjYbo/u5Bhrh5OLD+M54amV02kyPfaYFZrwL/sj3v+F2sbtjVHEGAzlMagQi9byxbPuz6srhBeU6DAVbMVzUyuzY5B8jIlNQmH6h66vCdV32FqUVWGn+DOIEAJTw7To0oThKDCW+tyuuj6GumFKFe0bd+GhzYsx/Qn4S4oNTKSo6/7SpImSGn0irs+IyuqKZMrpbGcda9ZNtr9aiikGYKkqVBRZIM2DHeKZvgUVVWaiR5IOYqDui2RYAjsjFArlCp92bwjg5gHEu+hrV2YxnOmjANlUJShYnogEffaRLTgJxGMRRhErDBwavibziMuA0wxtekYKI9bPijcXLnjb/DOThKdKb1wm1g7uewheaPODsRIosIDPVVAq9tIeknQOvoBAWMuDnhbX1hWER4XhMulZcHkqo0kG+KRxALy6PYvWxF7DUgO6xHS9N0iD1v7j7OIE4X9kJ4RT8TpkKHiuBa9iUjO6BCHUDkRPqdFyPsdtRuAwTbE0dCVhwM34+by1RzcLAwrNkmZZ2ZMK6MEJE0wDz4puInH4kta3wTTJNY6s3Q7oaVe3QbxyMFgNDiyZ6BOPsL9paY2rP3iKIH5uNYYgj6ph2cTTMHaOnQVQ3UzSawu7VAXZSgo2NdEWVEH7FqMHsHZPJTR9E0qShqWtXlGvRp/FQbenE2cb0fw+QYu1BeewWY1qsGanBlQeHQM2f9d0r1bao+ifmKz2HgcyZSpxAdzqZ2knpnIiIai6TcGv1hymnl888sEGPJ5PJFUZYsutFBRbW/MCDN8DOi4sHzwFG6a1mBV+j7ZYTwhlmQHwm4m2M1t/7G5tHjAgYda8gfNo9CaX7eGrH4PMbjwD5BqiA9aXrGDruRIjuOMmjRFi7oBiARYYviG/s3FrziNbe7wSzu/omvUzGmcnL9sJkAADw4Gd/lEMMdeqqjRUAKMOh7jOfSpml0Sv+WcW6zh9HRcaQY1Xm9EopzVZ+pnGX+lOFDTZOyYxLHw6TICpTIl9Fg/SWxFkD3n0bldvLwqyORMaN1bcsGrqy0D0UmKP5mrXjoEhVuY+vhnQgGpXJB4uQxpudOJhF2/BXgqEu3yaoBBTtZUNZ1uJv/AdDFpd7U9vgPfz6CxVqUGFzy0e6CjtS7bELkO23J0VHVkt5/iTBUCWH07t7roDEq1QQ20feVezzof5LQGi86eoCPPTg6hoXOaMCtChJ38jkw2TUOPZSl3OMXzQneR5+J875b2na5Ar0fbMVeoeyO6I8egKFlsO49GRNKOJJZT6m7SM8H5TFCTyjldaz73mbzGMfdNjDm3dboDKq1DdQCrjHriFXVz9+/4w2G0ihAlVB0288y04uPfcJw36euC4cImMpGJSJvMfEu+Kp3r6hW8H41rBSPpUAyXm2Sme+5+SS9dZiI8gmW1LTkfGMYPS3J6oJtd4eV1hqMVPmHHAD9MMN+67pmZvQIqnKE/TjQXpWiYD6e0x7TASGkcGM/66pGiGN3RWpGGnsJkQXBuShKc9oEExw7ztvxQfScf79l3J/2OxLul707Pelw9jLVZEZ+hVnNf516cjz9gti+78Q3oef4I/k/KQPNKldnO3OZNuBDGrBSsBRURF21zjv3OrP+qPEDSqmNPR4evbCjCaamrrDk7khaw/akhUm1Y8vuv/dFS0/ehTUvOD/QezzKSSZr1p+J8NZ1ZGmsVuvarofMqG6m9pshhVypANqXBAeaj+xQmI5CvdOwJZppMprug1/39dUFIxrjxlPTicrTez5k6UtnagEWAPQnH2Ne5mXct+7DcEIeauSwMHDv9rbmB3nOzCCgJ5C0AM5RVX9BgNb0VlWNS+iUuxUW501DarIC5xSvexe0TUQfAKlfOkiQAbin0p0WGynjfzgIQkjBymBNxbfmYsWjP57Sr6l1Sfts/FZGLbAf35rhAV5ovaK+AUOXI0r03JvSqGhLaeAO6+u4Jn+RwcZTaw6ay35Agkm342bf5oR8+ZjJRJ+pqCQ78mTcTHXiJa6GIkwLETniG4hf65wuwZCl5EDATuwTlNtdwhUJZSyfvNyUVfvFHq1Uy3iw4+S4LczgbeXVhnul5nRa07iqASu9F0YWdmeqw3SvTl60c8AghtDSB7/H5kt6nBZnVpuSqtInMkz/PjvJWdR01jQlHD0NX+b6x7w//GIMSZAH1S/F/QN071XGG3fc/twcPeKcgrf9I7dJ3X2vpaBnEAsWvhDKp4k0+R/OwhFkz/hXgu5ms2RUECIW1/rnLBay/NHAvTkMekUfylaie7PG+Cjl5WR43JcQYd1fLl403FnGnx0pNWRSg1fU7Jd+H/5/c0s8RDJj7CBBAhJBqhFxoyxgnOpstxm6VWYBSOkW4LqfSGuGtGs/KR95jZb4Fi69y/HdD2ajc/oZYAHuw+4ArwEy/k68Fe6rZZ0p+YeKLlN+STJJpcTdEpg5Du+K8wa4UZVIs52Y4c3fv7m4TfaGJmfG+GYIncHI6OYYqlo1McTuvjBmMnuPidtEIkXbqv/8L+lOJlv8NOh/uVrIYvxzjE9ruNcwjdqfyEffnoqC5Dyx3epfvFFIzU+Pp/Io0ljUc697+vJ9eMCRFb8eYOzWeXgJj/K5Oi3YROSps4GQCWlGGh8EAIcZ8FnpxhavozqKrjBUaqwZ9L2SlScE7trSJMHnZb1gUJN7OT5gSJIJi4N+2dv26NlHjlYvYfdWFETbj01yYWhFlNTo/knVPV4Wqd8Ninca/IFUcQZT/BQrfTWsxk39UQphObU2eei32CjAxR2sH3Gjiqw5b47S7b8QlU5GgCJPM8akUt66LoSKEsqzjI51d2gxubSIQS/R1vw72c0+caizk/OTd90hTW6kdpR+IE+W6u6j8yProhdFMvglYJeSJ62nTL8Ymo4sgLNBUcbSn+hY5QmLk2xLCSAS+SVLFoiHwLCxC36mrS26B/71JHdXEIZW4PTR9a+qy+C+HrmqsvYFww8OKHDIyQ35NY3eRq/lY7XiupoCVCrXneWu7sa0r0x1aZ8KGXE5S63xy2Og6+0DiDgLEYL/fAdE9dfkfe3862FEMdMmRddEMeeHMBzZMpLB7gC/q9akcuv/whI//GIV3XS4GkOuf9XpQs8DqnVdYZXLu7wOIRUTEJxXSvetNCDGd25BP9rdPwDponKhVtE1t7F9g7Owf50H35SFWgsL0E2M0INmm2URg6Qmun0bLRPe5nbR3InXbsnbo4tYW4roLePaFNvqxetoBeTJdMvfJ8rXCR1zr9NVMEznXFRTBa+mnwyoPCz2uEIsRjzK6WwWuFa/WPB+JskqhZ/d87BE6zlQ1cnXkm3Zl7s/ZSxg7g0c1IxhSJc0b4Xcwdhib6MbjP5v4ssHWu8MqLlW76HHvrAwXx6tf0khu+LGnS7GFhJmf0sV2rq2kfaTxWsm4SjhSkElZR6yTK161uCvs8obz5jt3keaPMFsEOCQfIAdUBs3+F0OPzI6s8QJTKEeNCjo2YL6WuEljebO8Xz1SozoYC86aTxB17a8qfxO4I/j7r3ntffheHB00deClCLWZxEYX09JdTmLsPddDD4UZVKJnYLM6hp80WzFhur/YCv0Bz4DLgkvxRs5mWwRegWCBjVfn8MZ9ExwY2u/OKam1cr57vDuIT/eJ8NrkSv4XxkYPP2/A6m/mJNF+LFxb/O5cu3L5XzmVsbiDFetP5/M+C9hIRBpmLexmsgDqNxPeukQQI5aaQuO4oKnZC84x1EYxIEGGkvBGCmQRIen+7Cx2Qwen8BZfOHcfQjau17VZBMXLqQZ5zMgtfrFrrD/zfi62uTNL5Gj2moYghVlAgrEox1gj+/mhlWtabB+8JbLcB7Io+wa1oz+DioNJSs+Se2LuelkPEIYPcsMTdkcIRbfngH9fOq3ADzTj/KLz6Y/njlyCax3rU04OL4nEdZohf8zzfBRFUT2dhCxitcPgAE+UF9tOo2kdTvh7ze4qB3Jt3del+jGu10aDSCTmIB+9oztjO0t0hRh6VAVsPeqIcJ641yGyg3XeI5Z/m9qtc/8mgVXK/Y+ZZJhsuh87HBZCqiDuemlMsMJr2iAKwakbegC1vXF4WBJYHqIcPzv9hECEFQuRx6a4hhJGRx1f51P8Xv4oO5twyrXD6bTCFHRPzLi/sB9quQcxURj+r4fuYkCYt/ub6HeZpnj5P0Mos1RR4nHHClhEs8/V+zJrBPOANpn2rK9PMvHDUkzpMrPyC6KOPXBEdWb2FvPCZdlmUY0MfSlgK+xI19e7K4TpbUlBzmOdI6HRW+vRN3i1KkBti/UNcazSYzXMMuoHIm0SRhV1dasRXzcXppqvFSlaDT5oXPDBFMp99d4v78r2M8fNr7I4XXOuvRslhjUl56Negmy37aN7qCNswfix8CHDJviHCuLLVkCaJpOjU1tWvIGpuXc2F3TQgiqQOZKWo1yO7x8QBqCX8AHsPdu2BIfiy5xeEc1nh5k1leqI5ROb9yJ/UIZ2uOo2yhxphq9W5L2zw8/uNxjqlmjZdQj3EKf/hL/gKD5JQiPj3135txAAR1+9GadXGVzErzZkX5NabMC3DWtAOYY6+VQFmyRYM5R5Fj0GVt8GHBKLyCAPVzVrI19+Gr1faFbemd45egazlqbMsrWsEec42XV3Cj7uZbTL16b8LW30tkhVGckpjbSaUF/SFGtnP8CbUKY9VY1iNfG7J7mwrFm21BZGeEiskiH132AtB8g64AKZ4YG9Ah6LLMpS25fNWaMEna12riElqUZxY20Q3g2w7KopTPsiZHlnU7kIoxXfEIgWdta4ztsYZbSeQGSxERuVprJqDFh7AwS1T3isUgohN9iogYucmhzGWbVtCH3vXJX0EbcryIaDYTSGcGN/k3N0SfhJYXmLaU+y6Z6ltqL+b4Y0hefW3FhKeT57TrGqCWsw7+BWHXsUtsaKsMNkgJK/lM0vINhHSC9iHsPEwc8o6sXyjfxRlsn72y+uWORzPYAv4jbU3oaIIJTK3TdK/MFEl9cAQdilxeimAlw7U8qdIzM547sW5YfTGCASCYG0ekzTMDONVyuF9F/WgI6R5O9dp+O5uBPGA9xiZAGSY/pUXH483kCcHlNzh8BVXqLAC1AKcOUD/vaqgL+DDmFhqGQAj8TAG8MU8cvGxejSXFthH9BZ9/dYLzAgAqa5m88/90H+kHRtJWPwo9kcKUWWKI6/vH1IV5p6S02VleisqbpzjbQvrlZPMCGlYs4pgUfrWMggcqZvUf5+/PyLfnbbViyG0ebDLGl/0SUNxM/ebp/kn2R9vwKhcRUwBnfhTzZDpVxPf0KCP4lbaX+ywCaAEChVQMINOIqo8OXJVmRn9X5gGrMCu0/8os/jd9aJaaLYcTuUYNqdNv6xsIMXKWuvUVgz8qx6oEcBR8jY6cBIlO4brXT0IZx3VSnWWtUs+JP2+B1HRgg8/FI2rLleEZDy4Cw1V9eULC3Gy59pSUBYXbSOKZwHEGZe7UtcL7S4pbxH1KlSvJ4/lXYlQ1rKx4N+EUJowtWEEOoqLAsQ5sH9fTiZnMTYA+Z7jurucbg+gbA8zRRAgmDhDcTzLFjYuOgM3L6LC4r7e0sTeLEXgKnCjX4tcWv/9Nr16h70obOFiggXaQAtkfGD/06w0xvkH0j1YR6MSsGloSj3L+bU669H7ViInCz8s1Ib/TRriI2TDq2YeWL/L0+Ql+PNQTuq635qq3PYuJ+SK/eevJpTHNE6gq2dJOz9q5pJCNTfgHnaHV1gAveQ6lqD3mMofsQZjgqYdPwbR40RVpeWzDP/sYZ0Yg/Ql6d2/BD6/4LHozB5H5DVkjY4LkK+A6OeP19EJJ0+XJ//cFyiMmcvMCSrxuZ3j2Q2ba8pfL2H+4sUXds3+fAuZZWFONnrCXMjufzHHXOMvoNgmnn5G5AgKiRam6v3QDe+9kXZ6ECjkkVmVTrQSp8zBNjDX5pwXk/P87fPDueguiJKbPtgT0TdzE4QZ8BeCGXcGCHxZKChwuhUMnBjXR59LJmD/KB02YrphGe5x/0al0ydNeOMFG4ZFFgt8ymRJEIwJBSvxXkgXN/kEUyjNefd6itc3g4tE7EzxmNMA1yXFxSXJpmkoilr22e9Gmjh71OPulnU4O3+IAHQECdAj5bnQ5of2DBlKRzSJZxYSaxMv8qLiX+yqbWwBPDn9tGLfE2IQwlTnqjdX4MZqrGt/3XW8UyZ0K1SnQ6tpT4k4OuiacNAZ5MQGQYHzCYJUWnjyLwH0d47Zibq94a0OIxNwsy2RX338N/g4w96zxWInpudxZBitNbvpKbosB/gJ/RDQ4UtD37VIFzGnrjJ6ohCxGjZMjyuZNXzVl2VldhmpSeueCuwzZYnW5zsg90WcHK/IB24BXZZHtbj3oDxDW/xzVRybhOjPqSFAiWBP3gA2TAWCWSbxDJsHqg1vTgVY+plwTPBZGDpePCxP+RkwAuF4ztrOLAFRca+/CA+M5YpdOD2U47vCx9f8Q3a82zouOxKdxMbQDliOluG/YucCA7ibJ3x8a0+pMY0UEWrUlee+civqc3kTQfQJCAz2oPcuxOjJvaz7JdlNn+M2FFqwwNJZR2BnTJwgpbdkIMy2IpF7wujThuVPaCJ5K0WFGgKX8H62/kGC35Lx3aMfKYF7FaxqEPNFD4eeCnkt+tYtUqPS+/WpWJDcnsgcKK7TlAkzIRNBpawJBFApNDbOU8fNbqYW3EBKm/zwdMtHaKQTg6HTsWA7lyf49dr+jTXeTi8WBHZ9s3oSU5dVBwADP1nXt1+wCyCevQyQdw09FHbt91sakhNiEYKGXjZc/wYmH2d64FnQAEWbv9ljdmIKs8+lEGMkQIo3GtN46U+g7hzT3Mr4Vbenu3qJPP/L1dFyFWh5y2k/JUwG9YrR7utAvzaee+isSJXpJzhNl/nqCqpuAyoYmHrj0pr/2abrKORBX+68ePPh+8Jva44/RMOAaFq6ob13ZuaNfXRPBgfzahu0fyvklxZlu/SKLWpEqufyk2OToW8wumVCopnnpte7zk+W6WOf7pC6Fgre6vr3D2Be1jNgG1sFsuU/vonkYAvLnE0GvP4QcowIbfNnh9iS6WsIves4f4KovRRVFqPyYAIiTGed2+OPMfVipbPxr+dCQ1bA85i/ZBunci1hotQgTFRo934eUYBYn1aa643odbFRODsZrrZW1zyQXV/9ltGd6ojEJwRRh6aVooLhlPDD8x51e51Y+6yc36PI5B23y2cCsozmiOd5vZgps7g8wP/7332okghIOiSJb0n64jhpCLwFv6JC1XXcwHbqn6xHA7RHGKXJ9GrTrwOnMcOh5mTuLaebmW4elEcEDx9XPulm2w7CkuR8C0VZJKj+Lv2MwLxFfOsnNvWxXn2C0T4AcY2ULoJke3rbb7fu43HNDVDOGc9ByJKn1C93cg/FXMepbKlilgP3P1RlkeXsBO7r2Vcn9NQPYVuQrwHZGF1iovwcP55ucEowBzfqxoqwNie4Frf2PL5tEqqLOcd2rDXrCULf8vnBJ+fUjy0iGU9gwQsMrRmxUqNa+b/L2Zoh+S8Odv2rX5oL6CTH53krpen9EWFewpyhBxPZE9fDo0cnQ7kMFYVkX96xUEx9RqhMcCWIaYJHv2jHD/Yt8dYKSWHo9BjZ4gTPCv08FNVRruxXLFAFPMezEv02FeDdJceSrjRy/Fo9/2gmYy9W5X0klaPyLb4oFYUOCP7q2kfWDXRivRxStsKgO6yqLdtDile5MLeoFLcNVbYY7pr1L5vbL+aqubD3aEkjvi4IBJYCe3j8EH8OCyo0Jjo8RcmjgFTezfbWjpNfci3PU1yModh3JSCtQ0WMEssn4CubEFPALehGSC9uQxiU/N27WFSOehgoPwUklqB4g4TPva8YsELyOxlyBGuRbQJRZpHVI3vdWaj4lFmWMa6piSHmsP5ifhR+acJQ4Ql9o04V0xv7YEJn9jiPcqS82JioV44U5SjBIx2YpWOkqNBUkxPCih+dJTxH/yagANewYUq0pXFKt3jK6cjgTtu5pGS9R6KdoHmFODJtaVSgGXgvFEyeewRXn0Dkyc2szfW0C69fdoxAcfVRTGBYcB0p62Yf1tGI7fkDGVEaEnIefRXuRizKrMD2y72Z2YM0hJiQRGuelwAYn6A2bPdrrAnq6+5+2Y5WGNdTP7afIgFXoxEFpMgwZkOmLcaJDNPjMTCSV8XUL+n96JO9VhptMMKwmhbmauYyNzz3o5DtIswwdorMZEPxUOBDzFPIKGUPAz7Jy/BJXNxCAfums4++DbHALc217sD+vYex2Z6FfPRvwpyl5zgm86qdkdtIpEtAqF/plPL8uc8jyVfVg9VxPzhrzJKswR04fwfDrIp+pEjRo2Ehu07dJz/kwxfjQw5T4SYvqlW+Sbc6reM0hZoUomIkAmjj+Q1oUSM74jUXgDiYanf33m1Gk/60PpaefMmqeeMQbwwLvYAGrdjYm9vwum1lqffxsWMVEER8qDYjgH0yVmovV9tP50L7Hpu66Vk+tShvb+iIGp0F1iK0tru2ipDTz4sw9JFwIEf1hQiI1YwWOWMK6cvyimpW9SdOZJxbAhiC1K5SM94wXapjcOZOLJeEq5Q0qro+fVe+YelWdXF3aXB3HOqGdS2wbYfUBJLx8Q+mQjlbzrv25S2s4sQrBsPfFHYJXCZyM4O0oliyfXGQ+RPO1Ze2qI8gi4m0Gn1scfbPuUM6tVBMC3cFSYfhFBm2FdnnK8LrIPCfAKkMTmYLxzbqStRDt0KkhvP8k3syarHi1P/lK4RjiwjPfxB2EzWZlW7HxOyGt4A9aT6wer441FEct17eiIncO5gB89aRb9cIxIeozY2SeW9olaMh5T9pELa0L8+fhJcjxcQcOtsBWIoMyqT74gs5PyIWvBpwq0q55E3Zi3A1LvJPOrhvRTbswnYW0ec3+YXJO3oLOkuywqPBnv05Itlsd/AyrGo+0gwnAxdUcCfFNy8oatljTILix800gk5dAg8qk4VI9jWVByEYuMDgTJ6gy9LHkV9leX7HsrnDGLYCP5BYaxGQWgjT42aCXX2uhi0NHfPNA3Pmk/VwToCZwjYZksCL9j6HgOepPFG+TVmg+5nTGR69i33JF3rglfGoOGU11mp0NqidzkF9C7xFt16pgyEmbwI8QD+zx7STPaBc3ShG6FyEfh844keHmJG/GEU6Uk2PBZPrLVMV3ilYKwbqS8vltdFLuSyLMCegDbSu8ICEb2THmgiCzx1hi3OdExg+isj80kBJiaaPfmeZtzAsG9EDuFqzo7eSXpTc95vVYhJADhF3IeMkjwgv56hnHc7l0SdaNMsuw9JUYT06QiHDH8DtuJE98o2Cm8XsoW1T/aLQBSYDl96zYaDgm1Ait5547wVlc5BFyXAwkb+GcsozkRJbv+6fgezc3pkEa+SU4TNZ/CowozOceZ38aVmY1ktHJQwImC4K9ql2i+OfzVd9SfsbouXg8YC904DyxPXn4aOOegTS2PL1uGNYg19lKTZ8Ot3rQFg2yeTkmj/ZfZXg8qHsDoEpiTG5d/dggXDkPfBosTO4srBcKxgtdUvwT37WQmodUUxS5L5lmUWewQiKTza0XmLawhWNs/1fZPabT2b6/7Hb5gF3zGm+aa1iEA2JoKx38pLN8cynou9qFrg1Q95UwNBuwE5XceVYOfkbZJ8OhlREidpWzSnPxJy5gJ0fdOJer0R45LmNNaKYxovOVYM8UCSAUwwE5yAmErGZqNFYBrdmfseqcLuALZTelVNEm3PkgIsMv1ukkjiSXCFDUhgy0569xQWRWWSVKPyjRTOd2Zl6u3PSRtmkGJGHNXh/NOQO4Ivdv+/wAU46EYNO/bSA7ScmrId3hjpFJ6wjYZaHhT1IZ1PjEu5DQ865yCmFCW3H2u5UiYsCipYPFeTVNO0uW6EALUcwSJ8tO59qEfw65DQ473Zla/6wa+wkMVeLxKrr6/CNDC6mxjYBSCjckN5aF93BvVDHIDZitd+7kxtI7zMnQL2Cq3w5+q/X21VdsQ9i0y1fBX/JYPPsZ0SDK49nCYW6G+9i8SyT39tVDH+kbrmau6FzXnhlueqY95piSa7bztNqaht1JE0JtxbL8FE71bAiM9DbpG0LJFPCsxlmHEi29npMhyqDdBRjhuldGQc/AlgGvyWc3aJTx3m8Gwhnqt9GTylTB+K8lTHBo+ow4nh2GGQO47MUMPFB6sHovLnVoE/OLtvPMUtnSHtSJbATlzJMaGC/rzeiuiYImLHuX4iyZLvPP93AwGkFxcRvGYTEoQAYQABQIdidP76uh8HkB9msn7YxUi+0Agq+lorYIW7oEYzry0MvSj/hSV1l1zktI2QYSdmL0D8y7CLZMicTq48RqRul0y+mIdjzXXM/5sJ1LfKW4SuoEVqpwD1yC+dVsc+VjlBPav0SbiiVHYhYhASTM81PPRuW6xQomUVJH6rZRsWXqPXS27ZYqAL+qXCwR691w1MjJ4glHvtGCiBp6kQJ871FCeuSI3NYLAP7WESi1Bh6ZzjMeQkR+YTFLG8ZRw1d1hnrJex7qVCZWHPqKuLb4m6PqPVFFnjkRsFKKZQTgET9C9cS9QgGAyKFhflDvevgabkcStRKUzz/cr+1nFFdN/s7Iv+zraGIBufpd6+K1PJDfNKFVPxmYE8qMTlns7vDlW5eoxisnFOieBmz102GZvnptyh48+dZ3DvUlT1X+8DKOGbIEm+Wom5lPvm5V7ZIFeKBOZjpENOxjUbHCmDSYatVJ1dpcmnjbB7CVivcKYF4SYl3mCAiq460uOoKiG0s/hjXXq9HJq8U3wlU7kye+DdPKmhC3wzQO67Il1FMuoL/fvcVtcFqgPclJKEJyAkYan0O8JMAghqd9WJvPB64STtICd/JuvvfYDUftZwVLt6c+7fvD5wt6ACnL/Xpaei8RPyhzPR8ViVnrzayjZdHYb3vo9oiTe8Fmem5bJ4NSd2eey/TBFOfNoNxlFk2BYDvRiAHAyXHfjnKADy7S8cIuKtLfbiGabnGt8DeuS+vbz72sKLLsve4kpxH3KvqZ0J6fWe1PO1uBpXMm7INO/8JSfOL3nMAoJSIreScekSxB2AYsg+Zsm72BlusIOjzfpNOn7rDFQ1fI3ior2yB4ckwXRx1EKgObFMNE6fGKxh9nxyU2UQM/SD9cqrGAfEWgHXufT3Wves8jGxLMhigo1thlKxizsnMbW/6wy1UoqQdWqCD6vp+7AS0F16gheUKpWJch++OgzFr0jysPDB+gX1zft+xEFapEQnC6EDFjrV+0nCZ77Kxv4p9m8/yDBkEMYPhdDukmdamO1ydYwG72ykxUb+rouECcdy5CtYUYJfY8LoOIQOsZpaK18zmiq1DFqKa+HbfZO+fZkOWvwGsrUn0a1GuYYn96XBr82iNPlDmPdMrYgMijicGQCRp2QKRmPUWYRfhoHyTUVZTZE3u+70pElqZHtvrGR6ajXoBTzknisj13s5bwAKhv6DvAEsAq/YSivKaOONlW7Asljl2Q0tWR1A9n9mK2/HOxLF4XB+P0Us1L7/V4mrRzzn2GPzK7DbSCeDxCGvGGUKmZ36y2lQ7hLuWyCRtAQ5ycEoZD3enH/EPeCYRO3i2h/niZsLBeAZoLQLS8aIciUeUQOb8O6mlq+LGDj4wuGYhxeTjh1mmp1UIodNofCpHd9lCXdTWmwG+2KGhOQ21w8bMneqmUQ8v8somxNCsN9v/MiKkm8oLjYJtM3s1KzxPKncMfWzKVQF5Y9fbgrAqhJopn/pElPWvkfUlJLHTWbM33FRj6u8v68X3HY/w6K41yPdAK/DjI6NoFORcbZwT/ER9N1nSqNC7Ucq4597U2oXE0lovUT1mARQB2qLiR7HzF6l/Qbi5C47dcaDfMZZZTz/4n7/2keCvD/DqsyJ6Rqj69GyaErbujEMbcxbgKR6CFINFWR2aq1T8hVQAuJWWpX19BDMPnlnf1yKrd3loJvfnBsN22Qg+WK+FNs/YzBkbZ+It5+C1MN65/VyBghf3x2XyLIFmQgBMT/g5kZIX41GKRxbUZd8/4tlQKyAB51RJe/wpj9dZfAPuxm63782EI9Q2+kXN3AZ7Nt9/JBWzBTWj1X5ajmbKn+9+L/lrVwNrteWeBoMWQnW25nWAZiSwp8HN3/TIEwhnmZa+tiQbHKpMAQVn5+AKQbU3fGPAz7/bPAi//Yq9eulQwQCUaFR984s+KBXheUT5jxBFJlyoZjOTsMZRxz8glc5Gfh51tDFXZyOcyH7JRkkZ/P5eNEh7qeTzc9ITdvYUQ+hJqkeOh/ZWWECs7dM7d+hADfsmQixJaqBVdfmW90NfFxZD9XClXOy1aPKQmOYkYP+YPTaIkWEfoak2vInFaPSChvFZ5wqfJkFIQfsvtubrORH/AGMFjkihYocC+/dAtjmf429TlKZ25+vfsJsMKx7ck/zKyORxjMUMiZlhF7EoCJKEQ5A53T18HT9qpqMkJwqjQGUaxJZ+e2nrslajDNfWIkXpRICKkUulEVA0qbkc8EZPepcQmM3ZI4TrCAZUZRR4FFm9L6H5WprJ1zkHLz94638gsvHbh9mzsipGsUrzz2y6M6VcpVmgMv9H2WpzgPHxVNTJmPRKBKXmk+VArdi+tU1/cpZwIzHRgXC5Uop6lRoJrq9KWqTilraKKzj/wniIFwBJV1Fow2Z2oQsONC9EFC+5iYBkWnQKRzJ7CFYSrsXvu/v/CGvIWfZy1SReesiM67SRIU+U8a1epW3e/6qRLCk4EvIOjoESnaovqGf7YW34NO2HOclKL8OONjb9aYod+j1SJauLuUt401mohaIfLz0iGMG2YRyE878ElF9DpcTInymXcfKrItORhpNKQTiAs/U0kTJT+zTWnUGHCeVeUrTOOcDveGSBh8aAn5+zpbm3jmnpxIk1IBK8c8VVIGeA72L03Kbk9Gry+M1HZtd/9pZfU4xBbMdVDq9032eJ6CYgtTB9klBcbxTPskkMWBvm1wg3Anoq84rqsHbIxZ1kf8QiJLTdXNuovPzYUEGfBDU7BkBjhMMZbAvQtWFJTbtagHFKzPvUKV82O82wc3TUVvQImPi3O88BROpArvL+hW2qsVv3i37eba6oQd4g6I6gLkSKH4MtTXiwEkk3PHJIhgwBebV0lg2L3BtotPu+Z1aOG4GjJr0XDG5CGPQPo6oL73D1umWctoRmXOucquENWoMnFB3CeffIJ1IdfTghSVqjedva1FWrG8RKiZvQZdbqe6fCoedd6TS1ysExPKZX5r7qdgRqIM0FFYbEN0zAaL3uxrX1Om+082qF+4bO6my+8NquihWHYpuqFD0iK69nyxHk5asyrHXsE8A8MJN3D3ho+Rr/Z1WpD9zJCcaQPcfhTVUQva7SBCDhCTxHgpD3PQWnWFBgNxhNBPcfaINYEfn6r4ON74JkgPAgdeMv7VRkIsAZwRqNVFQH8qpcCFlIOqEPE750/o7YCVVxklbFHimjT0pDsbnnVQ06itODEpL005X0+reU83vomIpHk/IGRv123WFPHqH9xmhxfR2DKEW/dkOS/otpCjm2FW39iFAKxvw0295klZda1p5FpcB9riKH5EFaku81uLG0RFVT7/fIjz18OZt/xHzUCVEIJYXJRljLdd0e6A9FVCQFQRzUA6klYXYVMv9XH2o0xLUjCVekVFXz6LJz3O79BpBD5kyYTq0/1lZM7kUeTK9lWTu1UZcackBCxMUx50nCn1Ix87I5Y9TeowQpuk7pcxmg4DBrZtX3vg3rXpSW350OBPSA/BK6f1V91S/kTIwGtRrfYxtEtadhao4NnyfaAk57z2UNnj314lRjbDa5uWmt0m+/2xbX+b2xAkhccsAsSr5EP+JazPhNDTsvMDS6Puqpk8qm5PMzvyR4JrEd85saTIgzE1w+Uqdbn7ow+oqK7hcwZAAH8UeOEkASaU3SKHbzXWc+QJHorreq6jJ6bDCsEG5Nfmb95fRtwlpFE0s1RxrZjkTi0k3LnG5lvEY4FEVe+d4IvgDItjRy+2SIMa+QmVI248xCnsvsFeZOAeywwxvYVye7+V10b2jdh8Ug++FRTM8iSB7lWGkcDzFKDxbuO+eGv75jURD524qSlIMNJAI5DKEWy6YVtMFwg4f71zkgVem46wVVd+YwkxbJ5tpmlCb6eZa9ajkdWWYG8pqw2q7XNm/BmQo6G/ogc/18HPV1bLo3R6xSDPWbTpkcwJF628BkPeTTwKcI0o29ZDVlgX/i/ctOuTHFaiFpm4rHVbPx5Sv7+uHLdyNeiaftK3v3U7aQHPtGTSCuYLdx9EZFqURAVZkmzFHXZzW28zWdIgBuLTDSGcAdK2cAGyiBqRm7MUa6No6ZIGRsQE/OKCZ62Ug+ANdU1abiOXPuDFJ+ENNEF6dkhB71Lt6tkcPiuOxUCTyQUbmzN4yCpfG5Iov92tW87JzzbUEF37WOpKGvpUk6SBw/9esVyDvjiJbGWjnfruN+oMA3f7WKo6pCwK2ZM0pvVGd9aiimDeE/0h4E+dgP1MphTjtrCR8YoNPzK4YwfAVawR3BS2st8fRYiokUNJ4hr9wyoYfhHfKWzExKUQINdQNTGX/0+Idl6DSywAGn8H5L9rGq7iuFweueaWy/S8BxX96itFmAi5LG0zBWgASfUOEprdD91TlZWJdhUQcYN54V9eM/rtHTUY6Y3kFTHJJvryZe0xY+qf8zh6Pjl0vPUF3vKo/VQPfgBxsDFfxDZxu1GDJRGS5hG/thSFrFyESo05sw+EarTx6Z11Jap1TWurS5b7itIREjA/yJ3/YJAyQjQ6wQ9RITM+DbSqECnhm8nhqNf2Ehfhr75DSI7s9rcYzPgu4x7UVnNwLQ5YP/6H2fZ7O6/0SEAvZp0mWPezay+EU7y9o0BNA5tpuFU1wcGlhFXPS/jbLFaHVBKYK5tFBwM4B2UeqzOQyuHZZTjrN1YrfsDIeGoEHyB7QrMC8r41e6wvmbBwbFKvhLb1mDqKAqMRqPigsWaZMb+t1zW/K7psDovLA4mjpNmPjCyUVKRTDDktg5NKRn7Nsn7mLI7mRejyWm1F9uMzL9lB3GeEgr+A6ipE8bSFgcsqyAhf/cYzZEnnR/x1Q7ERBHM9tIW7Yg3G0MzilVYkrTEVm3fJ5/KQUe9g/gs5v64OMZyrZgragnCnI6tlh6qfIPuwQsaTOOtvyTrv3fHlF/xPb28IKN0oloCmS2ZveWIv+n/zYAivH4/qxvNLQbSna88hcK5cijehihgua5ct26vk4vjJoPHXiHrHqfHM0LoRkgHvYQgn3/325pXkcM9A+wHPz0DuMhLhLHJ/4bAVNRjhoJkElMJRiUakrClobyUVC+XrJxC1cD6WGKTyiLISQPzv2oE4fareVmnacDyeHq2RTg3oswFongOyUsufcpTOV5N/J8Y+Ozt2pw3RLbaBgzo9jHwov4zizLG4tW1xvlAElTJOCDM8gzjUcZ0t3G8q79NqJb5WF/Uvzptsw4SsIEnGzmzIAEOHTwi/JKMSxkAVR2gaiRwLMBGnusHq8I9DdjxNG07qalCDb0XveEvIM+xZlBcTc2Prw/XDirKDI0MNZEQN0GgOuQGNEfs0SC3dUqdqjXNIZS/VMfBHJOtF6e0ZsKqj5wkUPrFe3sMTrT5HNUysloBrV2BN1HXwlq/ZsiAdxKJISMn4zY7b0CDtfRHFAKeVNnmGD8qXz7ToqJmPdSdcU5YEK5xa3lHZm/oGimObvkxyMV+HW0Ldy0+VqkfB+STbKk6cpIrOyIJtWhM7wjQtfVdX3XfQDE6le6m/ETBXvQqU4FHfysNRRIsi8PCuMDSJxEsgRFMNk/wen2GdM/n5k/3IiIzgZC894TKhc1HXQyPcKee154BheSPC4QIWw9O14Ywu6qyyslBIY791bKUcBrnAS/6MZCoMrGUISjVXFzZCjgWm4aNqhp0LhY6jXHekwI+8cbgu0Cj72bL4O3HD1LANWTSWq/pPeKUIN0rMouMD6zQm/djKOJAi8HzapAxdrqLFI9OxyztwpxNu+2h7jNgWW7k9i5uXa0KT+m/gq/G4/63U35M3iH9cukVgH4Uo0D/83skcOyLUmepF43nqGZWNYiWNuLIeM168okpNCdUamis8s1Elv1XDJZnXFy0oXkymF3Iz2UfY07nVMM1AUV8qO6hNcITEU0Wb6VokReA4/eJbP/TaXeBYfAU3LQz48p78ZSEtm84inFqarbouggQ53pZD6c7l+RxcVb5xKEB9s/zm1/aYkjOgGNuvSnG0nRp7hcZyKsnyDIwBqI/knDFjP3gkdqCbqj64JQS7vMdeJh/K9hQqHY6Wp7XiOiEQoejhdXDvZEAuJ7NdNMb+NTOHMG7XRfJrTexwXjZYC53CMZg7682Yre0KPlu/TAGbjkGPU6hphi0YTQqQL26hj0LlyTIuU9VwX2U+3jKR6Azxj7jJ3iIk565OBp4yhOnIuuH+Mune+xNKw5lSKmDQi2t+cuZZc8EXcHzInA3c7IjX8M6cZ0NCvAeANv5Pj+mr9hZ1lEXBISOJGda1O2P38GRibzEObARviPDU+wPNJjuDFRpDoeUtAtrY+LeRv0YOBUvPBI1VZ1lpX9O+1kskBXrgmIp5whLL30uqRFCf59LG0F4iOF2rgTgJNnCuK6zyEyHU1wuR+7k98dzVZhZGFbatO3l4J3rZKvFsW5sRfZceC8Oj8+OtS/4KZKaKyNa6r4kcDr61GYiW7c48SeI+ZG1F2heHTMMhM13mAElEDGscnQFjCnEeGh/flHTg3pyRhf2X2pSUYeRx44Z568kONd37KEYAfiKgiJ7vyM7TrCj80+Xo+bR3Koap3yToH6B+6yxchOrMWhtmbV1Q4Kyd5yHZFCFnPwrrAHv3/3urFQoDB2DL5Rb7/wM676D4+UugMCcu24pta6+Jl3thlTp05LT2xP6reU2yiZ+A9A9ja0/83BR0bum/hH+VpMphqcb2ot+T1Lvc5qzI5MboMBTLc+3TKj8e2ecoOxAmsx/lmud1BBydw0xeJ/W6iAJIuUb9d7Coe3NqCEniOzR11fL0KjwhHUfICRdBg8UMhzkHagiUS8JBc4BKSHa9oIQME/uSyfIQDBifYRIHjYNN8AaftIAtBbPsX5vax29k9XY/g3T67Pj1vTidz7sDzo4lXazINWDcmJ/pNWGathNtVmE5oe0ijT3J9VbphgUxApwo7GGta2Er0pcUyfnYcAoqWTu1lM89Xvs1Y0REsUxEjzWCLBzUpctQyE7Et4BKlUzQYdUiQt8tnledaN/hdWG21tsSduRsyT2P8J0iahIs1ND9+QpzYxAfvK+rVs/aTas8L0HiefYF0krehtnzWojQxi4DmHFuy65tRyWFFOUUwdUxQyax6US9xb2Es6yqr5dU+gafKL43639eXUjT7RmYq69MtgHVEnGfXo9insnCWleKNBN56m0jrTjVukO80pN+k7I+/pD90JLCuKJk2Ml0s726fbTQBsrlmHhIhQeZdwaztsPbE8pM6SxupP9e7HhU7etnIrQjhr6ZN0pnP4onXra3752m5K3vjrG1ie7pael9geQIOEDN8rZstx99/dnXh8mH2oFV/bFAF3ptJ8WVw9rjaOxeyClpn9RcasaM9pXyfLisXyGH9sGxcMMu/f0CQn0qVqV/duA1R41MpycrL112Y7pR+bF3lNoTnShJFnRLB9ao3zX0TVp9RrX3QeGZj7byme2Or9KD7MnysR6nRzXTQVxUJCOgS6atzayeltDBOYgDOfjArjvw9KZM7btzvZPNgsV0ud/cSEtrXZIeurlGEiQ1E7Ksh9hWdH9i2WNM7cOK37kGv4ik17HkRWGBVomzqsWmAcMQgdgYe2Ok1pwFgR4h17+WfMNftk0/u+qTnxQDRIqcm7CXIMpYcDTX9XEAdX9GgHFIfWt3wpx0Sp5c61EYreI0tJIRfmKwfl3gVTb1SRV1b31NnZFxMm5EjQ8NZeSwwILwRKd3FZXnXI+m1dtvu/IhCyN+UafuSJU6DrpWhRKiGxm2SfYYk9tOckzpATj7iKrfqwfcDRm2QoXmQ8ott2dQQVO2X4THktTWFbYO5G9xu+ZO6WReCa9HiowEAmNGJ7Hs8NUB6OfZoGP4poMojjDCn0aLm4DMAV1z8IxK8O32G3AHA0KAWTnF/vYV4Q8X9zCkgTJ3uD9i6SzAZ9d4+c6CYLulC3Mc1rFVum3W1WFimHoPQek07EFlsmnIykjZp1LzbAmMKXkBmxtQk0hBMsXvsLR8J/PyN63tEXTeKtYNtyvZwh1uAVJvV8yYbdoLdVc/6ydeA0nkUoqM9QSDpslU0mIQch5lYJaVFJ+qd3kd7N2uOXbtyGB6nndd+w4sQzqujtVnneIGc98SUy476Q9DW2Mun8MkddqH5Qe7ZBXWm4qQ/6anTHTD3e2hR0Vv72wMoHeAuV9+IxK+0NtHyTeRqO9GZ95Pj/gZzI25gHx7dDL1sMqElC0As53wEBo0QeGlkBZAj3IYF+unuAUgSYnQn1Im3xyTHAod8oOblNfF3e1zTWM55u+2nrbj4QvWDwr7sGgR147j8n06b7smLLDmaMg/GTf9GNdlBs4WgmVej65SCFQ9+xORgFrmoVp8QtWCjjQVPEDOvENop+g97jVUyHfSgH3wIuWYTD79K3xfOpcyRKC9mrCb6MD9OdEPbC3ixD86yY4bH18/39dA+4ISXVGfT8+3OB3OEiCQFpr/75PwWCjdZHoPA1gt2zKFL9mTntHxQ/qsC2wmKcqMKYfJPURV1xSKOej1h87VqniAEgypsI/KEtSYuqMhFl2cV3RZULsdQePAzKg+kRjlW2CvKwjcp7CmwdqOqNPze/YmBt1zpW6dRF+nopUgSsdGLq0gYZydVEKeHPEjpSxUwWj30qAF0trM00GU97mWO1ch4Mh1tz7kV2VmETxleoEZxTomEkHed1LWTXXm9aJsatox2q++NdqqaISxfP3jDxyONFx3Nq3tp6RmspQlYoIbSxmZqa464rc0ZHAK8H/GKDYnIjcruFdzOPmTEAqQDmmrexsxYnDyT+QIqrmGjaOjbkEpOBBHLcJbOz4jndWgcLzWrYFfSEcEJgmLhRI1zwrenD1iO8l55MgsMBEBIzBDjDwaMXs2jLfn2QU7R/JwHvbG5lLae4rtG4IGZe/D61GVAhjM1/YJZYn1vEJsaQKxVY46+On1Sa0i3jB+jImwxdkHblWWAanC9IDjF6kAsqcdWa0GYimVooavTokHhlrOLlTUBFM7ZjjKRT7IiSDJTY4xl7QyDEZaQJMpimdY8pzsoLJvvgKpX3rysDB/kifp50L+26lDy0WGUiX347VT3o9VbrKivzgZEeYrR+2bhkAb9uNrDylRbmj7XUmK+kMdUDBiPwu8+HUk13KLO33jpffZJyrAU/BwJg4lUdrLx1U2qlbcHDcv3bbNkpH7Q8eibJ1FyQndkWvkkM9j7zXCC/hSYPFKtsqY4Yhaexi3VEV1/4EdOQvCIC9W+fcvTBWKqmy81tw23MvgvoPqhQdiZb4s76Q8JYwjjcK2cPU1dv87l+kPPAlz1b2QITVb6OadjIEq+sBe7fjyRFqV6IfRODaoGT1RzHRZu4wn1j5aYQJQKkoz4j8Ro+aTqtIyzHU6eaxR23r7ZCDotsqUAOSZh2xu3gkCaKEhI4N8vGKyEN3qBDQqs20s8PD0kM0/aperF7vVcM53YFHSPBDhL9lzgem1/Ryk6ccQ2TtnPa8H4Hga/5Ayzreg1Yq67NpsLUWZY7Qm0hxs6OKBNvg5zdpJvcHCj2YZ14oaTbV8gMsd7GEIFutSnIVEkxf1O0B8lhY6GbCmjbpS3yOqI5ncAhHV9AtlYn7SWre8DrNgcqZGmzKj4NsvNcOmpZFo7jftXdWXtLzjUhKGWtD7GoDRa2ccIIJ1o+i8lPCOM8eSvdYW0m7+HAIrlH8zD1lYduwyjEgqXc2gjvz5jqe3TEnNOUib9dZIVIcWxjqyAsjgd95nXYAp5aJQMAR1P6isnYfIwpWR7e2RFydjnGVXnuuQC+f9yFX8VM9UXkOVaUy02fGF8CsufdfXzGAvbCh8muXY330LaNvctMp/F17GwcmEFJ4klOHOZx7s+EF3Em3mMBOGNgp508wP03OlH8AnLFXqbqGcpvXX40R74+iu7mieTQKaBMtT2aMPwhP7bTJ1QnYyLWXuExq3NfxYNkRGBJsBTKUus0RNUlUddKyH7iLf2Lht2zqdtDWWrK0rkkw9HTy7msJsP8ra+Fksidzcxg3MMqN+I32yMv9NuEDxvdoNNw7UKWquu6LGOGdYyysBgOuCtPM9CBnUubgP2PHn8A3EDxXpfKxB0Lo6DoHzP9zzOhPkojI3fPHoSNE/Or0Fyb5HEmVdbR6Ps9FTjVQC4xTjqyv+K6kvPsx8HoPia3Mye4QHI5IpIVsDmygZGazpU1nglKbF9ppXhSN16qScZ+WC3SfMXCSAIRKfpjidGEq7sEj81aDKEPIAwaVv1mF+cy65PX4kk5omogxEz4b1LJCRB0mjhxT/NvTSELYS1keuK8r0Mkyh6rM3mLLBRGkyXBXJSy+OQbiScLv2tu0TVM6k8BKGwLPHWxXP6bApIvxUDDqSXdqI5CZ7VBK1aCleex49zz9SdxyBHgI0A/k95t3+kzS6UPI/vHwVchwlJu/6rznWphmSmef7y1GvE7iU/dk4ma3ETXT8Muo1KjwzGZvdSfGxAqIaQ2tFYWaXOPtxNFJM2TpZ9bcwv4lsLgcq9k0dU438Nsf71W+znDq5MDL1h3GzWx/ZjIxgbmiKl9NvOhH91x21E5Y00jnCKGwBQ+LmSN9ervWUldmYZpxGcYCfA/4JqsrVNfKMCq/eIbmIYvgFafNn2vWIjSr08qQzkPh2dJ+3suChcg0igxm26ykZ0qMqBHioEqwk+V2HHb/V4wC1Jwo1iEyAKLwbrdgKzdYslU1hQ2sJT9qv8cKeEHrHlePHbAk86pw0qg8wcBPLnDVxgaNxXeC/+amPzGzce/Hs73lFhIH3Zv2PpzOR75cPWoPNx7cBagpWJvbpC8gJ/U5wQQyz5J3bs2KLGNaJw2HNPA/1Vfy8STSoV5okcYfJyc6HvmPIlGNKRVCVeCLjQ4IxPL8LhAYUGkAgQzhnOBqPoxF/Jf3JaHJuMv1kElnZy/rN/PbyM9kngvu3u9y374lh6MyA6cJyQGmhJUVs0ee6YpU1wi6VSnxOYH9OtuK9+83Va8mL0o06d7zzWeCE3U0DDAVYERM+WUtsPKjbBamDFnxubNeoBtH3tMkAHQ1vEFZP6Eg9BCVkYEwKgMRrUkHtL6oDWLYmXDuZ9HV7rkpRAOfKswHUcavM0afsAddE9eUJlaihxVaaRQWzN2r36bQlXfqsHg6oHtpe+Nnjt7Vay2rtnWo6GiCzj3QT2QDoUqCojUZwy3PWkCs2MvmTzcfBEN8EXVr1vew42aLoBXZ7rJoSBp5+yYK2O51GrmK9S4Je8NR4QSjcQSVIYyOpv4z2NSIe8MySOrQNZImluQx/9dkeN8PrP3/A0ez1tCoRQwg8WfBsLZwQS7nYhhfJRxgpvJc6aF4Px+xsVcyCTMSlZO1hqc5HeT4wUqgJXnQ052/bWsNJkbwzJOQ/Ua2Ho9TgZd/NIVQKlzZWXJcPnotMtzm00eeYIcF4ewVc9wlRcINpYack9R5UZfYad+zlfcphEhDN1QtSmIO0UQ6oPl1si95FNoHel5J/l9/Ea8bkkVi6/U0ZA9ck0wb8cTBDVQ51MsJb+6kOt7N637sFsKiT8A5RQ3MIBAObRGOsRcSuEQovah1Y93/Afd0jZWukeUH7ITCYwBBod84Sy/GLqjyGY1mid4KGmFbMzWPfIwK+lTNWFYNMmfeVGib7Ja8T80/GdT2duz7mFEfEPS2tLQPZ1tfhaLQkEISw/f9fl4o3KexqvDfuzDBlJpXkL7AggmrOJaldKsQNlr77yhE/jAS9kVstuZbskFhUdESQ2FgRIMfAmA8VEF+d2au6N+PwhZx2pC5uLgGRdIg/IKNu90R4S06aelyDXBBvFe1Jop/zU5ODjUFGEMOK3z6EYu1fSgYRLVkIbOjfsejvHvsn6eXvB+pR7RxQtB5xkvAUsDBKKpnSEUkS176bh+1nd3lzMB7SxQmAWvtzitqMYgmApvbhDKO+JnIwCR+qyBgI2nRc6lQD839ABSnvFeeXe8VC9BTx8Cb6X2TnAciLY4eXLco6sjlIP5dFEmu1k/gTrFp1/VG9yWzoEM0oCk86F/wh3cqhv8Pa/itrpuYcbwQZz4pD1lbTM+Fu/eQUt3KcMFyEpwZjvGkG1SrxDI/DyjrWv7vvYwrxU8V5NZFo4JYKYwwHbnHP3ruOuz3bND+cmZRp/ZAmJFrRcGty5wkKz7FiuBRIM+x+moxiNoMI7iO+j9Q556tzK08Z6+u0tHc+wT6lvMIKjM7f5l8Y8VA2QB/hAyNR/GzMYt1j75SioUdBGdLMZhYT0veGvg20ROhJsXP8Rihy1MTVthHr96o/FfbgXH/CJXXP3eJikxusJbi81Y53NiOlN0ZAFgBMjziDTNC5SV91NvzThqo9qgo/ZpaAPyNHGvqtC46w11T22FjPSg78jE4toux/ZdOd1M966SM139SQgV2pvA65BUVw2ajteeGlEdXkJBeO6vO5ovAA1GORokAgS3DoxjFiApdXRlN6XEM+664yKa2vTWh4QQ/zSvyhfG6KxURAnYudYJkUw7qv98sghZ1oBawd+dMzBbqxbxICARuEy/MAhHNi31S2OYspPSJV1FDH6v4obqeSgtPzStShuNZRByIWDctCsfC6m828R4Qff+uv5ldmU6DLNWynIHp/p2hU2KDiaX4Kv2vmO83jkd+4uvmU+hv0mgY5kj/V0Rt16eftEpBXEMCw9Ay1b9dfHEiw3fvEl4ZDjqgE+ouk9PjRtFxz2n0dzDsi4bgynnnmqO4VqEBhgQsy22zjRDI4Z3VKjKwPPr99lWn2E8Zl8fNMBPAbFfQAlW9B1x/y3kd4ABWWH1Rw3wtH86dPTCKW6nbtlBxYZkAOaZxXgWV58bC++E8gYBnsiTdJDGSdzCEUiX4WAful55veKSEuOTNP6BbhCGDFqFaCY26i7BiBnqtQbYDO0VFamilOoF5At/Q7hg0g/fiOfvQjl1s49HzRzwaDAdmDbrGtYXVDt+MP+H8SJ55qgberL0PCNNiUTCR6eKtfFLhyRHnHOH5fMRgPjThQ/b2H4n6Gg5vC/Xmhxs1iYxzLp0ieB/kRKq9GFcz7e61RPBjcw82fEnHFmBiWYZfggxtcJod4Ht29mzATRj4rKEZluUTPgdIAr8t6bJ3pneWj7cwRFTZWQK07kMVJ6y0P4UzFwykhf9I678qLjlWv5pnD6gC/OIXuZ4EWYn7JqeXT+TacgKFVIadrR394frEkWexAe3ZrK7TvG/p4LTfGAc1ZZBwycPItosEdwRTsYz6/bBh/fGmPA+Qux7vtWWqnbhcM5eBqB7DekXUMrIQnKiVYA0orjrWp0lpeH9NMYWvbFFUu7M9X1HVwwtlvKRwtMW9uC491CxSv+U1iecXqJjyu4LVm3cA3214FhXq7uo9KGJO+nA7PxQkfjuYYjRLnE6SudTtCMypQnhaTbkNnZ3d3jhymrOw9+X50/EAd35lkiaygVGI+loyBaiq3b2/sj3QrdbEB6HMfrWFyU6C4GuuPNlSFZPQ3DO9hpU+/5jt1un3rybksK3U5YbOsBww5urkn7zAxOhGN+Zs88JaDJDm5+QtrERRigRtikO19XVpOGeqSVUW+FZyFx5iNobUqrnU/LsGqm719Jf1wnMKhE03r4YHELw78zIP+e3+q+wXzcOuSIhRSbbg6okuNNbeYh0w= </div>]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[算法-堆]]></title>
      <url>/2017/11/03/%E7%AE%97%E6%B3%95-%E5%A0%86/</url>
      <content type="html"><![CDATA[<p>堆(heap)又被为优先队列(priority queue)。尽管名为优先队列，但堆并不是队列。回忆一下，在<a href="http://www.cnblogs.com/vamei/archive/2013/03/15/2961729.html" target="_blank" rel="external">队列</a>中，我们可以进行的限定操作是dequeue和enqueue。dequeue是按照进入队列的先后顺序来取出元素。而在堆中，我们不是按照元素进入队列的先后顺序取出元素的，而是按照元素的优先级取出元素。</p>
<p>这就好像候机的时候，无论谁先到达候机厅，总是头等舱的乘客先登机，然后是商务舱的乘客，最后是经济舱的乘客。每个乘客都有头等舱、商务舱、经济舱三种个键值(key)中的一个。头等舱-&gt;商务舱-&gt;经济舱依次享有从高到低的优先级。</p>
<p>Linux内核中的调度器(scheduler)会按照各个进程的优先级来安排CPU执行哪一个进程。计算机中通常有多个进程，每个进程有不同的优先级(该优先级的计算会综合多个因素，比如进程所需要耗费的时间，进程已经等待的时间，用户的优先级，用户设定的进程优先程度等等)。内核会找到优先级最高的进程，并执行。如果有优先级更高的进程被提交，那么调度器会转而安排该进程运行。优先级比较低的进程则会等待。“堆”是实现调度器的理想数据结构。</p>
<a id="more"></a>
<h1 id="堆的性质">1. 堆的性质</h1><p>堆的实现通过构造二叉堆（binary heap），实为二叉树的一种；由于其应用的普遍性，当不加限定时，均指该数据结构的这种实现。这种数据结构具有以下性质：</p>
<ol>
<li>以最大堆为例，最大堆指除了根节点以外的所有节点i都要满足$A[PARENT(i)]\geq A[i]$</li>
<li>堆是一颗完全树。即除了最底层，其他层的节点都被元素填满，且最底层尽可能地从左到右填入。</li>
</ol>
<h1 id="堆的应用场景">2. 堆的应用场景</h1><p>堆排序以及优先队列</p>
<ul>
<li>堆排序可具体参考<a href="http://vickyqi.com/2015/08/14/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%A0%86%E6%8E%92%E5%BA%8F/" target="_blank" rel="external">排序算法系列——堆排序</a></li>
<li>优先队列可参考<a href="http://blog.csdn.net/vickyway/article/details/49005011" target="_blank" rel="external">JDK并发工具类源码学习系列——介绍</a></li>
</ul>
<h1 id="堆的存储">3. 堆的存储</h1><p>由于我们需要频繁的对堆进行增加删除，所以一般堆的底层都是通过数组来实现（而不能用链表，因为链表需要频繁new 或 delete对象，非常慢）</p>
<p>因此堆的存储为，对于元素$A[i]$：</p>
<ul>
<li>父节点：$A[i/2]$(右移1)</li>
<li>左孩子：$A[2i]$ (左移1，可得到2i)</li>
<li>右孩子：$A[2i+1]$(左移1，低位+1，可得到2i+1)</li>
</ul>
<h1 id="堆的基本操作">4. 堆的基本操作</h1><p>堆的增删示意图如下所示：</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-11-13-22-10-15.png" alt=""> </p>
<h2 id="MAX-HEAPIFY-A-i">4.1. MAX-HEAPIFY(A,i)</h2><p>由于堆的建立是基于原来的数组的。假设我们现在已经有了一个半成品的堆。</p>
<p>初始状态如下图所示。在节点i=2处，A[2]违背了最大堆性质，因为它≤它的孩子。</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-11-13-22-11-32.png" alt=""></p>
<p>接下来我们找出i节点的孩子中最大的节点，即节点4，通过交换A[2]和A[4]的值，节点2恢复了最大堆的性质，如下图所示：</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-11-13-22-11-59.png" alt=""></p>
<p>但此时又导致了节点4违反了最大堆的性质。此时只需要递归调用MAX-HEAPIFY(A,4)，此时i=4，通过交换A[4]和A[9]的值，节点4的最大堆性质得到了恢复。如下图所示：</p>
<p>  <img src="http://om1bxijvl.bkt.clouddn.com/2017-11-13-22-13-00.png" alt=""> </p>
<p>以上操作的伪代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">MAX-HEAPIFY(A,i)</div><div class="line">  l = LEFT(i)</div><div class="line">  r = RIGHT(i)</div><div class="line">  <span class="keyword">if</span> l&lt;= A.heap-size and A[l]&gt;A[i]</div><div class="line">  	largest = l</div><div class="line">  <span class="keyword">else</span> largest = i</div><div class="line">  <span class="keyword">if</span> r&lt;= A.heap-size and A[r] &gt; A[largest]</div><div class="line">  	largest = r</div><div class="line">  <span class="keyword">if</span> largest != i</div><div class="line">  	exchange A[i] with A[largest]</div><div class="line">  	MAX-HEAPIFY(A,largest)</div></pre></td></tr></table></figure>
<h2 id="BUILD-MAX-HEAP-A">4.2. BUILD-MAX-HEAP(A)</h2><p><strong>我们通过一个实例来说明具体的建堆步骤。</strong></p>
<p>假设我们有数组<code>4,1,3,2,16,9,10,14,8,7</code></p>
<p>它的形状为：</p>
<p><img src="https://ooo.0o0.ooo/2017/11/03/59fc1f33088db.png" alt=""> </p>
<p>当然最暴力的方式就是从最后一个元素【7】开始，向上以此对树进行维护。但事实上由于后[n/2]个元素都是根节点，不需要进行维护。因此我们只需要维护前[n/2]个节点。</p>
<p>具体步骤如下图所示：</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-11-13-22-13-17.png" alt=""> </p>
<p>伪代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">BUILD-MAX-HEAP(A)</div><div class="line">	A.heap.size = A.length</div><div class="line">	<span class="keyword">for</span> i = [A.length/<span class="number">2</span>] downto <span class="number">1</span></div><div class="line">      MAX-HEAPIFTY(A,i)</div></pre></td></tr></table></figure>
<p><strong>Java实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HEAPIFY</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] A;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> heapSise;</div><div class="line">    HEAPIFY(<span class="keyword">int</span>[] A)&#123;</div><div class="line">        heapSise = A.length;</div><div class="line">        <span class="keyword">this</span>.A = A;</div><div class="line">        Build();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> temp = A[p];</div><div class="line">        A[p] = A[q];</div><div class="line">        A[q] = temp;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Heapify</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> l = <span class="number">2</span>*i;</div><div class="line">        <span class="keyword">int</span> r = <span class="number">2</span>*i+<span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;<span class="comment">//这个条件真的很重要</span></div><div class="line">            l = <span class="number">1</span>;</div><div class="line">            r = <span class="number">2</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> largest = -<span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span>(l&lt;heapSise &amp;&amp; A[l]&gt;A[i])&#123;<span class="comment">//一定要判断是否小于heapSize!找了好久这个bug</span></div><div class="line">            largest = l;</div><div class="line">        &#125;<span class="keyword">else</span> largest = i;</div><div class="line">        <span class="keyword">if</span>(r &lt; heapSise &amp;&amp; A[r] &gt; A[largest])&#123;</div><div class="line">            largest = r;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(largest != i)&#123;</div><div class="line">            swap(i,largest);</div><div class="line">            Heapify(largest);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Build</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = (heapSise-<span class="number">1</span>)/<span class="number">2</span>; i&gt;=<span class="number">0</span> ; i-=<span class="number">1</span>)&#123;</div><div class="line">            Heapify(i);</div><div class="line">            System.out.println(Arrays.toString(A));</div><div class="line">        &#125;</div><div class="line">        System.out.println(Arrays.toString(A));</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span>[] A = &#123;<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">16</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">14</span>,<span class="number">8</span>,<span class="number">7</span>&#125;;</div><div class="line">        HEAPIFY t = <span class="keyword">new</span> HEAPIFY(A);</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="复杂度">4.3. 复杂度</h2><p>在高度为h的结点上运行MAX-HEAPIFY的代价是$O(h)$，因此建树的总代价为：</p>
<p>$$\sum_{h=0}^{lgn}O(h)=O(n\sum_{h=0}^{lgn}\frac{h}{2^h})=O(n)$$</p>
<h2 id="poll">4.4. poll()</h2><p>一般来说，删除元素对象针对于根节点。</p>
<p>删除掉根节点之后该怎么办呢？《算法导论》说直接把最后一个元素提上来就可以了。一开始想不通为什么，我想的是直接把左右孩子中的比较大的那个提上来，然后向下递归就可以了。但再仔细思索，如果这样操作，那这个孩子下面几乎所有的元素都要变化位置。然而如果直接把最后一个元素提上来，只需要变化一半。很神奇。</p>
<p>伪代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">POP()</div><div class="line">  swap(<span class="number">1</span>,heapSize)</div><div class="line">  heapSize -= <span class="number">1</span></div><div class="line">  MAX-HEAPFITY(A,<span class="number">1</span>)</div></pre></td></tr></table></figure>
<h1 id="堆排序">5. 堆排序</h1><p>堆排序其实只需要利用堆的性质——根节点最大，然后依次将根节点执行POP操作即可。</p>
<p>伪代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SORT()</div><div class="line">  <span class="keyword">while</span> heapSize &gt; <span class="number">0</span>:</div><div class="line">		POP();</div></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> e = A[<span class="number">0</span>];</div><div class="line">    swap(<span class="number">0</span>,heapSise-<span class="number">1</span>);</div><div class="line">    heapSise -= <span class="number">1</span>;</div><div class="line">    Heapify(<span class="number">0</span>);</div><div class="line">    System.out.println(Arrays.toString(A)+<span class="string">'\t'</span>+heapSise);</div><div class="line">    <span class="keyword">return</span> e;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">while</span>(heapSise&gt;<span class="number">0</span>)&#123;</div><div class="line">        pop();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="HashHeap">6. HashHeap</h1><p>Hash堆与普通堆的区别：Hash堆多了一个用来指示元素位置的索引。这个索引表示元素在堆中的位置。</p>
<h2 id="add">6.1. add()</h2><p>向堆中添加一个元素</p>
<ol>
<li>将元素加到数组末尾</li>
<li>依次向上调整</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> now)</span> </span>&#123;</div><div class="line">        size_t++;</div><div class="line">        <span class="keyword">if</span> (hash.containsKey(now)) &#123;</div><div class="line">            Node hashnow = hash.get(now);</div><div class="line">            hash.put(now, <span class="keyword">new</span> Node(hashnow.id, hashnow.num + <span class="number">1</span>));</div><div class="line"></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            heap.add(now);</div><div class="line">            hash.put(now, <span class="keyword">new</span> Node(heap.size() - <span class="number">1</span>, <span class="number">1</span>));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        siftup(heap.size() - <span class="number">1</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="poll-1">6.2. poll()</h2><p>从堆顶拿走一个元素</p>
<ol>
<li>将堆顶元素拿走</li>
<li>将堆尾元素放到堆顶</li>
<li>依次向下调整</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function">Integer <span class="title">poll</span><span class="params">()</span> </span>&#123;</div><div class="line">        size_t--;</div><div class="line">        Integer now = heap.get(<span class="number">0</span>);</div><div class="line">        Node hashnow = hash.get(now);</div><div class="line">        <span class="keyword">if</span> (hashnow.num == <span class="number">1</span>) &#123;</div><div class="line">            swap(<span class="number">0</span>, heap.size() - <span class="number">1</span>);</div><div class="line">            hash.remove(now);</div><div class="line">            heap.remove(heap.size() - <span class="number">1</span>);</div><div class="line">            <span class="keyword">if</span> (heap.size() &gt; <span class="number">0</span>) &#123;</div><div class="line">                siftdown(<span class="number">0</span>);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            hash.put(now, <span class="keyword">new</span> Node(<span class="number">0</span>, hashnow.num - <span class="number">1</span>));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> now;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="peak">6.3. peak()</h2><p>从堆顶拿出一个值，并不删除</p>
<h2 id="delete">6.4. delete()</h2><p>删除指定元素now</p>
<ol>
<li>根据hashMap找到now在数组中的位置</li>
<li>删除这个元素，并将末尾元素放到这个位置</li>
<li>向上、向下调整</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> now)</span> </span>&#123;</div><div class="line">        size_t--;</div><div class="line">        ;</div><div class="line">        Node hashnow = hash.get(now);</div><div class="line">        <span class="keyword">int</span> id = hashnow.id;</div><div class="line">        <span class="keyword">int</span> num = hashnow.num;</div><div class="line">        <span class="keyword">if</span> (hashnow.num == <span class="number">1</span>) &#123;</div><div class="line"></div><div class="line">            swap(id, heap.size() - <span class="number">1</span>);</div><div class="line">            hash.remove(now);</div><div class="line">            heap.remove(heap.size() - <span class="number">1</span>);</div><div class="line">            <span class="keyword">if</span> (heap.size() &gt; id) &#123;</div><div class="line">                siftup(id);</div><div class="line">                siftdown(id);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            hash.put(now, <span class="keyword">new</span> Node(id, num - <span class="number">1</span>));</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="代码">6.5. 代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashHeap</span> </span>&#123;</div><div class="line">    ArrayList&lt;Integer&gt; heap;</div><div class="line">    String mode;</div><div class="line">    <span class="keyword">int</span> size_t;</div><div class="line">    HashMap&lt;Integer, Node&gt; hash;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</div><div class="line">        <span class="keyword">public</span> Integer id;</div><div class="line">        <span class="keyword">public</span> Integer num;</div><div class="line"></div><div class="line">        Node(Node now) &#123;</div><div class="line">            id = now.id;</div><div class="line">            num = now.num;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Node(Integer first, Integer second) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">this</span>.id = first;</div><div class="line">            <span class="keyword">this</span>.num = second;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashHeap</span><span class="params">(String mod)</span> </span>&#123; <span class="comment">// 传入min 表示最小堆，max 表示最大堆</span></div><div class="line">        <span class="comment">// TODO Auto-generated constructor stub</span></div><div class="line">        heap = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">        mode = mod;</div><div class="line">        hash = <span class="keyword">new</span> HashMap&lt;Integer, Node&gt;();</div><div class="line">        size_t = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">peak</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> heap.get(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> size_t;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function">Boolean <span class="title">empty</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (heap.size() == <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">parent</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (id == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (id - <span class="number">1</span>) / <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lson</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> id * <span class="number">2</span> + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rson</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> id * <span class="number">2</span> + <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">comparesmall</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (a &lt;= b) &#123;</div><div class="line">            <span class="keyword">if</span> (mode == <span class="string">"min"</span>)</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (mode == <span class="string">"min"</span>)</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> idA, <span class="keyword">int</span> idB)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> valA = heap.get(idA);</div><div class="line">        <span class="keyword">int</span> valB = heap.get(idB);</div><div class="line"></div><div class="line">        <span class="keyword">int</span> numA = hash.get(valA).num;</div><div class="line">        <span class="keyword">int</span> numB = hash.get(valB).num;</div><div class="line">        hash.put(valB, <span class="keyword">new</span> Node(idA, numB));</div><div class="line">        hash.put(valA, <span class="keyword">new</span> Node(idB, numA));</div><div class="line">        heap.set(idA, valB);</div><div class="line">        heap.set(idB, valA);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function">Integer <span class="title">poll</span><span class="params">()</span> </span>&#123;</div><div class="line">        size_t--;</div><div class="line">        Integer now = heap.get(<span class="number">0</span>);</div><div class="line">        Node hashnow = hash.get(now);</div><div class="line">        <span class="keyword">if</span> (hashnow.num == <span class="number">1</span>) &#123;</div><div class="line">            swap(<span class="number">0</span>, heap.size() - <span class="number">1</span>);</div><div class="line">            hash.remove(now);</div><div class="line">            heap.remove(heap.size() - <span class="number">1</span>);</div><div class="line">            <span class="keyword">if</span> (heap.size() &gt; <span class="number">0</span>) &#123;</div><div class="line">                siftdown(<span class="number">0</span>);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            hash.put(now, <span class="keyword">new</span> Node(<span class="number">0</span>, hashnow.num - <span class="number">1</span>));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> now;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> now)</span> </span>&#123;</div><div class="line">        size_t++;</div><div class="line">        <span class="keyword">if</span> (hash.containsKey(now)) &#123;</div><div class="line">            Node hashnow = hash.get(now);</div><div class="line">            hash.put(now, <span class="keyword">new</span> Node(hashnow.id, hashnow.num + <span class="number">1</span>));</div><div class="line"></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            heap.add(now);</div><div class="line">            hash.put(now, <span class="keyword">new</span> Node(heap.size() - <span class="number">1</span>, <span class="number">1</span>));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        siftup(heap.size() - <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> now)</span> </span>&#123;</div><div class="line">        size_t--;</div><div class="line">        ;</div><div class="line">        Node hashnow = hash.get(now);</div><div class="line">        <span class="keyword">int</span> id = hashnow.id;</div><div class="line">        <span class="keyword">int</span> num = hashnow.num;</div><div class="line">        <span class="keyword">if</span> (hashnow.num == <span class="number">1</span>) &#123;</div><div class="line"></div><div class="line">            swap(id, heap.size() - <span class="number">1</span>);</div><div class="line">            hash.remove(now);</div><div class="line">            heap.remove(heap.size() - <span class="number">1</span>);</div><div class="line">            <span class="keyword">if</span> (heap.size() &gt; id) &#123;</div><div class="line">                siftup(id);</div><div class="line">                siftdown(id);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            hash.put(now, <span class="keyword">new</span> Node(id, num - <span class="number">1</span>));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">siftup</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (parent(id) &gt; -<span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">int</span> parentId = parent(id);</div><div class="line">            <span class="keyword">if</span> (comparesmall(heap.get(parentId), heap.get(id)) == <span class="keyword">true</span>) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                swap(id, parentId);</div><div class="line">            &#125;</div><div class="line">            id = parentId;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">siftdown</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (lson(id) &lt; heap.size()) &#123;</div><div class="line">            <span class="keyword">int</span> leftId = lson(id);</div><div class="line">            <span class="keyword">int</span> rightId = rson(id);</div><div class="line">            <span class="keyword">int</span> son;</div><div class="line">            <span class="keyword">if</span> (rightId &gt;= heap.size() || (comparesmall(heap.get(leftId), heap.get(rightId)) == <span class="keyword">true</span>)) &#123;</div><div class="line">                son = leftId;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                son = rightId;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (comparesmall(heap.get(id), heap.get(son)) == <span class="keyword">true</span>) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                swap(id, son);</div><div class="line">            &#125;</div><div class="line">            id = son;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Java的PriorityQueue">7. Java的PriorityQueue</h1><p><strong>Integer最小堆实例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Queue&lt;Integer&gt; integerPriorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="number">7</span>);</div><div class="line">Random rand = <span class="keyword">new</span> Random();</div><div class="line"><span class="comment">//放</span></div><div class="line">integerPriorityQueue.add(<span class="keyword">new</span> Integer(rand.nextInt(<span class="number">100</span>)));</div><div class="line"><span class="comment">//拿</span></div><div class="line">Integer in = integerPriorityQueue.poll();</div></pre></td></tr></table></figure>
<p><strong>Integer最大堆实例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Queue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(nums.length+<span class="number">1</span>,idComparator);</div><div class="line"><span class="comment">//放</span></div><div class="line">heap.add(e);</div><div class="line"><span class="comment">//拿</span></div><div class="line">heap.poll();</div><div class="line"><span class="comment">//匿名Comparator实现</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Comparator&lt;Integer&gt; idComparator = <span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer c1, Integer c2)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) (c2 - c1);</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>自定义类的最小堆</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Queue&lt;Customer&gt; cutomerPriorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="number">7</span>,idComparator);</div><div class="line"><span class="comment">//放</span></div><div class="line">customerPriorityQueue.add(<span class="keyword">new</span> Customer(id, <span class="string">"Pankaj "</span>+id));</div><div class="line"><span class="comment">//拿</span></div><div class="line">Customer cust = customerPriorityQueue.poll();</div><div class="line"></div><div class="line"><span class="comment">//匿名Comparator实现</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Comparator&lt;Customer&gt; idComparator = <span class="keyword">new</span> Comparator&lt;Customer&gt;()&#123;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Customer c1, Customer c2)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) (c1.getId() - c2.getId());</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h1 id="相关leetcode题">8. 相关leetcode题</h1><p>TOP K问题也有多种解决方案，比如排序，最后截取靠前或者靠后的K个数据。当数据量小的时候，排序解决起来当然可以，算法简单，排序算法也有很多现成的。当数据量很大时，维护一个很长的数组，不管是空间存储上还是排序耗费的时间上都可能难以接受。这时我们可以采用最小堆的方式来实现，只需要维护一个K长度的数组就行。</p>
<p>然而具体到问题，就会有非常多的变种。</p>
<h2 id="Kth-Largest-Element-in-an-Array">8.1. Kth Largest Element in an Array</h2><p>给一个数组 <code>[3,2,1,5,6,4]</code> 和 k = 2, 输出第k大的值，5</p>
<p>这道题用一个最大堆完成即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Comparator;</div><div class="line"><span class="keyword">import</span> java.util.PriorityQueue;</div><div class="line"><span class="keyword">import</span> java.util.Queue;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by jiayi on 2017/11/13.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        Queue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(nums.length+<span class="number">1</span>,idComparator);</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> e : nums )&#123;</div><div class="line">            heap.add(e);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> ( k&gt;<span class="number">1</span> )&#123;</div><div class="line">            heap.poll();</div><div class="line">            --k;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> heap.peek();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//匿名Comparator实现</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Comparator&lt;Integer&gt; idComparator = <span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer c1, Integer c2)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>) (c2 - c1);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>&#125;;</div><div class="line">        <span class="keyword">int</span> k = <span class="number">2</span>;</div><div class="line">        System.out.println(<span class="keyword">new</span> Main().findKthLargest(nums,k));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Top-K-Frequent-Elements">8.2. Top K Frequent Elements</h2><p>给一个int[],输出频率最高的k个数字。</p>
<p>For example,<br>Given <code>[1,1,1,2,2,3]</code> and k = 2, return <code>[1,2]</code>.</p>
<p>思路：直接建一个堆，在遍历的同时对堆进行维护。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt;</span>&#123;</div><div class="line">        Integer s;</div><div class="line">        <span class="keyword">int</span> count;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node o)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.count &gt; o.count)&#123;</div><div class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.count == o.count)&#123;</div><div class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.s.compareTo(o.s)&gt;<span class="number">0</span>)&#123;</div><div class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">                &#125;<span class="keyword">else</span>&#123;</div><div class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        Node(Integer s,<span class="keyword">int</span> count)&#123;</div><div class="line">            <span class="keyword">this</span>.s = s;</div><div class="line">            <span class="keyword">this</span>.count = count;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">HashHeap</span></span>&#123;</div><div class="line">        Node[] E;</div><div class="line">        HashMap&lt;Integer,Integer&gt; map;</div><div class="line">        <span class="keyword">int</span> heapSize;</div><div class="line">        <span class="keyword">int</span> k;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">HashHeap</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">            E = <span class="keyword">new</span> Node[k+<span class="number">1</span>];</div><div class="line">            heapSize = <span class="number">0</span>;</div><div class="line">            map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">            <span class="keyword">this</span>.k = k ;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">left</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="number">2</span> * i;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">right</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">father</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</div><div class="line">            <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</div><div class="line">                <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> i/<span class="number">2</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">brother</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</div><div class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</div><div class="line">                <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</div><div class="line">                <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(i==<span class="number">2</span>)&#123;</div><div class="line">                <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</div><div class="line">                <span class="keyword">return</span> i+<span class="number">1</span>;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                <span class="keyword">return</span> i-<span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</div><div class="line">            <span class="keyword">int</span> indexq = map.get(E[q].s);</div><div class="line">            map.replace(E[q].s,map.get(E[p].s));</div><div class="line">            map.replace(E[p].s,indexq);</div><div class="line">            Node temp = E[p];</div><div class="line">            E[p] = E[q];</div><div class="line">            E[q] = temp;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Push</span><span class="params">(Node e)</span></span>&#123;</div><div class="line">            E[heapSize] = e;</div><div class="line">            heapSize+=<span class="number">1</span>;</div><div class="line">            map.put(e.s,heapSize-<span class="number">1</span>);</div><div class="line">            FixUP(heapSize-<span class="number">1</span>);</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">FixUP</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</div><div class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)<span class="keyword">return</span>;</div><div class="line">            <span class="keyword">int</span> father = father(i);</div><div class="line">            <span class="keyword">if</span>(E[father].compareTo(E[i])&gt;<span class="number">0</span>) &#123;</div><div class="line">                swap(i, father);</div><div class="line">            &#125;</div><div class="line">            FixUP(father);</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">private</span> Node <span class="title">Pop</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">if</span>(heapSize==<span class="number">0</span>)&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">            swap(<span class="number">0</span>,heapSize-<span class="number">1</span>);</div><div class="line">            heapSize-=<span class="number">1</span>;</div><div class="line">            FixDown(<span class="number">0</span>);</div><div class="line">            <span class="keyword">return</span> E[heapSize];</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">FixDown</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">            <span class="keyword">int</span> l = left(i);</div><div class="line">            <span class="keyword">int</span> r = right(i);</div><div class="line">            <span class="keyword">int</span> min = -<span class="number">1</span>;</div><div class="line">            <span class="keyword">if</span> (l &lt; <span class="keyword">this</span>.heapSize &amp;&amp; E[l].compareTo(E[i])&lt;<span class="number">0</span>)&#123;</div><div class="line">                min = l;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                min = i;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>( r &lt; <span class="keyword">this</span>.heapSize &amp;&amp; E[r].compareTo(E[min])&lt;<span class="number">0</span> )&#123;</div><div class="line">                min = r;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>( min != i )&#123;</div><div class="line">                swap(i,min);</div><div class="line">                FixDown(min);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">count_add1</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</div><div class="line">            <span class="keyword">int</span> index = map.get(s);</div><div class="line">            E[index].count+=<span class="number">1</span>;</div><div class="line">            FixUP(index);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        HashHeap heap = <span class="keyword">new</span> HashHeap(nums.length);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length ; i += <span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(heap.map.containsKey(nums[i]))&#123;</div><div class="line">                heap.count_add1(nums[i]);<span class="comment">//同时对堆进行维护</span></div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                heap.Push(<span class="keyword">new</span> Node(nums[i],<span class="number">1</span>));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; k ; i += <span class="number">1</span>)&#123;</div><div class="line">            ans.add(heap.Pop().s);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ans;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Kth-Smallest-Element-in-a-Sorted-Matrix">8.3. Kth Smallest Element in a Sorted Matrix</h2><p><strong>原题</strong></p>
<p>Given a <em>n</em> x <em>n</em> matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.</p>
<p>Note that it is the kth smallest element in the sorted order, not the kth distinct element.</p>
<p>给一个 <em>n</em> x <em>n</em>的数组，行列都有序（即$A[i][j]&lt;A[i+1][j]且A[i][j]&lt;A[i][j+1]$）。找到第K小的元素。</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">matrix = [</div><div class="line">   [ 1,  5,  9],</div><div class="line">   [10, 11, 13],</div><div class="line">   [12, 13, 15]</div><div class="line">],</div><div class="line">k = 8,</div><div class="line"></div><div class="line">return 13.</div></pre></td></tr></table></figure>
<p><strong>Note: </strong><br>You may assume k is always valid, 1 ≤ k ≤ n2.</p>
<p><strong>思路</strong></p>
<p>如果这道题用堆来解决，思考过程如下：</p>
<ul>
<li>k=1时，堆为[1]，此时第一小为1</li>
<li>k=2时，第2小一定是1的右或下，那就将它两都放进去。而同时1不可能是第二小，那就提前把它拿出来。那么堆为[5,10]，此时第2小为5</li>
<li>k=3时，第3小一定是5的右/下，或者就是10本身。而且不可能是5。此时堆为[9,10,11]，那么第3小就是9</li>
<li>k=4时，第4小一定是9的右/下，或者就是10本身。而且不可能是9。此时堆为[10,11,12]，那么第4小就是10</li>
</ul>
<p>将以上思考过程写为代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</div><div class="line">        <span class="keyword">int</span> x;</div><div class="line">        <span class="keyword">int</span> y;</div><div class="line">        <span class="keyword">int</span> val;</div><div class="line">        Node(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> val)&#123;</div><div class="line">            <span class="keyword">this</span>.x = x;</div><div class="line">            <span class="keyword">this</span>.y = y;</div><div class="line">            <span class="keyword">this</span>.val = val;</div><div class="line">        &#125;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node o1)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.val - o1.val;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(matrix.length==<span class="number">0</span> || matrix[<span class="number">0</span>].length==<span class="number">0</span>)<span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        <span class="keyword">boolean</span>[][] hash = <span class="keyword">new</span> <span class="keyword">boolean</span>[matrix.length][matrix[<span class="number">0</span>].length];</div><div class="line">        Queue&lt;Node&gt; priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k);</div><div class="line">        Node top_i;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i+=<span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(priorityQueue.size()==<span class="number">0</span>)&#123;</div><div class="line">               priorityQueue.add(<span class="keyword">new</span> Node(<span class="number">0</span>,<span class="number">0</span>,matrix[<span class="number">0</span>][<span class="number">0</span>]));</div><div class="line">            &#125;<span class="keyword">else</span> &#123;</div><div class="line">                top_i = priorityQueue.poll();</div><div class="line">                <span class="keyword">if</span>(top_i.x+<span class="number">1</span>&lt;matrix[top_i.y].length &amp;&amp; !hash[top_i.x+<span class="number">1</span>][top_i.y]) &#123;</div><div class="line">                    hash[top_i.x+<span class="number">1</span>][top_i.y]=<span class="keyword">true</span>;</div><div class="line">                    priorityQueue.add(<span class="keyword">new</span> Node(top_i.x + <span class="number">1</span>, top_i.y, matrix[top_i.x + <span class="number">1</span>][top_i.y]));</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(top_i.y+<span class="number">1</span>&lt;matrix.length &amp;&amp; !hash[top_i.x][top_i.y+<span class="number">1</span>]) &#123;</div><div class="line">                    hash[top_i.x][top_i.y+<span class="number">1</span>]=<span class="keyword">true</span>;</div><div class="line">                    priorityQueue.add(<span class="keyword">new</span> Node(top_i.x, top_i.y + <span class="number">1</span>, matrix[top_i.x][top_i.y + <span class="number">1</span>]));</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>  priorityQueue.peek().val;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>由于堆的add和poll操作的复杂度都是log(m)，其中m是堆的大小。</p>
<p>而此题堆长度不大于k，因此粗略来看总体复杂度为$O(klog(k))$。</p>
<p>但经过我测试发现，假设输入数组为$n \times n$，当$k&gt;n$时，堆长度是一定不大于n的。这里我有点想不通。</p>
<p><strong>另一种堆的思路</strong></p>
<p>以下这种方式，仅仅只需要向下遍历。我们从第一行构建初始的最小堆，每次从中移除一个元素，再从下一行的对应位置加一个元素进入最小堆（思考一下，这样做保证了所有元素按从小到大的顺序加入最小堆，同时不加入过多元素），执行k-1次这个过程，堆顶元素即为所求。 </p>
<p>时间复杂度：O（klogn) </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> n = matrix.length;</div><div class="line">        PriorityQueue&lt;Tuple&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;Tuple&gt;();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n-<span class="number">1</span>; j++) pq.offer(<span class="keyword">new</span> Tuple(<span class="number">0</span>, j, matrix[<span class="number">0</span>][j]));</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k-<span class="number">1</span>; i++) &#123;</div><div class="line">            Tuple t = pq.poll();</div><div class="line">            <span class="keyword">if</span>(t.x == n-<span class="number">1</span>) <span class="keyword">continue</span>;</div><div class="line">            pq.offer(<span class="keyword">new</span> Tuple(t.x+<span class="number">1</span>, t.y, matrix[t.x+<span class="number">1</span>][t.y]));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> pq.poll().val;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tuple</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Tuple</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">int</span> x, y, val;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tuple</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> val)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.x = x;</div><div class="line">        <span class="keyword">this</span>.y = y;</div><div class="line">        <span class="keyword">this</span>.val = val;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span> <span class="params">(Tuple that)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.val - that.val;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>骚操作——二分法</strong></p>
<p>先找到数组的最大值和最小值，然后以此作为二叉搜索的左右两边，求出其中间值，然后看比该值小的有多少个，是否满足条件，如果满足条件就返回，不然就将左右边界修改为mid即可。代码入下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> n = matrix.length;</div><div class="line">        <span class="keyword">int</span> lo = matrix[<span class="number">0</span>][<span class="number">0</span>], hi = matrix[n - <span class="number">1</span>][n - <span class="number">1</span>];</div><div class="line">        <span class="keyword">while</span> (lo &lt;= hi) &#123;</div><div class="line">            <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</div><div class="line">            <span class="keyword">int</span> count = getLessEqual(matrix, mid);</div><div class="line">            <span class="keyword">if</span> (count &lt; k) lo = mid + <span class="number">1</span>;</div><div class="line">            <span class="keyword">else</span> hi = mid - <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> lo;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getLessEqual</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> val)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> n = matrix.length, i = n - <span class="number">1</span>, j = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n) &#123;</div><div class="line">            <span class="keyword">if</span> (matrix[i][j] &gt; val) i--;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                res += i + <span class="number">1</span>;</div><div class="line">                j++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Find-K-Pairs-with-Smallest-Sums">8.4. Find K Pairs with Smallest Sums</h2><p><strong>题目</strong></p>
<p>You are given two integer arrays <strong>nums1</strong> and <strong>nums2</strong> sorted in ascending order and an integer <strong>k</strong>.</p>
<p>Define a pair <strong>(u,v)</strong> which consists of one element from the first array and one element from the second array.</p>
<p>Find the k pairs <strong>(u1,v1),(u2,v2) …(uk,vk)</strong> with the smallest sums.</p>
<p>给定两个数组nums1和nums2，找到nums1[i] + nums2[i] 的从最小到第k小的对(i,j)，并返回。</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Given nums1 = [1,7,11], nums2 = [2,4,6],  k = 3</div><div class="line"></div><div class="line">Return: [1,2],[1,4],[1,6]</div><div class="line"></div><div class="line">The first 3 pairs are returned from the sequence:</div><div class="line">[1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]</div></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Given nums1 = [1,1,2], nums2 = [1,2,3],  k = 2</div><div class="line"></div><div class="line">Return: [1,1],[1,1]</div><div class="line"></div><div class="line">The first 2 pairs are returned from the sequence:</div><div class="line">[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]</div></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Given nums1 = [1,2], nums2 = [3],  k = 3 </div><div class="line"></div><div class="line">Return: [1,3],[2,3]</div><div class="line"></div><div class="line">All possible pairs are returned from the sequence:</div><div class="line">[1,3],[2,3]</div></pre></td></tr></table></figure>
<p>这道题与上一道题非常像。要注意的有几点：</p>
<ol>
<li>并没有说两个数组已排序；</li>
<li>并没有说k会小于num1.length * nums2.length</li>
</ol>
<p><strong>思路</strong></p>
<p>首先将nums1和nums2排序，然后列出如下表：</p>
<table>
<thead>
<tr>
<th>nums2  nums1</th>
<th>1</th>
<th>7</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>2+1</td>
<td>2+7</td>
<td>2+4</td>
</tr>
<tr>
<td>4</td>
<td>4+1</td>
<td>4+7</td>
<td>4+4</td>
</tr>
<tr>
<td>6</td>
<td>6+1</td>
<td>6+7</td>
<td>6+4</td>
</tr>
</tbody>
</table>
<p>然后这道题就转化成了上一道题！按照上一道题的思路解即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</div><div class="line">        <span class="keyword">int</span> x;</div><div class="line">        <span class="keyword">int</span> y;</div><div class="line">        <span class="keyword">int</span> val;</div><div class="line">        Node(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> val)&#123;</div><div class="line">            <span class="keyword">this</span>.x = x;</div><div class="line">            <span class="keyword">this</span>.y = y;</div><div class="line">            <span class="keyword">this</span>.val = val;</div><div class="line">        &#125;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node o1)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.val - o1.val;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> List&lt;<span class="keyword">int</span>[]&gt; kSmallestPairs(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> k) &#123;</div><div class="line">        List&lt;<span class="keyword">int</span>[]&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">if</span>(nums1.length==<span class="number">0</span> || nums2.length==<span class="number">0</span> || k==<span class="number">0</span>) <span class="keyword">return</span> result;</div><div class="line">        <span class="keyword">if</span>(k&gt;nums1.length*nums2.length) k = nums1.length*nums2.length;</div><div class="line">        Arrays.sort(nums1);</div><div class="line">        Arrays.sort(nums2);</div><div class="line">        <span class="keyword">int</span> i,x,y;</div><div class="line">        Queue&lt;Node&gt; priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k);</div><div class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nums1.length;i+=<span class="number">1</span>)&#123;</div><div class="line">            priorityQueue.offer(<span class="keyword">new</span> Node(i,<span class="number">0</span>,nums2[<span class="number">0</span>]+nums1[i]));</div><div class="line">        &#125;</div><div class="line">        Node temp;</div><div class="line">        k-=<span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; k ; i+=<span class="number">1</span>)&#123;</div><div class="line">            temp = priorityQueue.poll();</div><div class="line">            x = temp.x;</div><div class="line">            y = temp.y;</div><div class="line">            <span class="keyword">int</span>[] aRes = &#123;nums1[x],nums2[y]&#125;;</div><div class="line">            result.add(aRes);</div><div class="line">            <span class="keyword">if</span>(y+<span class="number">1</span>&lt;nums2.length)</div><div class="line">                priorityQueue.offer(<span class="keyword">new</span> Node(x,y+<span class="number">1</span>,nums1[x]+nums2[y+<span class="number">1</span>]));</div><div class="line">        &#125;</div><div class="line">        temp = priorityQueue.poll();</div><div class="line">        x = temp.x;</div><div class="line">        y = temp.y;</div><div class="line">        <span class="keyword">int</span>[] aRes = &#123;nums1[x],nums2[y]&#125;;</div><div class="line">        result.add(aRes);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Merge-k-Sorted-Lists">8.5. Merge k Sorted Lists</h2><p>这道题给了k个链表ListNode[k] lists。每个链表都已排序。将这k个链表merge为一个有序链表。</p>
<p>思路：由于每次都要拿出最小的，那么一种解法就是用维护一个最小堆，最小堆的元素由当前的表头元素组成。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Comparator;</div><div class="line"><span class="keyword">import</span> java.util.PriorityQueue;</div><div class="line"><span class="keyword">import</span> java.util.Queue;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by jiayi on 2017/11/13.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> val;</div><div class="line">        ListNode next;</div><div class="line">        ListNode(<span class="keyword">int</span> x)&#123;</div><div class="line">            val = x;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  <span class="comment">//优先队列的元素</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt;</span>&#123;</div><div class="line">        <span class="keyword">int</span> val;</div><div class="line">        <span class="keyword">int</span> idx;</div><div class="line">        Node(<span class="keyword">int</span> val,<span class="keyword">int</span> idx)&#123;</div><div class="line">            <span class="keyword">this</span>.val = val ;</div><div class="line">            <span class="keyword">this</span>.idx = idx ;</div><div class="line">        &#125;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node o)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.val - o.val;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    Queue&lt;Node&gt; priorityQueue;</div><div class="line">  <span class="comment">// 将链表list的头加入到优先队列中，并删除当前的头</span></div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">add</span><span class="params">(ListNode list,<span class="keyword">int</span> idx)</span></span>&#123;</div><div class="line">        priorityQueue.add(<span class="keyword">new</span> Node(list.val,idx));</div><div class="line">        list = list.next;</div><div class="line">        <span class="keyword">return</span> list;</div><div class="line">    &#125;</div><div class="line">   <span class="comment">// merge 部分</span></div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>( lists.length == <span class="number">0</span> )<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(lists.length);</div><div class="line">        <span class="keyword">int</span> hashCount = <span class="number">0</span>;</div><div class="line">        <span class="keyword">boolean</span>[] hash = <span class="keyword">new</span> <span class="keyword">boolean</span>[lists.length];</div><div class="line">      <span class="comment">//把当前每个链表的头以此加入进优先队列</span></div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; lists.length ; ++i )&#123;</div><div class="line">            <span class="keyword">if</span>( <span class="keyword">null</span> == lists[i] )&#123;</div><div class="line">                hash[i] = <span class="keyword">true</span>;</div><div class="line">                ++hashCount;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                lists[i] = add(lists[i],i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">      <span class="comment">// 如果当前链表全部为空</span></div><div class="line">        <span class="keyword">if</span>( hashCount == lists.length )&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">       <span class="comment">// 初始化</span></div><div class="line">        Node min = priorityQueue.poll();</div><div class="line">        ListNode root = <span class="keyword">new</span> ListNode(min.val);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != lists[min.idx]) &#123;</div><div class="line">            lists[min.idx] = add(lists[min.idx], min.idx);</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">if</span>( !hash[min.idx] )&#123;</div><div class="line">                hash[min.idx] = <span class="keyword">true</span>;</div><div class="line">                ++hashCount;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>( hashCount == lists.length )&#123;</div><div class="line">            <span class="keyword">return</span> root;</div><div class="line">        &#125;</div><div class="line">        ListNode r = root;</div><div class="line">      <span class="comment">// 每次从堆中取出一个最小元素，然后将这个最小元素对应的链表的头加入到最小堆中</span></div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            min = priorityQueue.poll();</div><div class="line">            ListNode temp = <span class="keyword">new</span> ListNode(min.val);</div><div class="line">            r.next = temp;</div><div class="line">            r = r.next;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != lists[min.idx]) &#123;</div><div class="line">                lists[min.idx] = add(lists[min.idx], min.idx);</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                <span class="keyword">if</span>( ! hash[min.idx] )&#123;</div><div class="line">                    hash[min.idx] = <span class="keyword">true</span>;</div><div class="line">                    ++hashCount;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(hashCount == lists.length)&#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> root;</div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div><div class="line">   <span class="comment">// 辅助函数，将数组插入到链表中</span></div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">insert</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</div><div class="line">        ListNode root = <span class="keyword">new</span> ListNode(a[<span class="number">0</span>]);</div><div class="line">        ListNode r = root;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length ; ++i )&#123;</div><div class="line">            ListNode l = <span class="keyword">new</span> ListNode(a[i]);</div><div class="line">            r.next = l;</div><div class="line">            r = r.next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> root;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span>[] a1 = &#123;<span class="number">1</span>&#125;;</div><div class="line">        <span class="keyword">int</span>[] a2 = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</div><div class="line">        Main t = <span class="keyword">new</span> Main();</div><div class="line">        ListNode[] lists = <span class="keyword">new</span> ListNode[<span class="number">1</span>];</div><div class="line">        lists[<span class="number">0</span>] = t.insert(a1);</div><div class="line"><span class="comment">//        lists[1] = t.insert(a2);</span></div><div class="line">        t.mergeKLists(lists);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>但是！还有一种更骚的操作！</strong>！把每个LinkNode看做一个元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Comparator&lt;ListNode&gt; ListNodeComparator = <span class="keyword">new</span> Comparator&lt;ListNode&gt;() &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(ListNode left, ListNode right)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> left.val - right.val;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(List&lt;ListNode&gt; lists)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (lists == <span class="keyword">null</span> || lists.size() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        Queue&lt;ListNode&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;ListNode&gt;(lists.size(), ListNodeComparator);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lists.size(); i++) &#123;</div><div class="line">            <span class="keyword">if</span> (lists.get(i) != <span class="keyword">null</span>) &#123;</div><div class="line">                heap.add(lists.get(i));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        ListNode tail = dummy;</div><div class="line">        <span class="keyword">while</span> (!heap.isEmpty()) &#123;</div><div class="line">            ListNode head = heap.poll();</div><div class="line">            tail.next = head;</div><div class="line">            tail = head;</div><div class="line">            <span class="keyword">if</span> (head.next != <span class="keyword">null</span>) &#123;</div><div class="line">                heap.add(head.next);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dummy.next;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="Design-Twitter">8.6. Design Twitter</h2><p>这道题非常繁琐。要设计一个twitter类，使得它能够实现以下功能：</p>
<ol>
<li><strong>postTweet(userId, tweetId)</strong>: 发tweet</li>
<li><strong>getNewsFeed(userId)</strong>: 返回用户userId关注好友的最近10个feed流，并按发表时间输出</li>
<li><strong>follow(followerId, followeeId)</strong>: Follower 关注 followee.</li>
<li><strong>unfollow(followerId, followeeId)</strong>: Follower取关 followee（如果它想取关它自己，就什么都不做）</li>
</ol>
<p>思路：这道题主要要设计很多类。核心算法与上一题相同，一定要参考上一题的解法二。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.lang.reflect.Array;</div><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by jiayi on 2017/11/16.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Twitter</span> </span>&#123;</div><div class="line">    HashMap&lt;Integer,User&gt; users;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> time;</div><div class="line">    <span class="comment">/** 初始化 */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Twitter</span><span class="params">()</span> </span>&#123;</div><div class="line">        users = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        time = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">timego</span><span class="params">()</span></span>&#123;</div><div class="line">        ++<span class="keyword">this</span>.time;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.time;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	<span class="comment">//一条信息</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">tweet</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">tweet</span>&gt;</span>&#123;</div><div class="line">        <span class="keyword">int</span> tweetId;</div><div class="line">        <span class="keyword">int</span> userId;</div><div class="line">        <span class="keyword">int</span> time;</div><div class="line">        tweet(<span class="keyword">int</span> tweetId,<span class="keyword">int</span> userId, <span class="keyword">int</span> time)&#123;</div><div class="line">            <span class="keyword">this</span>.tweetId = tweetId;</div><div class="line">            <span class="keyword">this</span>.time = time;</div><div class="line">            <span class="keyword">this</span>.userId = userId;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(tweet o)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> o.time - <span class="keyword">this</span>.time;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 信息流类，用链表表示</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ListTweet</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">ListTweet</span>&gt;</span>&#123;</div><div class="line">        tweet tw;</div><div class="line">        ListTweet next;</div><div class="line">        ListTweet()&#123;</div><div class="line">            tw = <span class="keyword">null</span>;</div><div class="line">            next = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        ListTweet(tweet tw)&#123;</div><div class="line">            <span class="keyword">this</span>.tw = tw;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(ListTweet o)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.tw.compareTo(o.tw);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//用户类</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> userId;</div><div class="line">        ListTweet feed;</div><div class="line">        ListTweet feed_readed;</div><div class="line">        HashSet&lt;Integer&gt; follows;</div><div class="line">        <span class="keyword">int</span> helper;</div><div class="line">        User(<span class="keyword">int</span> userId)&#123;</div><div class="line">            <span class="keyword">this</span>.userId = userId;</div><div class="line">            feed = <span class="keyword">new</span> ListTweet();</div><div class="line">            follows = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">            follows.add(userId);</div><div class="line">            helper = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">       	<span class="comment">//发微博</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(<span class="keyword">int</span> tweetId)</span></span>&#123;</div><div class="line">            ListTweet tw = <span class="keyword">new</span> ListTweet(<span class="keyword">new</span> tweet(tweetId,<span class="keyword">this</span>.userId,timego()));</div><div class="line">            tw.next = <span class="keyword">this</span>.feed;</div><div class="line">            <span class="keyword">this</span>.feed = tw;</div><div class="line">        &#125;</div><div class="line">       	<span class="comment">//关注某人</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFollows</span><span class="params">(<span class="keyword">int</span> followId)</span></span>&#123;</div><div class="line">            <span class="keyword">if</span>(!follows.contains(followId))</div><div class="line">                follows.add(followId);</div><div class="line">        &#125;</div><div class="line">      	<span class="comment">//取关</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unFollow</span><span class="params">(<span class="keyword">int</span> folleeId)</span></span>&#123;</div><div class="line">            <span class="keyword">if</span>(follows.contains(folleeId))&#123;</div><div class="line">                follows.remove(folleeId);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/** 用户userId发一条tweeter tweetId */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postTweet</span><span class="params">(<span class="keyword">int</span> userId, <span class="keyword">int</span> tweetId)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>( ! users.containsKey(userId) )&#123;</div><div class="line">            users.put(userId,<span class="keyword">new</span> User(userId));</div><div class="line">        &#125;</div><div class="line">        users.get(userId).post(tweetId);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** 返回用户userId关注好友的最近10个feed流，并按发表时间输出 */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getNewsFeed</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</div><div class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        Queue&lt;ListTweet&gt; feeds = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="number">10</span>);</div><div class="line">        <span class="keyword">if</span>( !users.containsKey(userId) )&#123;</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">        User user = users.get(userId);</div><div class="line">        <span class="comment">// 获取用户所有好友</span></div><div class="line">        HashSet&lt;Integer&gt; follows = user.follows;</div><div class="line">        <span class="comment">//获取每个好友feed流</span></div><div class="line">        <span class="keyword">for</span>( Integer f : follows )&#123;</div><div class="line">            ListTweet f_feeds = users.get(f).feed;</div><div class="line">            <span class="keyword">if</span>(<span class="keyword">null</span> != f_feeds.tw)feeds.offer(f_feeds);</div><div class="line">        &#125;</div><div class="line">		<span class="comment">//骚操作</span></div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (!feeds.isEmpty())&#123;</div><div class="line">            ListTweet head = feeds.poll();</div><div class="line">            result.add(head.tw.tweetId);</div><div class="line">            <span class="keyword">if</span>(<span class="keyword">null</span> != head.next.tw)feeds.offer(head.next);</div><div class="line">            ++i;</div><div class="line">            <span class="keyword">if</span>( i == <span class="number">10</span> )&#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**用户follderid关注followee**/</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">follow</span><span class="params">(<span class="keyword">int</span> followerId, <span class="keyword">int</span> followeeId)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(! users.containsKey(followeeId) )&#123;</div><div class="line">            users.put(followeeId,<span class="keyword">new</span> User(followeeId));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(! users.containsKey(followerId) )&#123;</div><div class="line">            users.put(followerId,<span class="keyword">new</span> User(followerId));</div><div class="line">        &#125;</div><div class="line">        User er = users.get(followerId);</div><div class="line"></div><div class="line">        er.setFollows(followeeId);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** 取关，如果操作非法，则什么都不做 **/</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unfollow</span><span class="params">(<span class="keyword">int</span> followerId, <span class="keyword">int</span> followeeId)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(followeeId == followerId)<span class="keyword">return</span>;</div><div class="line">        <span class="keyword">if</span>(! users.containsKey(followeeId) )&#123;</div><div class="line">            users.put(followeeId,<span class="keyword">new</span> User(followeeId));</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(! users.containsKey(followerId) )&#123;</div><div class="line">            users.put(followerId,<span class="keyword">new</span> User(followerId));</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        User er = users.get(followerId);</div><div class="line">        er.unFollow(followeeId);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        Twitter twitter = <span class="keyword">new</span> Twitter();</div><div class="line">        <span class="comment">// User 1 posts a new tweet (id = 5).</span></div><div class="line"></div><div class="line">        twitter.postTweet(<span class="number">1</span>, <span class="number">1</span>);</div><div class="line"></div><div class="line">        <span class="comment">// User 1's news feed should return a list with 1 tweet id -&gt; [5].</span></div><div class="line">        System.out.println(twitter.getNewsFeed(<span class="number">1</span>));</div><div class="line">        <span class="comment">// User 1 follows user 2.</span></div><div class="line">        twitter.follow(<span class="number">2</span>, <span class="number">1</span>);</div><div class="line">        System.out.println(twitter.getNewsFeed(<span class="number">2</span>));</div><div class="line"><span class="comment">// User 2 posts a new tweet (id = 6).</span></div><div class="line">        twitter.postTweet(<span class="number">2</span>, <span class="number">6</span>);</div><div class="line"></div><div class="line"><span class="comment">// User 1's news feed should return a list with 2 tweet ids -&gt; [6, 5].</span></div><div class="line"><span class="comment">// Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.</span></div><div class="line">        System.out.println(twitter.getNewsFeed(<span class="number">1</span>));</div><div class="line">        twitter.unfollow(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line"></div><div class="line"><span class="comment">// User 1's news feed should return a list with 1 tweet id -&gt; [5],</span></div><div class="line"><span class="comment">// since user 1 is no longer following user 2.</span></div><div class="line">        System.out.println(twitter.getNewsFeed(<span class="number">1</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Split-Array-into-Consecutive-Subsequences">8.7. Split Array into Consecutive Subsequences</h2><p>给一个数组<code>[1,2,3,3,4,5]</code>，问它能不能分成多个长度大于3的连续子数组[1,2,3]和[3,4,5]。</p>
<p>思路：对我来说较难。很绕。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">==================step <span class="number">1</span>==================</div><div class="line"><span class="comment">//首先假设已经有两个连续子数组了：</span></div><div class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</div><div class="line">==================step <span class="number">2</span>==================</div><div class="line"><span class="comment">//in --&gt; 3</span></div><div class="line"><span class="comment">//之前子数组末尾没有3-1=2，开启新的子数组</span></div><div class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</div><div class="line">b = [<span class="number">3</span>]</div><div class="line">==================step <span class="number">3</span>==================</div><div class="line"><span class="comment">//in --&gt; 4</span></div><div class="line"><span class="comment">//之前的子数组的末尾有4-1=3，且有两个，选择较短的那个</span></div><div class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</div><div class="line">b = [<span class="number">3</span>,<span class="number">4</span>]</div><div class="line">==================step <span class="number">4</span>==================</div><div class="line"><span class="comment">// in --&gt; 5</span></div><div class="line"><span class="comment">//之前的子数组的末尾有5-1=4</span></div><div class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</div><div class="line">b = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</div><div class="line">==================step <span class="number">5</span>==================</div><div class="line"><span class="comment">//子数组长度都&gt;=3。返回true</span></div></pre></td></tr></table></figure>
<p>其实这个过程我们只需要维护每个子数组的最大值！</p>
<p>维护一个hashMap，key是当前某子数组的最大值，value是子数组的长度。由于同一个key可能对应多个value，且每次我们都要取最小值。因此我们将value设置为一个最小堆。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPossible</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</div><div class="line">        HashMap&lt;Integer,Queue&lt;Integer&gt;&gt; helper = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        Queue&lt;Integer&gt; heap;</div><div class="line">        <span class="keyword">int</span> min_count;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 流程</div><div class="line">         * 假设输入[1,2,3,3,4,5]</div><div class="line">         * [1] -&gt; helper = [1,[1]]</div><div class="line">         * [2] -&gt; helper = [2,[2]]</div><div class="line">         * [3] -&gt; helper = [3,[3]]</div><div class="line">         * [3] -&gt; helper = [3,[1,3]]</div><div class="line">         * [4] -&gt; helper = [3,[3]],[4,[1]]</div><div class="line">         * [5] -&gt; helper = [3,[3]],[5,[2]]</div><div class="line">         * **/</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> n : nums )&#123;</div><div class="line">            <span class="keyword">if</span>( helper.containsKey(n-<span class="number">1</span>) )&#123;</div><div class="line">                heap = helper.get(n-<span class="number">1</span>);</div><div class="line">                min_count = heap.poll()+<span class="number">1</span>;</div><div class="line">                <span class="keyword">if</span>( heap.isEmpty() ) helper.remove(n-<span class="number">1</span>);</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                min_count = <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>( !helper.containsKey(n) )&#123;</div><div class="line">                helper.put(n,<span class="keyword">new</span> PriorityQueue&lt;&gt;());</div><div class="line">            &#125;</div><div class="line">            heap = helper.get(n);</div><div class="line">            heap.offer(min_count);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer, Queue&lt;Integer&gt;&gt; key : helper.entrySet())&#123;</div><div class="line">            heap = key.getValue();</div><div class="line">            <span class="keyword">while</span> (!heap.isEmpty())&#123;</div><div class="line">                <span class="keyword">if</span>(heap.poll() &lt; <span class="number">3</span>)&#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="Trapping-Rain-Water-II">8.8. Trapping Rain Water II</h2><p>给一个二维数组，假设这是一个台子。边界没有挡板。求问这个台子最多能乘多少雨水。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  [1,4,3,1,3,2],</div><div class="line">  [3,2,1,3,2,4],</div><div class="line">  [2,3,3,2,3,1]</div><div class="line">]</div><div class="line">返回4</div></pre></td></tr></table></figure>
<p>这道题相对来说比较难。思路就是用堆维护一个最小边界，每次根据这个最小边界进行填水。</p>
<ul>
<li>维护一个最小堆，保存最外面一圈的高度，因为最矮的格子决定了水能存放多少</li>
<li>每次取最小高度 h，与周围4个中没有被访问过的元素进行比较<ul>
<li>如果该元素的高度小于 h，则注水到其中，并将其加入到最小堆中，设置该元素被访问过</li>
<li>如果该元素的高度大于 h，则直接将其加入到最小堆中，设置改元素被访问过</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt;</span>&#123;</div><div class="line">        <span class="keyword">int</span> h;</div><div class="line">        <span class="keyword">int</span> i;</div><div class="line">        <span class="keyword">int</span> j;</div><div class="line">        Node(<span class="keyword">int</span> h,<span class="keyword">int</span> i,<span class="keyword">int</span> j)&#123;</div><div class="line">            <span class="keyword">this</span>.h = h;</div><div class="line">            <span class="keyword">this</span>.i = i;</div><div class="line">            <span class="keyword">this</span>.j = j;</div><div class="line">        &#125;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node o)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.h - o.h;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trapRainWater</span><span class="params">(<span class="keyword">int</span>[][] heightMap)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>( heightMap.length &lt;= <span class="number">2</span> || heightMap[<span class="number">0</span>].length &lt;= <span class="number">2</span> )<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        Queue&lt;Node&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</div><div class="line">        <span class="keyword">int</span>[] bound_j = &#123;<span class="number">0</span>,heightMap[<span class="number">0</span>].length-<span class="number">1</span>&#125;;</div><div class="line">        <span class="keyword">int</span>[] bound_i = &#123;<span class="number">0</span>,heightMap.length-<span class="number">1</span>&#125;;</div><div class="line">        <span class="keyword">boolean</span>[][] hash = <span class="keyword">new</span> <span class="keyword">boolean</span>[heightMap.length][heightMap[<span class="number">0</span>].length];</div><div class="line">        <span class="keyword">int</span> i,j;</div><div class="line">        <span class="keyword">int</span> count = heightMap.length * heightMap[<span class="number">0</span>].length ;</div><div class="line">        <span class="comment">//将边界放入堆</span></div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> b : bound_i )&#123;</div><div class="line">            <span class="keyword">for</span>( j = <span class="number">0</span> ; j &lt; heightMap[<span class="number">0</span>].length ; ++j )&#123;</div><div class="line">                heap.offer(<span class="keyword">new</span> Node(heightMap[b][j],b,j));</div><div class="line">                hash[b][j] = <span class="keyword">true</span>;</div><div class="line">                --count;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> b : bound_j )&#123;</div><div class="line">            <span class="keyword">for</span>( i = <span class="number">1</span> ; i &lt; heightMap.length-<span class="number">1</span> ; ++i )&#123;</div><div class="line">                heap.offer(<span class="keyword">new</span> Node(heightMap[i][b],i,b));</div><div class="line">                hash[i][b] = <span class="keyword">true</span>;</div><div class="line">                --count;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        Node min;</div><div class="line">        <span class="keyword">int</span>[] ii = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,-<span class="number">1</span>&#125;;</div><div class="line">        <span class="keyword">int</span>[] jj = &#123;<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</div><div class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> k;</div><div class="line">        <span class="keyword">while</span> (count &gt; <span class="number">0</span>)&#123;</div><div class="line">            min = heap.poll();</div><div class="line">            <span class="comment">//检查min的上下左右</span></div><div class="line">            <span class="keyword">for</span>( k = <span class="number">0</span> ; k &lt; ii.length ; ++k )&#123;</div><div class="line">                i = min.i + ii[k];</div><div class="line">                j = min.j + jj[k];</div><div class="line">                <span class="keyword">if</span>( i &lt; <span class="number">0</span> || i &gt;= hash.length || j &lt; <span class="number">0</span> || j &gt;= hash[<span class="number">0</span>].length )<span class="keyword">continue</span>;</div><div class="line">                <span class="keyword">if</span>(!hash[i][j])&#123;</div><div class="line">                    <span class="keyword">if</span>(min.h &gt; heightMap[i][j])&#123;</div><div class="line">                        result +=  min.h - heightMap[i][j];</div><div class="line">                        heightMap[i][j] = min.h;</div><div class="line">                    &#125;</div><div class="line">                    heap.offer(<span class="keyword">new</span> Node(heightMap[i][j],i,j));</div><div class="line">                    hash[i][j] = <span class="keyword">true</span>;</div><div class="line">                    --count;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="The-Skyline-Problem">8.9. The Skyline Problem</h2><p>题意：给一些大楼<code>int[][] build</code>，每个楼是三元组[left,right,h]。如<code>[ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ]</code>。求这些大楼的关键点。即求这些点：</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-11-17-15-30-30.png" alt=""> </p>
<p>输出为：<code>[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ]</code></p>
<p>这题好难啊！！！</p>
<p><strong>出发点：</strong></p>
<ol>
<li>左顶点出现伴随着这栋楼开始</li>
<li>右顶点出现伴随着这栋楼结束</li>
<li>一旦哪个顶点处的max_height与前一个不一样，那这个就是key point了！</li>
</ol>
<p><strong>思路</strong>：借助大顶堆维护当前最高的楼，时间O(NlogN) 空间O(N)。<br>1 把这些矩形拆成两个点，一个左上顶点，一个右上顶点。将所有顶点按照横坐标排序后，开始遍历这些点。<br>2 遍历时，通过一个大顶堆来得知当前图形的最高位置。堆顶是所有顶点中最高的点，只要这个点没被移出堆，说明这个最高的矩形还没结束。<br>3 对于左顶点，我们将其加入堆中。对于右顶点，我们找出堆中其相应的左顶点，然后移出这个左顶点，同时也意味这这个矩形的结束。<br>4 代码中，为了区分左右顶点，左顶点高度值是负数，而右顶点高度值则存的是正数。注意，堆中先加入一个0高度，帮助我们在只有最矮的建筑物时选择最低值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by jiayi on 2017/11/13.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</div><div class="line">    <span class="keyword">public</span> List&lt;<span class="keyword">int</span>[]&gt; getSkyline(<span class="keyword">int</span>[][] buildings) &#123;</div><div class="line">        List&lt;<span class="keyword">int</span>[]&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        List&lt;<span class="keyword">int</span>[]&gt; height = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="comment">//构建左右顶点混合列表</span></div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span>[] b : buildings )&#123;</div><div class="line">            <span class="comment">//b[0] 左顶点</span></div><div class="line">            <span class="comment">//b[1] 右顶点</span></div><div class="line">            <span class="comment">//b[2] 楼高度</span></div><div class="line">            height.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;b[<span class="number">0</span>],-b[<span class="number">2</span>]&#125;);<span class="comment">//左高度为负</span></div><div class="line">            height.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;b[<span class="number">1</span>],b[<span class="number">2</span>]&#125;);<span class="comment">//右高度为负</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 按横坐标排序，相同横坐标其h小的在前</span></div><div class="line">        Collections.sort(height,(a,b) -&gt; &#123;</div><div class="line">            <span class="keyword">if</span>( a[<span class="number">0</span>] != b[<span class="number">0</span>] ) <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</div><div class="line">            <span class="keyword">else</span> <span class="keyword">return</span> a[<span class="number">1</span>] - b[<span class="number">1</span>];</div><div class="line">        &#125;);</div><div class="line">        <span class="comment">// 构建大顶堆，按照纵坐标来判断大小</span></div><div class="line">        Queue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="number">11</span>, (i1,i2) -&gt; (i2-i1));</div><div class="line">        <span class="comment">//将地平线值0加入堆</span></div><div class="line">        pq.offer(<span class="number">0</span>);</div><div class="line">        <span class="comment">//prev用于记录上次的keypoint高度</span></div><div class="line">        <span class="keyword">int</span> prev = <span class="number">0</span> ;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span>[] h : height )&#123;</div><div class="line">            <span class="keyword">if</span>( h[<span class="number">1</span>] &lt; <span class="number">0</span> )&#123;<span class="comment">//h是左顶点</span></div><div class="line">                <span class="comment">//将左顶点加入堆</span></div><div class="line">                pq.offer(-h[<span class="number">1</span>]);</div><div class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//h是右顶点</span></div><div class="line">                <span class="comment">// 将右顶点对应的左顶点移去</span></div><div class="line">                pq.remove(h[<span class="number">1</span>]);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">int</span> cur = pq.peek();</div><div class="line">            <span class="comment">// 如果堆的新顶部和上个keypoint高度不一样，则加入一个新的keypoint</span></div><div class="line">            <span class="keyword">if</span>( prev != cur )&#123;</div><div class="line">                result.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;h[<span class="number">0</span>],cur&#125;);</div><div class="line">                prev = cur;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">        <span class="comment">/**执行流程</span></div><div class="line">         * in -&gt; [2,9,10],[3 7 15]</div><div class="line">         * height -&gt; [2,-10],[3,-15],[7,15],[9,10]</div><div class="line">         * loop = 1 -&gt; [2,-10]是左顶点，pq = [10] --&gt; out [2,10]</div><div class="line">         * loop = 2 -&gt; [3,-15]是左顶点，pq = [10,15] --&gt; out [3,15]</div><div class="line">         * loop = 3 -&gt; [7,15]是右顶点，pq = [10] --&gt; out[7,10]</div><div class="line">         * loop = 4 -&gt; [9,10]是右顶点，pq = [] --&gt; out[]</div><div class="line">         * **/</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span>[][] nums = &#123;</div><div class="line">                &#123;<span class="number">2</span>,<span class="number">9</span>,<span class="number">10</span>&#125;,</div><div class="line">                &#123;<span class="number">3</span>,<span class="number">7</span>,<span class="number">15</span>&#125;,</div><div class="line">                &#123;<span class="number">5</span>,<span class="number">12</span>,<span class="number">12</span>&#125;,</div><div class="line">                &#123;<span class="number">15</span>,<span class="number">20</span>,<span class="number">10</span>&#125;,</div><div class="line">                &#123;<span class="number">19</span>,<span class="number">24</span>,<span class="number">8</span>&#125;</div><div class="line">        &#125;;</div><div class="line">        Main t = <span class="keyword">new</span> Main();</div><div class="line">        System.out.println(t.getSkyline(nums));</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="参考文献">9. 参考文献</h1><ol>
<li><a href="http://www.cnblogs.com/vamei/archive/2013/03/20/2966612.html" target="_blank" rel="external">纸上谈兵：堆</a></li>
<li><a href="http://vickyqi.com/2015/11/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%A0%86/" target="_blank" rel="external">数据结构系列-堆</a></li>
<li><a href="http://eugeneyang.com/2016/04/13/The%20Skyline%20Problem%20-%20%E5%A4%A9%E9%99%85%E7%BA%BF%E9%97%AE%E9%A2%98/" target="_blank" rel="external">The Skyline Problem - 天际线问题</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> TOP-K </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[算法-DP-钢条切割问题]]></title>
      <url>/2017/11/02/%E7%AE%97%E6%B3%95-DP-%E9%92%A2%E6%9D%A1%E5%88%87%E5%89%B2%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>在说钢条切割问题之前，我们先说说动态规划。</p>
<p><strong>动态规划</strong>——Dynamic programming(这个词指表格)：通过组合子问题的解求解原问题。</p>
<p><strong>与分治法对比：</strong></p>
<ol>
<li>相同点：都是通过子问题组合求解原问题</li>
<li>不同点：分治法将问题划分为<strong>不相交</strong>的子问题，求解再合并。动态规划应用于<strong>子问题重叠</strong>的情况，即<strong>不同</strong>的子问题具有<strong>公共</strong>的子子问题，此时如果用分治法就会出现重复计算求解。为了避免重复动态规划对子问题只求解一次，将其保存在表格中，从而无需每求解一个子子问题时重复计算。</li>
</ol>
<p><strong>求解步骤</strong></p>
<ol>
<li>刻画最优解的结构特征</li>
<li>递归定义最优解的值</li>
<li>计算最优解的值，通常采用自底向上的方法（可能需要同时维护一些额外信息）</li>
<li>利用计算出的信息构造最优解（不是必须）</li>
</ol>
<h1 id="钢条切割">1. 钢条切割</h1><p>Serling公司购买一根长钢管，将其切割成短钢管出售，给定钢管长度和对应的价钱如下表：</p>
<p><img src="https://i.loli.net/2017/10/31/59f7536b8fc8f.png" alt="img"></p>
<p>问题要求根据上面的价格，给出最佳的切割方案，使得收益最大。</p>
<p>以n=4为例，可以将钢条切割成如下图所示的8种情况，其中收益最大的是(c)：</p>
<p><img src="https://ooo.0o0.ooo/2017/10/30/59f73938d2f50.png" alt="img"></p>
<p>这个题的切入点非常重要，也就是——当知道长度为1到i的钢条的切割方案时，可以推导出长度为i+1的钢条如何切割最优。</p>
<p>我们定义长度=i，且长度为i时最优切割方案的收益是$r_i$</p>
<ul>
<li>i=1时， 当然不切割，即$r_1=p_1$</li>
<li>i=2时，有两种方案，要么切一刀，要么不切，即$r_2=max[p_2,r_1+r_1]$</li>
<li>i=3时，我们从下图可以看到，假设我们从它上面随便切一刀，我们会发现无论是左边还是右边都是已知的。即$r_3=max[p_3,r_1+r_2,r_2+r_1]$</li>
<li>i=4时，还是可以看到，无论我们从哪里切一刀，会发现无论是左边还是右边，都是已知的！即$r_4=max[p_4,r_1+r_3,r_2+r_2,r_3+r_1]$</li>
</ul>
<p><img src="https://i.loli.net/2017/11/02/59fb152d32886.png" alt="">  </p>
<p>因此，我们可以用<strong>更短的钢条的最优切割收益</strong>来描述它：</p>
<p>$$r_n = max[p_n,r_1+r_{n-1},r_2+r_{n-2},…,r_{n-1}+r_1]$$</p>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public int[] q;</div><div class="line">private void solve(int n,int k,int[] p)&#123;</div><div class="line">    if(k&gt;n)return;</div><div class="line">    //长度k的钢条</div><div class="line">    q[k] = p[k];</div><div class="line">    //遍历，也就是计算max = [r_1+r_&#123;n-1&#125;,r_2+r_&#123;n-2&#125;,...,r_&#123;n-1&#125;+r_1]</div><div class="line">    for(int i=1;i&lt;k;i+=1)&#123;</div><div class="line">        q[k] = Math.max(q[i]+ q[k-i], q[k]);</div><div class="line">    &#125;</div><div class="line">    solve(n,k+1,p);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="钢条切割升级版">2. 钢条切割升级版</h1><p>《算法导论》练习题15.1-3提出：除了切割下的钢条段具有不同价格$p_i$外，每次切割还要付出固定成本$c$。求修改后的钢条切割问题。</p>
<p><img src="https://i.loli.net/2017/11/02/59fb1b5eabefa.png" alt=""> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public int[] q;</div><div class="line"></div><div class="line">private void solve(int n,int k,int[] p,int c)&#123;</div><div class="line">    if(k&gt;n)return;</div><div class="line">    //长度k的钢条</div><div class="line">    q[k] = p[k];</div><div class="line">    for(int i=1;i&lt;k;i+=1)&#123;</div><div class="line">        q[k] = Math.max(q[i]+ q[k-i] - c, q[k]);</div><div class="line">    &#125;</div><div class="line">    solve(n,k+1,p,c);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深度学习算法-卷积网络]]></title>
      <url>/2017/10/31/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-%E5%8D%B7%E7%A7%AF%E7%BD%91%E7%BB%9C/</url>
      <content type="html"><![CDATA[<p>一般来说，图片是非常大的。至少有$n\times n\times 3$的像素，即有这么多特征。 对于小尺寸的图片问题，也许我们用深度神经网络的结构可以较为简单的解决一定的问题。但是当应用在大尺寸的图片上，输入规模将变得十分庞大，使用神经网络将会有非常多的参数需要去学习，这个时候神经网络就不再适用。</p>
<p>卷积神经网络在计算机视觉问题上是一个非常好的网络结构。</p>
<h1 id="概述">1. 概述</h1><h2 id="图像识别过程">1.1. 图像识别过程</h2><p> 当我们给定一个”X”的图案，计算机怎么识别这个图案就是“X”呢？一个可能的办法就是计算机存储一张标准的“X”图案，然后把需要识别的未知图案跟标准”X”图案进行比对，如果二者一致，则判定未知图案即是一个”X”图案。</p>
<p>而且即便未知图案可能有一些平移或稍稍变形，依然能辨别出它是一个X图案。如此，CNN是把未知图案和标准X图案一个局部一个局部的对比，如下图所示：</p>
<p><img src="https://i.loli.net/2017/11/02/59fa7bbb36b29.png" alt=""> </p>
<p><strong>而未知图案的局部和标准X图案的局部一个一个比对时的计算过程，便是卷积操作</strong>。卷积计算结果为1表示匹配，否则不匹配。</p>
<h2 id="图像边缘检测">1.2. 图像边缘检测</h2><p>卷积运算是卷积神经网络的基本组成部分。下面以边缘检测的例子来介绍卷积运算。</p>
<p>所谓边缘检测，在下面的图中，分别通过垂直边缘检测和水平边缘检测得到不同的结果：</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-06-14-38-35.png" alt=""> </p>
<p><strong>垂直边缘检测：</strong></p>
<p>假设对于一个 6×6 大小的图片（以数字表示），以及一个 3×3 大小的 <strong>filter</strong>（卷积核） 进行卷积运算，以“∗”符号表示。图片和垂直边缘检测器分别如左和中矩阵所示：</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-06-14-40-48.png" alt=""> </p>
<p><strong>filter</strong> 不断地和其大小相同的部分做【对应元素的乘法运算并求和】，最终得到的数字相当于新图片的一个像素值，如右矩阵所示，最终得到一个 4×4 大小的图片。</p>
<p><strong>边缘检测的原理：</strong></p>
<p>以一个有一条垂直边缘线的简单图片来说明。通过垂直边缘 <strong>filter</strong> 我们得到的最终结果图片可以明显地将边缘和非边缘区分出来：</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-06-14-41-29.png" alt=""> </p>
<p>卷积运算提供了一个方便的方法来检测图像中的边缘，成为卷积神经网络中重要的一部分。</p>
<p><strong>多种边缘检测：</strong></p>
<p>垂直和水平边缘检测</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-06-15-05-41.png" alt=""> </p>
<p>更复杂的<strong>filter</strong></p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-06-15-05-55.png" alt=""> </p>
<p>对于复杂的图片，我们可以直接将<strong>filter</strong>中的数字直接看作是需要学习的参数，其可以学习到对于图片检测相比上面filter更好的更复杂的<strong>filter</strong>，如相对于水平和垂直检测器，我们训练的 filter 参数也许可以知道不同角度的边缘。</p>
<p>通过卷积运算，在卷积神经网络中通过反向传播算法，可以学习到相应于目标结果的<strong>filter</strong>，将其应用于整个图片，输出其提取到的所有有用的特征。</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-06-15-06-48.png" alt=""> </p>
<h2 id="卷积网络结构">1.3. 卷积网络结构</h2><p>本节主要来自参考文献<a href="http://blog.csdn.net/v_july_v/article/details/51812459" target="_blank" rel="external">CNN笔记：通俗理解卷积神经网络</a></p>
<p><a href="http://cs231n.github.io/convolutional-networks/#overview" target="_blank" rel="external">cs231n</a>课程里给出了卷积神经网络各个层级结构，如下图：</p>
<p><img src="http://img.blog.csdn.net/20160702205047459" alt="img"></p>
<p>图中CNN要做的事情是：给定一张图片，是车还是马未知，是什么车也未知，现在需要模型判断这张图片里具体是一个什么东西，总之输出一个结果：如果是车，那是什么车。</p>
<p>上图的网络结构为：</p>
<ul>
<li>最左边是数据输入层，对数据做一些处理，比如去均值（把输入数据各个维度都中心化为0，避免数据过多偏差，影响训练效果）、归一化（把所有的数据都归一到同样的范围）、PCA/白化等等。CNN只对训练集做“去均值”这一步。</li>
<li>中间是<ul>
<li>CONV：卷积计算层，线性乘积求和。</li>
<li>ReLU：激励层，上文2.2节中有提到：ReLU是激活函数的一种。</li>
<li>POOL：池化层，简言之，即取区域平均或最大。</li>
</ul>
</li>
<li>最右边是<ul>
<li>FC：全连接层</li>
</ul>
</li>
</ul>
<p>这几个部分中，卷积计算层是CNN的核心，下文将重点阐述。</p>
<p>接下来，我们详细介绍一下这几个部分。</p>
<h1 id="卷积网络结构-1">2. 卷积网络结构</h1><p>卷积网络结构如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">输入层  --&gt;  卷积计算层  --&gt; 激励层 --&gt; 池化层  </div><div class="line">       --&gt;  卷积计算层  --&gt; 激励层 --&gt; 池化层  </div><div class="line">       --&gt; ...</div><div class="line">--&gt;全连接层</div></pre></td></tr></table></figure>
<p>卷积网络中一个典型层包括三级：卷积计算层、激励层（探测层）和池化层。</p>
<p>通过上一步的卷积运算，然后经过了激活函数，我们将此时的输入会输入池化层。</p>
<p><img src="https://i.loli.net/2017/10/31/59f881a6783fa.png" alt=""> </p>
<p><strong>卷积层</strong>：并行计算多个卷积，产生一组线性激活响应；</p>
<p><strong>激励层(探测层)</strong>(detector stage)：每个线性激活响应会通过一个非线性激活函数；</p>
<p><strong>池化层</strong>：我们使用池化(pooling)函数来进一步调整这一层的输出。</p>
<h2 id="卷积计算层">2.1. 卷积计算层</h2><p>卷积计算层最重要的就是卷积运算。接下来我们介绍卷积运算。</p>
<h3 id="卷积运算">2.1.1. 卷积运算</h3><p>假设我们在用激光传感器追踪宇宙飞船的位置，$t$时刻位置在$x(t)$。</p>
<p>为了更好地估计，我们将时间越近的测量给予更高的权重$w(a)$，其中$a$表示测量结果距当前的时间间隔，那么：</p>
<p>$$s(t)=\int x(a)w(t-a)da = (x*w)(t)$$</p>
<p>tips:<br>$a$：距离当前时间的间隔；<br>$x(a)$：$a$时刻，飞船位置，$x$也叫输入<br>$w(t-a)$：$t-a$时刻，也就是a秒前，飞船的权重，也是一种概率密度，叫做核函数</p>
<p>离散形式的卷积是：<br>$$s(t)=(x*w)(t)=\sum_{\alpha=-\infty}^{\infty}x(a)w(t-a)$$</p>
<p>二维形式的卷积（我们定义核为K）：</p>
<p>$$S(i,j)=(I*K)(i,j)=\sum_m \sum_n I(m,n)K(i-m,j-n)$$</p>
<p>卷积是可交换的，也可写作：</p>
<p>$$S(i,j)=(K*I)(i,j)=\sum_m \sum_n I(i-m,j-n)K(m,n)$$</p>
<p>出现上面可交换的原因是：我们将核的相对输入进行了翻转，也相当于一种变量替换；</p>
<p>然而，在许多神经网络中采用的是<strong>互相关函数(cross-correlation)</strong>：</p>
<p>$$S(i,j)=(I*K)(i,j)=\sum_m \sum_n I(i+m,j+n)K(m,n)$$</p>
<p>这个是不可交换的。</p>
<p>在数学定义上，矩阵的<strong>卷积</strong>（convolution）操作为首先将卷积核同时在水平和垂直方向上进行翻转，构成一个卷积核的镜像，然后使用该镜像再和前面的矩阵进行移动相乘求和操作。如下面例子所示：</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-06-15-07-46.png" alt=""> </p>
<p>在深度学习中，我们称为的卷积运算实则没有卷积核变换为镜像的这一步操作，因为在权重学习的角度，变换是没有必要的。深度学习的卷积操作在数学上准确度来说称为<strong>互相关</strong>（cross-correlation）。</p>
<p>一般来说，图像领域的卷积用的就是互相关函数。参考文献<a href="http://blog.csdn.net/v_july_v/article/details/51812459" target="_blank" rel="external">CNN笔记：通俗理解卷积神经网络</a>对卷积的定义是：对图像（不同的数据窗口数据）和滤波矩阵（一组固定的权重：因为每个神经元的多个权重固定，所以又可以看做一个恒定的滤波器filter）做内积（逐个元素相乘再求和）的操作就是所谓的『卷积』操作，也是卷积神经网络的名字来源。</p>
<hr>
<h3 id="卷积计算层-1">2.1.2. 卷积计算层</h3><p>举个具体的例子。比如下图中，图中左边部分是原始输入数据，图中中间部分是滤波器filter(有个高大上的名字叫<strong>卷积核</strong>)，图中右边是输出的新的二维数据。</p>
<p><img src="https://i.loli.net/2017/11/02/59fa7db46ec71.png" alt=""> </p>
<p>即将下面 两个矩阵对应位置先相乘，后相加：</p>
<p><img src="https://i.loli.net/2017/11/02/59fa7dcd89f03.png" alt=""> $$*$$<img src="https://i.loli.net/2017/11/02/59fa7de2c136e.png" alt=""> $$=$$<img src="https://i.loli.net/2017/11/02/59fa7df2b7759.png" alt=""> </p>
<p><img src="https://i.loli.net/2017/11/02/59fa82a30ef95.png" alt=""> </p>
<p>在CNN中，滤波器filter（带着一组固定权重的神经元）对局部输入数据进行卷积计算。每计算完一个数据窗口内的局部数据后，数据窗口不断平移滑动，直到计算完所有数据。这个过程中，有这么几个参数： </p>
<h4 id="Depth-深度">2.1.2.1. Depth-深度</h4><p>神经元个数，决定输出的depth厚度。同时代表滤波器个数。</p>
<h4 id="Stride-步长">2.1.2.2. Stride-步长</h4><p>决定滑动多少步可以到边缘。</p>
<p>以s表示stride的大小，那么在进行卷积运算后，图片的变化为：$n×n –&gt; ⌊\frac{n+2p−f}{s}+1⌋×⌊\frac{n+2p−f}{s}+1⌋$。</p>
<p>注意，在当padding≠1时，若移动的窗口落在图片外面时，则不要再进行相乘的操作，丢弃边缘的数值信息，所以输出图片的最终维度为<strong>向下取整</strong>。</p>
<h4 id="Padding-填充值">2.1.2.3. Padding-填充值</h4><p>在外围边缘补充若干圈0，方便从初始位置以步长为单位可以刚好滑到末尾位置，通俗地讲就是为了总长能被步长整除。</p>
<p>没有Padding的缺点 ： </p>
<ol>
<li>每次卷积操作，图片会缩小； 就前面的例子来说，6×6 大小的图片，经过 3×3 大小的 filter，缩小成了 4×4 大小 。图片：n×n –&gt; (n−f+1)×(n−f+1)</li>
<li>角落和边缘位置的像素进行卷积运算的次数少，可能会丢失有用信息。<br>其中，n表示图片的长或宽的大小，f表示filter的长或宽的大小。</li>
</ol>
<p>有Padding ： </p>
<ol>
<li>为了解决上面的两个缺点，我们在进行卷积运算前为图片加padding，包围角落和边缘的像素，使得通过filter的卷积运算后，图片大小不变，也不会丢失角落和边沿的信息。</li>
</ol>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-06-15-11-15.png" alt=""> </p>
<p>以p表示 Padding 的值，则输入n×n大小的图片，最终得到的图片大小为 (n+2p−f+1)×(n+2p−f+1)，为使图片大小保持不变，需根据filter的大小调整p的值。</p>
<p><img src="https://ooo.0o0.ooo/2017/11/02/59fa7f3498ba3.png" alt=""> </p>
<h3 id="卷积计算的过程">2.1.3. 卷积计算的过程</h3><p>对于灰色图像中，卷积核和图像均是二维的。而应用于彩色图像中，因为图片有R、G、B三个颜色通道，所以此时的卷积核应为<strong>三维卷积核</strong>。</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-06-15-19-44.png" alt=""> </p>
<p>单个卷积核应用于图片时，提取图片特定的特征，不同的卷积核提取不同的特征。如两个大小均为3×3×3 的卷积核分别提取图片的垂直边缘和水平边缘。</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-06-15-20-50.png" alt=""> </p>
<p>由图可知，最终提取到彩色图片的垂直特征图和水平特征图，得到有2个通道的4×4大小的特征图片。</p>
<p>这张gif诠释了三维、两个卷积核的卷积过程：</p>
<p>输入图像：三维</p>
<p>卷积核W0和W1：分别都是三维</p>
<p><img src="http://img.blog.csdn.net/20160707204048899" alt=""></p>
<p>  可以看到：</p>
<ul>
<li>两个神经元，即depth=2，意味着有两个滤波器。</li>
<li>数据窗口每次移动两个步长取3*3的局部数据，即stride=2。</li>
<li>zero-padding=1。</li>
</ul>
<p>然后分别以两个滤波器filter为轴滑动数组进行卷积计算，得到两组不同的结果。</p>
<p>​    如果初看上图，可能不一定能立马理解啥意思，但结合上文的内容后，理解这个动图已经不是很困难的事情：</p>
<ul>
<li>蓝色输入（<strong>7*7*3</strong>中，7*7代表图像的像素/长宽，3代表R、G、B 三个颜色通道）</li>
<li>红色是两个不同的滤波器Filter w0、Filter w1</li>
<li>绿色则是两个不同的输出，每一个格子都等于一次滤波窗口内的内积和（RGB三通道相加）</li>
</ul>
<p>​    随着左边数据窗口的平移滑动，滤波器Filter w0 / Filter w1对不同的局部数据进行卷积计算。如果这一部分看不明白，可以继续看<a href="http://blog.csdn.net/v_july_v/article/details/51812459" target="_blank" rel="external">CNN笔记：通俗理解卷积神经网络</a>，这里讲的非常详细。</p>
<h4 id="单层卷积网络">2.1.3.1. 单层卷积网络</h4><p>和普通的神经网络单层前向传播的过程类似，卷积神经网络也是一个先由输入和权重及偏置做线性运算，然后得到的结果输入一个激活函数中，得到最终的输出：</p>
<p>$$z^{[1]}=w^{[1]}a^{[0]}+b^{[1]}$$</p>
<p>$$a^{[1]}=g(z^{[1]})$$</p>
<p>不同点是在卷积神经网络中，权重和输入进行的是卷积运算。</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-06-15-28-06.png" alt=""> </p>
<p><strong>单层卷积的参数个数：</strong></p>
<p>在一个卷积层中，如果我们有10个 3×3×3 大小的卷积核，那么加上每个卷积核对应的偏置，则对于一个卷积层，我们共有的参数个数为：</p>
<p>$$(3×3×3+1)×10=280$$</p>
<p>无论图片大小是多少，该例子中的卷积层参数个数一直都是280个，相对于普通的神经网络，卷积神经网络的参数个数要少很多。</p>
<h4 id="多层卷积网络">2.1.3.2. 多层卷积网络</h4><p>多层卷积构成卷积神经网络，下面是一个卷积神经网络的例子：</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-06-15-30-34.png" alt=""></p>
<h2 id="激励层">2.2. 激励层</h2><p>几种不同的激活函数$g(x)$：</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-06-14-16-43.png" alt=""> </p>
<ul>
<li><p>sigmoid：</p>
<p>$$a = \frac{1}{1+e^{-z}}$$</p>
<p>导数：$a′=a(1−a)$</p>
</li>
<li><p>tanh：</p>
<p>$$a = \frac{e^z - e^{-z}}{e^z + e{-z}}$$</p>
<p>导数：$a′=1−a2$</p>
</li>
<li><p>ReLU（修正线性单元）：<br>$$a=max(0,z)$$</p>
</li>
<li><p>Leaky ReLU：<br>$$a=max(0.01z,z)$$</p>
</li>
</ul>
<p><strong>激活函数的选择</strong></p>
<p>sigmoid函数和tanh函数比较：</p>
<ul>
<li>隐藏层：tanh函数的表现要好于sigmoid函数，因为tanh取值范围为[−1,+1]，输出分布在0值的附近，均值为0，从隐藏层到输出层数据起到了归一化（均值为0）的效果。</li>
<li>输出层：对于二分类任务的输出取值为{0,1}，故一般会选择sigmoid函数。</li>
</ul>
<p>然而sigmoid和tanh函数在当|z|很大的时候，梯度会很小，在依据梯度的算法中，更新在后期会变得很慢。在实际应用中，要使|z|尽可能的落在0值附近。</p>
<p>ReLU弥补了前两者的缺陷，当z&gt;0时，梯度始终为1，从而提高神经网络基于梯度算法的运算速度。然而当z&lt;0时，梯度一直为0，但是实际的运用中，该缺陷的影响不是很大。</p>
<p>Leaky ReLU保证在z&lt;0的时候，梯度仍然不为0。</p>
<p>在选择激活函数的时候，如果在不知道该选什么的时候就选择ReLU，当然也没有固定答案，要依据实际问题在交叉验证集合中进行验证分析。</p>
<h2 id="池化层">2.3. 池化层</h2><p><strong>池化函数</strong></p>
<p>使用某一位置的相邻输出的总体统计特征来代替网络再该位置的输出。</p>
<p>最大池化函数：给出相邻矩形区域内的最大值。</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-06-15-33-58.png" alt=""> </p>
<p>在最大池化中，有一组超参数需要进行调整，其中，$f $表示池化的大小，$s$表示步长。</p>
<ul>
<li>池化前：$n×n$</li>
<li>池化后：$⌊\frac{n+2p−f}{s}+1⌋×⌊\frac{n+2p−f}{s}+1⌋$</li>
</ul>
<p>此外还有平均池化、最小池化等等。注意，池化层没有需要学习的参数。</p>
<p><strong>池化的用途</strong></p>
<p>池化函数帮助输入近似不变：即当我们对输入进行少量平移时，经过池化函数后的大多数输出并不会发生改变。通俗地说就是——为了让我们的网络具有平移不变形（我的理解是无论输入轻微旋转或平移，输出都不变），我们引入池化这个骚操作来达到这个目的。</p>
<p>例如下图所示的例子。上图是一个网络，下图是一个网络，每个网络的下层是非线性输出，上层是最大池化输出。下图的非线性输出是通过向右平移一个像素得到的。我们可以发现，池化层的输出只有一半发生了改变，这是因为最大池化单元只对周围的最大值较敏感，而不是精确的位置。</p>
<p><img src="https://i.loli.net/2017/11/01/59f939076125c.png" alt=""> </p>
<p>当我们只关心某个特征是否出现（比如是否有眼睛），而不关心它的具体位置时，局部平移不变性是一个非常有用的性质。</p>
<p>对空间区域进行池化产生了平移不变性。下图是一种学习不变性的实例：反映的是池化的旋转不变性，对于输入手写5，有三个滤波器分别检测选择不同角度的手写5。当滤波器和对应的手写5匹配时，滤波器会得到一个较大的激活值，然后池化会选择得到最大的激活值，无论手写5是怎样的旋转的。</p>
<p><img src="https://ooo.0o0.ooo/2017/11/01/59f95b688c95b.png" alt=""> </p>
<p>总的来说就是：通过卷积后，为了引入不变性，同时防止过拟合问题或欠拟合问题、降低计算量，我们常进行池化处理。</p>
<h1 id="卷积网络的优势">3. 卷积网络的优势</h1><p>我们先说一下卷积网络的概念：卷积神经网络（Convolutional Neural Networks）的卷积操作是通过可训练的滤波器对上一层的输出进行卷积求和，然后添加上偏移量经过激活函数，得到了特征映射图作为下一层的输入。卷积操作相对于传统神经网络主要有稀疏链接、权值共享和等变表达的特性。</p>
<p>卷积通过三个重要思想来帮助改进机器学习系统：稀疏交互、参数共享、等变表示。</p>
<p>与普通的全连接神经网络相比，卷积神经网络的参数更少。如图中的例子，卷积神经网络仅有6×(5×5+1)=156个参数，而普通的全连接网络有3072×4704≈14M个参数。</p>
<p><strong>稀疏交互</strong></p>
<p>对于一张图像来说，输入图像可能包含上千万像素点。但我们可以通过只占用几十或几百的核来检测一些小的但有意义的特征，例如图像边缘。即——在每一层中，每个输出值只取决于少量的输入，也就是稀疏交互。</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-06-15-51-25.png" alt=""> </p>
<p>下图是一种稀疏连接的例子，从下往上看，我们强调了一个输入单元$x_3$以及$s$中受该单元影响的输出单元。这个是当$s$由核宽度为3的卷积产生的，只有3个输出受到了$x$的影响：</p>
<p><img src="https://i.loli.net/2017/10/31/59f865cb07946.png" alt=""> </p>
<p>从另一个角度，从上往下看，这次我们抢到了一个输出单元$s_3$以及$x$中影响该单元的输入单元。这些单元被称为$s_3$的<strong>接受域</strong>。</p>
<p><img src="https://i.loli.net/2017/10/31/59f86ae962147.png" alt=""> </p>
<p>从深层的网络来看，我们可以看到尽管连接稀疏，但处在更深层的单元可以间接地连接到全部或大部分输入图像中。</p>
<p><img src="https://i.loli.net/2017/10/31/59f86aff4a4b1.png" alt="">  </p>
<p><strong>参数共享</strong></p>
<p>一个特征检测器（filter）对图片的一部分有用的同时也有可能对图片的另外一部分有用。</p>
<p>因为核的每一个元素都作用在输入的每一个位置上，因此卷积运算会导致用于一个输入的权重也会被绑定在其它权重上。这样的参数共享保证了我们只需要学习一个参数集合，而不是对每一个位置都需要学习一个单独的参数集合。如下图所示，黑色箭头表示两个不同模型中使用了特殊的参数连接。灰色箭头表示它用了黑色箭头的参数。其实就是一个$x$只有一个参数，但这个参数被用于了多个下一层。</p>
<p><img src="https://i.loli.net/2017/10/31/59f86f09c700e.png" alt="">  </p>
<p>对于卷积，参数共享的特殊形式使得神经网络层具有对<strong>平移等变的性质</strong>：先平移后卷积=先卷积后平移。</p>
<p><strong>边缘检测的例子</strong></p>
<p>如图所示，我们使用每个像素减去左边相邻像素形成的。这其实就是一种最简单的卷积。</p>
<p><img src="https://i.loli.net/2017/10/31/59f879f482dd9.png" alt=""></p>
<h1 id="训练卷积神经网络">4. 训练卷积神经网络</h1><p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-06-16-04-01.png" alt=""> </p>
<p>我们将训练集输入到卷积神经网络中，对网络进行训练。利用梯度下降（Adam、momentum等优化算法）最小化代价函数来寻找网络最优的参数。</p>
<h1 id="复杂度">5. 复杂度</h1><h2 id="卷积网络的时间复杂度">5.1. 卷积网络的时间复杂度</h2><h3 id="单个卷积层的时间复杂度">5.1.1. 单个卷积层的时间复杂度</h3><p>$$O(M^2 K^2 C_{in}C_{out})$$</p>
<ul>
<li>M : 每个卷积核输出特征图（feature map）的边长<ul>
<li><strong>输出</strong>特征图尺寸本身又由<strong>输入</strong>矩阵尺寸 X 、卷积核尺寸K、填充大小Padding、步长Stride 这四个参数所决定，表示如下：<br>$$M = (X - K + 2 * Padding) / Stride + 1$$</li>
</ul>
</li>
<li>K : 每个卷积核的边长</li>
<li>Cin :  每个卷积核的通道数，也即输入通道数，也即上一层的输出通道数</li>
<li>Cout : 本卷积层具有的卷积核个数，也即输出通道数</li>
</ul>
<h3 id="卷积神经网络整体的时间复杂度">5.1.2. 卷积神经网络整体的时间复杂度</h3><p>$$O\sum_{l = 1}^D(M^2_l K_l ^2 C_{l-1}C_{l})$$</p>
<ul>
<li>D : 网络深度</li>
</ul>
<h2 id="卷积网络的空间复杂度">5.2. 卷积网络的空间复杂度</h2><p>$$O(\sum_{l = 1}^D K_l^2 C_{l - 1}C_l)$$</p>
<ul>
<li>与输入数据大小无关</li>
<li>当我们需要裁剪模型时，由于卷积核的尺寸通常已经很小，而网络的深度又与模型的能力紧密相关，不宜过多削减，因此模型裁剪通常最先下手的地方就是通道数</li>
</ul>
<h1 id="参考文献">6. 参考文献</h1><ol>
<li><a href="">深度学习</a></li>
<li><a href="http://www.datagrand.com/blog/neural.html" target="_blank" rel="external">达观数据深度学习</a></li>
<li><a href="http://www.dlworld.cn/ZiLiaoXiaZai/1757.html" target="_blank" rel="external">深度学习笔记（一）卷积神经网络(Convolutional Neural Networks)</a></li>
<li><a href="http://blog.csdn.net/v_july_v/article/details/51812459" target="_blank" rel="external">CNN笔记：通俗理解卷积神经网络</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/31575074" target="_blank" rel="external">卷积神经网络的复杂度分析</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> 深度学习算法 </category>
            
            <category> 卷积网络 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[数学-最大似然估计]]></title>
      <url>/2017/10/26/%E6%95%B0%E5%AD%A6-%E6%9C%80%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1/</url>
      <content type="html"><![CDATA[<p>其实在之前的博客<a href="https://jiayi797.github.io/2017/07/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%9A%84%E7%90%86%E8%A7%A3/" target="_blank" rel="external">朴素贝叶斯的理解</a>一文中曾经提到过最大似然估计。</p>
<p>极大似然估计的核心思想是：我们已知$x$已发生，我们再根据实际情况写出$x$发生的概率$p(x;θ)$。目标函数是使得这个概率$p(x;θ)$最大，然后求得$θ$：</p>
<p>$$\theta_{ML}=arg max_\theta p(X;\theta)=arg max_\theta ∏_{i=1}^mp(x^{i};\theta)$$</p>
<font size="2.5">上公式中：<br>$p(X;\theta)$是样本集$X$出现的概率；<br>$p(x^{i};\theta)$是某个样本出现的概率；<br>左式等于右式原因是每个样本出现的概率独立；<br></font>

<p>多个数的连乘容易溢出，我们可以将它转化为log运算：<br>$$\theta_{ML}=arg max_\theta \sum{i=1}^mlog p(x^{i};\theta)$$<br>将上式除以$m$，得到一种期望：<br>$$\theta_{ML}=arg max_\theta E_{x\text{~}p’_{data}}log p(x^{i};\theta) \tag{公式1}$$<br>这个式子的含义是：在经验分布$x\text{~}p^`$上，求得一个$\theta$，使得模型分布的期望最大化。</p>
<p>此时我们暂时先不看上面这个公式。我们从另一个角度——误差来衡量。训练集上的经验分布$p’_{data}​$和模型之间的分布差异可以用KL散度衡量：</p>
<p>$$D_{KL}(p’_{data}||p_{model}) = E_{x\text{~}p’_{data}}[logp’_{data}(x)-logp_{model}(x)]$$</p>
<p>我们的目标是使上式最小化。减号左边是在训练集上的，是一个常数；我们只关心右边：</p>
<p>$$\theta_{KL}=argmin_{\theta} -E_{x\text{~}p’_{data}}[logp_{model}(x)]\tag{公式2}$$</p>
<p>很明显我们可以看到，公式2与公式1其实是一样的。我们从这个角度证明了这种度量下的误差与极大似然是相同的。</p>
]]></content>
      
        <categories>
            
            <category> 数学 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[深度学习算法-误差函数探究]]></title>
      <url>/2017/10/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-%E8%AF%AF%E5%B7%AE%E5%87%BD%E6%95%B0%E6%8E%A2%E7%A9%B6/</url>
      <content type="html"><![CDATA[<p>之前我们在<a href="https://jiayi797.github.io/2017/09/05/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%80%E4%BB%8B/" target="_blank" rel="external">神经网络简介</a>中曾经提到过误差函数。这一节我们总结一下误差函数。</p>
<p>误差函数一般有两种来源：</p>
<ol>
<li>如果参数模型定义了一个分布$p(y|x;\theta)$，我们采用最大似然原理得到代价函数：训练数据和模型预测间的交叉熵。这个在之后会详细解释。</li>
<li>如果不预测y的完整概率分布，仅仅预测在给定x条件下y的某种统计量，那就用某些专门的损失函数来计算。</li>
</ol>
<h1 id="方法1，使用最大似然学习条件分布">1. 方法1，使用最大似然学习条件分布</h1><p>可以在博客<a href="https://jiayi797.github.io/2017/10/26/%E6%95%B0%E5%AD%A6-%E6%9C%80%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1/" target="_blank" rel="external">最大似然估计</a>中看到，参数模型定义了一个分布$p(y|x;\theta)$，为了求得参数，我们使用最大似然原理，得到最终的目标函数是最小化代价函数J——<strong>训练数据</strong>和<strong>模型预测</strong>间的<strong>交叉熵:</strong></p>
<p>$$J(\theta)=-E_{x,y\sim p’_{data}}log p_{model}(y|x)$$</p>
<p>上式的意义是：在$x,y$服从训练数据$ p’_{data}$分布下，使得模型的$-Elog p_{model}(y|x)$最小。</p>
<p>用似然解决问题带来的好处：</p>
<ol>
<li>当明确了一个模型$p(y|x)$时，就自动地确定了代价函数$logp(y|x)$。</li>
<li>对数函数能帮我们避免梯度过小（例如有的输出单元有一个指数函数，取对数后梯度就不那么小了）</li>
</ol>
<h1 id="方法2，简单学习条件统计量">2. 方法2，简单学习条件统计量</h1><p>我们用历史的数据，计算出特征x下y发生的概率：$f(x)=p(y|x)$，将它作为x特征下y的预测。学习这个条件统计量的过程就是我们这节介绍的方法。</p>
<h2 id="均方误差">2.1. 均方误差</h2><p>通过解优化问题：</p>
<p>$$f^*=arg min_f E_{x,y\sim p_{data}}||y-f(x)||^2 \tag{均方误差最小化时的f^{※}}$$</p>
<p>得到$f^*$,我们用它来进行预测得到：</p>
<p>$$f^*(x)=E_{y\sim p_{data}(y|x)}[y]\tag{将所有服从p_{data}(y|x)的y的y均值作为x特征下y的预测}$$</p>
<p>可以看出，这样得到的函数是可以用来对每个x的值预测出y的<strong>均值</strong>。</p>
<h2 id="平均绝对误差">2.2. 平均绝对误差</h2><p>还有另一种误差叫平均绝对误差，通过解优化问题：</p>
<p>$$f^*=arg min_f E_{x,y \sim p_{data}}||y-f(x)||_1$$</p>
<p>得到的函数，可以对每个x预测y取值的<strong>中位数</strong>。</p>
<h1 id="比较">3. 比较</h1><p>一般，均方误差和平均绝对误差在梯度下降法表现不好，因为饱和的输出单元梯度非常小。所以一般来说交叉熵代价函数更受欢迎。</p>
]]></content>
      
        <categories>
            
            <category> 深度学习算法 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[机器学习算法-L2R进一步了解]]></title>
      <url>/2017/09/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-L2R%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BA%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>之前的博客中简单介绍了Learning to Rank的基本原理，也讲到了Learning to Rank的几类常用的方法：pointwise，pairwise，listwise。这篇博客就pairwise中的RankSVM、GBRank和LambdaRank做简要介绍。</p>
<p>RankSVM是2000年提出的；GBRank是2007年提出的；LambdaMART是2008年提出的。因此我们按照提出顺序来讲解这三种算法。</p>
<h1 id="引言">1. 引言</h1><p>机器学习一般都是解决分类问题。而在Rank中我们遇到的是排序问题。那么如何将排序问题转化为分类问题成了当下的关键。</p>
<h2 id="如何将排序问题转化为分类问题？">1.1. 如何将排序问题转化为分类问题？</h2><p>对于一个query-doc pair（检索-文档结果对），我们可以将其用一个feature vector表示：x。而排序函数为f(x)，我们根据f(x)的大小来决定哪个doc排在前面，哪个doc排在后面。即如果f(xi) &gt; f(xj)，则xi应该排在xj的前面，反之亦然。可以用下面的公式表示：</p>
<p><img src="https://i.loli.net/2017/09/25/59c8b1ffea865.png" alt=""> </p>
<p>理论上，f(x)可以是任意函数，为了简单起见，我们假设其为线性函数：<br><img src="https://i.loli.net/2017/09/25/59c8b2152e915.png" alt=""><br>如果这个排序函数f(x)是一个线性函数，那么我们便可以将一个排序问题转化为一个二元分类问题。理由如下：<br>首先，对于任意两个feature vector xi和 xj，在f(x)是线性函数的前提下，下面的关系都是存在的：<br><img src="https://i.loli.net/2017/09/25/59c8b41b9bba0.png" alt=""><br>然后，便可以对xi和 xj的差值向量考虑二元分类问题。特别地，我们可以对其赋值一个label：<br><img src="https://i.loli.net/2017/09/25/59c8b4335d7e6.png" alt=""> </p>
<p>有一个很好的例子说明了如何将排序问题转化为分类问题，在L2R的笔记中已提到过，此处不再多加阐述。</p>
<p>将排序问题转化为分类问题之后, 我们就可以使用常用的机器学习方法解决该问题。</p>
<h1 id="RankSVM">2. RankSVM</h1><p>RankSVM的<strong>基本思想</strong>是，将排序问题转化为pairwise的分类问题，然后使用SVM分类模型进行学习并求解。Ranking SVM使用SVM来进行分类:<br><img src="https://i.loli.net/2017/09/25/59c8b8e74b0df.png" alt=""> </p>
<p>其中w为参数向量, x为文档的特征,y为文档对之间的相对相关性, ξ为松弛变量。</p>
<p>对这个公式，<a href="https://www.zhihu.com/question/23764120" target="_blank" rel="external">知乎</a>上有一个很好的解释：<br>之前svm为实现软间隔最大化，约束条件里有<img src="https://i.loli.net/2017/09/25/59c8b458a2a54.png" alt=""> 。而rank-svm是典型的pairwise方法，考虑两个有偏序关系的文档对，训练样本是xi^(1)-xi^(2)，所以要把约束条件改成<img src="https://i.loli.net/2017/09/25/59c8b472b130b.png" alt=""> ，由于相减不再需要偏置b。而优化问题中的目标函数和其他约束项不变。</p>
<h2 id="使用Clikthrough数据作为训练数据">2.1. 使用Clikthrough数据作为训练数据</h2><p>T. Joachims提出了一种非常巧妙的方法, 来使用Clickthrough数据作为Ranking SVM的训练数据。</p>
<p>假设给定一个查询”Support Vector Machine”, 搜索引擎的返回结果为<br><img src="https://ooo.0o0.ooo/2017/09/25/59c8b9563cab6.png" alt=""><br>其中1, 3, 7三个结果被用户点击过, 其他的则没有。因为返回的结果本身是有序的, 用户更倾向于点击排在前面的结果, 所以用户的点击行为本身是有偏(Bias)的。为了从有偏的点击数据中获得文档的相关信息, 我们认为: 如果一个用户点击了a而没有点击b, 但是b在排序结果中的位置高于a, 则a&gt;b。<br>所以上面的用户点击行为意味着: 3&gt;2, 7&gt;2, 7&gt;4, 7&gt;5, 7&gt;6。</p>
<h2 id="Ranking-SVM的开源实现">2.2. Ranking SVM的开源实现</h2><p><a href="http://www.cs.cornell.edu/people/tj/svm_light/svm_rank.html" target="_blank" rel="external">Joachims的主页</a>上有Ranking SVM的开源实现。</p>
<p>数据的格式与LIBSVM的输入格式比较相似, 第一列代表文档的相关性, 值越大代表越相关, 第二列代表查询, 后面的代表特征:<br>qid:1 1:1 2:1 3:0 4:0.2 5:0 # 1A<br>qid:1 1:0 2:0 3:1 4:0.1 5:1 # 1B<br>qid:1 1:0 2:1 3:0 4:0.4 5:0 # 1C<br>qid:1 1:0 2:0 3:1 4:0.3 5:0 # 1D<br>qid:2 1:0 2:0 3:1 4:0.2 5:0 # 2A<br>qid:2 1:1 2:0 3:1 4:0.4 5:0 # 2B<br>qid:2 1:0 2:0 3:1 4:0.1 5:0 # 2C<br>qid:2 1:0 2:0 3:1 4:0.2 5:0 # 2D<br>qid:3 1:0 2:0 3:1 4:0.1 5:1 # 3A<br>qid:3 1:1 2:1 3:0 4:0.3 5:0 # 3B<br>qid:3 1:1 2:0 3:0 4:0.4 5:1 # 3C<br>qid:3 1:0 2:1 3:1 4:0.5 5:0 # 3D</p>
<h1 id="GBRank">3. GBRank</h1><p>参考文献<a href="http://www.tuicool.com/articles/yAfiQ3r" target="_blank" rel="external">GBRank:一种基于回归的学习排序算法</a><br>对GBRank做出了较好的解释。原论文是[A Regression Framework for Learning Ranking Functions Using Relative Relevance Judgments]。下面对这个博客和论文进行摘录和整理。</p>
<h2 id="算法原理">3.1. 算法原理</h2><p>一般来说在搜索引擎里面，相关性越高的越应该排在前面。现在 query-doc 的特征使用向量x或者y表示，假设现在有一个文档对<xi,yi>，当xi排在yi前面时，我们使用xi&gt;yi来表示。我们含顺序的 pair 对用如下集合表示(也就是真的xi真的排在yi前面):<br><img src="https://i.loli.net/2017/09/25/59c8b9d26d47d.png" alt=""><br>现假设学习的排序函数为h，我们希望当h(xi)&gt;h(yi)时，满足xi&gt;yi的数量越多越好。那么如何来评价这个h到底好不好呢，那么我们可以定义h的风险函数为:<br><img src="https://i.loli.net/2017/09/25/59c8ba28f012e.png" alt=""><br>对于这个风险函数，我们可以做如下解释。我们的目标是：对于集合S中的某个文档对<xi,yi>来说，h要符合我们之前的设定，也就是：</xi,yi></xi,yi></p>
<p>当h(xi)&gt;h(yi)时，h是正确的，不造成损失；<br>当h(xi)&lt;h(yi)时，h是不符合预期的，会造成损失，并且损失的大小成残差的平方级别；</p>
<p>将R(h)与每个 pair 对<xi,yi>的cost画成图可表示为：<br><img src="https://i.loli.net/2017/09/25/59c8ba5bd7a2e.png" alt=""> </xi,yi></p>
<p>上述风险函数直接优化比较困难，这里一个巧妙的解决方案：也就是首先固定h(xi)或者h(yi)当中其中的一个，然后再通过回归的方式来解决问题。<br>为了避免优化函数h是一个常量，我们对风险函数加入一个平滑项τ(0&lt;τ≤10)：<br><img src="https://i.loli.net/2017/09/25/59c8ba71a4abd.png" alt=""><br>其实加上了这个平滑项之后，一来可以防止h变为常数，二来还对损失函数给了更严格的条件：如果希望xi&gt;yi，就得有h(xi)&gt;h(yi)+τ，也就是更为严格了。</p>
<p>接下来我们用Functional Gradient Descent法来求解h.</p>
<p>参考文献<a href="http://www.cnblogs.com/bentuwuying/p/6684585.html" target="_blank" rel="external">Learning to Rank算法介绍：GBRank</a>对这个求解方法做了扼要的介绍：</p>
<p>在GBDT中，Functional Gradient Descent的使用为：将需要求解的F(x)表示成一个additive model，即将一个函数分解为若干个小函数的加和形式，而这每个小函数的产生过程是串行生成的，即每个小函数都是在拟合 loss function在已有的F(x)上的梯度方向（由于训练数据是有限个数的，所以F(x)是离散值的向量，而此梯度方向也表示成一个离散值的向量），然后将拟合的结果函数进一步更新到F(x)中，形成一个新的F(x)。</p>
<ol>
<li>将h(xi)和h(xi)作为未知数。梯度下降使得R最小，来求得这些未知数。</li>
<li>对R计算h的负梯度：<br><img src="https://i.loli.net/2017/09/25/59c8baf10df1f.png" alt=""> </li>
<li>当pair对<xi,yi>符合条件时，上述梯度为0；反之，他们对应的梯度为：<br><img src="https://i.loli.net/2017/09/25/59c8bb529920a.png" alt=""> </xi,yi></li>
<li>接下来，还需要知道如何将梯度作用到h的更新上。通过设定xi的目标值为h(yi)+τ。yi的目标值为h(xi)−τ（这一步我的理解就是首先固定x/y中的某一个，然后去计算另一个）。因此在每轮迭代中，当h不满足<xi,yi>会产生一组数据：<img src="https://i.loli.net/2017/09/25/59c8bb6276a5c.png" alt=""> </xi,yi></li>
</ol>
<p>我们需要拟合本轮产生的所有负例。</p>
<p>下面形式化本算法：<br><img src="https://ooo.0o0.ooo/2017/09/25/59c8d9a57ef9f.png" alt=""><br>可以看到step3里面每轮都拟合误判的结果，在迭代中这个集合会越来越小。还有一种做法是将曾经误判的集合维持在训练集中，那么训练集就会始终增长。在这个步骤中使用GBDT模型进行回归预测，当然其他的回归方法也可以使用。</p>
<h1 id="LambdaMART">4. LambdaMART</h1><p>在learn to rank的成长过程中，2000提出了SVMRank，2006年提出GBrank，2008年提出lambdaMART。看了几个比较大的框架，我发现现在市面上最常见的learn to rank算法就是LambdaMART了。接下来先介绍一下LambdaMART的原理，然后再介绍xgboost中是怎么写的LambdaMart。</p>
<h2 id="LambdaMart的原理">4.1. LambdaMart的原理</h2><p>这一小节主要参考资料<a href="https://liam0205.me/2016/07/10/a-not-so-simple-introduction-to-lambdamart/" target="_blank" rel="external">LambdaMART 不太简短之介绍</a></p>
<p>Pointwise和Pairwise类型的LTR算法，将排序问题转化为回归、分类或者有序分类问题。Listwise 类型的 LTR 算法则另辟蹊径，将用户查询（Query）所得的结果作为整体，作为训练用的实例（Instance）。</p>
<p>LambdaMART 是一种 Listwise 类型的 LTR 算法，它基于 LambdaRank 算法和 MART(Multiple Additive Regression Tree)算法，<strong>将搜索引擎结果排序问题转化为回归决策树问题</strong>。MART实际就是梯度提升决策树（GBDT, Gradient Boosting Decision Tree）算法。GBDT 的核心思想是在不断的迭代中，新一轮迭代产生的回归决策树模型拟合损失函数的梯度，最终将所有的回归决策树叠加得到最终的模型。LambdaMART使用一个特殊的 Lambda 值来代替上述梯度，也就是将LambdaRank算法与MART算法加和起来。考虑到LambdaRank是基于RankNet算法的，所以在搞清楚LambdaMART算法之前，我们首先需要了解 MART、RankNet 和 LambdaRank 是怎么回事。</p>
<p>MART其实也是GBDT。此处对GBDT不再做过多的介绍。值得一提的是，MART并不对损失函数的形式做具体规定。实际上，损失函数几乎只需要满足可导这一条件就可以了。这一点非常重要，意味着我们可以把任何合理的可导函数安插在 MART 模型中。LambdaMART 就是用一个 λ 值代替了损失函数的梯度，将 λ和 MART 结合起来罢了。</p>
<h2 id="LambdaMART是怎么来的">4.2. LambdaMART是怎么来的</h2><p>Lambda 的设计，最早是由 LambdaRank 从 RankNet 继承而来。因此，我们先要从 RankNet 讲起。<br>后记：其实这些文章都是到处整理得来，远不及直接看论文的好。如果有兴趣的话，可以读一读微软整理的这篇论文<a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/MSR-TR-2010-82.pdf" target="_blank" rel="external">https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/MSR-TR-2010-82.pdf</a></p>
<p><strong>RankNet的创新</strong></p>
<p>Ranking常见的评价指标都无法求梯度，因此没法直接对评价指标做梯度下降。</p>
<p>RankNet 的创新之处在于，它将不适宜用梯度下降求解的Ranking问题，转化为对概率的交叉熵损失函数的优化问题，从而适用梯度下降方法。</p>
<p>RankNet的终极目标是得到一个带参的算分函数s = f(x;w)</p>
<p>参考文献机器学习—RankNet.md](<a href="https://github.com/MangoLiu/mangoliu.github.io/blob/master/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0---RankNet.md)给了一个非常好的例子：那么如何通过pair来训练，并最终作用到针对point的算分函数上，请看下面的简单例子。假设有以下同一个query下的4个文档，并且有3个特征维度，并对它们进行了人工打分，我们就利用它们来训练model。" target="_blank" rel="external">https://github.com/MangoLiu/mangoliu.github.io/blob/master/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0---RankNet.md)给了一个非常好的例子：那么如何通过pair来训练，并最终作用到针对point的算分函数上，请看下面的简单例子。假设有以下同一个query下的4个文档，并且有3个特征维度，并对它们进行了人工打分，我们就利用它们来训练model。</a></p>
<pre><code>point       特征f1  特征f2  特征f3  label     
文档doc1      3       2        1      3(很好) 
文档doc2      1       2        1      2（好） 
文档doc3      1       1        2      1（一般） 
文档doc4      1       0        3      0（不好） 
</code></pre><p>于是，根据这个算分函数，我们可以根据特征来计算文档xi和xj的得分si和sj：<br>                        Si = f(xi;w),sj = f(xj,w)</p>
<p>我们并不知道每个特征维度的具体权值w[i]。但我们感觉到要训练出这样的结果，就是使label得分比较高的样本得分尽量大，让label低的样本得分尽量小。<br>即本例中，我们应该让f(doc1)得分尽量大，f(doc4)得分尽量小。其实也就是f(doc1)-f(doc4)的结果尽量大，因为这个分差实际就包含了前者尽量大后者尽量小的含义。并且之前那个常量b通过作差后，不见了。<br>这样两两文档即可组成一个文档对，我们把前者好于后者的成为正向文档对；反之称之为负向文档对。正向对表示前者好于后者，负向对表示后者劣于前者。其实表述的是同样的意义。因此，我们只需要正向的对就好了。因为负向对不能再额外提供有意义的信息了。那么我们提取出上面的正向对：</p>
<pre><code>Pair  作差       特征f1 特征f2  特征f3
P12 (doc1-doc2)    2      0       0
P13 (doc1-doc3)    2      1      -1
P14 (doc1-doc4)    2      2      -2
P23 (doc2-doc3)    0      1      -1
P24 (doc2-doc4)    0      2      -2
P34 (doc3-doc4)    0      1      -1
</code></pre><p>需要注意的是，这里的特征也进行了相减！</p>
<p>我们再引入一个文档对概率，表示文档i好于文档j的概率。我们将它称为两者的偏序概率：(这个东西我理解为是将偏序关系转化为概率的函数，类似于lr里面的sigmod函数)<br><img src="https://i.loli.net/2017/09/25/59c8db05e3ddb.png" alt=""> </p>
<p>那么，现在这个问题就转化成了使所有正向对的概率和最大。我们现在已经知道了目标函数，那么接下来就需要一个损失函数来将这个目标函数最优化。<br>再将以上的交叉熵定义为损失函数：<br><img src="https://i.loli.net/2017/09/25/59c8db19cd5b2.png" alt=""><br>然后对这个损失函数进行梯度下降：<br><img src="https://i.loli.net/2017/09/25/59c8db276ebc2.png" alt=""><br>在以上的方法中，我们将偏序关系转化为目标函数，然后再定义目标函数的损失函数，再通过梯度下降法求参数使得损失函数最小，得到目标函数。那么我们能不能直接定义梯度呢？</p>
<p><strong>LambdaRank</strong></p>
<p>参考文献<a href="http://blog.csdn.net/huagong_adu/article/details/40710305" target="_blank" rel="external">Learning To Rank之LambdaMART的前世今生</a>对下面这个图有非常详细的解释。此处对一些重点内容进行摘录。<br><img src="https://ooo.0o0.ooo/2017/09/25/59c8db4cb37ec.png" alt=""><br>如图所示，每个线条表示文档，蓝色表示相关文档，灰色表示不相关文档。<br>RankNet以pairwise error的方式计算cost，左图的cost为13，右图通过把第一个相关文档下调3个位置，第二个文档上条5个位置，将cost降为11，但是像NDCG或者ERR等评价指标只关注top k个结果的排序，在优化过程中下调前面相关文档的位置不是我们想要得到的结果。图 1右图左边黑色的箭头表示RankNet下一轮的调序方向和强度，但我们真正需要的是右边红色箭头代表的方向和强度，即更关注靠前位置的相关文档的排序位置的提升。</p>
<p>LambdaRank正是基于这个思想演化而来，其中Lambda指的就是红色箭头，代表下一次迭代优化的方向和强度，也就是梯度。<br>受LambdaNet的启发，LambdaRank对RankNet的梯度做因式分解：<br><img src="https://i.loli.net/2017/09/25/59c8db76c9652.png" alt=""><br>注意有下面对称性<br><img src="https://i.loli.net/2017/09/25/59c8db85eb3f3.png" alt=""><br><img src="https://i.loli.net/2017/09/25/59c8db9255992.png" alt=""><br>也就是说：<strong>每条文档移动的方向和趋势取决于其他所有与之 label 不同的文档</strong>。<br>现在回过头来看，看看我们做了些什么？</p>
<ul>
<li>分析了梯度的物理意义；</li>
<li>绕开损失函数，直接定义梯度。<br>当然，我们可以反推一下 LambdaRank 的损失函数：<br><img src="https://i.loli.net/2017/09/25/59c8dbaf0603f.png" alt=""> </li>
</ul>
<p><strong>LambdaMART</strong><br>现在的情况变成了这样：</p>
<ul>
<li>MART 是一个框架，缺一个「梯度」；</li>
<li>LambdaRank 定义了一个「梯度」。<br>于是，就有了 LambdaMART：<br><img src="https://i.loli.net/2017/09/25/59c8dbc928934.png" alt=""> </li>
</ul>
<h1 id="Xgboost中的Learning-to-rank">5. Xgboost中的Learning to rank</h1><p>为了后续方便后续小伙伴们的使用，我将官方文档<a href="https://github.com/dmlc/xgboost/tree/master/demo/rank" target="_blank" rel="external">xgboost的learning to rank文档</a>进行扼要的翻译，并在此贴出。<br>Xgboost的rank模型是基于lambdaRank的。<br>XGBoost支持以ranking为目标的学习。在ranking的情况下，数据集一般都需要被格式化为group input：<br>在ranking中，数据是根据不同的真实场景被分为groups的。例如，在学习web pages的rank场景下，rank page数据是根据不同的queries分到各groups的。</p>
<p><strong>数据形式</strong><br><strong>基本数据形式train.txt</strong><br>Xgboost接受像libSVM格式数据，例如：</p>
<pre><code>1 101:1.2 102:0.03
0 1:2.1 10001:300 10002:400
0 0:1.3 1:0.3
1 0:0.01 1:0.3
0 0:0.2 1:0.3
</code></pre><p>每行表示：</p>
<pre><code>label   特征1索引:值 特征2索引:值
</code></pre><p><strong>groups索引文件train.txt.group</strong><br>除了group input format,XGboost需要一个索引group信息的文件，索引文件train.txt.group格式如下：</p>
<pre><code>2
3
</code></pre><p>这意味着，数据集包含5个实例，前两个是一个group，后三个是一个group。</p>
<p><strong>实例权重文件train.txt.weight</strong></p>
<p>XGboost还支持每个实例的权重调整，数据格式如下：</p>
<pre><code>1
0.5
0.5
1
0.5
</code></pre><p><strong>初始margin文件train.txt.base_margin</strong></p>
<p>XGBoost还可以支持每个实例的初始化margin prediction.例如我们对train.txt可以有一个initial margin file:</p>
<pre><code>-0.4
1.0
3.4
</code></pre><p>XGBoost will take these values as initial margin prediction and boost from that. An important note about base_margin is that it should be margin prediction before transformation, so if you are doing logistic loss, you will need to put in value before logistic transformation. If you are using XGBoost predictor, use pred_margin=1 to output margin values.</p>
<p><strong>使用Demo:</strong></p>
<p><a href="https://github.com/stegben/kaggle_outbrain/blob/990f5e1cc18ff0f6156a56b9d919ac0d52222268/train_xgb.py" target="_blank" rel="external">https://github.com/stegben/kaggle_outbrain/blob/990f5e1cc18ff0f6156a56b9d919ac0d52222268/train_xgb.py</a></p>
<p><strong>xgboost的pairwiseRank实现</strong></p>
<p><strong>**如何构造pair对？</strong><br>xgboost/src/objective/rank_obj.cc,75行开始构造pair对。如上理论所说，每条文档移动的方向和趋势取决于其他所有与之 label 不同的文档。因此我们只需要构造不同label的“正向文档对”。其方法主要为:遍历所有的样本，从与本样本label不同的其他label桶中，任意取一个样本，构造成正样本；<br><strong>**如何定义梯度？</strong><br>xgboost/src/objective/rank_obj.cc中，写到了它是使用lambdaWeight.<br>然后将梯度和文档对输入GBDT训练即可。<br><strong>**输出是什么？</strong><br>根据labdaMart原理，输出是模型对每个文档的打分。</p>
<p>#　参考文献</p>
<p><a href="http://www.cnblogs.com/kemaswill/p/3241963.html" target="_blank" rel="external">Learning to Rank之Ranking SVM 简介</a><br><a href="http://www.tuicool.com/articles/yAfiQ3r" target="_blank" rel="external">GBRank:一种基于回归的学习排序算法</a><br><a href="http://mlnote.com/2016/09/18/gbRank-logsitRank-from-up-to-bottom/" target="_blank" rel="external">gbRank &amp; logsitcRank自顶向下</a></p>
]]></content>
      
        <categories>
            
            <category> 机器学习算法 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[深度学习算法-神经网络]]></title>
      <url>/2017/09/05/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
      <content type="html"><![CDATA[<p>本文是吴恩达老师的课程总结。主要参考了<a href="http://blog.csdn.net/koala_tree" target="_blank" rel="external">大树先生</a>和<a href="http://www.bijishequ.com/authorarticle.html?author=PilgrimHui#" target="_blank" rel="external">PilgrimHui</a> 的笔记。如有不当之处，还请各位指出。</p>
<p>本课程附带编程作业。本文的编程作业有：</p>
<ol>
<li><p>实现浅层神经网络 ：<a href="/2017/12/05/深度学习实践-1-3-构建浅层神经网络/" title="深度学习实践-1-3-构建浅层神经网络">深度学习实践-1-3-构建浅层神经网络</a></p>
</li>
<li><p>实现深层神经网络： <a href="/2017/12/10/深度学习实践-1-4-1-构建深层神经网络/" title="深度学习实践-1-4-1-构建深层神经网络">深度学习实践-1-4-1-构建深层神经网络</a></p>
</li>
<li><p>用神经网络做猫脸识别：<a href="/2017/12/10/深度学习实践-1-4-2-用神经网络识别猫/" title="深度学习实践-1-4-2-用神经网络识别猫">深度学习实践-1-4-2-用神经网络识别猫</a></p>
</li>
<li><p>待续</p>
</li>
</ol>
<h1 id="神经网络概念">1. 神经网络概念</h1><p>所谓神经网络就是将许多个单一“神经元”联结在一起，这样，一个“神经元”的输出就可以是另一个“神经元”的输入。神经网络就是按照一定规则将多个神经元连接起来的网络。</p>
<p><img src="https://i.loli.net/2017/09/05/59aea656bf8da.png" alt=""><br>我们使用圆圈来表示神经网络的输入，标上“+1”的圆圈被称为<strong>偏置节点</strong>，也就是截距项。神经网络最左边的一层叫做<strong>输入层</strong>，最右的一层叫做<strong>输出层</strong>（本例中，输出层只有一个节点）。中间所有节点组成的一层叫做<strong>隐藏层</strong>，因为我们不能在训练样本集中观测到它们的值。同时可以看到，以上神经网络的例子中有3个<strong>输入单元</strong>（偏置单元不计在内），3个<strong>隐藏单元</strong>及一个<strong>输出单元</strong>。</p>
<p>记：<br>$a^{[0]} = X$，表示输入特征，也表示“acitive value”<br>$a^{[1]}$，表示隐藏层的“active value”<br>$a^{[2]} = y^{\text{~}}$，表示输出层</p>
<p>刚才提到的是一种最简单的神经网络，叫<strong>深度前馈(feedforword)网络</strong>，又称前馈神经网络、多层感知机，是典型的深度学习模型。</p>
<p>前馈网络的目标是近似某个函数$f^*(x)$,将输入$x$映射到输出$y$。</p>
<p>而映射$ f(x;\theta)$，并且学习参数$\theta$的值，使它能够得到最佳函数$f^*(x) $的近似。</p>
<p>前馈是因为没有反馈连接。如果有反馈的话，叫循环(recurrent)神经网络。</p>
<p>全连接：第N层的每个神经单元和第N-1层的所有神经元相连。</p>
<a id="more"></a>
<h1 id="浅层神经网络">2. 浅层神经网络</h1><p>上面简单地介绍了神经网络的构造。我们首先从浅层神经网络开始看起，看看如何通过样本学习到一个模型，然后用这个模型对新的样本进行预测。</p>
<p>那么我们就需要解决两个问题：</p>
<ol>
<li><p>如何通过x+模型 –&gt; 计算y’</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">---------------------------------------</div><div class="line">  --&gt; |	          |</div><div class="line">x --&gt; |	神经网络   | ---&gt; 得到预测的y&apos;</div><div class="line">  --&gt; |	          |</div><div class="line">---------------------------------------</div></pre></td></tr></table></figure>
</li>
<li><p>如何通过x + y –&gt; 计算模型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">-------------------------------------------</div><div class="line">      --&gt; |	          |</div><div class="line">x + y --&gt; |	前向+反向  | ---&gt; 得到网络参数w,b</div><div class="line">      --&gt; |	          |</div><div class="line">--------------------------------------------</div></pre></td></tr></table></figure>
<p>首先我们来解决第一个问题，如何计算输出。</p>
</li>
</ol>
<h2 id="如何计算输出？">2.1. 如何计算输出？</h2><p>首先，我们回顾最简单的LR单元如何计算输出：</p>
<ol>
<li>首先计算$z = w^Tx+b$;</li>
<li>代入激活函数计算$a = a(z)$</li>
<li>得到预测值$a = y^{\text ~}$</li>
</ol>
<p>在神经网络中，我们以此计算每个神经元即可。</p>
<p>为了方便表示，我们先约定符号：<br>$$a_{i\text{&lt;- node index in layer}}^{[j]\text{&lt;- layer index}}$$</p>
<p>上标方括号表示层数；下标表示在本层的第几个node。</p>
<p>因此，在神经网络中，我们计算以下即可：<br><img src="https://i.loli.net/2017/09/06/59afebe9849fe.png" alt=""> </p>
<p>即依次计算z和a即可。</p>
<p>我们将上面的计算过程向量化，得到：<br>$$<br>z^{[1]} =<br>\begin{bmatrix}<br>w_1^{[1]T}\\<br>w_2^{[1]T}\\<br>w_3^{[1]T} \\<br>\end{bmatrix}<br>\begin{bmatrix}<br>x_1\\<br>x_2\\<br>x_3\\<br>\end{bmatrix}<br>+\begin{bmatrix}<br>b_1^{[1]}\\<br>b_2^{[1]}\\<br>b_3^{[1]} \\<br>\end{bmatrix}<br>$$<br>$$=\begin{bmatrix}<br>w_1^{[1]T}x+b_1^{[1]}\\<br>w_2^{[1]T}x+b_2^{[1]}\\<br>w_3^{[1]T}x+b_3^{[1]} \\<br>\end{bmatrix}<br>=\begin{bmatrix}<br>z_1^{[1]}\\<br>z_2^{[1]}\\<br>z_3^{[1]} \\<br>\end{bmatrix}<br>$$</p>
<p>而这一层得到的输出$a$作为下一层的输入$x$</p>
<p>因此在神经网络中，我们按照以下步骤计算：<br><img src="https://i.loli.net/2017/09/06/59aff15c7043c.png" alt=""> </p>
<p>我们将上面的计算步骤叫作<strong>前向传播</strong>。即：给定第$l$层激活值$a^{[l]}$，第$l+1$层的激活值$a^{[l+1]}$可以按照以下步骤得到：<br>$z^{[l+1]} = w^{[l]}a^{[l]}+b^{[l]}$<br>$a^{[l+1]} =  a(z^{[l+1]})$</p>
<p><strong>向量化-加速多样本计算</strong></p>
<p>在上一节中，我们讲到我们的输出是依次计算的。即从$x^{(1)}$到$x^{(m)}$</p>
<p>假设输入样本$X$有m个，那么我们的计算过程为：<br>$x^{(1)} \text{  ———-&gt;  } a^{[l]\text{(1)}} = y^{\text{~(1)}}$<br>…<br>$x^{(i)} \text{  ———-&gt;  } a^{[l]\text{(i)}} = y^{\text{~(i)}}$<br>…<br>$x^{(m)} \text{  ———-&gt;  } a^{[l]\text{(m)}} = y^{\text{~(m)}}$</p>
<p>同样的，我们也可以将这个过程向量化，只需要将m个样本放入一个大矩阵$X$中即可。此处对于我来说较容易理解，故不再多加阐述。</p>
<p><strong>激活函数</strong></p>
<p>回顾之前的内容，我们的网络为：</p>
<ol>
<li>计算$z = wx+b$</li>
<li>将$z$代入激活函数$\sigma(z)$得到预测值</li>
</ol>
<p>其中的$\sigma = \frac{1}{1+e^{-z}}$就是sigmod激活函数。当然也有其它的激活函数：</p>
<ol>
<li>$tanh$(在神经网络隐藏层，$tanh$比$\sigma$表现更佳)<br>$tanh(z) = \frac{e^z-e^{-z}}{e^z+e^{-z}}$<br><img src="https://i.loli.net/2017/10/15/59e3657d65b64.png" alt=""> </li>
<li>$ReLU$-修正线性单元，更普遍<br>$a=max(0,z)$<br>学习速度很快</li>
<li>带泄露的ReLU<br>$a=max(0.0001z,z)$<br>z小于零时，函数稍微倾斜一些</li>
</ol>
<p><strong>为什么需要激活函数？</strong></p>
<p>会导致输出结果就是输入特征的线性组合，导致网络并没有什么卵用。</p>
<h2 id="如何计算参数">2.2. 如何计算参数?</h2><p>接下来我们来解决第二个问题：</p>
<p>如何通过x + y –&gt; 计算模型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">-------------------------------------------</div><div class="line">      --&gt; |	          |</div><div class="line">x + y --&gt; |	前向+反向  | ---&gt; 得到网络参数w,b</div><div class="line">      --&gt; |	          |</div><div class="line">--------------------------------------------</div></pre></td></tr></table></figure>
<p>这个过程我们主要由两部分构成：</p>
<ol>
<li>正向传播，通过现有的网络计算输出y‘，然后计算损失函数L</li>
<li>反向传播，通过损失函数L，计算参数对L的导数dL/dw和dL/db，然后得到新的w和b。回到第1步。</li>
</ol>
<h3 id="正向传播">2.2.1. 正向传播</h3><p>我的理解是：正向传播就是从输入计算输出的过程，也就是我们常说的进行预测。也就是我们现在已经有了一个模型，只需要把输入喂进去，然后得到的输出就是预测值。</p>
<ol>
<li>$z^{[1]}=w^{[1]}x+b^{[1]}$</li>
<li>$A^{[1]}=g^{[1]}(z^{[1]})$该层的激活函数</li>
<li>$z^{[2]}=w^{[2]}A^{[1]}+B^{[2]}$</li>
<li>$A^{[2]}=g^{[2]}(^{[2]})=\sigma(z^{[2]})$</li>
</ol>
<h3 id="反向传播">2.2.2. 反向传播</h3><p>上述正向传播时我们假设我们已经有了一个模型。但事实上我们应该是已经有了一堆样本想和样本的y，我们想去学习这个模型。那如何进行模型学习呢？就要用到反向传播法，从已知的输出y出发，结合梯度下降，得到一个模型，使得这个模型最符合x的分布。</p>
<p>反向传播算法其实指的是用于计算梯度的方法。而梯度下降是使用这个计算好了的梯度来进行学习的方法。</p>
<p>具体过程的<strong>思想精华：在样本集下，想要得到各层的z=wx+b的参数w和b，使得损失函数L(a,y)最小。用梯度下降法的话，就要沿着$L(a,y)$导数的方向来调节w和b。</strong></p>
<p>关于误差函数$L(a,y)$我会在之后的博客<a href="https://jiayi797.github.io/2017/10/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-%E8%AF%AF%E5%B7%AE%E5%87%BD%E6%95%B0%E6%8E%A2%E7%A9%B6/" target="_blank" rel="external">误差函数探究</a>里进行叙述。</p>
<p>要计算$L(a,y)$的导数$\frac{dL(a,y)}{da}=-\frac{y}{a} + \frac{1-y}{1-a}$,那么就要计算$dz=\frac{dL}{dz}$，从而要计算$dw=\frac{dL}{dw}$和$db=\frac{dL}{db}$</p>
<ol>
<li>$dz^{[2]}=A^{[2]}-Y,Y=[y^{[1]}],y^{[2]},…,y^{[m]}$</li>
<li>$dw^{[2]}=\frac{1}{m}dz^{[2]}A^{[1]T}$</li>
<li>$db^{[2]}=\frac{1}{m}sum(dz^{[2]},axis=1,keepdims=True)$</li>
<li>$dz^{[1]}=w^{[2]T}dz^{[2]} \times g^{[1]’}(z^{[1]})$</li>
<li>$dw^{[1]}=\frac{1}{m}dz^{[1]}X^T$</li>
<li>$db^{[1]}=\frac{1}{m}np.sum(dz^{[1]},axis=1,keepdims=True)$</li>
</ol>
<h1 id="深度神经网络">3. 深度神经网络</h1><p>上面介绍完了浅层神经网络。接下来我们看看深度神经网络是怎样计算的。</p>
<h2 id="深度神经网络的好处">3.1. 深度神经网络的好处</h2><p><strong>人脸识别和语音识别</strong></p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-11-07-20-02-37.png" alt=""> </p>
<p>对于人脸识别，神经网络的第一层从原始图片中提取人脸的轮廓和边缘，每个神经元学习到不同边缘的信息；网络的第二层将第一层学得的边缘信息组合起来，形成人脸的一些局部的特征，例如眼睛、嘴巴等；后面的几层逐步将上一层的特征组合起来，形成人脸的模样。随着神经网络层数的增加，特征也从原来的边缘逐步扩展为人脸的整体，由整体到局部，由简单到复杂。层数越多，那么模型学习的效果也就越精确。</p>
<p>对于语音识别，第一层神经网络可以学习到语言发音的一些音调，后面更深层次的网络可以检测到基本的音素，再到单词信息，逐渐加深可以学到短语、句子。</p>
<p>所以从上面的两个例子可以看出随着神经网络的深度加深，模型能学习到更加复杂的问题，功能也更加强大。</p>
<p><strong>电路逻辑计算</strong></p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-11-07-20-03-13.png" alt=""> </p>
<p>假定计算异或逻辑输出：</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-11-07-20-03-48.png" alt=""></p>
<p>对于该运算，若果使用深度神经网络，每层将前一层的相邻的两单元进行异或，最后到一个输出，此时整个网络的层数为一个树形的形状，网络的深度为 <img src="http://www.zhihu.com/equation?tex=O%28%5Clog_%7B2%7D%28n%29%29" alt="O(\log_{2}(n))"> ，共使用的神经元的个数为： </p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-11-07-20-04-05.png" alt=""> </p>
<p>即输入个数为n，输出个数为n-1。</p>
<p>但是如果不适用深层网络，仅仅使用单隐层的网络（如右图所示），需要的神经元个数为 <img src="http://www.zhihu.com/equation?tex=2%5E%7Bn-1%7D" alt="2^{n-1}"> 个 。同样的问题，但是深层网络要比浅层网络所需要的神经元个数要少得多。</p>
<h2 id="前向传播和反向传播">3.2. 前向传播和反向传播</h2><p><img src="http://om1bxijvl.bkt.clouddn.com/2017-11-07-21-20-54.png" alt=""> </p>
<p>规定以下符号：</p>
<ul>
<li>$L$：DNN的层数</li>
<li>$n^{[l]}$：第$l$层的包含的单元个数</li>
<li>$a^{[l]}$：第$l$层激活函数的输出</li>
<li>$W^{l}$：第$l$层的参数</li>
<li>输入$x$记为$a^{[0]}$。输出$y’$记为$a^{[L]}$</li>
</ul>
<p><strong>总体框架</strong></p>
<p>深层网络的前向传播和反向传播的总体框架如下：</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-11-07-21-29-22.png" alt=""> </p>
<ol>
<li>输入X</li>
<li>通过一层层的计算$a^{[l]}=g^{[l]}(w^{[l]}\cdot a^{[l-1]}+b^{[l]})$，得到最终的$y’$——<strong>前向传播</strong></li>
<li>通过$y’$计算损失$L(y’,y)$，计算出$da^{[l]}$——<strong>反向传播1</strong></li>
<li>通过$da^{[l]}$计算$da^{[l-1]}$，然后通过每层的$da^{[l]}$计算本层的$dw^{[l]}$和$db^{[l]}$——<strong>反向传播2</strong></li>
<li>然后再返回第2步，进行迭代</li>
</ol>
<p><strong>前向传播</strong></p>
<p>输入：$a^{[l-1]}$</p>
<p>输出：$a^{[l]}$和临时变量$cache(z^{[l]})$</p>
<p>计算：</p>
<p>$$z^{[l]}=w^{[l]}\cdot a^{[l-1]}+b^{[l]}$$</p>
<p>$$a^{[l]}=g^{[l]}(z^{[l]})$$</p>
<p><strong>反向传播</strong></p>
<p>输入：$da^{[l]}$</p>
<p>输出：$dw^{[l]},db^{[l]},da^{[l-1]}$</p>
<p>计算$dz^{[l]}$：</p>
<p>$$dz^{[l]}=\frac{dL}{dz^{[l]}}=\frac{dL}{da^{[l]}}\cdot \frac{dL}{d^{[l]}}=\frac{dL}{da^{[l]}}\cdot  g^{[l]’}(z^{[l]}) = da^{[l]}\cdot g^{[l]’}(z^{[l]})$$</p>
<p>计算$dw^{[l]}$：</p>
<p>$$dw^{[l]}=\frac{dL}{dw^{[l]}}=\frac{dL}{dz^{[l]}}*\frac{dz^{[l]}}{dw^{[l]}}=\frac{dL}{dz^{[l]}}\cdot a^{[l-1]}=dz \cdot a^{[l-1]}$$</p>
<p>计算$db^{[l]}$:</p>
<p>$$db^{[l]}=\frac{dL}{db^{[l]}}=\frac{dL}{dz^{[l]}}*\frac{dz^{[l]}}{db^{[l]}}=\frac{dL}{dz^{[l]}}=dz^{[l]}$$</p>
<p>计算$da^{[l-1]}$:</p>
<p>$$da^{[l-1]}=\frac{dL}{da^{[l-1]}}=\frac{dL}{dz^{[l]}}\cdot \frac{dz^{[l]}}{da^{[l-1]}}=dz^{[l]}\cdot w^{[l]}$$</p>
<h1 id="改善深层神经网络">4. 改善深层神经网络</h1><h2 id="训练、验证、测试集">4.1. 训练、验证、测试集</h2><p>对于一个需要解决的问题的样本数据，在建立模型的过程中，我们会将问题的<strong>data</strong>划分为以下几个部分：</p>
<ul>
<li><strong>训练集</strong>（train set）：用训练集对算法或模型进行训练过程；</li>
<li><strong>验证集</strong>（development set）：利用验证集或者又称为简单交叉验证集（hold-out cross validation set）进行交叉验证，选择出最好的模型；</li>
<li><strong>测试集</strong>（test set）：最后利用测试集对模型进行测试，获取模型运行的无偏估计。</li>
</ul>
<p><strong>小数据时代</strong></p>
<p>在小数据量的时代，如：100、1000、10000的数据量大小，可以将<strong>data</strong>做以下划分：</p>
<ul>
<li>无验证集的情况：70% / 30%；</li>
<li>有验证集的情况：60% / 20% / 20%；</li>
</ul>
<p>通常在小数据量时代，以上比例的划分是非常合理的。</p>
<p><strong>大数据时代</strong></p>
<p>但是在如今的大数据时代，对于一个问题，我们拥有的<strong>data</strong>的数量可能是百万级别的，所以验证集和测试集所占的比重会趋向于变得更小。</p>
<p>验证集的目的是为了验证不同的算法哪种更加有效，所以验证集只要足够大能够验证大约2-10种算法哪种更好就足够了，不需要使用20%的数据作为验证集。如百万数据中抽取1万的数据作为验证集就可以了。</p>
<p>测试集的主要目的是评估模型的效果，如在单个分类器中，往往在百万级别的数据中，我们选择其中1000条数据足以评估单个模型的效果。</p>
<ul>
<li>100万数据量：98% / 1% / 1%；</li>
<li>超百万数据量：99.5% / 0.25% / 0.25%（或者99.5% / 0.4% / 0.1%）</li>
</ul>
<p><strong>Notation</strong></p>
<ul>
<li>建议验证集要和训练集来自于同一个分布，可以使得机器学习算法变得更快；</li>
<li>如果不需要用无偏估计来评估模型的性能，则可以不需要测试集。</li>
</ul>
<h2 id="偏差、方差">4.2. 偏差、方差</h2><p>对于下图中两个类别分类边界的分割： </p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-12-16-41-05.png" alt=""> </p>
<p>从图中我们可以看出：</p>
<ul>
<li>欠拟合（underfitting）的情况下，出现高偏差（high bias）的情况；</li>
<li>过拟合（overfitting）的情况下，出现高方差（high variance）的情况。</li>
</ul>
<p>在bias-variance tradeoff 的角度来讲，我们利用训练集对模型进行训练就是为了使得模型在train集上使 bias（偏差） 最小化，避免出现underfitting的情况；</p>
<p>但是如果模型设置的太复杂，虽然在train集上 bias 的值非常小，模型甚至可以将所有的数据点正确分类，但是当将训练好的模型应用在dev 集上的时候，却出现了较高的错误率。这是因为模型设置的太复杂则没有排除一些train集数据中的噪声，使得模型出现overfitting的情况，在dev 集上出现高方差的现象。</p>
<p>所以对于bias和variance的权衡问题，对于模型来说是一个十分重要的问题。</p>
<p>假如对于一个数据集，以下几种模型：</p>
<table>
<thead>
<tr>
<th>模型</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td>训练集误差</td>
<td>1%</td>
<td>15%</td>
<td>15%</td>
<td>0.5%</td>
</tr>
<tr>
<td>验证集误差</td>
<td>11%</td>
<td>16%</td>
<td>30%</td>
<td>1%</td>
</tr>
<tr>
<td></td>
<td>高方差</td>
<td>高偏差</td>
<td>高偏差、高方差</td>
<td>低偏差、低方差</td>
</tr>
<tr>
<td></td>
<td>过拟合</td>
<td>欠拟合</td>
<td>欠拟合</td>
</tr>
</tbody>
</table>
<p>上面的模型3出现的原因可能如下：</p>
<p>没有找到边界线（蓝色部分），但却在部分数据点上出现了过拟合（紫色），则会导致这种高偏差和高方差的情况。</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-12-16-48-33.png" alt=""> </p>
<p>虽然在这里二维的情况下可能看起来较为奇怪，出现的可能性比较低；但是在高维的情况下，出现这种情况就成为可能。</p>
<p><strong>解决高偏差和高方差</strong></p>
<p>在训练机器学习模型的过程中，解决高偏差（High bias）和高方差（High variance）的过程：</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-12-16-51-45.png" alt=""> </p>
<ul>
<li>存在高偏差？<ul>
<li>增加网络结构，如增加隐藏层数目；</li>
<li>训练更长时间；</li>
<li>寻找合适的网络架构，使用更大的NN结构；</li>
</ul>
</li>
<li>存在高方差？<ul>
<li>获取更多的数据；</li>
<li>正则化（ regularization）；</li>
<li>寻找合适的网络结构；</li>
</ul>
</li>
</ul>
<p>在大数据时代，深度学习对监督式学习大有裨益，使得我们不用像以前一样太过关注如何平衡偏差和方差的权衡问题，通过以上方法可以使得再不增加另一方的情况下减少一方的值。</p>
<h1 id="正则化">5. 正则化</h1><p>利用正则化来解决高方差的问题，正则化是在 Cost function 中加入一项正则化项，惩罚模型的复杂度。</p>
<h2 id="逻辑回归的正则化">5.1. 逻辑回归的正则化</h2><p>加入正则化项的代价函数： </p>
<p>$$J(w,b)=\dfrac{1}{m}\sum\limits_{i=1}^{m}l(\hat y^{(i)},y^{(i)})+正则化项$$</p>
<p>其中，正则化项有：</p>
<ul>
<li>L2正则化：$\dfrac{\lambda}{2m}||w||_{2}^{2} = \dfrac{\lambda}{2m}\sum\limits_{j=1}^{n_{x}} w_{j}^{2}=\dfrac{\lambda}{2m}w^{T}w$</li>
<li>L1正则化：$\dfrac{\lambda}{2m}||w||_{1}=\dfrac{\lambda}{2m}\sum\limits_{j=1}^{n_{x}}|w_{j}|$</li>
</ul>
<p>其中，$\lambda$是正则化因子</p>
<h2 id="神经网络的正则化">5.2. 神经网络的正则化</h2><p>加入正则化项的代价函数： </p>
<p>$$J(w^{[1]},b^{[1]},\cdots,w^{[L]},b^{[L]})=\dfrac{1}{m}\sum\limits_{i=1}^{m}l(\hat y^{(i)},y^{(i)})+\dfrac{\lambda}{2m}\sum\limits_{l=1}^{L}||w^{[l]}||_{F}^{2}$$</p>
<p>其中，$||w^{[l]}||_{F}^{2}=\sum\limits_{i=1}^{n^{[l-1]}}\sum\limits_{j=1}^{n^{[l]}}(w_{ij}^{[l]})^{2}$。而因为$w$的大小为$(n^{[l-1]},n^{[l]})$，因此该矩阵范数被称为“Frobenus norm”。</p>
<p><strong>权重衰减</strong></p>
<p>在加入正则化项后，梯度变为：</p>
<p>$$\frac{dL}{dW^{[l]}} = dW^{[l]} = (form_backprop)+\dfrac{\lambda}{m}W^{[l]}$$</p>
<p>因此梯度更新公式变为：</p>
<p>$$W^{[l]}:= W^{[l]}-\alpha dW^{[l]}\\= W^{[l]}-\alpha [ (form_backprop)+\dfrac{\lambda}{m}W^{[l]}]\ = W^{[l]}-\alpha\dfrac{\lambda}{m}W^{[l]} -\alpha(form_backprop)\\=(1-\dfrac{\alpha\lambda}{m})W^{[l]}-\alpha(form_backprop)$$</p>
<p>其中，$(1-\dfrac{\alpha\lambda}{m}) &lt; 1$，因此会给原来的$W^{[l]}$带来一个衰减的参数。因此L2范数正则化又被称为“权重衰减(weight decay)”。</p>
<h2 id="为什么正则化可以减小过拟合">5.3. 为什么正则化可以减小过拟合</h2><p>假设下图的神经网络结构属于过拟合状态： </p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-12-17-10-25.png" alt=""> </p>
<p>对于神经网络的Cost function： </p>
<p>$$J(w^{[1]},b^{[1]},\cdots,w^{[L]},b^{[L]})=\dfrac{1}{m}\sum\limits_{i=1}^{m}l(\hat y^{(i)},y^{(i)})+\dfrac{\lambda}{2m}\sum\limits_{l=1}^{L}||w^{[l]}||_{F}^{2}$$</p>
<p><strong>直观解释</strong></p>
<p>加入正则化项，直观上理解，正则化因子λ设置的足够大的情况下，为了使代价函数最小化，权重矩阵W就会被设置为接近于0的值。则相当于消除了很多神经元的影响，那么图中的大的神经网络就会变成一个较小的网络。</p>
<p>当然上面这种解释是一种直观上的理解，但是实际上隐藏层的神经元依然存在，但是他们的影响变小了，便不会导致过拟合。</p>
<p><strong>数学解释</strong></p>
<p>假设神经元中使用的激活函数为$g(z)=tanh(z)$，在加入正则化项后： </p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-12-17-11-56.png" alt=""> </p>
<p>当$λ$增大，导致$W[l]$减小，$Z^{[l]}=W^{[l]}a^{[l-1]}+b^{[l]}$便会减小，由上图可知，在z较小的区域里，$tanh(z)$函数近似线性，所以每层的函数就近似线性函数，整个网络就成为一个简单的近似线性的网络，从而不会发生过拟合。</p>
<h2 id="Dropout正则化">5.4. Dropout正则化</h2><p>Dropout（随机失活）就是在神经网络的Dropout层，为每个神经元结点设置一个随机消除的概率，对于保留下来的神经元，我们得到一个节点较少，规模较小的网络进行训练。</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-12-17-14-04.png" alt=""> </p>
<p><strong>实现方法：反向随机激活（inverted dropout）</strong></p>
<p>假设对 layer 3 进行dropout：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">keep_prob = <span class="number">0.8</span>  <span class="comment"># 设置神经元保留概率</span></div><div class="line">d3 = np.random.rand(a3.shape[<span class="number">0</span>], a3.shape[<span class="number">1</span>]) &lt; keep_prob</div><div class="line">a3 = np.multiply(a3, d3)</div><div class="line">a3 /= keep_prob</div></pre></td></tr></table></figure>
<p>依照例子中的<code>keep_prob = 0.8</code> ，那么就有大约20%的神经元被删除了，也就是说$a[3]$中有20%的元素被归零了，在下一层的计算中有$Z^{[4]}=W^{[4]}\cdot a^{[3]}+b^{[4]}$，所以为了不影响Z[4]的期望值，所以需要$W^{[4]}\cdot a^{[3]}$的部分除以一个keep_prob。</p>
<p>Notation：在测试阶段不要用dropout，因为那样会使得预测结果变得随机。</p>
<p><strong>缺点</strong></p>
<p>dropout的一大缺点就是其使得 Cost function不能再被明确的定义，因为每次迭代都会随机消除一些神经元结点，所以我们无法绘制出每次迭代J(W,b)下降的图，如下：</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-12-17-21-05.png" alt=""> </p>
<p><strong>使用Dropout：</strong></p>
<ul>
<li>关闭dropout功能，即设置 keep_prob = 1.0；</li>
<li>运行代码，确保$J(W，b)$函数单调递减；</li>
<li>再打开dropout函数。</li>
</ul>
<h2 id="其它正则化方法">5.5. 其它正则化方法</h2><ul>
<li><p>数据扩增（Data augmentation）：通过图片的一些变换，得到更多的训练集和验证集； </p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-12-17-22-46.png" alt=""> </p>
</li>
<li><p>Early stopping：在交叉验证集的误差上升之前的点停止迭代，避免过拟合。这种方法的缺点是无法同时解决bias和variance之间的最优。</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-12-17-23-08.png" alt="">  </p>
</li>
</ul>
<h1 id="归一化输入">6. 归一化输入</h1><p>对数据集特征x1,x2归一化的过程： </p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-12-17-26-15.png" alt=""> </p>
<ul>
<li>计算每个特征所有样本数据的均值：$\mu = \dfrac{1}{m}\sum\limits_{i=1}^{m}x^{(i)}$</li>
<li>减去均值得到对称的分布$x : =x-\mu$</li>
<li>归一化方差 : $\sigma^{2} = \dfrac{1}{m}\sum\limits_{i=1}^{m}x^{(i)^{2}},x = x/\sigma^{2}$</li>
</ul>
<p><strong>使用归一化的原因</strong>：</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-12-17-33-01.png" alt=""> </p>
<p>由图可以看出不使用归一化和使用归一化前后Cost function 的函数形状会有很大的区别。</p>
<p>在不使用归一化的代价函数中，如果我们设置一个较小的学习率，那么很可能我们需要很多次迭代才能到达代价函数全局最优解；如果使用了归一化，那么无论从哪个位置开始迭代，我们都能以相对很少的迭代次数找到全局最优解。</p>
<h1 id="梯度相关">7. 梯度相关</h1><h2 id="梯度消失与梯度爆炸">7.1. 梯度消失与梯度爆炸</h2><p>如下图所示的神经网络结构，以两个输入为例：</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-12-17-56-17.png" alt=""> </p>
<p>方便起见，我们先假定激活函数$g(z) = z$，偏置$b = 0$。那么目标输出是：</p>
<p>$\hat y = W^{[L]}W^{[L-1]}\cdots W^{[2]}W^{[1]}X$</p>
<ul>
<li>如果$W^{[l]}$大于1：<br>$W^{[l]}=\left[ \begin{array}{l}  1.5 &amp; 0 \ 0 &amp; 1.5\end{array} \right]$，随着一层层的递进，激活函数的值将以指数递增；</li>
<li>如果$W^{[l]}$小于1：<br>$W^{[l]}=\left[ \begin{array}{l}  0.5 &amp; 0 \ 0 &amp; 0.5\end{array} \right]$，随着一层层的递进，激活函数的值将以指数递减；</li>
</ul>
<p>而对于梯度来说，梯度函数也会以指数级递增或递减，也叫做梯度爆炸或梯度消失。那么就会出现如下的图所示的情况：</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-12-19-49-59.png" alt=""> </p>
<p>当参数接近这样的悬崖区域时，梯度下降更新会使参数弹得非常远，可能会让大量已完成的优化工作成为无用功。</p>
<p><strong>解决梯度消失与爆炸</strong></p>
<p><strong>利用初始化缓解梯度消失和爆炸</strong></p>
<p>以一个单个神经元为例子：</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-12-19-55-25.png" alt="">  </p>
<p>由上图可知，当输入的数量$n$较大时，我们希望每个$w_i$的值都小一些，这样它们的和得到的$z$也较小。这里为了得到较小的$w_i$，将它初始化为$Var(w_i)=\frac{1}{n}$，这里称为Xavier initialization。 即：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">WL = np.random.randn(WL.shape[<span class="number">0</span>],WL.shape[<span class="number">1</span>])* np.sqrt(<span class="number">1</span>/n)</div></pre></td></tr></table></figure>
<p>这么做是因为，如果激活函数的输入$x$近似设置成均值为0，标准方差1的情况，输出$z$也会调整到相似的范围内。虽然没有解决梯度消失和爆炸的问题，但其在一定程度上确实减缓了梯度消失和爆炸的速度。</p>
<p>不同激活函数下，也有不同的Xavier initialization：</p>
<ul>
<li>激活函数为Relu时，$Var(w_{i})=\dfrac{2}{n}$</li>
<li>激活函数为tanh时，$Var(w_{i})=\dfrac{1}{n}$</li>
</ul>
<p>其中n是输入神经元个数，也就是$n^{[l-1]}$</p>
<p><strong>启发式梯度截断缓解梯度消失和爆炸</strong></p>
<p>传统的梯度下降的梯度只指明了方向，而步长是定值。而启发式梯度截断的思路是：当传统的梯度建议更新很大一步时，启发式梯度截断会干涉来缩减步长，从而使其不太可能走出梯度近似为最陡方向的悬崖区域。</p>
<h2 id="梯度的数值逼近">7.2. 梯度的数值逼近</h2><p>使用双边误差的方法去逼近导数： </p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-12-20-11-28.png" alt=""> </p>
<p>由图可以看出，双边误差逼近的误差是0.0001，先比单边逼近的误差0.03，其精度要高了很多。</p>
<p>涉及的公式：</p>
<ul>
<li><p>双边导数：<br>$$f’(\theta) = \lim\limits_{\varepsilon  \to 0}=\dfrac{f(\theta+\varepsilon)-(\theta-\varepsilon)}{2\varepsilon}$$<br>误差：$O(\varepsilon^{2})$</p>
</li>
<li><p>单边导数：</p>
<p>$$f’(\theta) = \lim\limits_{\varepsilon  \to 0}=\dfrac{f(\theta+\varepsilon)-(\theta)}{\varepsilon}$$</p>
<p>误差：$O(\varepsilon)$</p>
</li>
</ul>
<h2 id="梯度检验">7.3. 梯度检验</h2><p>众所周知，反向传播算法很难调试得到正确结果，尤其是当实现程序存在很多难于发现的bug时。举例来说，索引的缺位错误（off-by-one error）会导致只有部分层的权重得到训练，再比如忘记计算偏置项。这些错误会使你得到一个看似十分合理的结果（但实际上比正确代码的结果要差）。因此，但从计算结果上来看，我们很难发现代码中有什么东西遗漏了。本节中，我们将介绍一种对求导结果进行数值检验的方法，该方法可以验证求导代码是否正确。</p>
<p>假设我们已经用代码实现了计算$\frac{dL}{dw}$ 的函数$g(w)$ ，接着我们使用$w:=w - \lambda g(w)$来实现梯度下降算法。那么我们如何检验$g$的实现是否正确呢？</p>
<p>回忆导数的数学定义：</p>
<p><img src="http://ufldl.stanford.edu/wiki/images/math/a/2/3/a23bea0ab48ded7b9a979b68f6356613.png" alt="\begin{align}\frac{d}{d\theta}J(\theta) = \lim_{\epsilon \rightarrow 0}\frac{J(\theta+ \epsilon) - J(\theta-\epsilon)}{2 \epsilon}.\end{align}"></p>
<p>那么对于任意 <img src="http://ufldl.stanford.edu/wiki/images/math/6/9/d/69d920fe8e1da0543eb63d1097f21754.png" alt="\textstyle \theta"> 值，我们都可以对等式左边的导数用：</p>
<p><img src="http://ufldl.stanford.edu/wiki/images/math/4/8/a/48a000aed96c8595fcca2a45f48343ce.png" alt="\begin{align}\frac{J(\theta+{\rm EPSILON}) - J(\theta-{\rm EPSILON})}{2 \times {\rm EPSILON}}\end{align}"></p>
<p>来近似。</p>
<p>实际应用中，我们常将 <img src="http://ufldl.stanford.edu/wiki/images/math/8/5/c/85c12e90fcb870ff439cb037d805e09c.png" alt="\textstyle EPSILON"> 设为一个很小的常量，比如在<img src="http://ufldl.stanford.edu/wiki/images/math/c/f/d/cfd7bf1257600c6c7706c5597af1b94d.png" alt="\textstyle 10^{-4}"> 数量级（虽然 <img src="http://ufldl.stanford.edu/wiki/images/math/8/5/c/85c12e90fcb870ff439cb037d805e09c.png" alt="\textstyle EPSILON"> 的取值范围可以很大，但是我们不会将它设得太小，比如 <img src="http://ufldl.stanford.edu/wiki/images/math/f/a/b/fab2be95b827b3db4ea4d2e27a3d5f99.png" alt="\textstyle 10^{-20}">，因为那将导致数值舍入误差。）</p>
<p>给定一个被认为能计算 <img src="http://ufldl.stanford.edu/wiki/images/math/0/9/6/09643c7c4bb96e039caf25737d835201.png" alt="\textstyle \frac{d}{d\theta}J(\theta)"> 的函数<img src="http://ufldl.stanford.edu/wiki/images/math/e/9/f/e9fed70b38b2cfac3b42d1d21d46e449.png" alt="\textstyle g(\theta)">，我们可以用下面的数值检验公式</p>
<p><img src="http://ufldl.stanford.edu/wiki/images/math/c/6/d/c6d06b4a25dab5ef468c72900872eda0.png" alt="\begin{align}g(\theta) \approx\frac{J(\theta+{\rm EPSILON}) - J(\theta-{\rm EPSILON})}{2 \times {\rm EPSILON}}.\end{align}"></p>
<p>计算两端是否一样来检验函数是否正确。</p>
<p>而在多维情况下，即可计算：</p>
<p>$$\dfrac {||d\theta_{approx}-d\theta||_{2}}{||d\theta_{approx}||_{2}+||d\theta||_{2}}$$</p>
<p>将它与代码计算出来的$g(\theta)$进行比较。如果近似，则说明计算没有出错。</p>
<p>也就是：</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-12-20-20-57.png" alt=""> </p>
<p>再判断$d\theta_{approx}\approx d\theta$是否成立</p>
<p>其中，“$||⋅||2$”表示欧几里得范数，它是误差平方之和，然后求平方根，得到的欧氏距离。</p>
<p><strong>notes</strong></p>
<ul>
<li>不要在训练过程中使用梯度检验，只在debug的时候使用，使用完毕关闭梯度检验的功能；</li>
<li>如果算法的梯度检验出现了错误，要检查每一项，找出错误，也就是说要找出哪个$d\theta_{approx}[i]$与dθ的值相差比较大；</li>
<li>不要忘记了正则化项；</li>
<li>梯度检验不能与dropout同时使用。因为每次迭代的过程中，dropout会随机消除隐层单元的不同神经元，这时是难以计算dropout在梯度下降上的代价函数J；</li>
<li>在随机初始化的时候运行梯度检验，也可以在训练几次后再进行。</li>
</ul>
<h1 id="优化算法">8. 优化算法</h1><h2 id="Mini-batch-梯度下降法">8.1. Mini-batch 梯度下降法</h2><p>对整个训练集进行梯度下降法的时候，我们必须处理整个训练数据集，然后才能进行一步梯度下降，即每一步梯度下降法需要对整个训练集进行一次处理，如果训练数据集很大的时候，如有500万或5000万的训练数据，处理速度就会比较慢。</p>
<p>但是如果每次处理训练数据的一部分即进行梯度下降法，则我们的算法速度会执行的更快。而处理的这些一小部分训练子集即称为Mini-batch。</p>
<p>详细地说，就是在做梯度下降的时候，不选取训练集的所有样本计算损失函数，而是切分成很多个相等的部分，每个部分称为一个mini-batch，我们对一个mini-batch的数据计算代价，做完梯度下降，再对下一个mini-batch做梯度下降。比如500w个数据，一个mini-batch设为1000的话，我们就做5000次梯度下降（5000个mini-batch，每个mini-batch样本数为1000，总共500w个样本）。</p>
<p>对于batch梯度下降（每次计算所有的样本），随着迭代次数增加，代价不断减少。对于mini-batch梯度下降，mini-batch的迭代过程中，代价是震荡下降的（有时上升有时下降），因为每次下降时只考虑了部分样本，下降方向可能不正确。如下图所示：</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-14-22-33-03.png" alt=""> </p>
<p>mini-batch的size为m时就是batch梯度下降，它的弊端是m很大的时候单次训练需要花费很长的时间。</p>
<p>size为1时就是随机梯度下降（每次只计算一个样本），随机梯度下降在每次梯度下降可能会远离最优点，可能会接近最优点，平均来看会不断靠近最优点，但有时也会方向错误。随机梯度下降最终不会收敛，而是会在最优点附近波动。它的弊端就是失去了向量化带来的加速优势，因为每次只训练一个样本，要用m次循环去迭代。</p>
<p>所以实践中选取不大不小的mini-batch size，这样既利用了向量化的优势，也避免了m太大带来的训练时间太长的弊端。它也会震荡式地靠近最优点，但是相比于随机梯度下降要好很好，最终可能会在最优点附近波动，这个时候可以调整学习率来改善该问题。</p>
<p>数据集小的时候，比如m小于2000，一般直接用batch梯度下降；一般mini-batch的size在64，128，256，512这些值之间考虑（考虑到电脑的内存设置方式，设定为2的次方训练比较快）；记得要确保mini-batch的大小要符合你的CPU/GPU大小。</p>
<h2 id="指数加权平均">8.2. 指数加权平均</h2><p>指数加权平均的关键函数： </p>
<p>$$v_{t} = \beta v_{t-1}+(1-\beta)\theta_{t}$$</p>
<p>以时间-温度为例。我们已知每天的温度为Θ1, Θ2,..。那么时间-温度的指数加权平均函数为：V, 有V0 = 0，V(t) = 0.9 <em> V(t-1) + 0.1 </em> Θt。即用（前一天的V乘以0.9）加上（当天的温度乘以0.1）。</p>
<p>对V绘制图，如下图中的红线所示，它大致表示了平均10天的温度</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-14-22-37-50.png" alt=""> </p>
<p>如果我们把它展开：</p>
<p>$$v_{100}=0.1\theta_{100}+0.9(0.1\theta_{99}+0.9(0.1\theta_{98}+0.9v_{97}))\\=0.1\theta_{100}+0.1\times0.9\theta_{99}+0.1\times(0.9)^{2}\theta_{98}+0.1\times(0.9)^{3}\theta_{97}+\cdots$$</p>
<p>我们可以理解为：V就是指数加权了 x天的温度。这个x是多少呢，有个计算方法就是β的x次方约等于1/e，以此求出x，那其实这个x就是1/(1-β)。</p>
<ul>
<li>当β=0.9时，加权了10天，指数加权平均最后的结果如图中红色线所示；</li>
<li>当β=0.98时，加权了50天，指数加权平均最后的结果如图中绿色线所示；</li>
<li>当β=0.5时，加权了2天，指数加权平均最后的结果如下图中黄色线所示；</li>
</ul>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-14-22-38-26.png" alt=""> </p>
<p><strong>指数加权平均的偏差修正</strong></p>
<p>如下图所示，β=0.98时，实际执行上面的计算步骤我们会得到紫色的曲线，而不是绿色曲线。</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-14-23-05-02.png" alt=""> </p>
<p>原因如下：一开始的时候v0 = 0，然后</p>
<p>$$v_{0}=0\\v_{1}=0.98v_{0}+0.02\theta_{1}=0.02\theta_{1}\\v_{2}=0.98v_{1}+0.02\theta_{2}=0.98\times0.02\theta_{1}+0.02\theta_{2}=0.0196\theta_{1}+0.02\theta_{2}$$</p>
<p>如果第一天的值为如40，则得到的$v_{1}=0.02\times40=8$，则得到的值要远小于实际值，后面几天的情况也会由于初值引起的影响，均低于实际均值。</p>
<p>所以刚开始的几个点都会偏低，不能做出很好的估计，所以需要做一定的偏差修正，修正方法为：</p>
<p>$$\dfrac{v_{t}}{1-\beta^{t}}$$</p>
<p>当t = 2 时，$1-\beta^{t}=1-(0.98)^{2}=0.0396$，则$\dfrac{v_{2}}{0.0396}=\dfrac{0.0196\theta_{1}+0.02\theta_{2}}{0.0396}$</p>
<p>偏差修正得到了绿色的曲线，在开始的时候，能够得到比紫色曲线更好的计算平均的效果。到后面t增大，作为分母的( 1 - β^t ) 趋近于0，所以后面绿色的曲线和紫色的曲线逐渐重合了。</p>
<p>虽然存在这种问题，但是在实际过程中，一般会忽略前期均值偏差的影响。</p>
<h2 id="动量梯度下降（Gradient-descent-with-momentum">8.3. 动量梯度下降（Gradient descent with momentum )</h2><p>我们把之前学的指数加权平均应用到梯度下降中可以改善问题。</p>
<p>考虑代价函数的等高线如下图所示，使用mini-batch时因为方向不一定是最优方向，所以可能在不断靠近最优点时候会上下波动（下图蓝线）。</p>
<p>这个时候我们希望在上下方向上用较小的学习步长，在往右方向上使用较大的学习步长，那么可以对求得的梯度做指数加权平均的运算得到一个平均值，这时上下波动求平均，一正一负平均为0，往右前进平均还是往右，在抵达最优点的路上我们减少了动荡，能够以理想的步长去靠近最优点（下图红线）。</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-14-23-09-14.png" alt=""> </p>
<p>具体做法：</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-14-23-09-58.png" alt=""> </p>
<p>即，每次做梯度下降时，求一下指数加权平均，用这个平均值来做梯度下降。</p>
<p>这就是加了动量的梯度下降法，它不像之前的梯度下降（每次下降都是独立于之前的步骤），这个时候就有两个超参数，α和β，β一般设为0.9，表示平均了最近10次的迭代速度。</p>
<p>对于动量的理解：把微分dW理解成球往山下滚的加速度，momentum项v理解成速度，球因为加速度越滚越快，β稍小于1可以理解为摩擦力的阻碍，所以球不会无限加速下去。</p>
<p>关于偏差修正，实际上一般不用，因为10次迭代后就不需要修正了，我们平时的学习一般都不会少于10次。</p>
<h2 id="RMSProp（root-mean-square">8.4. RMSProp（root mean square )</h2><p>还有一种算法叫RMSProp也可以用来加速mini-batch梯度下降，它是在momentum的基础上做了修改。公式如下图所示，dW变成dW的平方，在下降的时候多除以了一个根号项。可以理解成竖直方向的微分项比较大，所以除以一个比较大的数，水平方向的微分项比较小，所以除以一个比较小的数，这样就可以消除下降中的摆动，可以采用较大的学习率快速学习。为了确保除以的分母不会为0，在实操上会加上一个很小的数ε。</p>
<p><img src="http://images2017.cnblogs.com/blog/1160281/201711/1160281-20171121162838852-1473232431.png" alt="img"></p>
<h2 id="Adam">8.5. Adam</h2><p>在深度学习领域，经常有很多新的优化算法被提到然后又遭到质疑。adam和RMSProp是少有的经得起考验的两种优化算法，已经被证明适用于不同的深度学习结构，被用来很好地解决了很多问题。</p>
<p>adam算法基本就是结合了momentum和RMSProp。</p>
<p><strong>算法实现</strong></p>
<ul>
<li>初始化$V_{dw} = 0，S_{dw}=0，V_{db}=0，S_{db} = 0$</li>
<li>第t次迭代：<ul>
<li>在当前的mini-batch上计算$dw,db$</li>
<li>$V_{dw}=\beta_{1}V_{dw}+(1-\beta_{1})dw，V_{db}=\beta_{1}V_{db}+(1-\beta_{1})db$ ——的V就是动量（momentum），与原来的计算方式一样</li>
<li>$S_{dw}=\beta_{2}S_{dw}+(1-\beta_{2})(dw)^{2}，S_{db}=\beta_{2}S_{db}+(1-\beta_{2})(db)^{2}$ ——S按照RMSprop的方式计算</li>
<li>$V_{dw}^{corrected} = V_{dw}/(1-\beta_{1}^{t})，V_{db}^{corrected} = V_{db}/(1-\beta_{1}^{t})$ ——再做一点偏差修正</li>
<li>$S_{dw}^{corrected} = S_{dw}/(1-\beta_{2}^{t})，S_{db}^{corrected} = S_{db}/(1-\beta_{2}^{t})$</li>
<li>$w:=w-\alpha\dfrac{V_{dw}^{corrected}}{\sqrt{S_{dw}^{corrected}}+\varepsilon}，b:=b-\alpha\dfrac{V_{db}^{corrected}}{\sqrt{S_{db}^{corrected}}+\varepsilon}$ —— 按照RMSprop的方式更新</li>
</ul>
</li>
</ul>
<p>这个方法有比较多的超参数，比如学习率α需要自己调整，β1一般为0.9，β2的话adam的论文作者推荐0.999，ε的话adam的论文作者推荐10的-8次方。在使用adam的时候一般β和ε使用缺省值就可以了。</p>
<p>adam表示adaptive moment estimate，β1用于计算dw微分的平均，称为first moment，β2用于计算dw的平方的平均，称为second moment，adam由此而来。</p>
<h2 id="学习率衰减">8.6. 学习率衰减</h2><p>做学习率衰减的原因很简单，就是梯度下降早期离最优点很远，可以用较大的步长靠近，到了后期，离最优点很近的时候就要小心了，因为你跨一大步可能会跨过头，远离最优点。如下图蓝色线所示。</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-15-10-49-15.png" alt=""> </p>
<p>所以到后面步长要变小，也就是学习率要进行衰减。变成绿色线。</p>
<p>学习率衰减常用的方法为：</p>
<ul>
<li><p>常用<br>$$\alpha = \dfrac{1}{1+decay_rate*epoch_num}\alpha_{0}$$</p>
<p>1 / ( 1+ decay rate * epoch_num ) 乘上初始学习率α，衰减率作为新的超参，epoch_num表示迭代了第几轮。</p>
</li>
<li><p>指数衰减<br>$$\alpha = 0.95^{epoch_num}\alpha_{0}$$</p>
</li>
<li><p>其它<br>$$\alpha = \dfrac{k}{epoch_num}\cdot\alpha_{0}$$</p>
</li>
<li><p>离散下降（不同阶段使用不同的学习速率）</p>
</li>
</ul>
<h2 id="局部最优问题">8.7. 局部最优问题</h2><p>在深度学习的早期，人们总是担心优化问题会陷入局部最优。随着深度学习理论的发展，我们对局部最优的理解也发生了改变，我们对它的理解也还在不断发展中。</p>
<p>我们可能会想象到一个Cost function 如左图所示，存在一些局部最小值点，在初始化参数的时候，如果初始值选取的不得当，会存在陷入局部最优点的可能性。</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-15-10-53-43.png" alt=""> </p>
<p>但这些理解并不正确，事实上，如果你要创建一个神经网络，通常梯度为0的点并不是左图那些局部最优点，而是右图的这个鞍点。鞍点可以理解为在某一方向上是极大值点，在另一方向上是极小值点，可以想象成马背上的马鞍。</p>
<p>在高维空间中梯度为0的点，在每个方向上可能是凸函数，也可能是凹函数。比如你在2w维空间中你想得到局部最优，所有的2w个方向都需要是这样的,这样的概率大概是$2^{-20000}$ ，实在是太小了。</p>
<p>也就是说，我们更有可能遇到的是有些方向向上弯曲，而另一些方向向下弯曲，如右图所示，因此在高维空间我们更有可能碰到的是鞍点。</p>
<p>所以在深度学习中（假设你有大量参数，代价函数被定义在高维空间）你不太可能陷入局部极值点，但是位于鞍点这样的平稳地段你可能学习的非常慢，如下图所示。所以才有了momentum，RMSProp，adam这样的算法来加快运算。</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-12-15-11-00-22.png" alt=""> </p>
<p>总之，在高纬度的情况下： </p>
<ul>
<li>几乎不可能陷入局部最小值点； </li>
<li>处于鞍点的停滞区会减缓学习过程，利用如Adam等算法进行改善。</li>
</ul>
<h1 id="参考文献">9. 参考文献</h1><ol>
<li>[吴恩达，deepLearning.ai]</li>
<li><a href="http://ufldl.stanford.edu/wiki/index.php/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C" target="_blank" rel="external">神经网络</a></li>
<li><a href="http://www.jianshu.com/p/d161a22a0292" target="_blank" rel="external">不会停的蜗牛，什么是神经网络</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/29738823" target="_blank" rel="external">大树先生，吴恩达 DeepLearning.ai 课程提炼笔记（1-4）神经网络和深度学习 — 深层神经网络</a></li>
<li><a href="http://ufldl.stanford.edu/wiki/index.php/%E6%A2%AF%E5%BA%A6%E6%A3%80%E9%AA%8C%E4%B8%8E%E9%AB%98%E7%BA%A7%E4%BC%98%E5%8C%96" target="_blank" rel="external">梯度检验与高级优化</a></li>
<li><a href="http://www.bijishequ.com/detail/563266" target="_blank" rel="external">吴恩达-深度学习-课程笔记-7: 优化算法( Week 2 )</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> 深度学习算法 </category>
            
            <category> 神经网络 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Java学习笔记4-泛型数组列表(ArrayList)]]></title>
      <url>/2017/09/04/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04-%E6%B3%9B%E5%9E%8B%E6%95%B0%E7%BB%84%E5%88%97%E8%A1%A8/</url>
      <content type="html"><![CDATA[<p>ArrayList : 是一个采用类型参数(type parameter)的泛型类(generic class)（泛型类指数组内的元素可以是任意类型）。</p>
<p>新建：</p>
<pre><code>ArrayList&lt;Employee&gt; staff = new ArrayList&lt;Employee&gt;();
</code></pre><p>增：</p>
<pre><code>add();
</code></pre><p>若调用add且内部数组已经满了，数组列表就自动地创建一个更大的数组，并将所有的对象从较小的数组中拷贝到较大的数组中。</p>
<p>指定数组大小：</p>
<pre><code>test.ensureCapacity(100);
</code></pre><p>或</p>
<pre><code>ArrayList&lt;Employee&gt; staff = new ArrayList&lt;&gt;(100);
</code></pre><p>一旦确定数组大小不再发生变化，即可调用<code>trimeToSize</code>方法，使得存储区域的大小调整为当前元素数量所需的存储空间数目。垃圾回收器将回收多余的存储空间。</p>
<p>其它操作：</p>
<pre><code>get(index);
set(index,element);
add(index,element);
remove(index);
</code></pre>]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[深度学习算法-引言-LR的梯度下降法]]></title>
      <url>/2017/09/04/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-%E5%BC%95%E8%A8%80-LR%E7%9A%84%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>本节是吴恩达老师在deepLearning.ai第二周课程的笔记。</p>
<p>本节以逻辑回归的梯度下降法为例，讲了我们究竟如何使用梯度下降法。</p>
<h1 id="LR的梯度下降">1. LR的梯度下降</h1><p>在LR中，我们想要得到z=wx+b，并且这个z在样本上，损失函数L(a,y)最小。那么，我们可以不断地改变w和b，找到一个合适的w和b，达到我们上述的目的。</p>
<p><img src="https://i.loli.net/2017/09/04/59acd4eac78da.png" alt=""> </p>
<p>如何改变w和b，能更快地得到最优的w和b呢？那么我们就要使用梯度下降法。<br><img src="https://i.loli.net/2017/09/04/59acd39e1a9ea.png" alt=""> </p>
<p>上图中，从左到右的计算过程就是前向传播法。</p>
<p>一般来说，我们都用后向传播法来计算这个过程：</p>
<p>在单个样本中，<br>想要计算$L(a,y)$的导数:</p>
<ol>
<li>先向前一步，计算损失函数$L(a,y)$关于$a$的导数$da = \frac{dL(a,y)}{da} = -\frac{y}{a} + \frac{1-y}{1-a}$。</li>
<li>再向前一步，计算$dz = \frac{dL}{dz} = a - y$</li>
<li>再向前一步，计算$dw = \frac{dL}{dw} = …=x(a-y), db = …=a-y$</li>
<li>用 $ w = w - \lambda dw,b = b - \lambda db$</li>
</ol>
<p>在m个训练集中，<br>$J(w,b) = \frac{1}{m} \sum{_i^m L(a^{(i)},y^{(i)})}$<br>那么：<br>$\frac{d(J(w,b))}{w1} = \frac{1}{m}\sum_i^m\frac{d(L(w^{(i)},y^{(i)}))}{w_i}$</p>
<p>也就是说，m个训练样本的损失函数的导数 = 每个训练样本损失函数导数的均值</p>
<p>伪代码：</p>
<pre><code>J = 0; dw1 = 0; dw2 = 0 ; db = 0;
for i = 1 to m :
    z = w1x1[i] + w2x2[i] + b ;
    y = sigmod(z) ;
    a = get(i) ;
    J += ylog(a) + (1-y)log(1-a);
    dz = a - y; # 先算dz
    dw1+= x1dz; # 后算dw,db
    dw2 += x2dz;
    db+= dz;
J/= m;
dw1 /= m;
dw2 /= m;
db /= m; 
</code></pre><p>此时就已经得到了全部样本的dw1,dw2,db,J</p>
<p>然后应用梯度下降：</p>
<pre><code>w1 = w1 - sdw1
w2 = w2 - sdw2
b = b - sb
</code></pre><p>其中，s是步长。</p>
<h1 id="向量化">2. 向量化</h1><p>一般来说，for循环是很不好的。可以使用向量化来摆脱for循环，加速运算。接下来我们来讲一讲向量化。</p>
<p>一般来说，如果我们想计算$z = w^T x + b$,其中，w和x都是一个n维的列向量。在非向量化实现中，我们会用：</p>
<pre><code>z = 0;
for i in range(n):
    z += w[i]*x[i];
z += b ;
</code></pre><p>在向量化（例如numpy中），我们用：</p>
<pre><code>z = np.dot(w,x) + b
</code></pre><p>向量运算非常快（主要原因是并行运算）。因此我们尽量将loop运算转换为向量运算。</p>
<h1 id="向量化的LR">3. 向量化的LR</h1><p>x是m维向量</p>
<pre><code>import numpy as np
J = 0; dw1 = 0; dw2 = 0 ; db = 0;
z = np.dot(w.T,x) + b; # m维列向量
y = sigmod(z) ;# m维列向量
a = label;# m维列向量
J = np.dot(y.T,log(a)) + np.dot((1-y).T,log(1-a));
J/= m;
dz = a - y; # 先算dz
dw1 = np.dot(x1.T,dz) /m ; # 后算dw,db
dw2 = np.dot(x2.T,dz) /m ;
db= np.sum(dz) /m ;
</code></pre><p>然后应用梯度下降：</p>
<pre><code>w1 = w1 - sdw1
w2 = w2 - sdw2
b = b - sb
</code></pre><h1 id="总结">4. 总结</h1><p>这一节主要讲了我们如何将梯度下降法应用到LR中，以及强调了Nuppy。应该只是为了后续的学习做一些准备。</p>
<p>一定一定要看这个作业<a href="http://kakack.github.io/2017/09/Logistic-Regression-with-a-Neural-Network-mindset/" target="_blank" rel="external">通过神经网络mindset实现简单的Logistic Regression</a></p>
]]></content>
      
        <categories>
            
            <category> 深度学习算法 </category>
            
            <category> 神经网络 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[机器学习算法-初识Learning to Rank]]></title>
      <url>/2017/08/30/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-%E5%88%9D%E8%AF%86Learning-to-Rank/</url>
      <content type="html"><![CDATA[<p>本文主要对排序模型做一个简要的整理。首先介绍了一些传统的排序模型，然后介绍比较新的learning to rank.</p>
<p>要想了解L2R，首先我们要了解一下传统的排序模型。</p>
<h1 id="传统的排序模型">1. 传统的排序模型</h1><p>传统的排序模型主要分为两类：相关度排序模型和重要性排序模型。</p>
<h2 id="相关度排序模型-Relevance-Ranking-Model">1.1. 相关度排序模型(Relevance Ranking Model)</h2><p>相关度排序模型根据查询和文档之间的相似度来对文档进行排序。常用的模型包括：布尔模型(Boolean Model)，向量空间模型(Vector Space Model)，隐语义分析(Latent Semantic Analysis)，BM25，LMIR模型等等。</p>
<p>相关度排序模型主要用在查询（例如搜索引擎）上，它主要是要计算【关键字】与【文档】之间的相关性，给出【关于关键字】的排序。</p>
<h2 id="重要性排序模型-Importance-Ranking-Model">1.2. 重要性排序模型(Importance Ranking Model)</h2><p>重要性排序模型就不考虑上述提到的【查询】，而仅仅根据网页(亦即文档)之间的图结构来判断文档的权威程度，典型的权威网站包括Google，Yahoo!等。常用的模型包括PageRank，HITS，HillTop，TrustRank等等。</p>
<h2 id="传统排序模型的缺陷">1.3. 传统排序模型的缺陷</h2><p>以上的这些传统的排序模型，单个模型往往只能考虑某一个方面(相关度或者重要性)，所以只是用单个模型达不到要求。搜索引擎通常会组合多种排序模型来进行排序，但是，如何组合多个排序模型来形成一个新的排序模型，以及如何调节这些参数，都是一个很大的问题。</p>
<p>因此，伟大的科学家们提出了Learning to Rank，来解决上述问题。</p>
<h1 id="Learning-to-Rank">2. Learning to Rank</h1><p>Learning to Rank是一种机器学习模型。它使用机器学习的方法，我们可以把各个现有排序模型的【输出作为特征】，然后训练一个新的模型，并自动学得这个新的模型的参数，从而很方便的可以组合多个现有的排序模型来生成新的排序模型。</p>
<h1 id="L2R特征的选取">3. L2R特征的选取</h1><p>与文本分类不同，L2R考虑的是【给定查询的文档集合的排序】。所以，L2R用到的特征不仅仅包含文档d本身的一些特征(比如是否是Spam)等，也包括文档d和给定查询q之间的相关度，以及文档在整个网络上的重要性(比如PageRank值等)，亦即我们可以使用相关性排序模型和重要性排序模型的输出来作为L2R的特征。</p>
<p>总结来说，L2R的特征有以下两点：</p>
<ol>
<li>传统排序模型的输出，既包括相关性排序模型的输出f(q,d)，也包括重要性排序模型的输出。</li>
<li>文档本身的一些特征，比如是否是Spam等。</li>
</ol>
<h1 id="L2R训练数据的构造">4. L2R训练数据的构造</h1><p>L2R的训练数据可以有三种形式：</p>
<ol>
<li>对于每个查询，各个文档的绝对相关值(非常相关，比较相关，不相关，等等)；</li>
<li>对于每个查询，两两文档之间的相对相关值(文档1比文档2相关，文档4比文档3相关，等等)；</li>
<li>对于每个查询，所有文档的按相关度排序的列表(文档1&gt;文档2&gt;文档3)。</li>
</ol>
<p>这三种形式的训练数据之间可以相互转换，详见[1]。</p>
<p>训练数据的获取有两种主要方法：人工标注[3]和从日志文件中挖掘[4]:</p>
<p>人工标注：首先从搜索引擎的搜索记录中随机抽取一些查询，将这些查询提交给多个不同的搜索引擎，然后选取各个搜索引擎返回结果的前K个，最后由专业人员来对这些文档按照和查询的相关度进行标注。</p>
<p>从日志中挖掘：搜索引擎都有大量的日志记录用户的行为，我们可以从中提取出L2R的训练数据。Joachims提出了一种很有意思的方法[4]：给定一个查询，搜索引擎返回的结果列表为L，用户点击的文档的集合为C，如果一个文档di被点击过，另外一个文档dj没有被点击过，并且dj在结果列表中排在di之前，则di&gt;dj就是一条训练记录。亦即训练数据为：{di&gt;dj|di属于C，dj属于L-C，p(dj) &lt; p(di)}，其中p(d)表示文档d在查询结果列表中的位置，越小表示越靠前。</p>
<h1 id="L2R模型训练">5. L2R模型训练</h1><p>L2R是一个有监督学习过程。</p>
<p>对与每个给定的查询-文档对(query document pair)，抽取相应的特征(既包括查询和文档之间的各种相关度，也包括文档本身的特征以及重要性等)，另外通过或者人工标注或者从日志中挖掘的方法来得到给定查询下文档集合的真实序列。然后我们使用L2R的各种算法来学到一个排序模型，使其输出的文档序列和真实序列尽可能相似。</p>
<h1 id="L2R算法分类和简介">6. L2R算法分类和简介</h1><p>L2R算法主要包括三种类别：PointWise，PairWise，ListWise。</p>
<h2 id="PointWise-L2R">6.1. PointWise L2R</h2><p><strong>pointwise简介</strong><br>PointWise方法只考虑【给定查询下】，单个文档的绝对相关度，而不考虑其他文档和给定查询的相关度。亦即给定查询q的一个真实文档序列，我们只需要考虑【单个文档di和该查询的相关程度ci】，亦即输入数据应该是如下的形式：<br><img src="https://i.loli.net/2017/08/30/59a69397eeec7.png" alt=""> </p>
<p>一种思想是将query与doc之间的相关程度作为标签，比如标签有三档，问题就变为多类分类问题,模型有McRank,svm，最大熵等。另一种思想是将query与doc之间的相关程度作为分数利用回归模型拟合，经典回归模型有线性回归，dnn，mart等。</p>
<p><strong>pointwise形式</strong><br>输入：doc 的特征向量<br>输出：每个doc的相关性分数<br>损失函数: 回归loss，分类loss，有序回归loss</p>
<p><strong>pointwise常用算法</strong><br>Pointwise方法主要包括以下算法：Pranking (NIPS 2002), OAP-BPM (EMCL 2003), Ranking with Large Margin Principles (NIPS 2002), Constraint Ordinal Regression (ICML 2005)。</p>
<p><strong>pointwise特点</strong><br>Pointwise方法仅仅使用传统的分类，回归或者Ordinal Regression方法来对给定查询下单个文档的相关度进行建模。这种方法没有考虑到排序的一些特征，比如文档之间的排序结果针对的是给定查询下的文档集合，而Pointwise方法仅仅考虑单个文档的绝对相关度；另外，在排序中，排在最前的几个文档对排序效果的影响非常重要，Pointwise没有考虑这方面的影响。</p>
<h2 id="PairWise">6.2. PairWise</h2><p><strong>pairwise简介</strong><br>Pairwise方法考虑给定查询下，【两个文档之间】的相对相关度。亦即给定查询q的一个真实文档序列，我们只需要考虑任意两个相关度不同的文档之间的相对相关度：di&gt;dj，或者di &lt; dj 。</p>
<p><strong>pairwise原理</strong><br>Pairwise的方法是将文档组成文档对，不单考虑单个文档，而是考虑文档组对是否合理，比如对于query 1返回的三个文档 doc1，doc2，doc3, 有三种组对方式，<doc1,doc2>,<doc2,doc3>,<doc1,doc3>。当三个文档原来的label为3,4,2时，这样组对之后的三个例子就有了新的分数（表达这种顺序是否合理），可以利用这种数据进行分类学习，模型如SVM Rank, 还有RankNet(C. Burges, et al. ICML 2005)， FRank(M.Tsai, T.Liu, et al. SIGIR 2007)，RankBoost(Y. Freund, et al. JMLR 2003)。</doc1,doc3></doc2,doc3></doc1,doc2></p>
<p>参考文献<a href="http://www.javashuo.com/content/p-5980716.html" target="_blank" rel="external">机器学习排序之Learning to Rank简单介绍</a>对pairwise方法做出了比较容易理解的介绍：<br>文档对方法（parwise）则将重点转向量对文档顺序关系是否合理进行判断。<br>之所以被称为文档对方法，是因为这种机器学习方法的训练过程和训练目标，是判断任意两个文档组成的文档对<d0c1，d0c2>是否满足顺序关系，即判断是否D0C1应该排在DOC2的前面。图3展示了一个训练实例：査询Q1对应的搜索结果列表如何转换为文档对的形式，因为从人工标注的相关性得分可以看出，D0C2得分最高，D0C3次之，D0C1得分最低，于是我们可以按照得分大小顺序关系得到3个如图3所示的文档对，将每个文档对的文档转换为特征向量后，就形成了一个具体的训练实例。【备注：根据我的理解，下图有了一些错误。doc1分数应该为3，doc2分数应该为5】。<br><img src="https://ooo.0o0.ooo/2017/08/30/59a69437ecc6a.png" alt=""><br>                         图3  文档对的方法训练实例</d0c1，d0c2></p>
<p>根据转换后的训练实例，就可以利用机器学习方法进行分类函数的学习，具体的学习方法有很多，比如SVM. Boosts、神经网络等都可以作为具体的学习方法，但是不论具体方法是什么，其学习目标都是一致的，即输入- 个査询和文档对<docl，doc2>, 机器学习排序能够判断这种顺序关系是否成立，如果成立，那么在搜索结果中D0C1应该排在D0C2 前面，否则Doe2应该摔在Docl前面，通过这种方式，就完成搜索结果的排序任务。</docl，doc2></p>
<p>那么，<strong>如何将排序问题转化为机器学习能够学习的分类问题呢？</strong></p>
<p>参考文献<a href="http://www.cnblogs.com/kemaswill/p/3241963.html" target="_blank" rel="external">Learning to Rank之Ranking SVM 简介</a>给出了一个很好的例子解释这个问题：给定查询q, 文档d1&gt;d2&gt;d3(亦即文档d1比文档d2相关, 文档d2比文档d3相关, x1, x2, x3分别是d1, d2, d3的特征)。为了使用机器学习的方法进行排序，我们将排序转化为一个分类问题。我们定义新的训练样本, 令x1-x2, x1-x3, x2-x3为正样本,令x2-x1, x3-x1, x3-x2为负样本, 然后训练一个二分类器(支持向量机)来对这些新的训练样本进行分类，如下图所示:<br><img src="https://i.loli.net/2017/08/30/59a694b19797c.png" alt=""><br>左图中每个椭圆代表一个查询, 椭圆内的点代表那些要计算和该查询的相关度的文档, 三角代表很相关, 圆圈代表一般相关, 叉号代表不相关。我们把左图中的单个的文档转换成右图中的文档对(di, dj), 实心方块代表正样本, 亦即di&gt;dj, 空心方块代表负样本, 亦即di &lt; dj。将【排序问题转化为分类问题】之后, 我们就可以使用常用的机器学习方法解决该问题。</p>
<p><strong>pairwise存在的问题</strong></p>
<p>尽管文档对方法相对单文档方法做出了改进，但是这种方法也存在两个明显的问题：</p>
<p>一个问题是：文档对方法只考虑了两个文档对的相对先后顺序，却没有考虑文档出现在搜索列表中的位置，排在搜索站果前列的文档更为重要，如果前列文档出现判断错误，代价明显高于排在后面的文档。针对这个问题的改进思路是引入代价敏感因素，即每个文档对根据其在列表中的顺序具有不同的权重，越是排在前列的权重越大，即在搜索列表前列如 果排错顺序的话其付出的代价更高?</p>
<p>另外一个问题是：不同的査询，其相关文档数量差异很大，所以转换为文档对之后， 有的查询对能有几百个对应的文档对，而有的查询只有十几个对应的文档对，这对机器学习系统的效果评价造成困难 ?我们设想有两个查询，査询Q1对应500个文文档对，查询Q2 对应10个文档对，假设学习系统对于査询Ql的文档对能够判断正确480个，对于査询 Q2的义格对能够判新正确2个，如果从总的文档对数量来看，这个学习系统的准确率是 (480+2)/（500+10）=0.95.即95%的准确率，但是从査询的角度，两个査询对应的准确率 分别为：96%和20%,两者平均为58%,与纯粹从文档对判断的准确率相差甚远，这对如何继续调优机器学习系统会带来困扰。</p>
<h2 id="ListWise（文档列表方法）">6.3. ListWise（文档列表方法）</h2><p><strong>listwise简介</strong><br>单文档方法将训练集里每一个文档当做一个训练实例，文档对方法将同一个査询的搜索结果里任意两个文档对作为一个训练实例。与Pointwise和Pairwise方法不同，文档列表方法与上述两种表示方式不同，是将每一个查询对应的【所有搜索结果列表整体】作为一个训练实例，这也是为何称之为文档列表方法的原因。</p>
<p><strong>listwise原理</strong><br>文档列表方法根据K个训练实例（一个査询及其对应的所有搜索结果评分作为一个实 例）训练得到最优评分函数F， 对于一个新的用户査询，函数F 对每一个文档打分，之后按照得分顺序由高到低排序，就是对应的搜索结果。 </p>
<p>所以关键问题是：<strong>拿到训练数据，如何才能训练得到最优的打分函数？</strong></p>
<p>这里介绍一种训练方法，它是基于搜索结果排列组合的概率分布情况来训练的，图4是这种方式训练过程的图解示意。<br><img src="https://i.loli.net/2017/08/30/59a6951348a74.png" alt=""><br>            图4 不同评分函数的KL距离</p>
<p>首先解释下什么是搜索结果排列组合的概率分布，我们知道，对于搜索引擎来说，用户输入査询Q， 搜索引擎返回搜索结果，我们假设搜索结果集合包含A、B和C 3个文档，搜索引擎要对搜索结果排序，而这3个文档的顺序共有6种排列组合方式:</p>
<p>ABC, ACB, BAG, BCA, CAB和CBA,</p>
<p>而每种排列组合都是一种可能的搜索结果排序方法。</p>
<p>对于某个评分函数F来说，对3个搜索结果文档的相关性打分，得到3个不同的相关度得分F(A)、F(B)和F(C)，根据这3个得分就可以计算6种排列组合情况各自的概率值。</p>
<p>不同的评分函数，其6种搜索结果排列组合的概率分布是不一样的。</p>
<p>了解了什么是搜索结果排列组合的概率分布，我们介绍如何根据训练实例找到最优的评分函数。图4展示了一个具体的训练实例，即査询Q1及其对应的3个文档的得分情况，这个得分是由人工打上去的，所以可以看做是标准答案。</p>
<p>可以设想存在一个最优的评分函数g，对查询Q1来说，其打分结果是：A文档得6分，B文档得4分，C文档得3分， </p>
<p>因为得分是人工打的，所以具体这个函数g是怎样的我们不清楚，我们的任务就是找到一 个函数，使得函数对Ql的搜索结果打分顺序和人工打分顺序尽可能相同。既然人工打分 (虚拟的函数g) 已知，那么我们可以计算函数g对应的搜索结果排列组合概率分布，其具体分布情况如图4中间的概率分布所示。</p>
<p>假设存在两个其他函数h和f，它们的计算方法已知，对应的对3个搜索结果的打分在图上可以看到，由打分结果也可以推出每个函数对应的搜索结果排列组合概率分布，那么h与f哪个与虚拟的最优评分函数g更接近呢？</p>
<p>一般可以用两个分布概率之间的距离远近来度量相似性，KL距离就是一种衡量概率分布差异大小的计算工具，通过分别计算h与g的差异大小及f与g的差异大小，可以看出f比h更接近的最优函数g，那么在这个函数中，我们应该优先选f作为将来搜索可用的评分函数，训练过程就是在可能的函数中寻找最接近虚拟最优函数g的那个函数作为训练结果，将来作为在搜索时的评分函数。</p>
<p>上述例子只是描述了对于单个训练实例如何通过训练找到最优函数，事实上我们有K 个训练实例，虽然如此，其训练过程与上述说明是类似的，可以认为存在一个虚拟的最优 评分函数g(实际上是人工打分），训练过程就是在所有训练实例基础上，探寻所有可能的 候选函数，从中选择那个KL距离最接近于函数g的，以此作为实际使用的评分函数。 经验结果表明，基于文档列表方法的机器学习排序效果要好于前述两种方法。</p>
<p><strong>常用算法</strong><br>Listwise算法主要包括以下几种算法：LambdaRank (NIPS 2006), AdaRank (SIGIR 2007), SVM-MAP (SIGIR 2007), SoftRank (LR4IR 2007), GPRank (LR4IR 2007), CCA (SIGIR 2007), RankCosine (IP&amp;M 2007), ListNet (ICML 2007), ListMLE (ICML 2008) 。</p>
<p>相比于Pointwise和Pairwise方法，Listwise方法直接优化给定查询下，整个文档集合的序列，所以比较好的解决了克服了以上算法的缺陷。Listwise方法中的LambdaMART(是对RankNet和LambdaRank的改进)在Yahoo Learning to Rank Challenge表现出最好的性能。</p>
<h1 id="参考文献">7. 参考文献</h1><p>[1]. Learning to Rank for Information Retrieval. Tie-yan Liu.<br>[2]. Learning to Rank for Information Retrieval and Natural Language Processing. Hang Li.<br>[3]. A Short Introduction to Learning to Rank. Hang Li.<br>[4]. Optimizing Search Engines using Clickthrough Data. Thorsten Joachims. SIGKDD,2002.<br>[5]. Learning to Rank小结</p>
<ol>
<li><a href="http://www.cnblogs.com/kemaswill/archive/2013/06/01/3109497.html" target="_blank" rel="external">Learning to Rank 简介</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/26221188" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/26221188</a></li>
<li><a href="http://www.javashuo.com/content/p-5980716.html" target="_blank" rel="external">机器学习排序之Learning to Rank简单介绍</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> 机器学习算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> L2R </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数据库常用语句]]></title>
      <url>/2017/07/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E8%AF%AD%E5%8F%A5/</url>
      <content type="html"><![CDATA[<h1 id="启动-关闭">1. 启动/关闭</h1><ul>
<li>启动：<code>sudo systemctl start mysqld</code>或<code>mysql -u root -p</code></li>
<li>查看状态：<code>sudo systemctl status mysqld</code></li>
</ul>
<h1 id="linux下执行sql脚本">2. linux下执行sql脚本</h1><p>进入到mysql后，执行<code>source /路径/tester.sql;</code>即可</p>
<h1 id="databases操作">3. databases操作</h1><ul>
<li>列出所有数据库：<code>SHOW DATABASES;</code></li>
<li>创建数据库：<code>CREATE DATABASE database_name;</code></li>
<li>进入某数据库：<code>USE database_name;</code></li>
</ul>
<h1 id="tables操作">4. tables操作</h1><ul>
<li>列出所有表：<code>SHOW TABLES;</code></li>
<li><p>创建表：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE 表名称</div><div class="line">(</div><div class="line">列名称1 数据类型,</div><div class="line">列名称2 数据类型,</div><div class="line">列名称3 数据类型,</div><div class="line">....</div><div class="line">)</div></pre></td></tr></table></figure>
</li>
<li><p>输出表头：<code>SHOW COLUMNS FROM Table_name;</code></p>
</li>
</ul>
<h1 id="MYSQL数据类型">5. MYSQL数据类型</h1><p><a href="http://www.runoob.com/mysql/mysql-data-types.html" target="_blank" rel="external">MySQL 数据类型</a></p>
<h1 id="参考文献">6. 参考文献</h1><ol>
<li><a href="http://www.centoscn.com/mysql/2016/0315/6844.html" target="_blank" rel="external">CentOS 7 安装 MySQL</a></li>
<li><a href="http://www.2cto.com/database/201210/164243.html" target="_blank" rel="external">linux下执行mysql的sql文件</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> 数据库 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[推荐系统初探]]></title>
      <url>/2017/07/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%88%9D%E6%8E%A2/</url>
      <content type="html"><![CDATA[<p>推荐系统根据用户过去的购买和搜索历史，以及其他用户的行为，自主地为各个用户识别推荐内容。</p>
<p>常见的推荐系统有以下几类：</p>
<ul>
<li>协同过滤推荐</li>
<li>基于内容的推荐</li>
<li>混合推荐</li>
</ul>
<p>参考文献<a href="https://www.zhihu.com/question/19971859" target="_blank" rel="external">协同过滤和基于内容推荐有什么区别？</a>给出了一个很好的例子，来区分协同过滤和内容推荐：<br>举个简单的小例子，我们已知道：<br>用户u1喜欢的电影是A，B，C<br>用户u2喜欢的电影是A, C, E, F<br>用户u3喜欢的电影是B，D</p>
<p>我们需要解决的问题是：决定对u1是不是应该推荐F这部电影</p>
<p>基于内容的做法：要分析F的特征和u1所喜欢的A、B、C的特征，需要知道的信息是A（战争片），B（战争片），C（剧情片），如果F（战争片），那么F很大程度上可以推荐给u1，这是基于内容的做法，你需要对item进行特征建立和建模。</p>
<p>协同过滤的办法：那么你完全可以忽略item的建模，因为这种办法的决策是依赖user和item之间的关系，也就是这里的用户和电影之间的关系。我们不再需要知道ABCF哪些是战争片，哪些是剧情片，我们只需要知道用户u1和u2按照item向量表示，他们的相似度比较高，那么我们可以把u2所喜欢的F这部影片推荐给u1</p>
<p>下面我们对这几种推荐算法进行简介。</p>
<h1 id="协同过滤推荐算法">1. 协同过滤推荐算法</h1><h2 id="简介">1.1. 简介</h2><p><strong>简介</strong>：通过在用户的一系列行为中寻找特定模式来产生用户特殊推荐。<br><strong>输入</strong>：仅仅依赖于惯用数据（例如评价、购买、下载等用户偏好行为）。<br><strong>方式</strong>：可通过单个用户行为单独构造模型；也可以通过其他用户行为，使用群组知识并基于相似用户来形成推荐内容。<br><strong>类型</strong>：</p>
<ul>
<li>基于领域的协同过滤（user-based或item-based）</li>
<li>基于模型的协同过滤（矩阵因子分解、受限玻尔兹曼机、贝叶斯网络等等）</li>
</ul>
<h2 id="实例">1.2. 实例</h2><p>为了更好地理解，我们以博客推荐为例。<br>已知用户已订阅并阅读博客的信息，可以根据用户偏好来对他们进行分组。例如可以将阅读多篇相同博客的用户分到一个组。基于组信息，可识别出该组阅读了哪些最流行的博客，然后对于群组中的某个用户，可以向他推荐他还未阅读也未订阅的最流行的博客。</p>
<ol>
<li>在下图的表中，行是一组博客，列是用户，表是该用户阅读该文章的数量。</li>
<li>通过根据用户的阅读习惯来为用户划分集群。比如使用一个 nearest-neighbor 算法：找到与当前用户user口味相近的k各用户；对用户u没有见过的博客p，利用k个近邻对p进行预测评分。</li>
<li>用以上算法我们得到两个分别包含两个用户的cluster，每个cluster中的成员都有相似的阅读习惯：Marc 和 Elise（他们都阅读了多篇关于 Linux® 和云计算的文章）形成 Cluster 1。Cluster 2 中包含 Megan 和 Jill，他们都阅读了多篇关于 Java™ 和敏捷性的文章。</li>
</ol>
<p><img src="https://i.loli.net/2017/07/16/596ae56897d11.png" alt=""> </p>
<h2 id="nearest-nerghbor算法">1.3. nearest-nerghbor算法</h2><p>刚才说到了用nearest-nerghbor算法来计算user-based的user相似度，然后再进行推荐，那么就带来了两个问题：</p>
<ul>
<li>如何度量user之间的相似性？</li>
<li><p>如何推荐博客？</p>
</li>
<li><p>首先解决第一个问题，<strong>如何度量相似性？</strong></p>
</li>
</ul>
<p>先说<strong>结论：采用改进的余弦相似度来进行度量。</strong></p>
<p>首先我们看一下Pearson相关系数和余弦相似度。<br>pearson相关系数用来描诉两组向量一同变化的趋势，取值从+1（强正相关）到-1（强负相关）。用户a和用户b的相似度：<br><img src="https://i.loli.net/2017/07/16/596af2f5cba54.png" alt=""><br>其中：</p>
<ul>
<li>$r_{a,p}$表示用户a对博客p的阅读量；</li>
<li>$\overline{r_a}$表示用户a的平均阅读量；</li>
<li>pearson相关系数越接近于1，那么用户a、b月相似。</li>
</ul>
<p>然而，这并不完美，pearson相关系数存在以下缺陷：</p>
<ul>
<li>未考虑博客的数量对相似度的影响；<br>例如：用户a与b有两个重叠项，用户a与c有10个重叠项；但有可能出现$sim(a,c)&lt; sim(a,b)$的情况，因为计算pearson系数时，重叠项的个数没有影响。但这并不能说明用户b更与a相似。</li>
<li>如果只有一个重叠项，或所有重叠项的评分都相等，就无法计算pearson相关系数（分子或分母为0）。</li>
</ul>
<p>接下来我们看看另一种相似度度量方式——<strong>余弦相似度</strong>。<br><img src="https://i.loli.net/2017/07/16/596b1d46cc650.png" alt=""><br>这代表两个user向量的夹角。但这与向量的大小无关，因此伟大的科学家们提出了<strong>改进的余弦相似度</strong>：<br><img src="https://i.loli.net/2017/07/16/596b1d9a7a066.png" alt=""><br>它的取值范围在$[-1,1]$。</p>
<ul>
<li>接下来我们来解决第二个问题，<strong>如何推荐博客？</strong></li>
</ul>
<p>先选取k个用户的近邻，利用这k个近邻的阅读排行来做推荐。</p>
<p>其实，这个方法是基于user-based的。它并不是完美的。有两个问题：数据稀疏（用户看过的博客非常少）和算法复杂度高。而这两个问题可以通过item-based方法来解决。具体内容见参考文献<a href="http://www.chongchonggou.com/g_60592064.html" target="_blank" rel="external">基于物品的协同过滤推荐算法——读“Item-Based Collaborative Filtering Recommendation Algorithms”</a></p>
<h2 id="协同过滤的方法">1.4. 协同过滤的方法</h2><p>上面提到的方法是<strong>基于领域（记忆）的方法</strong>，而还有一类叫<strong>基于模型的方法——即隐语义模型</strong>。矩阵分解就是实现隐语义模型的成果实现。参考文献<a href="http://baogege.info/2014/10/19/matrix-factorization-in-recommender-systems/" target="_blank" rel="external">个性化推荐中的矩阵分解技术</a>给出了矩阵分解的方法。<br>矩阵分解的核心思想认为用户的兴趣只受少数几个因素的影响，因此将稀疏且高维的User-Item评分矩阵分解为两个低维矩阵，即通过User、Item评分信息来学习到的用户特征矩阵P和物品特征矩阵Q，通过重构的低维矩阵预测用户对产品的评分。</p>
<h1 id="基于内容的推荐">2. 基于内容的推荐</h1><p>基于内容的推荐是指根据用户的行为来推荐内容。</p>
<p><strong>基于内容推荐的过程：</strong></p>
<ul>
<li>item Representation:为每个item抽取特征（也就是item的内容）来表示item;</li>
<li>Profile Learning:利用用户过去喜欢（及不喜欢）的item的特征数据，来学习出此用户的喜好特征(profile)；</li>
<li>Recommendation Generation:通过比较上一步得到的用户profile与候选item的特征，为此用户推荐一组相关性最大的item。</li>
</ul>
<p>上面三个步骤有一张很细致的流程图（第一步对应着Content Analyzer，第二步对应着Profile Learner，第三步对应着Filtering Component）：<br><img src="https://i.loli.net/2017/07/16/596b2b6a02c0e.png" alt=""><br>举个例子，对于博客推荐来说，一个item就是一篇博客；</p>
<ul>
<li>第一步，首先从文章内容中抽取文章的特征。常用算法就是利用这篇文章的关键词来代表这篇文章，而每个词对应的权重往往使用tf-idf来计算。利用这种方法，将一篇文章用一个向量来表示即可；</li>
<li>第二步，根据用户过去喜好来刻画用户profile。最简单的方法可以把用户所有喜欢的文章对应的向量的平均值作为此用户的profile。比如某个用户经常关注与推荐系统有关的文章，那么他的profile中“CB”、“CF”和“推荐”对应的权重值就会较高。</li>
<li>第三步，利用所有item与用户profile的相关度进行推荐。一个常用的相关度计算方法是向量的cos夹角。最终把候选item里与此用户最相关（cosine值最大）的N个item作为推荐返回给此用户。</li>
</ul>
<p>接下来我们来详细了解一下以上三个步骤。</p>
<h2 id="item-representation">2.1. item representation</h2><p>想用属性来描述item时，我们会遇到两种属性：</p>
<ul>
<li>结构化(structured)属性：取值固定，例如身高、学历、籍贯等；</li>
<li>非结构化(unstructured)属性：如文章；</li>
</ul>
<p>接下来我们针对如何将非结构化的属性转化为结构化属性。我们采用最常用的<strong>向量空间模型</strong>（Vector Space Model,简称VSM）：<br>已知：</p>
<ul>
<li>所有文章集合$D={d_1,d_2,…,d_N}$</li>
<li>所有文章中出现的词的集合$T={t_1,t_2,…,t_n}$</li>
</ul>
<p>目标：用向量表示文章：</p>
<ul>
<li>第j篇文章被表示为$d_j={w_{1j},w_{2j},…,w_{nj}}$,其中$w_{nj}$表示第$n$个词在文章$j$中的权重。</li>
</ul>
<p>最简单的表示权重$w_{nj}$的方式是直接统计出现次数。但一般来说我们还是使用tf-idf：<br>$$TFIDF(t_k,d_j)=TF(t_k,d_j)log \frac{N}{n_k}$$<br>其中：</p>
<ul>
<li>$TF(t_k,d_j)$是词频，表示第$k$个词在文章$j$中出现的次数；</li>
<li>$log \frac{N}{n_k}$是逆文档词频，其中$n_k$是所有文章中包括第$k$个词的文章数量；$N$是文章数量。</li>
</ul>
<p>最终第$k$个词在文章$j$中的权重由下面公式获得：<br>$$w_{k,j}=\frac{TFIDF(t_k,d_j)}{\sqrt{\sum_{s=1}^{|T|}TFIDF(t_k,d_j)^2}}$$<br>做归一化的好处是不同文章之间的表示向量被归一到一个量级上，便于下面步骤的操作。 </p>
<h2 id="Profile-Learning">2.2. Profile Learning</h2><p>假设用户u已经对一些item给出了他的喜好判断，喜欢其中的一部分item，不喜欢其中的另一部分。<br>那么，这一步要做的就是通过用户u过去的这些喜好判断，为他产生一个模型。有了这个模型，我们就可以根据此模型来判断用户u是否会喜欢一个新的item。所以，我们要解决的是一个典型的有监督分类问题，理论上机器学习里的分类算法都可以照搬进这里。</p>
<p>下面我们简单介绍下CB里常用的一些学习算法：</p>
<ol>
<li>KNN</li>
<li>Rocchio</li>
<li>决策树（DT）</li>
<li>线性分类（LC）</li>
<li>朴素贝叶斯（NB）</li>
</ol>
<h2 id="Recommendation-Generation">2.3. Recommendation Generation</h2><p>如果上一步Profile Learning中使用的是分类模型（如DT、LC和NB），那么我们只要把模型预测的用户最可能感兴趣的n个item作为推荐返回给用户即可。而如果Profile Learning中使用的直接学习用户属性的方法（如Rocchio算法），那么我们只要把与用户属性最相关的n个item作为推荐返回给用户即可。其中的用户属性与item属性的相关性可以使用如cosine等相似度度量获得。</p>
<h2 id="基于内容的推荐的优缺点">2.4. 基于内容的推荐的优缺点</h2><p><strong>优点</strong></p>
<ol>
<li>用户之间的独立性（User Independence）：既然每个用户的profile都是依据他本身对item的喜好获得的，自然就与他人的行为无关。而协同过滤就需要利用很多其他人的数据。因此这种用户独立性带来的一个显著好处是别人不管对item如何作弊（比如利用多个账号把某个产品的排名刷上去）都不会影响到自己。</li>
<li>好的可解释性（Transparency）：如果需要向用户解释为什么推荐了这些产品给他，你只要告诉他这些产品有某某属性，这些属性跟你的品味很匹配等等。</li>
<li>新的item可以立刻得到推荐（New Item Problem）：只要一个新item加进item库，它就马上可以被推荐，被推荐的机会和老的item是一致的。而协同过滤对于新item就很无奈，只有当此新item被某些用户喜欢过（或打过分），它才可能被推荐给其他用户。所以，如果一个纯CF的推荐系统，新加进来的item就永远不会被推荐:( 。这也就是常说的item冷启动问题。</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>item的特征抽取一般很难（Limited Content Analysis）：如果系统中的item是文档（如个性化阅读中），那么我们现在可以比较容易地使用信息检索里的方法来“比较精确地”抽取出item的特征。但很多情况下我们很难从item中抽取出准确刻画item的特征，比如电影推荐中item是电影，社会化网络推荐中item是人，这些item属性都不好抽。其实，几乎在所有实际情况中我们抽取的item特征都仅能代表item的一些方面，不可能代表item的所有方面。这样带来的一个问题就是可能从两个item抽取出来的特征完全相同，这种情况下基于内容的推荐就完全无法区分这两个item了。比如如果只能从电影里抽取出演员、导演，那么两部有相同演员和导演的电影对于基于内容的推荐来说就完全不可区分了。</li>
<li>无法挖掘出用户的潜在兴趣（Over-specialization）：既然CB的推荐只依赖于用户过去对某些item的喜好，它产生的推荐也都会和用户过去喜欢的item相似。如果一个人以前只看与推荐有关的文章，那基于内容的推荐只会给他推荐更多与推荐相关的文章，它不会知道用户可能还喜欢数码。</li>
<li>无法为新用户产生推荐（New User Problem）：新用户没有喜好历史，自然无法获得他的profile，所以也就无法为他产生推荐了。当然，这个问题协同过滤也有。</li>
</ol>
<h1 id="参考文献">3. 参考文献</h1><ol>
<li><a href="https://www.ibm.com/developerworks/cn/opensource/os-recommender1/index.html" target="_blank" rel="external">推荐系统,IBM</a></li>
<li><a href="http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part01" target="_blank" rel="external">推荐算法综述（一）</a></li>
<li><a href="http://blog.csdn.net/keyboardlabourer/article/details/26692177" target="_blank" rel="external">协同过滤之基于用户的最近邻推荐</a></li>
<li><a href="http://www.chongchonggou.com/g_60592064.html" target="_blank" rel="external">基于物品的协同过滤推荐算法——读“Item-Based Collaborative Filtering Recommendation Algorithms”</a></li>
<li><a href="https://www.zhihu.com/question/19971859" target="_blank" rel="external">协同过滤和基于内容推荐有什么区别？</a></li>
<li><a href="https://read.douban.com/reader/column/3346397/chapter/18909999/" target="_blank" rel="external">基于内容的推荐</a></li>
<li><a href="http://baogege.info/2014/10/19/matrix-factorization-in-recommender-systems/" target="_blank" rel="external">个性化推荐中的矩阵分解技术</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> 机器学习实践 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[朴素贝叶斯的理解]]></title>
      <url>/2017/07/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h1 id="朴素贝叶斯分类的思想基础">1. 朴素贝叶斯分类的思想基础</h1><p>参考文献<a href="http://www.cnblogs.com/leoo2sk/archive/2010/09/17/naive-bayesian-classifier.html" target="_blank" rel="external">算法杂货铺——分类算法之朴素贝叶斯分类</a>指出，朴素贝叶斯分类是一种十分简单的分类算法，叫它朴素贝叶斯分类是因为这种方法的思想真的很朴素，朴素贝叶斯的<strong>思想基础</strong>是这样的：对于给出的待分类项，求解在此项出现的条件下各个类别出现的概率，哪个最大，就认为此待分类项属于哪个类别。通俗来说，就好比这么个道理，你在街上看到一个黑人，我问你你猜这哥们哪里来的，你十有八九猜非洲。为什么呢？因为黑人中非洲人的比率最高，当然人家也可能是美洲人或亚洲人，但在没有其它可用信息下，我们会选择条件概率最大的类别，这就是朴素贝叶斯的思想基础。</p>
<p>将上面的描述形式化描述，就是下面的朴素贝叶斯分类的定义。</p>
<h1 id="朴素贝叶斯分类的定义和求解">2. 朴素贝叶斯分类的定义和求解</h1><ol>
<li>设$x={a_1,a_2,…,a_m}$为一个待分类项，其中每个$a$是$x$的一个特征属性。</li>
<li>有类别集合$C={y_1,y_2,…,y_n}$</li>
<li>计算$P(y_1|x),P(y_2|x),…,P(y_n|x)$。(也就是这个特征成为每个类别的概率)</li>
<li>如果$P(y_k|x)=max[P(y_1|x),P(y_2|x),…,P(y_n|x)],则x\in y_k$。(选出一个最可能的类别，将这个类别设为x的类别)</li>
</ol>
<h2 id="如何计算-P-y-i-x">2.1. 如何计算$P(y_i|x)$?</h2><p>问题来了，那么我们应该如何计算第3步当中的$P(y_i|x)$呢？</p>
<p>$P(y_i|x)$代表在这个$x$的情况下的类别成为$y_i$的概率，一般来说通过建模$p(y|x)$来预测$y$的模型叫“<strong>判别式模型</strong>”。<br>但问题在于如果特征数量n较大或者每个特征能取大量值时，基于概率模型列出概率表变得不现实。所以我们修改这个模型使之变得可行。因此我们可以先对联合概率分布$p(x,y)$建模，然后再由此得出$P(y_i|x)$，这样的是“<strong>生成式模型</strong>”。贝叶斯定理为：<br>$$P(y|x)=\frac{p(x,y)}{p(x)}=\frac{p(y)p(x|y)}{p(x)}\tag{公式0}$$</p>
<h2 id="因此将问题转化成了：如何基于训练数据D来估计先验-p-y-和似然-p-x-y-？">2.2. 因此将问题转化成了：如何基于训练数据D来估计先验$p(y)$和似然$p(x|y)$？</h2><ul>
<li>$p(y)$是先验概率，表示样本空间中各类样本所占比例；可以通过统计近似得出；</li>
<li>$p(x|y)$是各类样本条件下，所有$x$特征分布的概率。假设特征空间$x$有$d$维，且每一维都有2个取值，那么$x$的取值就有$2^d$种。一般来说这远大于训练样本数m。也就是很多取值是覆盖不到的。所以用频率来估计它不可行，因为“未被观测到”和“与出现概率为0”通常是不同的。</li>
</ul>
<h2 id="现在问题又来了，如何去估计-p-x-y-？">2.3. 现在问题又来了，如何去估计$p(x|y)$？</h2><p>估计类条件概率的通用解决方案：先假定其具有某种确定的概率分布形式，再基于训练样本对概率分布的参数进行估计。</p>
<h2 id="问题又转化成了-如何进行参数估计？">2.4. 问题又转化成了:如何进行参数估计？</h2><p>为明确起见，我们将$p(x|y)$记作$p(x|θ_y)$。</p>
<p>根据频率学派的思路，我们可以通过极大似然法来估计参数θ。</p>
<p>极大似然估计的核心思想是：我们已知$x$已发生，我们再根据实际情况写出$x$发生的概率$p(x_θ)$。目标函数是使得这个概率$p(x_θ)$最大，然后求得$θ$。</p>
<p>在本问题中，我们有训练样本集$X$，令$X_y$表示训练样本集$X$中第$y$类样本组成的集合，假设这些样本独立同分布。似然函数是某事件发生的概率，也就是$P(X_y|θ_y)$:<br>$$P(X_y|θ_y)=∏_{x\in X_y}P(x|θ_y) \tag{公式1}$$<br><em>小注，上式表达的意思是：</em>$在参数θ_y时，第y类样本集X_y发生的概率 = X_y中每个样本x发生的概率的乘积$</p>
<p>我们已经知道$X_y|θ_y$这个事件发生了（因为我们观测到了），那就让这个概率$P(X_y|θ_y)$最大化，去求得一个$θ_y$，这就是我们的最终目标——得到$θ_y$。</p>
<h2 id="如何解出参数？">2.5. 如何解出参数？</h2><p>如上所述，我们现在的目标是求得一个$θ_y$是的公式1最大。而公式1的连乘操作容易造成下溢，因此我们通常使用对数似然：<br>$$LL(θ_y)=log P(X_y|θ_y)$$<br>$$=\sum_{x\in X_y}log P(x|θ_y)\tag{公式2.1}$$<br>此时我们求得一个$θ_y$，使得公式2.1最大:</p>
<p>$$θ_y=arg_{θ_y} max LL(θ_y)\tag{公式2.2}$$</p>
<p>因此，我们只需要知道$p(x|θ)$,就可以求得各$y$类标签取值下的$θ$，就得到了$x$下各label的概率:$P(x|θ_y)$，也就是$P(x|y)$。代入<em>公式0</em>，我们得到了$P(y|x)$。此时我们就<strong>解决了朴素贝叶斯分类的定义的第3步</strong>，这样就能进行下一步了。</p>
<h2 id="并没有那么简单">2.6. 并没有那么简单</h2><p>然而，<strong>这个问题并没有这么简单。</strong>在公式2中我们要求得$θ$。假设$x^{(j)}$有$S_j$个取值，那么每个类别下的$θ_y$就有$∏_{j=1}^nS_j$维。且$y$的取值有$k$个，那就是$k∏_{j=1}^nS_j$，这样就很难算，几乎算不出来。</p>
<h2 id="参数太多，维度爆炸了，怎么办？">2.7. 参数太多，维度爆炸了，怎么办？</h2><p>因此，朴素贝叶斯分类器用了<strong>属性条件独立性假设</strong>:对于已知类别，假设所有属性相互独立。</p>
<p>此时，<em>公式0</em>可以改写成：<br>$$P(y|x)=\frac{p(y)p(x|y)}{p(x)}=\frac{p(y)}{p(x)}∏_{i=1}^dP(x_i|y)\tag{公式4}$$</p>
<p>而$p(x)$是样本分布，可以认为是常数，所以忽略。<br>按照我们刚刚推导的步骤，想求得$P(y|x)$，我们就回到了朴素贝叶斯分类的定义的第3步，算出公式2.2:</p>
<p>$$θ_y=arg_{θ_y} max LL(θ_y)=arg max_{y\in Y}P(y)∏_{i=1}^dP(x_i|y)\tag{公式5}$$</p>
<p>之后还有半朴素贝叶斯分类器。我们来日再说。</p>
<h1 id="参考文献">3. 参考文献</h1><ol>
<li><a href="http://www.cnblogs.com/leoo2sk/archive/2010/09/17/naive-bayesian-classifier.html" target="_blank" rel="external">算法杂货铺——分类算法之朴素贝叶斯分类</a></li>
<li><a href="https://github.com/endymecy/spark-ml-source-analysis/blob/master/%E5%88%86%E7%B1%BB%E5%92%8C%E5%9B%9E%E5%BD%92/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/nb.md" target="_blank" rel="external">朴素贝叶斯</a></li>
<li><a href="">机器学习，周志华</a></li>
<li><a href="">概率论与数理统计，华师大出版社</a></li>
</ol>
<p>那我们回头看看我们的训练集。训练集是由一个已知分类的集合构成，也就是集合$X$和对应的$y$。也就是说，我们可以通过统计来获得各类别下各特征属性的条件概率估计：<br>$P(a_1|y_1),P(a_2|y_1),…,P(a_m|y_1);$<br>$P(a_1|y_2),P(a_2|y_2),…,P(a_m|y_2);$<br>$…,$<br>$P(a_1|y_n),P(a_2|y_n),…,P(a_m|y_n)$</p>
]]></content>
      
        <categories>
            
            <category> 机器学习算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 贝叶斯理论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[机器学习算法-总结]]></title>
      <url>/2017/07/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>我一想到明天要面试，我就贼紧张。赶紧好好复习一下吧。</p>
<h1 id="特征降维">1. 特征降维</h1><p>主成分分析PCA<br>线性判别分析LDA<br>矩阵奇异值分解SVD<br>深度学习SparseAutoEncoder<br>LASSO<br>小波分析法<br>拉普拉斯特征映射</p>
<h1 id="统计模式分类问题中，当先验概率未知时，可以使用">2. 统计模式分类问题中，当先验概率未知时，可以使用</h1><p>最小误判概率准则<br>最小损失准则</p>
<h1 id="各种决策树">3. 各种决策树</h1><table>
<thead>
<tr>
<th>决策树</th>
<th>ID3/C4.5</th>
<th>CART</th>
</tr>
</thead>
<tbody>
<tr>
<td>相同</td>
<td>都是基于信息论的决策树算法</td>
<td></td>
</tr>
<tr>
<td>不同1</td>
<td>ID3是信息增益，C4.5是信息增益比</td>
<td>CART中用于选择变量的不纯性度量是Gini指数</td>
</tr>
<tr>
<td>不同2</td>
<td>C4.5/ID3不一定是二叉树</td>
<td>CART一定是二叉树</td>
</tr>
</tbody>
</table>
]]></content>
      
        <categories>
            
            <category> 机器学习算法 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[SVD分解]]></title>
      <url>/2017/07/10/%E6%95%B0%E5%AD%A6-SVD%E5%88%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p><strong>简介</strong></p>
<ul>
<li>SVD(Singular Value Decomposition，奇异值分解)是对实数矩阵(甚至复数矩阵)的一种因式分解。</li>
<li>任意的一个矩阵都可以做SVD分解。相比SVD分解，和SVD相近的特征值分解只能应用于方阵。</li>
<li>SVD分解可用来解决非方阵不能计算逆矩阵的问题。</li>
</ul>
<h1 id="SVD定义">1. SVD定义</h1><p>设一个$m\times n$的矩阵$M$,它的SVD分解是：<br>$$M=UΣV^*$$<br>其中：</p>
<ul>
<li>$U$是一个$m\times m$的酉矩阵。(我的理解：酉矩阵是在复数空间上，类似正交矩阵的矩阵。它有很多不错的性质。可以在我上一篇博客里看到)</li>
<li>$Σ$是$m\times n$的矩形对角矩阵，并且在对角线上的元素都是非负实数$σ_i$，称为$M$的奇异值</li>
<li>$V^*$是一个$n\times n$的酉矩阵，也是$V$的共轭转置矩阵。</li>
</ul>
<h1 id="SVD的原理">2. SVD的原理</h1><p>首先，我们对正交矩阵进行一些回顾。</p>
<p><strong>正交矩阵回顾</strong></p>
<p>从上一节我们知道，正交矩阵对应的变换是不会改变向量长度的。即，对于向量$(a,b)$，正交矩阵$U$，变换后的向量$U(a,b)$的长度与$(a,b)$是相等的。这个正交变换只是对$(a,b)$做了旋转或者镜射等操作。</p>
<h2 id="特征值分解——EVD">2.1. 特征值分解——EVD</h2><p>在讨论SVD之前，我们先讨论矩阵的特征值分解（EVD）。</p>
<p>回顾特征值分解，特征值分解是把一个n阶实对称矩阵分解为下面的形式：<br>$$A=QΣQ^{-1}$$<br>其中：</p>
<ul>
<li>$Q$是这个矩阵$A$的特征向量组成的矩阵，是一个正交矩阵</li>
<li>$Σ$是一个对角阵，每个对角线上的元素就是一个特征值</li>
</ul>
<p>此时假设有一个$x$向量，用$A$将这个向量$x$变换到$A$的列空间中，即：<br>$$Ax=QΣQ^{-1}x=QΣQ^Tx=QΣ(Q^Tx)$$</p>
<ol>
<li>首先进行$Q^Tx$操作。$Q$和$T^T$都是正交阵，那么$Q^T$对$x$的变换是正交变换，它将$x$用新的坐标系，这个坐标系就是$A$的所有正交的特征向量构成的坐标系。<br>我们如果将$x$用$A$的所有特征向量来表示的话，即表示为$x=a_1x_1+a_2x_2+…+a_mx_m$，则通过第一个变换，$(Q^Tx)=[a_1,a_2,…,a_m]’$,即<img src="https://ooo.0o0.ooo/2017/07/10/596382b7bdde7.png" alt=""> </li>
<li>紧接着，在新的坐标系表示下，由中间那个对角矩阵对新的向量坐标换，其结果就是将向量往各个轴方向拉伸或压缩：<img src="https://ooo.0o0.ooo/2017/07/10/596382f4d62b4.png" alt=""><br>从上图可以看到，如果A不是满秩的话，那么就是说对角阵的对角线上元素存在0，这时候就会导致维度退化，这样就会使映射后的向量落入m维空间的子空间中。</li>
<li>最后一个变换就是U对拉伸或压缩后的向量做变换，由于U和U’是互为逆矩阵，所以U变换是U’变换的逆变换。</li>
</ol>
<p>因此，从对称阵的分解对应的映射分解来分析一个矩阵的变换特点是非常直观的。假设对称阵特征值全为1那么显然它就是单位阵，如果对称阵的特征值有个别是0其他全是1，那么它就是一个正交投影矩阵，它将m维向量投影到它的列空间中。</p>
<h2 id="奇异值分解–SVD">2.2. 奇异值分解–SVD</h2><p>上面的矩阵$A$要求必须是n阶实对称的。那么对于任意的$M\times N$矩阵，能否找到一个相似的变换呢？这就是SVD分解的精髓所在。</p>
<p>在上面的特征值分解中，我们能找到一个变换$A$，将一组正交基映射到另一组正交基。</p>
<ul>
<li>我们假设存在$M \times N$的矩阵$A$。现在我们的目标是，在n维空间中找到一组正交基$${v_1,v_2,…,v_n}$$，使得经过A变换后还是正交的。</li>
<li>那么$A$矩阵就将这组基映射为：$${Av_1,Av_2,…,Av_n}$$</li>
<li>如果要使得它们两两正交，即：$$Av_i\cdot Av_j = (Av_i)^TAv_j=v_i^TA^TAv_j=0$$</li>
<li>根据假设，存在$$v_i^Tv_j=v_i\cdot v_j = 0$$</li>
<li>所以如果正交基v选择为A’A的特征向量的话，由于A’A是对称阵，v之间两两正交，那么$$v_i^TA^TAv_j=v_i^T\lambda _jv_j=0$$，这样就找到了正交基映射后还是正交基了。</li>
<li>将映射后的正交基单位化，$$u_i = \frac{Av_i}{|Av_i|}=\frac{1}{\sqrt{\lambda_i}}Av_i$$<br>其中$u_i$是映射后的正交基，$v_i$是映射前的正交基。</li>
<li>由此可得，$$Av_i=u_i\alpha_i(奇异值)=\sqrt{\lambda_i},0\leq i \leq k,k=Rank(A)$$</li>
</ul>
<p>这样我们就证明了，这个变换是存在的。</p>
<p>接下来，我们将向量组${u_1,u_2,…,u_k}$扩充为$R^m$中的标准正交基$u_1,u_2,…,u_r,…,u_m$，则：<br>$$AV=A(v_1,v_2,…,v_n)=(Av_1,Av_2,…,Av_k,0,0,…,0)$$<br>而由之前的推导我们知道，$Av_i=u_i\alpha_i(奇异值)$，因此上式变为<br>$$AV=(u_1\alpha_1,u_2\alpha_2,…,u_k\alpha_k,0,0,…,0)=UΣ$$</p>
<p>即：<br>$$A=UΣV^T$$</p>
<p>这就<strong>表明</strong>任意的矩阵$A$是可以分解成三个矩阵。$V$表示了原始域的标准正交基，$U$表示经过$A$变换后的co-domain的标准正交基，$Σ$表示了$V$中的向量与$U$中相对应向量之间的关系。</p>
<p>其中：</p>
<ul>
<li>$A是m\times n维度$</li>
<li>$U叫左奇异向量，是m\times m维的正交矩阵$</li>
<li>$Σ叫右奇异向量，是n\times n维的对角矩阵，但实际上只有左上角的k阶非零$,即:<img src="https://ooo.0o0.ooo/2017/07/10/5963960b257f5.png" alt=""> </li>
</ul>
<p>从大小上来看：<img src="https://ooo.0o0.ooo/2017/07/10/59639293b5bc5.png" alt=""> </p>
<p>即：<img src="https://ooo.0o0.ooo/2017/07/10/59639634df34d.png" alt=""> </p>
<h2 id="特征值分解与奇异值分解">2.3. 特征值分解与奇异值分解</h2><p>参考文献<a href="https://www.cnblogs.com/LeftNotEasy/archive/2011/01/19/svd-and-applications.html" target="_blank" rel="external">机器学习中的数学(5)-强大的矩阵奇异值分解(SVD)及其应用</a>提到，奇异值和特征值可以对应起来。</p>
<h2 id="部分奇异值分解">2.4. 部分奇异值分解</h2><p>在很多情况下，前10%甚至1%的奇异值的和就占了全部的奇异值之和的99%以上了。也就是说，我们也可以用前r大的奇异值来近似描述矩阵，这里定义一下部分奇异值分解：<br>$$A_{m\times n}\approx U_{m\times r}Σ_{r_\times r}V^T_{r\times n}$$<br> r是一个远小于m、n的数，这样矩阵的乘法看起来像是下面的样子：<br><img src="https://ooo.0o0.ooo/2017/07/10/596398011f9e0.png" alt=""><br>右边的三个矩阵相乘的结果将会是一个接近于A的矩阵，在这儿，r越接近于n，则相乘的结果越接近于A。而这三个矩阵的面积之和（在存储观点来说，矩阵面积越小，存储量就越小）要远远小于原始的矩阵A，我们如果想要压缩空间来表示原矩阵A，我们存下这里的三个矩阵：U、Σ、V就好了。</p>
<p><strong>小例子</strong></p>
<p>接下来我们给出一个用python的SVD分解小例子。</p>
<pre><code>&apos;&apos;&apos;Python
#coding=utf-8
# 首先做一些数据声明
from sklearn.decomposition import TruncatedSVD
from matplotlib import pyplot as plt
from numpy import random
import numpy as np
from mpl_toolkits.mplot3d import Axes3D
import pandas as pd
fig = plt.figure()
ax = Axes3D(fig)
ax=plt.subplot(111,projection=&apos;3d&apos;)
ax.set_zlabel(&apos;Z&apos;) #坐标轴
ax.set_ylabel(&apos;Y&apos;)
ax.set_xlabel(&apos;X&apos;)
X = np.arange(0, 4, 0.125) + 0.2 * random.randn(32)
Y = np.arange(0, 4, 0.125) + 0.2 * random.randn(32)
Z = np.arange(0, 4, 0.125) + 0.2 * random.randn(32)
# 数据是3维×32维
data = [[x, y, z] for x, y, z in zip(X, Y, Z)]


# 分解，n_components是主元素个数，也就是维度
svd = TruncatedSVD(n_components=2, algorithm=&quot;arpack&quot;, n_iter=1000)
transformed_data = svd.fit_transform(data)
# 还原
data_inverse = svd.inverse_transform(transformed_data)

#画图
X_ = [x[0] for x in data_inverse]
Y_ = [y[1] for y in data_inverse]
Z_ = [z[2] for z in data_inverse]
ax.scatter(X, Y, Z, c=&apos;r&apos;)#原始数据是红色
ax.scatter(X_, Y_, Z_, c=&apos;b&apos;)#分解后的数据是蓝色
plt.savefig(&quot;svd.png&quot;)
plt.show()
print svd.explained_variance_ratio_
&apos;&apos;&apos;
</code></pre><p>当降到二维，再还原时，我们看到：<br><img src="https://ooo.0o0.ooo/2017/07/11/59643b2a666c7.png" alt=""><br>降到一维，再还原，我们看到：<br><img src="https://ooo.0o0.ooo/2017/07/11/59643cbeed773.png" alt=""> </p>
<h1 id="SVD与潜在语义索引">3. SVD与潜在语义索引</h1><p>$$A=UΣV^T$$</p>
<p>吴军老师在矩阵计算与文本处理中的分类问题中谈到：三个矩阵有非常清楚的物理含义。</p>
<ul>
<li>$U$中的每一行表示意思相关的一类词，其中的每个非零元素表示这类词中每个词的重要性（或者说相关性），数值越大越相关。</li>
<li>$V^T$中的每一列表示同一主题一类文章，其中每个元素表示这类文章中每篇文章的相关性。中间的矩阵则表示类词和文章雷之间的相关性。</li>
<li>因此，我们只要对关联矩阵$A$进行一次奇异值分解，我们就可以同时完成了近义词分类和文章的分类。（同时得到每类文章和每类词的相关性）。</li>
</ul>
<p>参考文献<a href="https://www.cnblogs.com/LeftNotEasy/archive/2011/01/19/svd-and-applications.html" target="_blank" rel="external">机器学习中的数学(5)-强大的矩阵奇异值分解(SVD)及其应用</a>给出了一个理解这句话的例子，此处不再阐述。</p>
<p>我在做比赛的过程中，曾尝试过用SVD分解做APP特征，来描述APP之间的相似性特征。但效果不佳。推测原因是维度过低（几百万维压到了20维）。项目<a href="https://github.com/jiayi797/svd_app_recommend" target="_blank" rel="external">在这里</a></p>
<p>但这里我还是打算好好看看。万一以后用到呢？</p>
<p>参考文献<a href="http://charleshm.github.io/2016/03/SVD-Recommendation-System/" target="_blank" rel="external">SVD在推荐系统中的应用</a>以经典的电影评分问题为例，讲述了整个过程。参考文献<a href="http://www.jscon.co/multiarray/rs_used_svd.html" target="_blank" rel="external">SVD在推荐系统中的应用</a>用matlab进行了详细的过程复现。</p>
<p>我的理解：<br><strong>SVD分解</strong><br>SVD分解是：$$A_{m\times n}=U_{m\times m}Σ_{m\times n}V^T_{n\times n}$$<br>其中：</p>
<ul>
<li>$Σ_{m\times n}$是一个对角阵。</li>
<li>U_{m\times m}表示行间元素（一般是用户）的相似度</li>
<li>V^T_{n\times n}表示列间元素（一般是商品）的相似度<br>根据好友张思遥的理解，是通过数学的方法，来将行和列的拆开，放在两个矩阵里。<br><strong>降维</strong><br>根据PCA理论（强烈建议看斯坦福大学安德鲁老师的机器学习课程，这里有前辈的笔记<a href="http://blog.csdn.net/stdcoutzyx/article/details/37568225" target="_blank" rel="external">斯坦福ML公开课笔记14——主成分分析</a>，我们可以取前$r$维来对矩阵进行近似表示：<br>$$A_{m\times n}\approx U_{m\times r}Σ_{m\times n}V^T_{r\times n}$$</li>
</ul>
<h1 id="项目代码">4. 项目代码</h1><p><a href="https://github.com/jiayi797/svd_app_recommend" target="_blank" rel="external">SVD项目代码</a></p>
<h1 id="参考文献">5. 参考文献</h1><ol>
<li><a href="http://www.qiujiawei.com/linear-algebra-9/" target="_blank" rel="external">线性代数之奇异值(SVD)分解</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_3f738ee00102val0.html" target="_blank" rel="external">奇异值分解(SVD)原理详解及推导</a></li>
<li><a href="http://charleshm.github.io/2016/03/Singularly-Valuable-Decomposition/" target="_blank" rel="external">漫谈奇异值分解</a></li>
<li><a href="http://www.sohu.com/a/127149396_464826" target="_blank" rel="external">机器学习系列-SVD篇</a></li>
<li><a href="https://www.cnblogs.com/LeftNotEasy/archive/2011/01/19/svd-and-applications.html" target="_blank" rel="external">机器学习中的数学(5)-强大的矩阵奇异值分解(SVD)及其应用</a></li>
<li><a href="http://charleshm.github.io/2016/03/SVD-Recommendation-System/" target="_blank" rel="external">SVD在推荐系统中的应用</a></li>
<li><a href="http://www.jscon.co/multiarray/rs_used_svd.html" target="_blank" rel="external">SVD在推荐系统中的应用</a></li>
<li><a href="http://blog.csdn.net/stdcoutzyx/article/details/37568225" target="_blank" rel="external">斯坦福ML公开课笔记14——主成分分析</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> 数学 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 矩阵分解 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[矩阵相关知识复习]]></title>
      <url>/2017/07/10/%E6%95%B0%E5%AD%A6-%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/</url>
      <content type="html"><![CDATA[<h1 id="特征值与奇异值">1. 特征值与奇异值</h1><p><strong>特征值与特征向量</strong></p>
<p>如果一个向量$v$是方阵$A$的特征向量，那么：<br>$$Av=\lambda v$$</p>
<ul>
<li>$\lambda$:特征值</li>
<li>$v$:特征向量<br>把$A$乘到$v$上，得到一个$\lambda v$，也就是意味着我们得到了一个方向未变但在长度上有伸缩改变的向量（方向未变不准确，有可能变反向）。这是让$A$乘以他的特征向量表现出来的性质。</li>
</ul>
<p>因此：</p>
<ul>
<li>特征向量所在直线上的向量都是特征向量；</li>
<li>特征向量所在的直线，叫特征空间；</li>
</ul>
<p><strong>特征值分解</strong></p>
<p>特征值分解是把一个n阶实对称矩阵分解为下面的形式：<br>$$A=QΣQ^{-1}$$<br>其中：</p>
<ul>
<li>$Q$是这个矩阵$A$的特征向量组成的矩阵，是一个正交矩阵</li>
<li>$Σ$是一个对角阵，每个对角线上的元素就是一个特征值</li>
</ul>
<h1 id="正交变换与正交军阵">2. 正交变换与正交军阵</h1><h2 id="正交变换">2.1. 正交变换</h2><p><strong>什么是正交变换？</strong><br>正交变换：在线性空间中，保持向量长度不变的线性变换。<br><strong>正交变换的定义是什么？</strong><br>设$V$为欧式空间，$T$是$V$的一个线性变换。如果$T$保持$V$中任一向量$x$的长度不变，即有：<br>$$(x,x)=(Tx,Tx)$$<br>那么称$T$是$V$的一个正交变换。（即内积不变）</p>
<p>注：<br>$(x,x)$是向量内积<br><strong>怎样的变换算是正交变换？</strong><br>线性变换$T$为正交变换的充要条件是，对于欧式空间$V$中任二向量$x,y$都有：<br>$$(x,y)=(Tx,Ty)$$</p>
<h2 id="正交矩阵">2.2. 正交矩阵</h2><p><strong>正交矩阵的定义是什么？</strong><br>如果实方阵$Q$满足：<br>$$T^TQ=I,或 Q^{-1}=Q^T$$<br>则称$Q$为正交矩阵</p>
<p>其中，$I$是单位矩阵。<br><strong>正交矩阵有哪些特点？</strong></p>
<ul>
<li>正交矩阵的行列式必定为$+-1$</li>
<li>行列式值为+1的正交矩阵，称为特殊正交矩阵，它是一个旋转矩阵。</li>
<li>行列式值为-1的正交矩阵，称为瑕旋转矩阵。瑕旋转是旋转加上镜射。镜射也是一种瑕旋转。</li>
<li>正交矩阵的逆矩阵依然是正交矩阵</li>
<li>两个正交矩阵的乘积依然是正交矩阵</li>
<li>下面是一些小的正交矩阵和可能的解释：<br><img src="https://ooo.0o0.ooo/2017/07/10/59632337a1cdf.png" alt=""> </li>
</ul>
<p><strong>怎样的矩阵能够成为正交矩阵？</strong><br>$Q$是正交矩阵的充要条件是，它的列向量是两两正交的单位向量。</p>
<h2 id="正交变换与正交矩阵的关系">2.3. 正交变换与正交矩阵的关系</h2><p>欧式空间的线性变换是正交变换的充要条件是，它对于标准正交基的矩阵是正交矩阵。</p>
<h1 id="酉空间">3. 酉空间</h1><p>欧式空间是针对实数域$R$上的线性空间；<br>酉空间是特殊的复线性空间。</p>
<p><strong>酉变换</strong><br>酉空间$V$中的线性变换$T$，如果满足<br>$$(x,x)=(Tx,Tx),x\in V$$<br>则称$T$为$V$的酉变换。<br><strong>酉矩阵</strong><br>酉变换在酉空间的标准正交基下的矩阵$A$是酉矩阵，即$A$满足下式：<br>$$A^HA=AA^H=I$$</p>
<ul>
<li>酉矩阵的逆矩阵也是酉矩阵</li>
<li>两个酉矩阵的乘积还是酉矩阵</li>
</ul>
<h2 id="Schur定理">3.1. Schur定理</h2><p><strong>酉空间上的Schur定理（定理1.41）</strong><br>设$A\in C^{n\times n}$的特征值为$\lambda _1,\lambda _2,…,\lambda _n$，则存在酉矩阵$P$,使得：<br>$$P^{-1}AP=P^HAP=\left[<br>\begin{matrix}<br>\lambda _1 &amp; .          &amp; …&amp; . \\<br>           &amp; \lambda _2 &amp; …&amp; . \\<br>           &amp;            &amp; …&amp; . \\<br>           &amp;            &amp;    &amp;\lambda _n<br>\end{matrix}<br>\right]$$</p>
<p><strong>实数空间上的Schur定理</strong><br>设$A\in R^{n\times n}$的特征值为$\lambda _1,\lambda _2,…,\lambda _n$，且$\lambda _n \in R(i=1,2,…,n)$,则存在正交矩阵$Q$,使得：<br>$$Q^{-1}AQ=Q^HAQ=\left[<br>\begin{matrix}<br>\lambda _1 &amp; .          &amp; …&amp; . \\<br>           &amp; \lambda _2 &amp; …&amp; . \\<br>           &amp;            &amp; …&amp; . \\<br>           &amp;            &amp;    &amp;\lambda _n<br>\end{matrix}<br>\right]$$</p>
<p><strong>正规矩阵</strong></p>
<p>设$A \in C^{n \times n}$，且等式<br>$$A^HA=AA^H$$<br>成立，则称$A$为正规矩阵。</p>
<p><strong>正规矩阵与对角矩阵的定理（定理1.42）</strong></p>
<ul>
<li>（酉空间）设$A \in C^{n \times n}$，则$A$酉相似于对角矩阵的充要条件是$A$为正规矩阵；</li>
<li>（实数空间）$A \in R^{n \times n}$，且$A$的特征值都是实数，则$A$正交相似于对角矩阵的充要条件是$A$为正规矩阵。</li>
</ul>
<h1 id="参考文献">4. 参考文献</h1><ol>
<li><a href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E4%BA%A4%E7%9F%A9%E9%98%B5" target="_blank" rel="external">维基百科，正交矩阵</a></li>
<li><a href="">矩阵论，程云鹏</a></li>
<li><a href="http://zisong.me/post/wo-dui-te-zheng-zhi-yu-te-zheng-xiang-liang-de-li-jie" target="_blank" rel="external">我对特征值与特征向量的理解</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> 数学 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 矩阵论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[简单搜索引擎的实现]]></title>
      <url>/2017/07/09/Python-%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<p>这是很久以前的IRIE的期末大作业。现在贴在自己的博客上。</p>
<p>实验要求：</p>
<ol>
<li>用爬虫采集特定网站的信息；</li>
<li>设计实现信息检索与提取系统，对采集的信息进行检索提取；</li>
<li>结合webpy与html实现界面展示。</li>
</ol>
<h1 id="相关知识">1. 相关知识</h1><h2 id="爬虫">1.1. 爬虫</h2><p>网络爬虫是捜索引擎抓取系统中重要的组成部分，其主要目的是将互联网上的网页下载到本地形成一个文件或互联网内容的镜像备份。流程如下：<br>a.  从给定的入口网址把第一个网页下载下来<br>b.  从第一个网页中提取出所有新的网页地址，放入下载列表中<br>c.  按下载列表中的地址，下载所有新的网页<br>d.  从所有新的网页中找出没有下载过的网页地址，更新下载列表<br>e.  重复3、4两步，直到更新后的下载列表为空表时停止<br>其实就是简化成下面的步骤：<br>a.  按下载列表进行下载<br>b.  更新下载列表<br>c.  循环操作a，b，直到列表为空结束<br>在本次作业中我们使用python编码实现爬虫的功能，其中用到的python组件有：<br>urllib2：用于获取URLs（Uniform Resource Locators）的组件，以urlopen函数的形式提供一个非常简单的接口，具有利用不同协议获取URLs的能力，同时提供了一个比较复杂的接口来处理一般情况，如：基础验证，cookies代理和其他。通过handlers和openers的对象提供。urllib2支持获取不同格式的URLs并利用它们相关网络协议（例如FTP，HTTP）进行获取。<br>BeautifulSoup：是python的一个库，最主要的功能是从网页抓取数据。它提供简单的、python式的函数用来处理导航、搜索、修改分析树等功能。可以通过解析文档为用户提供需要抓取的数据。在bs4库中导入。<br>Htmlparser：是一个开源项目，提供了线性和嵌套两种方式来解析网页，主要用于 html 网页的转换（Transformation）以及网页内容的抽取（Extraction）。HtmlParser 有如下一些易于使用的特性：过滤器（Filters），访问者模式（Visitors），处理自定义标签以及易于使用的 JavaBeans。<br>selenium ：是一个模拟浏览器，进行web的自动化测试的工具，它提供一组API可以与真实的浏览器内核交互。用于抓取js动态生成的页面。</p>
<h2 id="信息检索系统模型">1.2. 信息检索系统模型</h2><p>信息检索系统的模型主要有布尔模型、向量模型和概率模型。其中布尔模型<br>是最早的IR模型，也是应用最广泛的模型，目前仍然应用于商业系统中，布尔模型查询简单但不支持部分匹配，很难控制被检索的文档数量；向量模型（VSM：Vector Space Model）是Salton在上世纪60年代提出的，成功应用于SMART（System for the Manipulation and Retrieval of Text）文本检索系统，其基于关键词，并根据关键词的出现频率计算相似度，向量模型中术语权重的算法提高了检索的性能，部分匹配的策略使得检索的结果文档集更接近用户的检索需求，同时可以根据结果文档对于查询串的相关度使用Cosine Ranking等公式对结果文档进行排序。<br>在本次作业中信息检索系统采用向量模型，根据相似度返回结果。</p>
<h2 id="结巴（Jieba）分词">1.3. 结巴（Jieba）分词</h2><p>结巴（jieba）是一个可以对一段中文进行分词的插件，支持精确模式、全模式及搜索引擎模式三种分词模式，可以适应不同需求。其基本实现原理有：（1）基于Trie树结构实现高效的词图扫描，生成句子中汉字所有可能成词情况所构成的有向无环图（DAG）；（2）采用了动态规划查找最大概率路径, 找出基于词频的最大切分组合；（3）对于未登录词，采用了基于汉字成词能力的HMM模型，使用了Viterbi算法。</p>
<h2 id="基于webpy界面设计网页">1.4. 基于webpy界面设计网页</h2><p>webpy 是一个轻量级Python web框架，可以快速的完成简单的web页面。在本次实验中使用webpy建立搜索网页，web.py 的模板语言叫做 Templetor，它能负责将 python 的强大功能传递给模板系统。本实验中使用template与html编写网页。</p>
<h1 id="系统设计">2. 系统设计</h1><p>本次实验中信息检索与提取系统的整体设计流程如下图所示。主要包括抓取信息、分词、建立索引、建立向量模型、计算比较相似度、返回结果这六个过程，此外，我们基于webpy建立了搜索的网页界面，使查询过程更加简洁明了。下面具体介绍相应的模块。<br><img src="https://ooo.0o0.ooo/2017/07/09/596238be1b600.png" alt=""> </p>
<p><strong>抓取信息</strong></p>
<p>使用python编写爬虫程序抓取新浪网（<a href="http://news.sina.com.cn/）" target="_blank" rel="external">http://news.sina.com.cn/）</a><br>上的新闻，使用urllib2获取网页源代码，使用beautifulsoup和htmlparser解析网页获取网页中的新闻（标题、关键字、内容、日期），用selenium获取js动态生成的数据(评论数)。解析过的与未解析的链接分开标记。经过一段时间的抓取，共获得3000多条新闻信息，保存为txt文件，具体格式如下：<br><img src="https://ooo.0o0.ooo/2017/07/09/596238dc23fb4.png" alt=""><br>每条新闻包括标题、关键字、时间、网址、评论数（热度）等信息。</p>
<p><strong>分词</strong><br>导入jieba分词模块，首先按是否为汉字、数字、英文字符及标点<br>符号对新闻内容进行梳理，去除掉信息缺失的数据，然后用jieba分词对title及description内容进行分词，得到如下txt文件；<br><img src="https://ooo.0o0.ooo/2017/07/09/596239055fe8a.png" alt=""><br><strong>建立索引</strong><br>对于所有的词，按照其在全部新闻中出现的情况建立倒排索引，将每个词与相应的新闻序号建立联系。<br><strong>建立向量模型</strong><br>结合建立的倒排索引表，计算每个新闻条目的向量，其中权重采用tf-idf算法生成，构建向量模型。<br><img src="https://ooo.0o0.ooo/2017/07/09/5962392041016.png" alt=""><br><strong>查询返回结果</strong><br>根据在query中输入的关键词与向量模型进行数量积计算相似度，根据相似度的大小将检索到的新闻按序列出。如：query中输入“南海，菲律宾”，得到的检索结果如下：<br><img src="https://ooo.0o0.ooo/2017/07/09/5962393a9743b.png" alt=""><br><strong>前后端实现</strong><br>基于webpy界面设计搜索网页，建立交互的界面。在之前系统设计的基<br>础上，在webpy框架下，利用templates模板语言将后台结果与前端界面进行交互，并在服务器端使用GET和POST函数与客户端web交互并传递参数传递参数，将搜索新闻在网页上呈现出来。其主要步骤为：（1）客户端发送get请求，触发服务端get()函数，调用index.html网页，返回给客户端。（2）客户端发送搜索关键字并通过post方式给服务端，触发服务端post()函数，post()函数将收到的关键字传入之前设计的搜索系统中，得到返回值新闻条目。（3）通过webpy传递给result.html，得到html网页后发给客户端。<br><img src="https://ooo.0o0.ooo/2017/07/09/5962395e27566.png" alt=""> </p>
<h1 id="最终效果">3. 最终效果</h1><p>校内网网址：<a href="http://10.108.112.154:8080/" target="_blank" rel="external">http://10.108.112.154:8080/</a><br>例如想要查询与“习近平”“南海”相关的新闻，按下图输入，关键词之间要有空格。<br><img src="https://ooo.0o0.ooo/2017/07/09/5962397f56a5b.png" alt=""><br>点击search之后的网页界面如下，将我们之前抓取的与“习近平”及“南海”有关的新闻链接按照相似度大小排列，同时列出相应的时间、内容及热度。<br><img src="https://ooo.0o0.ooo/2017/07/09/59623992a4464.png" alt=""><br>如果输入的关键词并不在之前建立的索引中，则会出现如下界面：<br><img src="https://ooo.0o0.ooo/2017/07/09/596239a2c7fc9.png" alt=""> </p>
<h1 id="遇到的问题及解决方法">4. 遇到的问题及解决方法</h1><p>•   对Python语言不熟悉、甚至0基础：<br>阅读相关书籍，掌握for循环，try\except异常处理，list  dict 等基本数据结构的操作及语法，文件读写操作，数学运算等，快速上手。<br>•   Python程序运行打印之后不输出：<br>import sys<br>reload(sys)<br>sys.setdefaultencoding(‘utf-8’)<br>•   获取网页速度慢：<br>if response.info().get(‘Content-Encoding’) == ‘gzip’:<br>    buf = StringIO(response.read())<br>    f = gzip.GzipFile(fileobj=buf)<br>下载压缩的网页，速度更快<br>•   获取网页异常时，程序中断，导致不能源源不断地爬取到需要的网页：<br>利用try/except处理异常。<br>try:<br>    …<br>except urllib2.HTTPError as e:  # 处理HTTP异常<br>    …<br>except urllib2.URLError as e:#处理URL异常<br>   …<br>except:#处理全部类型异常，使程序不中断<br>•   beautifulsoup解析网页内容不全，无法获取新闻网页中关于评论数目的信息：<br>查看网页源代码发现评论数是js动态生成的，beautifulsoup不能用于获取动态生成的数据，经查阅网上资料，返现selenium包可以用于解析网页中js动态生成的数据，我们首先获取新闻id，访问新浪新闻评论链接，找到其中评论数据。<br>commenturl = ‘<a href="http://comment5.news.sina.com.cn/comment/skin/default.html?channel=gn&amp;newsid=comos-" target="_blank" rel="external">http://comment5.news.sina.com.cn/comment/skin/default.html?channel=gn&amp;newsid=comos-</a>‘ + newsid<br>driver = webdriver.PhantomJS()<br>driver.set_page_load_timeout(30)#设置延时<br>driver.get(commenturl)#获取网页<br>comment = driver.find_element_by_class_name(‘f_red’).text#获取元素<br>•   selenium运行报错：<br>需要添加环境变量，将PhantomJS文件所在文件夹添加到$PATH文件下：sudo vi /etc/paths<br>•   搜索时建立索引过程耗费时间<br>预先建立好索引，存储在内存中，搜索时直接利用已经建立好的索引进行搜索。<br>•   为每条新闻数据、query建立向量并存储速度慢、由于字典集合很大，导致向量稀疏、耗费资源，另外进行向量乘法运算计算相似度时产生不必要的浪费：<br>仅为每条新闻数据建立字典，存储包含的词和tf-idf权重值，计算query和每一个新闻条目的相似度时，只需要对query中包含的关键词在新闻条目中的权值进行运算即可（因为其它位都是0），简化运算。<br>•   新闻条目数量庞大，query与新闻的匹配计算量大、效率低：<br>给定query时，我们先访问query中关键词在索引中的倒排列表，只对其中的新闻与query进行相似度计算、排序、返回最终结果，极大程度上过滤掉与query不相关的新闻条目。<br>•   字典创建无序，不能按创建顺序输出结果：<br>利用OrderedDict有序字典，能够记录下字典的创建顺序，有序输出结果dict= collections.OrderedDict()<br>•   搜索结果优化：搜索返回的结果题目中不包含关键词：<br>对在新闻题目中出现的关键词增加权重，使得题目与关键词匹配度越高的新闻排名越靠前，符合真实需求。<br>•   webpy不能直接调用Python中的函数：<br>在webpy模板首行定义一个变量$def with (posts) 在Python中计算后利用将参数传入，可以是任意类型。<br>•   webpy使用template时，路径设置：<br>render = web.template.render(‘templates/‘)<br>打开render下的index.html：<br>render.index() </p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[转化率预估之贝叶斯平滑]]></title>
      <url>/2017/07/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5-%E8%BD%AC%E5%8C%96%E7%8E%87%E9%A2%84%E4%BC%B0%E4%B9%8B%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%B9%B3%E6%BB%91/</url>
      <content type="html"><![CDATA[<h1 id="问题描述">1. 问题描述</h1><p>在做比赛的过程中，我们发现了有转化率这个指标在大量数据下是有效的。理想情况下，例如某个广告点击量是10000次，转化量是100次，那转化率就是1%。但有时，例如某个广告点击量是2次，转化量是1次，这样算来转化率为50%。但此时这个指标在数学上是无效的。因为大数定律告诉我们，在试验不变的条件下，重复试验多次，随机事件的频率近似于它的概率。后者点击量只有2次，不满足“重复试验多次”的条件。</p>
<p>那么如何解决这个问题呢？</p>
<p><strong>整体思路</strong>：用估计值来模拟实际CVR。</p>
<h1 id="解决方案">2. 解决方案</h1><p>实际上，广告妆化率是随着时间迁移和用户喜好变化而变化的。因此我们可以利用先验知识来持续性地调整CVR。<a href="https://zhuanlan.zhihu.com/p/21724759" target="_blank" rel="external">计算广告训练与平滑思想</a>给出了一个很好的解决方案：贝叶斯平滑。</p>
<p>考虑到时序序列模型，我们把从第一天到第n天的所有先验知识汇总到第n天的结果，并以此来对第n+1天的CTR进行平滑。在广告平滑上，没有什么方法比贝叶斯平滑能够更好的利用先验知识了，而帮助贝叶斯平滑方法实现目标的就是Beta分布。Beta分布的强大之处在于，通过改变其中的两个参数α和β，你可以让Beta分布的图形变成任意形状，而且在加入先验知识前后，通过贝叶斯变换，对CTR的预估都可以表示为Beta分布。</p>
<p>Beta分布中参数α和β的本质含义，即：α表示点击数，β表示曝光数。因为贝叶斯平滑的具体公式就是：</p>
<p>$$SmoothCTR = \frac{(α + CurrentC - 1)}{( α + β + CurrentI -2)}$$</p>
<p>能不能直接把历史点击和历史曝光分别赋值给α和β来进行计算呢？显然不行，因为这么做就会犯之前我们提到的那些问题，比如不同日期的曝光、点击权重应该不一样。所以基础的贝叶斯平滑是不能解决我们刚才提到的问题的，我们需要深入研究Beta分布的特性，用一种新的方法通过先验知识求解α和β，从而计算SmoothCTR。</p>
<p>Beta分布除了两个显性的重要参数α和β外，还有两个相对隐形但同样重要的参数，平均值和中位数，通过平均值和众数可以唯一确定α和β的值，它们的数学关系如下：</p>
<p>$$均值=\frac{\alpha}{\alpha+\beta}$$<br>$$众数=\frac{\alpha-1}{\alpha+\beta-2}$$</p>
<p>因此，如果我们确定了平均值和中位数，那么α和β的值也就确定了（根据均值和中位数求解α和β的过程请读者自行推导），所以可以试着从平均值和中位数入手分析。让我们来看看beta分布的密度函数：<br><img src="https://ooo.0o0.ooo/2017/07/09/596235ef428c7.png" alt=""> </p>
<p>2017.7.9 好困，先回去休息。明日继续。</p>
<h1 id="代码">3. 代码</h1><pre><code>&apos;&apos;&apos;Python
#!/usr/bin/python
# coding=utf-8

import numpy
import random
import scipy.special as special
import pandas as pd
import time
import math
from math import log

class HyperParam(object):
    def __init__(self, alpha, beta):
        self.alpha = alpha
        self.beta = beta
    def sample_from_beta(self, alpha, beta, num, imp_upperbound):
        sample = numpy.random.beta(alpha, beta, num)
        I = []
        C = []
        for click_ratio in sample:
            imp = random.random() * imp_upperbound
            #imp = imp_upperbound
            click = imp * click_ratio
            I.append(imp)
            C.append(click)
        return I, C
    def update_from_data_by_FPI(self, tries, success, iter_num, epsilon):
        &apos;&apos;&apos;estimate alpha, beta using fixed point iteration&apos;&apos;&apos;
        for i in range(iter_num):
            new_alpha, new_beta = self.__fixed_point_iteration(tries, success, self.alpha, self.beta)
            if abs(new_alpha-self.alpha)&lt;epsilon and abs(new_beta-self.beta)&lt;epsilon:
                break
            self.alpha = new_alpha
            self.beta = new_beta
    def __fixed_point_iteration(self, tries, success, alpha, beta):
        &apos;&apos;&apos;fixed point iteration&apos;&apos;&apos;
        sumfenzialpha = 0.0
        sumfenzibeta = 0.0
        sumfenmu = 0.0
        sumfenzialpha = special.digamma(success+alpha) - special.digamma(alpha)
        print sumfenzialpha
        # for i in range(len(tries)):
        #     sumfenzialpha += (special.digamma(success[i]+alpha) - special.digamma(alpha))
        #     sumfenzibeta += (special.digamma(tries[i]-success[i]+beta) - special.digamma(beta))
        #     sumfenmu += (special.digamma(tries[i]+alpha+beta) - special.digamma(alpha+beta))
        return alpha*(sumfenzialpha/sumfenmu), beta*(sumfenzibeta/sumfenmu)
    def update_from_data_by_moment(self, tries, success):
        &apos;&apos;&apos;estimate alpha, beta using moment estimation&apos;&apos;&apos;
        mean, var = self.__compute_moment(tries, success)
        #print &apos;mean and variance: &apos;, mean, var
        #self.alpha = mean*(mean*(1-mean)/(var+0.000001)-1)
        self.alpha = (mean+0.000001) * ((mean+0.000001) * (1.000001 - mean) / (var+0.000001) - 1)
        #self.beta = (1-mean)*(mean*(1-mean)/(var+0.000001)-1)
        self.beta = (1.000001 - mean) * ((mean+0.000001) * (1.000001 - mean) / (var+0.000001) - 1)
    def __compute_moment(self, tries, success):
        &apos;&apos;&apos;moment estimation&apos;&apos;&apos;
        ctr_list = []
        # var = 0.0
        mean = (success / tries).mean()
        if len(tries) == 1:
            var = 0
        else:
            var = (success / tries).var()
        # for i in range(len(tries)):
        #     ctr_list.append(float(success[i])/tries[i])
        # mean = sum(ctr_list)/len(ctr_list)
        # for ctr in ctr_list:
        #     var += pow(ctr-mean, 2)
        return mean, var

def test():
    #设定初始值
    hyper = HyperParam(1, 1)
    #--------sample training data--------
    # I, C = hyper.sample_from_beta(10, 1000, 10000, 1000)
    # print I, C
    train_data = pd.read_csv(&apos;data.csv&apos;,nrows=10000)
    print &apos;read finish&apos;
    # 统计点击次数和转化次数
    key = [&apos;creativeID&apos;]
    train_data[&apos;count&apos;] = 1
    train_data = train_data.groupby(key).agg(&apos;sum&apos;).reset_index()
    # 此时，train_data[&apos;count&apos;]是点击次数
    # train_data[&apos;label&apos;]是点击次数
    print &apos;cal finish&apos;
    I = train_data[&apos;count&apos;]
    C = train_data[&apos;label&apos;]
    print key
    start = time.clock()
    #--------estimate parameter using fixed-point iteration--------
    # 计算平滑
    hyper.update_from_data_by_FPI(I, C, 1000, 0.00000001)
    end = time.clock()
    print hyper.alpha, hyper.beta
    print &apos;run time: &apos;,end - start

    start1 = time.clock()
    #--------estimate parameter using moment estimation--------
    hyper.update_from_data_by_moment(I, C)
    end1 = time.clock()
    print hyper.alpha, hyper.beta
    print &apos;EM run time: &apos;, end1 - start1

if __name__ == &apos;__main__&apos;:
    test()
&apos;&apos;&apos;
</code></pre><h1 id="参考文献">4. 参考文献</h1><ol>
<li><a href="https://zhuanlan.zhihu.com/p/21724759" target="_blank" rel="external">计算广告训练与平滑思想</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> 腾讯算法大赛-CVR预估 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CVR,贝叶斯平滑 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[word embedding]]></title>
      <url>/2017/06/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5-CVR-word-embedding/</url>
      <content type="html"><![CDATA[<p>在做比赛的过程中，我曾用过word embedding生成app特征，对结果提升了有几个万分点。</p>
<p>论文：tem2vec: Neural Item Embedding for Collaborative Filtering</p>
<h1 id="思想">1. 思想</h1><p>这篇文章比较朴素，创新性不高，基本是参照了google的word2vec方法，应用到推荐场景的i2i相似度计算中，但实际效果看还有有提升的。主要做法是把item视为word，用户的行为序列视为一个集合，item间的共现为正样本，并按照item的频率分布进行负样本采样，缺点是相似度的计算还只是利用到了item共现信息，1).忽略了user行为序列信息; 2).没有建模用户对不同item的喜欢程度高低。</p>
<h1 id="实现">2. 实现</h1><p>主要代码来自于写论文的作者分享的<a href="https://github.com/Bereket123/Recommendation-based-on-sequence-" target="_blank" rel="external">代码</a></p>
<h1 id="参考文献">3. 参考文献</h1><ol>
<li><a href="https://zhuanlan.zhihu.com/p/24339183" target="_blank" rel="external">DNN论文分享 - Item2vec: Neural Item Embedding for Collaborative Filtering</a></li>
<li><a href="https://view.inews.qq.com/a/20170428A07XNU00" target="_blank" rel="external">达观数据推荐算法实现：协同过滤之item embedding</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> 腾讯算法大赛-CVR预估 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 推荐 </tag>
            
            <tag> 腾讯算法大赛 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[不平衡类的处理]]></title>
      <url>/2017/06/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5-CVR-%E4%B8%8D%E5%B9%B3%E8%A1%A1%E7%B1%BB%E7%9A%84%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<p>最近在做比赛，发现在工业上，很多分类问题的标签分布都是不平衡的。如参考文献<a href="http://bourneli.github.io/machine-learning/prml/2016/12/19/compensating-for-class-priors.html" target="_blank" rel="external">标签倾斜修正方法记要</a>所属，比如用分类器去判断x光片中的癌症，这是一个二元分类问题，由于癌症的比例是非常小的，比如0.001。那么，将这些样本放到大多数分类模型中训练，模型的表现会非常相似，将所有数据都预测为没有癌症，因为这样也可以得到99.999%的准确率。</p>
<h1 id="常见的解决办法">1. 常见的解决办法</h1><p>参考文献<a href="https://www.jiqizhixin.com/articles/1dd8da6e-ae24-4fc5-ab90-ee39020bc5ff" target="_blank" rel="external">解决真实世界问题：如何在不平衡类上使用机器学习？</a>说，从不平衡数据中学习，是一项已被研究了 20 年之久的问题。它曾是许多论文、研讨会、特别议程的主题（一项最近的调查就有大约 220 个引用）。人们尝试了许多方法，但结果各不相同，所以至今没有得到明晰的答案。当数据科学家们第一次遇到这个问题，他们往往会问：「如果我的数据是不平衡的，我该怎么做？」而这一问题是没有固定答案的，就像你问「哪个学习算法是最好的」一样：<strong>答案取决于数据。</strong></p>
<p>一般来说，有下面几种方法：</p>
<ul>
<li><p>什么也不做</p>
</li>
<li><p>通过某些方法使得数据更加平衡：</p>
</li>
<li><ul>
<li>对少数类进行过采样</li>
</ul>
</li>
<li><ul>
<li>对多数类进行欠采样</li>
</ul>
</li>
<li><ul>
<li>合成新的少数类</li>
</ul>
</li>
<li><ul>
<li>舍弃所有少数类，切换成一个异常检测框架。</li>
</ul>
</li>
<li><p>在算法层面之上（或之后）：</p>
</li>
<li><ul>
<li>调整类的权重（错误分类成本）</li>
</ul>
</li>
<li><ul>
<li>调整决策阈值</li>
</ul>
</li>
<li><ul>
<li>使已有的算法对少数类更加敏感</li>
</ul>
</li>
<li><ul>
<li>构造一个在不平衡数据上表现更好的全新算法。</li>
</ul>
</li>
</ul>
<h1 id="一种标签倾斜修正方法">2. 一种标签倾斜修正方法</h1><p>参考文献<a href="">Practical Lessons from Predicting Clicks on Ads at<br>Facebook</a>6.3指出，欠采样可以加快训练速度，提升模型表现。需要注意的是，就算数据被欠采样，其实也可以通过在欠采样空间中对预测结果进行修正。例如，在采样之前CTR只有0.1%，那么我们对负样本欠采样0.01，那么CTR就会变为10%。为了修正结果，使得CTR恢复到0.1%,我们可以通过公式：<br>$$q=\frac{p}{p+(1-p)/w}$$<br>其中，$p$是欠采样空间下预测的概率，<br>$w$是对负样本的采样率。</p>
<p>在这里我决定先复习一下先验概率、后验概率</p>
<h2 id="先验概率、后验概率">2.1. 先验概率、后验概率</h2><p><strong>先验概率</strong>是指事件尚未发生，对该事件发生的概率的估计，是在缺乏某个事情的情况下描述一个变量。<br>先验概率可以通过已知的关于事件本身的先验知识得到，蒙特卡洛方法也可以用于计算先验概率。<br><strong>后验概率</strong>是指在事件已经发生的条件下，求该事件发生原因是由某个因素引起的可能性的大小，是考虑一个事件之后的条件概率。<br>后验概率可以基于 贝叶斯定理，通过先验概率乘以似然度，再归一化得到。具体来说，贝叶斯公式：<br>$$P(h|D)=\frac{P(D|h)P(h)}{p(D)}$$<br>其中，$P(h)$为$h$的先验概率，$P(h|D)$为$h$的后验概率。<br>通常，事件A在事件B（发生）的条件下的概率，与事件B在事件A（发生）的条件下的概率是不一样的；然而，这两者是有确定的关系的，贝叶斯定理就是这种关系的陈述。贝叶斯公式的一个用途在于通过已知的三个概率函数推出第四个。</p>
<h2 id="标签倾斜修正">2.2. 标签倾斜修正</h2><p>参考文献<a href="http://bourneli.github.io/machine-learning/prml/2016/12/19/compensating-for-class-priors.html" target="_blank" rel="external">标签倾斜修正方法记要</a>通过理论推导来验证这个结论。<br>上参考文献作者提到，PRML的1.5.4节中介绍了一种标签倾斜修正的方法。</p>
<p>首先，你的模型必须是一个软分类器，即预测值为0到1之间的概率。假设输入向量x，预测标签$C_k$，那么可以用条件概率表示，即计算$p(C_k|x)$的概率。根据贝叶斯公式，条件概率可以如下变化：<br>$$p(C_k|x)=\frac{p(x|C_k)p(C_k)}{p(x)}$$</p>
<p>上面是没有做重采样时，得到概率。当做重采样时，只是改变了标签$C_k$的先验概率$p(C_k)$，即将$p(C_k)$变为$p’(C_k)$（其实就是标签$C_k$的先验分布而已）。而$p(x)$是条件$x$发生的概率，不会变化。$p(x|C_k)$是后验概率，也不会变化。【问题，为什么不变？我感觉是因为特征是采样前的特征，因此这个没变】</p>
<p>因为是对负样本进行了抽样，假设对负样本抽样比例为$w$，抽样后：</p>
<p>$$n’(0)=n(0)\times w,n’(1)=n(1)$$</p>
<p>易知：<br>$$p(1)=\frac{n(1)}{n(1)+n(0)}=\frac{n’(1)}{n’(1)+n’(0)/ w}$$<br>$$=\frac{p’}{p’+(1-p’)/w}$$<br>其中，$n(C_k)$表示$C_k$的个数</p>
<p>我们推导出了先验概率$p’(C_k)$与$p(C_k)$的关系。那么，如果我们想修正$p(C_k|x)$，则：</p>
<p>$$p(1|x) = \frac{p(x|1)p(1)}{p(x)} = \frac{p(x|1)p’(1)p(1)}{p(x)p’(1)}$$<br>$$=p’(1|x)\frac{p(1)}{p’(1)}=p’(1|x)\frac{p}{p’}$$</p>
<p>而由之前的推导我们可知$p=\frac{p’}{p’+(1-p’)/w}$，代入得：<br>$$p(1|x)=p’(1|x)\frac{p}{p’}=p’(1|x)\frac{\frac{p’}{p’+(1-p’)/w}}{p’}$$<br>$$=p’(1|x)\frac{1}{p’+(1-p’)/w}$$</p>
<p>需要注意的是，$p’(1|x)$是预测出来的概率，$p’$是抽样之后正样本的比例，而在facebook的论文中，假设$p’\approx p’(1|x)$（也就是说，我们假设了预测集中，1出现的概率=预测出来的为1的概率。我的理解就是，我们完全信任了预测的结果），并记$q=p’(1|x)$则以上公式变为：</p>
<p>$$p(1|x)=\frac{q}{q+(1-q)/w}$$</p>
<p>【问题：在预测时，$p’$可不可以变为预测集的正样本比例$p’$】</p>
<h2 id="结论">2.3. 结论</h2><p>在欠采样中，假设对负样本采样率为$w$，则直接将结果按照如下公式修正即可：</p>
<p>$$p=\frac{q}{q+(1-q)/w}$$</p>
<p>其中：</p>
<ul>
<li>$q$是在欠采样之后，模型预测出来的概率。</li>
<li>$p$是修正后的概率。</li>
</ul>
<p>当w=0.1时，变换其实为：</p>
<p><img src="https://ooo.0o0.ooo/2017/06/10/593c0b680d2b7.png" alt=""> </p>
<p>上面是y1=q(不做变换)，下面是本变换y2。</p>
<p>而如果我们将y3=y1-y2绘出：<br><img src="https://ooo.0o0.ooo/2017/06/10/593c0bc5aa670.png" alt=""> </p>
<p>我们发现，概率大的压缩的小。<br>因为你负样本采样了之后，就是会预测的比实际的高一点，所以要给它压下去。</p>
<p>附上matlab代码：<br>    q=0.001:0.01:1;<br>    y1=1./(1+(1./q-1)./0.1);<br>    y2 = q;<br>    plot(q,y1);<br>    hold on;<br>    plot(q,y2);<br>    hold on;<br>    y3 = y2-y1;<br>    plot(q,y3)</p>
<h2 id="小trick（有错，删掉）">2.4. 小trick（有错，删掉）</h2><p>如果在已知样本中，正样本的概率$p$,那么：</p>
<p>$$p’(1)=\frac{n’(1)}{n’(1)+n’(0)}=\frac{n(1)}{n(1)+n(0)\times w}$$<br>$$=\frac{1}{1+\frac{n(0)\times w}{n(1)}}=\frac{1}{1+\frac{p(0)\times w}{p(1)}}$$<br>$$=\frac{p(1)}{p(1)+p(0)\times w}=\frac{p}{p+(1-p)\times w}$$</p>
<p>而因为：<br>$$p(1|x)=p’(1|x)\frac{p}{p’}$$</p>
<p>代入得：</p>
<p>$$p(1|x)=p’(1|x)\frac{p}{\frac{p}{p+(1-p)\times w}}$$<br>$$=p’(1|x)(p+(1-p)\times w)$$</p>
<p>这里的p是样本中，正样本的概率。</p>
<h1 id="参考文献">3. 参考文献</h1><ol>
<li><a href="http://bourneli.github.io/machine-learning/prml/2016/12/19/compensating-for-class-priors.html" target="_blank" rel="external">标签倾斜修正方法记要</a></li>
<li><a href="https://www.jiqizhixin.com/articles/1dd8da6e-ae24-4fc5-ab90-ee39020bc5ff" target="_blank" rel="external">解决真实世界问题：如何在不平衡类上使用机器学习？</a></li>
<li><a href="https://mqshen.gitbooks.io/prml/content/" target="_blank" rel="external">PRML(《模式识别和机器学习》)翻译</a></li>
<li><a href="http://bourneli.github.io/ml/2017/05/25/gdbt-lr-facebook-paper.html?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="external">GBDT特征转换+LR总结</a></li>
<li><a href="http://sighingnow.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/prior_posterior_probability_and_estimation.html" target="_blank" rel="external">先验和后验概率以及估计</a></li>
<li><a href="">Practical Lessons from Predicting Clicks on Ads at<br>Facebook</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> 腾讯算法大赛-CVR预估 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 特征工程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[腾讯社交广告APP转化率预估预估初赛&复赛思路总结]]></title>
      <url>/2017/06/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5-CVR-Tencent_CVR%E9%A2%84%E4%BC%B0%E5%88%9D%E8%B5%9B%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>“这一段奔波太过匆忙，有时来不及回头张望。”</p>
<p>腾讯“人工寻找trick”大赛初赛今天结束了。最终初赛线上logloss为0.099104，排名为64名：<img src="http://om1bxijvl.bkt.clouddn.com/2017-06-07-15-22-48.png" alt=""> </p>
<p>复赛成绩0.101941，排名26名：<img src="https://ooo.0o0.ooo/2017/07/11/59646ce45d3e0.png" alt=""> </p>
<p>虽然与前排大神的分相差甚远，虽结果不那么如人意，也是对这个领域入了个门。</p>
<h1 id="赛题">1. 赛题</h1><p>详细赛题见<a href="http://algo.tpai.qq.com/home/information/index.html" target="_blank" rel="external">官方网站</a></p>
<p><strong>已知</strong>：17-30天移动APP的广告、用户的转化情况，及相关上下文。<br><strong>预测</strong>：第31天指定用户和对应广告的转化率。</p>
<p><strong>评估方式</strong>：<br>$$logloss=-\frac{1}{N}\sum_{i=1}^N(y_ilog(p_i)+(1-y_i)log(1-p_i))$$</p>
<p>其中，</p>
<ul>
<li>N是测试样本总数</li>
<li>$y_i$是二值变量，取值为0或1，表示第i个样本的label</li>
<li>$p_i$是模型预测第i个样本label为1的概率</li>
</ul>
<p>总之，就是预测的越准越好（这不废话么2333）</p>
<h1 id="主要流程">2. 主要流程</h1><p>这是Kaggle上数据挖掘比赛的黄金流程图：<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-06-07-15-44-01.png" alt=""> </p>
<p>其实对于这个比赛的初赛而言，线上是容易过拟合的。因为线上只有一个集，可反复提交多次来使得线上得分很高，但实际上模型是有些过拟合的。不过这不是重点。</p>
<p>接下来一步步做说明</p>
<h1 id="数据分析与清洗">3. 数据分析与清洗</h1><p>训练集train.csv没有大问题，我注意的只是后几天的一些数据没有回流的问题。</p>
<p>值得注意的是，本次竞赛的训练数据提供的截止第31天0点的广告日志，因此，对于最后几天的训练数据，也就是说后五天部分用户实际上是转化了，但广告主还没有来得及将这条转化汇报给广告系统，导致数据集中的label被误标记为了0（实际上是1）。（如果我还没有描述清楚，这里具体可以看官网赛题FAQ.1）</p>
<p>这里我采取了一种很暴力的方法，即去掉每个广告主最后一次回流之后的数据。</p>
<p>通过分析我们发现，其实有近一半的广告主还是尽职尽责的，直到30号23点还在反馈回流。只有有一部分广告主在30号下班后，或29号下班后就不回流了。所以我们将这些广告主最后一次回流之后的数据都删除（其实这些都是负样本），这样就在一定程度上减少了不准的负样本。</p>
<p>这样筛去了大概有3万条，也不算多。</p>
<h1 id="特征工程">4. 特征工程</h1><p>一开始的时候我们采用了很多基本特征，即各种ID（AppID,UserID,creativeID,pisitionID等）的onehot编码，又对单特征进行了一定的统计。后来看了大神“为情所困的少年”的分享，才反应过来其实无论是onehot还是对ID单维度的统计特征，其实都是对于一个特征的一种表达，从一定意义上是重复的。我个人感觉onehot之后的稀疏特征更适合于线性模型，如LR；而统计量的连续特征更适合于树模型，如GBDT。</p>
<p>回头来看，其实特征工程需要根据模型预先选择方向。李沐说过，模型是使用离散特征还是连续特征，其实是一个“海量离散特征+简单模型” 同 “少量连续特征+复杂模型”的权衡。既可以离散化用线性模型，也可以用连续特征加深度学习。就看是喜欢折腾特征还是折腾模型了。通常来说，前者容易，而且可以n个人一起并行做，有成功经验；后者目前看很赞，能走多远还须拭目以待。</p>
<p>就此题来说，有两个方向：</p>
<h2 id="海量离散特征-简单模型">4.1. 海量离散特征+简单模型</h2><p>如果我们懒得分析数据（初期我们就是这样），并且有还不错的设备（自以为64G内存很有优势），我们可以直接选择这个方向。</p>
<p>初期的时候，我们是选择的这条路。<br>当时只有简单的ID类特征，以及ID类特征的交叉组合，将这些特征onehot之后输入了LR模型。</p>
<p>关于特征组合，我在后面会介绍到。</p>
<p>做完特征和特征组合，将它onehot之后输入模型就可以了。</p>
<p>对于LR这种线性模型来说，它更适合于onehot类型的特征，首先它对于稀疏高维特征处理是无压力的，其次离散化后的特征对异常数据有很强的鲁棒性，这些在参考文献2<a href="http://blog.csdn.net/yang090510118/article/details/39478033" target="_blank" rel="external">逻辑回归LR的特征为什么要先离散化</a>中可以看到。</p>
<p>但由于ID类特征非常多，例如本题的UserID有好几百万个。这时就会带来维度灾难问题，见参考文献4<a href="https://zhuanlan.zhihu.com/p/26945814" target="_blank" rel="external">机器学习中的维度灾难</a>。不仅如此，这时基本上也就被设备问题限制死了。这很烦。于是我们就换模型了。</p>
<h2 id="少量连续特征-复杂模型">4.2. 少量连续特征+复杂模型</h2><p>这是我们暂定的一个方案，就是采用少量、但表现很不错的组合特征统计量，以及一些手工提取的特征（如用户历史安装次数、APP历史被安装次数），这些特征主要来源于群内“为情所困”大神分享的一张表。</p>
<p>模型我们采用的是GBDT，直接使用了陈天奇大牛的xgboost框架。模型我暂时还没有很认真地研究，只是熟悉了一些参数，为决赛做了一些准备。</p>
<h1 id="特征组合">5. 特征组合</h1><p>特征组合真是我遇到的一个大难题。</p>
<h2 id="怎么表达组合特征？">5.1. 怎么表达组合特征？</h2><p>说到特征组合，从统计的角度解释，基本特征仅仅是真实特征分布在低维空间的映射，不足以描述真实分布，加入组合特征是为了在更高维空间拟合真实分布，使得预测更准确。<br>组合特征我现在用过的有以下两种方式：</p>
<p><strong>对离散ID进行hash生成新特征</strong></p>
<p>在初期用LR的时候，我们采用的方式是hash。即对两个ID做hash运算，得到一个新特征。这是一个很巧妙的方法。例如下面这个表，我们做哈希：</p>
<p>$$age\times 10 + gendar$$</p>
<p>得到第三列：</p>
<table>
<thead>
<tr>
<th style="text-align:center">age</th>
<th style="text-align:center">gendar</th>
<th style="text-align:center">hash</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">10</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">21</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">2</td>
<td style="text-align:center">32</td>
</tr>
</tbody>
</table>
<p>第三列的的特征的取值有两位，十位是age,个位是gendar。新特征是一种新的交叉特征的体现。</p>
<p><strong>对组合进行统计生成新特征</strong></p>
<p>像之前“为情所困”大神说过的那样，其实无论onehot还是统计特征，其实都是对于一个特征的一种表达。因为后期我们采用了GBDT，因此我们弃用了之前的hash组合方式，而选用统计量（即点击量、转化量和转化率）。这样就在一个维度上表达了这两个特征的组合，而且非常便于计算。</p>
<h2 id="选谁做特征组合？">5.2. 选谁做特征组合？</h2><p>需要注意的是，特征组合也不是随便从原来的特征里摘出来两列就做组合。这种随意地对特征堆叠其实会增加模型的负担，而且这些其实就像是“随机数一般的，毫无作用的特征”，可能会使得效果变差。</p>
<p>究竟对谁做组合，这也是一直困扰我们的问题。以下是我搜集到的几种方案：</p>
<p><strong>迭代选取方式</strong></p>
<p>Jerrylin大神曾经说过，可以先对一个组合做groupby分析，看看转化率的分布。可是我遇到了一个瓶颈——大多数特征的转化率分布都是不均匀的，组合起来就更不均匀了。不知道大神是怎么解决的，也许是计算这个分布的方差？【这是个问题，等来日解决，我再回来填坑】<br>大神刚才回我了，他说他是按照gbdt给的一个评分，选取评分较高的几个进行组合，然后再次输入模型进行迭代筛选。<br>在此我要再次偷偷感谢一下这位大神。要是没有他，我可能还会在二百名外挣扎。</p>
<p>刚才风，飞扬。。大神告诉我，其实xgb给的评分也是只能作为一个参考，因为不一定组合之后给会更高。</p>
<p>忆『凌』殇大神说，构造的特征很可能相关性很高，然后这两个特征的重要性肯定都不低。但是因为相关性高反而会影响性能。这个相关性可以计算这两个特征的相关系数corrcoef来得到。</p>
<p><strong>穷举后用卡方检验筛特征</strong></p>
<p>参考文献<a href="http://202.197.191.206:8080/30/text/chapter04/4_8.htm" target="_blank" rel="external">描述量选择及特征的组合优化</a>提到，由于任何非穷举的算法都不能确保所得结果是最优的，因此要得最优解，就必需采用穷举法，只是在搜索技术上采用一些技巧，使计算量有可能降低。</p>
<p>我的学长“酱紫”对此有一种建议就是直接对所有基本特征进行遍历两两组合，然后用卡方检验筛出来一些比较好的特征。这种方式很简单，大多数工作只需要交给模型来完成。</p>
<p><strong>循环特征消减和特征重要性评级</strong></p>
<p>参考文献<a href="http://www.jianshu.com/p/8f6f94f1d275" target="_blank" rel="external">scikit-learn系列之特征选择</a>中提到，在scikit-learn中有两种特征选择的方法，一种叫做循环特征消减(Recursive Feature Elimination)和特征重要性评级 (feature importance ranking)。</p>
<ul>
<li>循环特征消减：其实就是循环地移除变量和建立模型，通过模型的准确率来评估变量对模型的贡献。这种方式很暴力，但也很准确。但是问题是我们没有那么多的时间来等待模型训练这么多次。</li>
<li>特征重要性评级：“组合决策树算法”（例如Random Forest or Extra Trees）可以计算每一个属性的重要性。重要性的值可以帮助我们选择出重要的特征。</li>
</ul>
<p><strong>用GBDT筛特征</strong></p>
<p><em>主要思想</em>：<br>GBDT每棵树的路径直接作为LR输入特征使用。</p>
<p><em>原理</em>：<br>用已有特征训练GBDT模型，然后利用GBDT模型学习到的树来构造新特征，最后把这些新特征加入原有特征一起训练模型。构造的新特征向量是取值0/1的，向量的每个元素对应于GBDT模型中树的叶子结点。当一个样本点通过某棵树最终落在这棵树的一个叶子结点上，那么在新特征向量中这个叶子结点对应的元素值为1，而这棵树的其他叶子结点对应的元素值为0。新特征向量的长度等于GBDT模型里所有树包含的叶子结点数之和。</p>
<p>【这里其实不太懂，一会问问张思遥】</p>
<p><em>步骤</em>：</p>
<ol>
<li>首先要切分数据集，一部分用于训练GBDT，另一部分使用训练好的GBDT模型</li>
<li>GBDT模型的apply方法生成x在GBDT每个树中的index，然后通过onehot编码做成特征。</li>
<li>新的特征输入到分类（如LR）模型中训练分类器。</li>
</ol>
<p><em>实现</em>：<br>参考文献<a href="http://blog.csdn.net/shine19930820/article/details/71713680" target="_blank" rel="external">GBDT原理及利用GBDT构造新的特征-Python实现</a>的末尾有一个调用GBDT训练模型构建树，调用<a href="http://blog.csdn.net/shine19930820/article/details/71713680" target="_blank" rel="external">apply()</a>方法得到特征，然后将特征通过one-hot编码后作为新的模型输入LR进行训练。<a href="http://scikit-learn.org/stable/auto_examples/ensemble/plot_feature_transformation.html#example-ensemble-plot-feature-transformation-py" target="_blank" rel="external">feature trainsformation with ensembles of tree官方文档</a></p>
<h2 id="本赛题特征构造">5.3. 本赛题特征构造</h2><p><a href="https://github.com/z564808896/Tencent_Social_Ads" target="_blank" rel="external">竟然有这种操作队分享</a>总结得非常好，主要特征是分为以下几类：</p>
<ul>
<li>Trick特征：<br>通过观察原始数据是不难发现的,有很多只有clickTime和label不一样的重复数据，按时间排序发现重复数据如果转化，label一般标在头或尾，少部分在中间，在训练集上出现的情况在测试集上也会出现，所以标记这些位置后onehot，让模型去学习，再就是时间差特征，关于trick我比赛分享的这篇文章有较详细的说明。比赛后期发现了几个和这个trick相类似的文章1和文章2，可以参考。</li>
<li><p>统计特征：<br>原始特征主要三大类：广告特征、用户特征、位置特征，通过交叉组合算统计构造特征，由于机器限制，统计特征主要使用了转化率，丢掉了点击次数和转化次数。初赛利用了7天滑窗构造，决赛采用了周冠军分享的clickTime之前所有天算统计。三组合特征也来自周冠军分享的下载行为和网络条件限制，以及用户属性对app需求挖掘出。贝叶斯平滑user相关的特征特别废时间，初赛做过根据点击次数阈值来操作转化率，效果和平滑差不多但是阈值选择不太准。</p>
</li>
<li><p>活跃数特征：</p>
</li>
<li><p>特征构造灵感来自这里,比如某个广告位的app种数。</p>
</li>
<li><p>均值特征：</p>
</li>
<li><p>比如点击某广告的用户平均年龄</p>
</li>
<li><p>平均回流时间特征：<br>利用回流时间方式不对的话很容易造成leackage，这里参考了官方群里的分享，计算了每个appID的平均回流时间，没有回流的app用其所在类的平均回流时间代替</p>
</li>
<li><p>用户流水和历史特征：<br>利用installed文件关联user和app获得历史统计特征，利用actions进行7天滑动窗口获得用户和app流水特征。</p>
</li>
</ul>
<h2 id="一些特殊的东西">5.4. 一些特殊的东西</h2><p><strong>多线程抽特征</strong></p>
<p>决赛数据集太大，而我们组合特征非常多。因此我们采用了多线程抽特征的方式。<br>代码见<a href="https://github.com/zsyandjyhouse/TencentAD_contest" target="_blank" rel="external">TencentAD_contest</a>，extra_rate_thread_0623.py<br><strong>贝叶斯平滑</strong><br>在决赛时，我们还使用了贝叶斯平滑。针对Pandas，我们对网上已有的代码进行了改进。<br><a href="https://jiayi797.github.io/2017/07/09/%E8%BD%AC%E5%8C%96%E7%8E%87%E9%A2%84%E4%BC%B0%E4%B9%8B%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%B9%B3%E6%BB%91/" target="_blank" rel="external">贝叶斯平滑笔记</a><br><strong>word embedding</strong><br>这个我没有做过多研究，这里是<a href="https://jiayi797.github.io/2017/06/21/word-embedding/" target="_blank" rel="external">word embedding笔记</a><br><strong>SVD分解</strong><br>思路和代码主要看我这篇博客<a href="https://jiayi797.github.io/2017/07/10/SVD%E5%88%86%E8%A7%A3/" target="_blank" rel="external">SVD分解</a></p>
<h1 id="训练集构造">6. 训练集构造</h1><p>训练集特征做不好，就很容易造成泄露。这是我试过的两种方式：</p>
<ol>
<li>用滑动窗口，即每天的前七天的统计（统计指统计转化量、点击量、转化率，下同）来作为第本天的特征。并拿30号来做线下测试集。<br>如下图所示：<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-06-07-21-49-53.png" alt=""><br>经测试我们发现，即使我们去掉了30号的部分负样本，还是有一些问题的。因此我们将时间区间改了一下：<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-06-07-21-53-21.png" alt=""><br>这样做出于两种目的：一是尽量做到了线上线下统一，二是不让模型学习30号的样本数据，防止一些错误样本被模型学到。</li>
<li>用第一周统计，第二周做交叉验证并训练模型。如下图所示：<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-06-07-21-59-59.png" alt=""> </li>
</ol>
<p>相信很多人都用的是这两种其中的一种。我是一个对自己极度不自信的人，来来回回换了好几次。最终觉得第2种方式很稳定，线上线下较统一。第1种方式特征更新较快，模型更准确，但带来的问题就是线上线下不太统一。</p>
<h1 id="模型训练和验证">7. 模型训练和验证</h1><p>至此特征工程已经完毕，开始训练。</p>
<p>训练其实没什么好说的，只要注意一下别过拟合就可以。</p>
<p>初赛我们采用的xgboost，决赛用的lightgbm。其实都是对GBDT的实现，两者都很好，但lightGBM更快一些，因为它只对部分节点进行生长。</p>
<h2 id="stacking">7.1. stacking</h2><p>在初赛的时候听到最多的就是stacking魔法了。文章<a href="https://www.qcloud.com/community/article/895055" target="_blank" rel="external">【SPA大赛】腾讯广告点击大赛：对stacking的一些基本介绍</a>非常详细地介绍了stacking大法。我觉得这句话很好：“在我看来stacking严格来说不能称为一种算法，我理解的是一种非常精美而复杂的对模型的集成策略。”</p>
<h1 id="总结">8. 总结</h1><p>平时在学习的过程中，过于注重理论的推导，只是在一遍遍地看那些公式。但没有切身实践过，感受不到模型真正的威力和缺憾。通过这次比赛，还是收获比较多的。注意到了平时学习过程中自以为不重要的、很容易被忽略的细节。</p>
<p>在初赛中，我们其实并没有注重模型的调参等，而是一直在做特征工程。其实我初期也不知道究竟该怎么办。但JerryLin大神用他的言行教会我，特征决定了结果的上限，而模型只是在不断地逼近这个上限而已。只有得到了好的特征，才会拿到好的模型。</p>
<p>做了这么久的特征工程，最大的感想就是，只有认认真真、踏踏实实分析数据，才能得到好的特征。过度依赖算法在工业上是不可靠的。</p>
<p>越来越发现务实基础的必要性。比如LR中为什么要采用正则化项，为什么GBDT能有筛特征的功效，为什么树模型容易过拟合，为什么为什么……这些为什么直接决定了在遇到问题的时候能不能独立解决。而不能像我现在一样，分分钟心态爆炸，宛如一只无头的苍蝇。</p>
<p>还有就是，写代码一定要认认真真地写。不能直接把别人的直接粘过来用，这样是极其不负责的，也非常容易出错。在比赛的过程中，我的xgboost预测的代码是直接粘贴的O2O优惠券使用预测的冠军的代码，但他那个的目标是auc，因此他将结果映射到了（0,1）区间上。这句话让我白白浪费了很久很久的时间去试特征，结果发现线上线下不统一，整个人直接崩溃。</p>
<p>希望自己在未来的日子里，能将周志华老师的《机器学习》和李航老师的《统计学习方法》这两本书吃透，而不是像现在这样，狗熊掰棒子。</p>
<p>失败乃成功之母。</p>
<p>天行健，君子以自强不息。</p>
<h1 id="项目代码">9. 项目代码</h1><p><a href="https://github.com/zsyandjyhouse/TencentAD_contest" target="_blank" rel="external">TencentAD_contest</a></p>
<h1 id="参考文献">10. 参考文献</h1><ol>
<li><a href="https://zhuanlan.zhihu.com/p/26820998" target="_blank" rel="external">Kaggle 数据挖掘比赛经验分享</a></li>
<li><a href="http://blog.csdn.net/yang090510118/article/details/39478033" target="_blank" rel="external">逻辑回归LR的特征为什么要先离散化</a></li>
<li><a href="http://breezedeus.github.io/2014/11/20/breezedeus-feature-hashing.html" target="_blank" rel="external">特征哈希（Feature Hashing）</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/26945814" target="_blank" rel="external">机器学习中的维度灾难</a></li>
<li><a href="http://blog.jasonding.top/2015/11/12/Feature%20Engineering/%E3%80%90%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B%E3%80%91%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E4%B8%8E%E7%89%B9%E5%BE%81%E5%AD%A6%E4%B9%A0/" target="_blank" rel="external">【特征工程】特征选择与特征学习</a></li>
<li><a href="http://202.197.191.206:8080/30/text/chapter04/4_8.htm" target="_blank" rel="external">描述量选择及特征的组合优化</a></li>
<li><a href="http://www.jianshu.com/p/8f6f94f1d275" target="_blank" rel="external">scikit-learn系列之特征选择</a></li>
<li><a href="http://blog.csdn.net/shine19930820/article/details/71713680" target="_blank" rel="external">GBDT原理及利用GBDT构造新的特征-Python实现</a></li>
<li><a href="http://www.bigbear2017.com/blog/2016/11/02/facebook-ctr-paper/" target="_blank" rel="external">很好的文献资料Facebook CTR Paper</a></li>
<li><a href="https://github.com/z564808896/Tencent_Social_Ads" target="_blank" rel="external">竟然有这种操作队分享</a></li>
<li><a href="https://www.qcloud.com/community/article/895055" target="_blank" rel="external">【SPA大赛】腾讯广告点击大赛：对stacking的一些基本介绍</a></li>
<li><a href="http://blog.csdn.net/ben3ben/article/details/74838338" target="_blank" rel="external">第七名</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> 腾讯算法大赛-CVR预估 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[特征选择与正则化]]></title>
      <url>/2017/05/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E4%B8%8E%E6%AD%A3%E5%88%99%E5%8C%96/</url>
      <content type="html"><![CDATA[<p>特征选择：很重要</p>
<p><strong>tip:冗余特征(redundant feature)</strong>：</p>
<ul>
<li>本特征能被其它特征中推演出来。它不一定有坏处，但也不一定有好处。例如：考虑立方体对象，若已有特征“长”、“宽”，则“底面积”是冗余特征。</li>
<li>冗余特征在很多时候不起作用，会增加学习过程的负担。</li>
<li>但如果学习目标是估算立方体体积，则“底面积”特征会对学习更好。</li>
</ul>
<p>结论：如果某冗余特征恰好对应完成学习任务所需的“中间概念”，则该冗余特征是有益的。</p>
<h1 id="子集搜索与评价">1. 子集搜索与评价</h1><p>特征选取时，若没有任何领域知识进行先验假设，只能遍历所有可能子集。–&gt;不可取！</p>
<p><strong>可行做法</strong>:<br>产生个“候选子集”，评价它的好坏，基于评价结果产生下一个候选子集。</p>
<h2 id="问题一，如何评价结果获取下一个候选特征子集？">1.1. 问题一，如何评价结果获取下一个候选特征子集？</h2><p><strong>子集搜索</strong></p>
<ol>
<li>前向搜索</li>
</ol>
<ul>
<li>给定特征集合${a_1,a_2,…,a_d}$,将每个特征看做一个候选子集。对d个候选单特征子集进行评价，假定${a_2}$最优，将${a_2}$做为第一轮选定集；</li>
<li>加入一个新特征，构成包含两个特征的候选子集，假定在这$d-1$个候选两特征子集中${a_2,a_4}$最优，则将${a_2,a_4}$作为本轮选定集；</li>
<li>…</li>
<li>k+1轮时，不再更好，停止迭代</li>
</ul>
<ol>
<li>后向搜索<br>每次都删除掉一个特征</li>
</ol>
<h2 id="问题二，如何评价候选特征子集？">1.2. 问题二，如何评价候选特征子集？</h2><p><strong>信息增益</strong></p>
<ul>
<li>给定数据集$D$,假定$D$中第$i$类样本所占的比例为$p_i(i=1,2,…,|Y|)$.</li>
<li>假定所有样本属性均为离散型</li>
<li>对属性子集$A$,假定根据其取值将$D$分成了$V$个子集${D^1,D^2,…,D^V}$,每个子集中的样本在A上取值相同，则属性子集$A$的信息增益为：</li>
</ul>
<p>$$Gain(A)=Ent(D)-\sum_{v=1}^V\frac{|D^v|}{|D|}Ent(D^v)$$</p>
<p>其中信息熵定义为：</p>
<p>$$Ent(D)=-\sum_{k=1}^{|y|}p_klog_2p_k$$</p>
<p>信息增益$Gain(A)$越大，特征子集A包含的有助于分类的信息越多。</p>
<h2 id="总结">1.3. 总结</h2><p>特征选择方法=子集搜索+子集评价</p>
<p>常见特征选择方法：</p>
<ul>
<li>过滤式(filter)</li>
<li>包裹式(wrapper)</li>
<li>嵌入式(embedding)</li>
</ul>
<h1 id="过滤式选择-filter">2. 过滤式选择(filter)</h1><p>概念：先特征选择，再训练模型</p>
<p>特点：特征选择与模型学习无关</p>
<p>===来日填坑===</p>
<h1 id="包裹式选择">3. 包裹式选择</h1><p>概念：把最终将要使用的学习器的性能作为特征子集的评价准则</p>
<p>特点：需要多次训练学习器</p>
<p>===来日填坑===</p>
<h1 id="嵌入式选择与L1正则化">4. 嵌入式选择与L1正则化</h1><p>概念：将特征选择过程与学习器训练过程融为一体，两者在同一个优化过程中完成</p>
<p>给定数据集$D={(x_1,y_1),(x_2,y_2),…(x_m,y_m)}$,其中$x\in R^d,y\in R$.</p>
<p>考虑最简单的线性回归，以平方误差为损失函数，则优化目标为：</p>
<p>$$min_w\sum_{i=1}^m(y_i-w^Tx_i)^2$$</p>
<p>当样本特征很多，而样本数较少时，上式很容易陷入过拟合。解决方案，正则化项。</p>
<p>$L_2$范数正则化（“岭回归”(redge regression)）：</p>
<p>$$min_w\sum_{i=1}^m(y_i-w^Tx_i)^2+\lambda ||w||_2^2$$</p>
<p>$L_1$范数正则化：</p>
<p>$$min_w\sum_{i=1}^m(y_i-w^Tx_i)^2+\lambda ||w||_1$$</p>
<p>区别：$L_2$比$L_1$更容易获得“稀疏”(sparse)解，即它求得的$w$会有更少的非零分量。<br>（这里一定要看一下西瓜书-253页的解释）</p>
<h2 id="正则化的理解">4.1. 正则化的理解</h2><p>以以下的拟合为例：<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-05-30-18-21-29.png" alt=""> </p>
<p>在图二中，明显是因为高次项的系数$\theta_3,\theta_4$过大造成的。</p>
<p>因此我们加入正则化项：<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-05-30-18-24-26.png" alt=""> </p>
<p>即给目标函数加一点东西。</p>
<p>现在，如果我们要最小化这个函数，那么为了最小化这个新的代价函数，我们要让$θ3$和$θ4$尽可能小。因为，如果你在原有代价函数的基础上加上1000乘以$θ3$这一项，那么这个新的代价函数将变得很大，<strong>所以，当我们最小化这个新的代价函数时，我们将使$θ3$的值接近于0，同样$θ4$的值也接近于0，</strong>就像我们忽略了这两个值一样。如果我们做到这一点（$θ3$和$θ4$接近0），那么我们将得到一个近似的二次函数。</p>
<p>更一般地：</p>
<p>$L_2$范数正则化：</p>
<p>$$min_w\sum_{i=1}^m(y_i-w^Tx_i)^2+\lambda ||w||_2^2 $$<br>$$= min_w\sum_{i=1}^m(y_i-w^Tx_i)^2+\lambda\sqrt{\sum_{n=1}^nw_i^2}$$</p>
<p>(其中,m是数据个数，n是特征维度)<br>因此在正则化里，我们要做的事情，就是把减小我们的代价函数（例子中是线性回归的代价函数）所有的参数值，因为我们并不知道是哪一个或哪几个要去缩小。</p>
<p>因此，我们需要修改代价函数，在这后面添加一项，就像我们在方括号里的这项。当我们添加一个额外的正则化项的时候，我们收缩了每个参数。</p>
<p>$$ min_w\frac{1}{2m}[\sum_{i=1}^m(y_i-w^Tx_i)^2+\lambda\sqrt{\sum_{n=1}^nw_i^2}]$$</p>
<h1 id="参考文献">5. 参考文献</h1><ol>
<li><a href="http://www.cnblogs.com/jianxinzhou/p/4083921.html" target="_blank" rel="external">机器学习之正则化（Regularization）</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> 机器学习算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 特征工程 </tag>
            
            <tag> 正则化 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java-Buffer]]></title>
      <url>/2017/05/22/Java-Buffer/</url>
      <content type="html"><![CDATA[<p><strong>引言</strong></p>
<p>说到缓冲区，不得不提Java NIO。</p>
<p>Java NIO(New IO)是一个可以替代标准Java IO API的IO API（从Java 1.4开始)，Java NIO提供了与标准IO不同的IO工作方式。</p>
<p>Java NIO: Channels and Buffers（通道和缓冲区）</p>
<h1 id="什么是缓冲区">1. 什么是缓冲区</h1><p><strong>Buffer定义</strong></p>
<p>代码的角度来讲（可以查看JDK中Buffer、ByteBuffer、DoubleBuffer等的源码），Buffer类内部其实就是一个基本数据类型的数组，以及对这个缓冲数组的各种操作；</p>
<p>常见的缓冲区如ByteBuffer、IntBuffer、DoubleBuffer…内部对应的数组依次是byte、int、double…</p>
<p><strong>Buffer与通道的关系</strong></p>
<p>标准的IO基于字节流和字符流进行操作的，而NIO是基于通道（Channel）和缓冲区（Buffer）进行操作，数据总是<em>从通道读取到缓冲区中</em>，或者<em>从缓冲区写入到通道中</em>。</p>
<p><strong>继承结构</strong></p>
<p>以ByteBuffer为例：</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-05-22-20-31-24.png" alt=""> </p>
<p>Buffer是顶层抽象类，ByteBuffer继承Buffer，也是抽象类，ByteBuffer最常见的两个具体实现类如下：</p>
<p>DirectByteBuffer（JVM堆外部、通过unsafe.allocateMemory实现）、HeapByteBuffer（JVM堆）</p>
<p><strong>缓冲区用途</strong></p>
<p>写，然后读出</p>
<h1 id="缓冲区的四个属性">2. 缓冲区的四个属性</h1><ul>
<li><p>容量(capacity)<br>capacity指的是缓冲区能够容纳元素的最大数量，这个值在缓冲区创建时被设定，而且不能够改变，如下，我们创建了一个最大容量为10的字节缓冲区；</p>
<pre><code>ByteBuffer bf = ByteBuffer.allocate(10);
</code></pre></li>
<li><p>上界（limit）<br>limit指的是缓冲区中第一个不能读写的元素的数组下标索引，也可以认为是缓冲区中实际元素的数量；</p>
</li>
<li><p>位置（position）<br>position指的是下一个要被读写的元素的数组下标索引，该值会随get()和put()的调用自动更新；</p>
</li>
<li><p>标记（mark）<br>一个备忘位置，调用mark()方法的话，mark值将存储当前position的值，等下次调用reset()方法时，会设定position的值为之前的标记值；</p>
</li>
<li><p>四个属性值之间的关系<br>根据以上四个属性的定义，我们可以总结出它们之间的关系如下：<br>0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity</p>
</li>
</ul>
<h1 id="缓冲区调用一般步骤">3. 缓冲区调用一般步骤</h1><ol>
<li>写入数据到 Buffer</li>
<li>调用flip()方法</li>
<li>从 Buffer 中get()数据</li>
<li>调用clear()方法或者compact()方法</li>
</ol>
<h1 id="参考文献">4. 参考文献</h1><ol>
<li><a href="http://www.cnblogs.com/chenpi/p/6475510.html" target="_blank" rel="external">Java NIO中的缓冲区Buffer（一）缓冲区基础</a></li>
<li>[Java编程思想2]</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Buffer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[内存映射文件]]></title>
      <url>/2017/05/21/%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%AF%94%E8%B5%9B-%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>内存映射文件：利用虚拟内存实现将文件“映射”到内存中。文件对应于内存中的一个字节数组，对文件的操作变为对这个字节数组的操作，而字节数组的操作直接映射到文件上。这样这个文件就可以当做是一个内存数组一样的访问，这比传统的文件操作要快得多。</p>
<p>映射：<strong>硬盘上文件</strong>的位置与进程<strong>逻辑地址空间</strong>中一块大小相同的区域之间的一一对应</p>
<p>不过，这种映射是操作系统提供的一种假象，文件一般不会马上加载到内存，操作系统只是记录下了这回事，当实际发生读写时，才会按需加载。</p>
<p>这种按需加载的方式，使得内存映射文件可以方便处理非常大的文件，内存放不下整个文件也不要紧，操作系统会自动进行处理，将需要的内容读到内存，将修改的内容保存到硬盘，将不再使用的内存释放。</p>
<p>内存映射文件也有局限性，比如，它不太适合处理小文件，它是按页分配内存的，对于小文件，会浪费空间，另外，映射文件要消耗一定的操作系统资源，初始化比较慢。</p>
<h1 id="java使用内存映射">1. java使用内存映射</h1><h2 id="步骤">1.1. 步骤</h2><ul>
<li>引入java.nio包</li>
<li><p>从文件中获得一个通道(channel)。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FileChannel channel = FileChanne.open(path,options)</div></pre></td></tr></table></figure>
</li>
<li><p>通过调用FileChannel类的map方法从这个通道中获得一个ByteBuffer,它代表内存中的字节数组。其中，映射文件区域与映射模式支持三种方式：</p>
<h2 id="–-FileChannel-MapMode-READ-ONLY-缓冲区只读">1.2. – FileChannel.MapMode.READ_ONLY:缓冲区只读</h2><p>FileChannel.MapMode.READ_WRITE：可读写。任何缓冲区的修改都会写回文件（非立即）<br>– FileChannel.MapMode.PRIVATE：缓冲区可写，但修改不会传播到文件中</p>
</li>
</ul>
<p>映射完成后，文件就可以关闭了，后续对文件的读写可以通过MappedByteBuffer。</p>
<p>例：以读写模式映射文件”abc.dat”，代码可以为：</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(<span class="string">"abc.dat"</span>,<span class="string">"rw"</span>);</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    MappedByteBuffer buf = file.getChannel().map(MapMode.READ_WRITE, <span class="number">0</span>, file.length());</div><div class="line">    <span class="comment">//使用buf...</span></div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125;<span class="keyword">finally</span>&#123;</div><div class="line">    file.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><p>##　</p>
<h1 id="参考文献">2. 参考文献</h1><p>1.<a href="https://juejin.im/post/58626ac361ff4b006cf14faf" target="_blank" rel="external">计算机程序的思维逻辑 (61) - 内存映射文件及其应用 - 实现一个简单的消息队列</a><br>2.<a href="http://blog.csdn.net/king_is_everyone/article/details/28096583" target="_blank" rel="external">java流的性能优化2-内存映射文件</a></p>
]]></content>
      
        <categories>
            
            <category> 中间件比赛 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OpenMessaging源码阅读2-demo]]></title>
      <url>/2017/05/19/%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%AF%94%E8%B5%9B-OpenMessaging%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB2-demo/</url>
      <content type="html"><![CDATA[<h1 id="producer操作">1. producer操作</h1><p>tips:以下涉及到的代码是关键步骤代码。</p>
<ol>
<li><p>====================构造n个<strong>Topic</strong>和n个<strong>Queue</strong>====================</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">String topic1 = <span class="string">"TOPIC1"</span>; <span class="comment">//实际测试时大概会有100个Topic左右</span></div><div class="line">String queue2 = <span class="string">"QUEUE2"</span>; <span class="comment">//实际测试时，queue数目与消费线程数目相同</span></div><div class="line">List&lt;Message&gt; messagesForTopic1 = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">1024</span>);</div><div class="line">List&lt;Message&gt; messagesForQueue1 = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">1024</span>);</div></pre></td></tr></table></figure>
</li>
<li><p>====================向Topic和Queue中<strong>create</strong>数据====================</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">messagesForTopic1.add(producer.createBytesMessageToTopic(topic1,  (topic1 + i).getBytes()));</div></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>调用<code>producer</code>的<code>producer.createBytesMessageToTopic()</code>方法来创建<code>BytesMessage</code></li>
<li>将上一步产生的标准消息扔进messagesForTopic1中，即调用了每个<code>messagesForTopic1.add()</code>来向这个<code>Topic</code>中添加消息</li>
</ul>
<p>需要注意的是：</p>
<ul>
<li>messageFactory,而createBytesMessageToTopic()正是通过messageFactory.createBytesMessageToTopic(topic, body);来创建消息；</li>
<li>messageFactory.createBytesMessageToTopic(topic, body);仅仅只是将消息的body和header放入了一个defaultBytesMessage类型的消息中，并返回</li>
<li>每个producer对应一个messageStore<br><strong>总结：这一步将producer产生的数据放入消息列表messagesForTopic/Queue中</strong></li>
</ul>
<p>3.====================<strong>send</strong>数据====================</p>
<p>方式：</p>
<pre><code>producer.send(messagesForTopic1.get(i));
</code></pre><p>然后<code>send()</code>内部是：</p>
<pre><code>String topic = message.headers().getString(MessageHeader.TOPIC);
messageStore.putMessage(topic或queue, message);
</code></pre><p>需要注意的是：</p>
<ul>
<li>每个producer有一个messageStore，通过调用它的putMessage()来进行发送消息（将消息存储在硬盘中）</li>
<li>MessageStore类有一个成员变量<code>Map &lt;String, ArrayList&lt;Message&gt;&gt; messageBuckets</code>用来装消息，其中键是topic或queue的名字，值是new ArrayList&lt;&gt;(1024)(这里有一点疑问？)</li>
</ul>
<p>而putMessage：</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">putMessage</span><span class="params">(String bucket, Message message)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!messageBuckets.containsKey(bucket)) &#123;</div><div class="line">        messageBuckets.put(bucket, <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">1024</span>));</div><div class="line">    &#125;</div><div class="line">    ArrayList&lt;Message&gt; bucketList = messageBuckets.get(bucket);</div><div class="line">    bucketList.add(message);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><ul>
<li>如果本messageStore的messageBuckets没有本bucket(Topic或Queue)，则将这个buket加入到messageBuckets中,并使得其键值为new ArrayList&lt;&gt;(1024)</li>
<li>从本messageBuckets拿出(get)本bucket，放入消息列表bucketList中</li>
<li>再将本message加入消息列表bucketList</li>
</ul>
<p><strong>总结：将Topic或Queue放入MessageStore的messageBuckets中，将消息体放入bMessageStore的ucketList中</strong></p>
<h1 id="consumer操作">2. consumer操作</h1><ol>
<li>====================进行消息订阅<strong>attach</strong>====================</li>
</ol>
<p>操作：</p>
<pre><code>consumer1.attachQueue(queue1, Collections.singletonList(topic1));
</code></pre><p>备注：</p>
<ul>
<li>singletonList(T) 方法用于返回一个只包含指定对象的不可变列表</li>
</ul>
<p>然后DefaultPullConsumer的attachQueue如下：</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">attachQueue</span><span class="params">(String queueName, Collection&lt;String&gt; topics)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (queue != <span class="keyword">null</span> &amp;&amp; !queue.equals(queueName)) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClientOMSException(<span class="string">"You have alreadly attached to a queue "</span> + queue);</div><div class="line">    &#125;</div><div class="line">    queue = queueName;</div><div class="line">    buckets.add(queueName);</div><div class="line">    buckets.addAll(topics);</div><div class="line">    bucketList.clear();</div><div class="line">    bucketList.addAll(buckets);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><ul>
<li>buckets是DefaultPullConsumer的一个成员变量：private Set<string> buckets = new HashSet&lt;&gt;();</string></li>
<li>bucketList是DefaultPullConsumer的一个成员变量：private List<string> bucketList = new ArrayList&lt;&gt;();</string></li>
<li>将本queue以及其下的所有topic都加入到buckets中</li>
<li>将bukets都加入到bucketList中</li>
</ul>
<p>2.====================进行消息拉取<strong>pull</strong>====================</p>
<p>操作：</p>
<p>Message message = consumer1.poll();</p>
<p>其中，poll为：</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Message <span class="title">poll</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (buckets.size() == <span class="number">0</span> || queue == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//use Round Robin</span></div><div class="line">    <span class="keyword">int</span> checkNum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (++checkNum &lt;= bucketList.size()) &#123;</div><div class="line">        String bucket = bucketList.get((++lastIndex) % (bucketList.size()));</div><div class="line">        Message message = messageStore.pullMessage(queue, bucket);</div><div class="line">        <span class="keyword">if</span> (message != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> message;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><ul>
<li>遍历每个bucketList（bucketList装的是本consumer订阅的topics以及对应的queue）</li>
<li>对遍历到的每个bucket，从messageStore拉取消息</li>
</ul>
<p>而 messageStore.pullMessage为：</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Message <span class="title">pullMessage</span><span class="params">(String queue, String bucket)</span> </span>&#123;</div><div class="line">    ArrayList&lt;Message&gt; bucketList = messageBuckets.get(bucket);</div><div class="line">    <span class="keyword">if</span> (bucketList == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    HashMap&lt;String, Integer&gt; offsetMap = queueOffsets.get(queue);</div><div class="line">    <span class="keyword">if</span> (offsetMap == <span class="keyword">null</span>) &#123;</div><div class="line">        offsetMap = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        queueOffsets.put(queue, offsetMap);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> offset = offsetMap.getOrDefault(bucket, <span class="number">0</span>);</div><div class="line">    <span class="keyword">if</span> (offset &gt;= bucketList.size()) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    Message message = bucketList.get(offset);</div><div class="line">    offsetMap.put(bucket, ++offset);</div><div class="line">    <span class="keyword">return</span> message;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><ul>
<li>先从messageStore的messageBuckets中get到本bucket的bucketList</li>
<li>将这个consumer绑定的queue放入本messageStore的queueOffsets中</li>
<li>然后我就有点疑惑了？？</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 中间件比赛 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OpenMessaging </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RocketMQ简介]]></title>
      <url>/2017/05/17/%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%AF%94%E8%B5%9B-RocketMQ%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<p>RocketMQ:分布式开放消息系统</p>
<h1 id="消息中间件需要解决哪些问题？">1. 消息中间件需要解决哪些问题？</h1><h2 id="发布订阅（Publish-Subscribe）">1.1. 发布订阅（Publish/Subscribe）</h2><p>发布订阅是消息中间件的最基本功能，也是相对于传统RPC通信而言。在此不再详述。</p>
<h2 id="消息优先级（Message-Priority）">1.2. 消息优先级（Message Priority）</h2><p>两种方式：</p>
<ol>
<li>严格优先级，例如0-65535。开销大，精准，但可能没有必要。</li>
<li>档位优先级。高、中、低，或其他。每个优先级可以用不同的topic表示，发消息时，指定不同的topic来表示优先级。精确性低。</li>
</ol>
<h2 id="消息有序性（Message-Order）">1.3. 消息有序性（Message Order）</h2><ol>
<li>一个订单的发出的消息顺序不能变</li>
<li>订单之间是可以并行消费</li>
</ol>
<h2 id="消息过滤（Message-Filter）">1.4. 消息过滤（Message Filter）</h2><h3 id="消息协商器（Broker端）消息过滤">1.4.1. 消息协商器（Broker端）消息过滤</h3><p>在Broker中，按照Consumer的要求做过滤</p>
<ol>
<li>优点是减少了对于Consumer无用消息的网络传输。</li>
<li>缺点是增加了Broker的负担，实现相对复杂。</li>
</ol>
<p>淘宝Notify支持多种过滤方式：<br>包含直接按照消息类型过滤，灵活的语法表达式过滤，几乎可以满足最苛刻的过滤需求。</p>
<p>淘宝RocketMQ支持按照简单的Message Tag过滤，也支持按照Message Header、body进行过滤。</p>
<p>CORBA Notification规范中也支持灵活的语法表达式过滤。</p>
<h3 id="Consumer端消息过滤">1.4.2. Consumer端消息过滤</h3><p>这种过滤方式可由应用完全自定义实现，但是缺点是很多无用的消息要传输到Consumer端。</p>
<h3 id="消息持久化（Message-Persistence）">1.4.3. 消息持久化（Message Persistence）</h3><p>持久化（Persistence）：即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的主要应用是将内存中的对象存储在数据库中，或者存储在磁盘文件中、XML数据文件中等等。</p>
<p>消息中间件通常采用的几种持久化方式：</p>
<ol>
<li>持久化到数据库，例如Mysql。</li>
<li>持久化到KV存储，例如levelDB、伯克利DB等KV存储系统。</li>
<li>文件记录形式持久化，例如Kafka，RocketMQ</li>
<li>对内存数据做一个持久化镜像，例如beanstalkd，VisiNotify</li>
<li>(1)、(2)、(3)三种持久化方式都具有将内存队列Buffer进行扩展的能力，(4)只是一个内存的镜像，作用是当Broker挂掉重启后仍然能将之前内存的数据恢复出来。</li>
</ol>
<p>JMS与CORBA Notification规范没有明确说明如何持久化，但是持久化部分的性能直接决定了整个消息中间件的性能。</p>
<p>RocketMQ充分利用Linux文件系统内存cache来提高性能。</p>
<h3 id="消息可靠性（Message-Reliablity）">1.4.4. 消息可靠性（Message Reliablity）</h3><p>响消息可靠性的几种情况：</p>
<ol>
<li>Broker正常关闭</li>
<li>Broker异常Crash</li>
<li>OS Crash</li>
<li>机器掉电，但是能立即恢复供电情况。</li>
<li>机器无法开机（可能是cpu、主板、内存等关键设备损坏）</li>
<li>磁盘设备损坏</li>
</ol>
<p>(1)、(2)、(3)、(4)四种情况都属于硬件资源可立即恢复情况，RocketMQ在这四种情况下能保证消息不丢，或者丢失少量数据（依赖刷盘方式是同步还是异步）。</p>
<p>(5)、(6)属于单点故障，且无法恢复，一旦发生，在此单点上的消息全部丢失。RocketMQ在这两种情况下，通过异步复制，可保证99%的消息不丢，但是仍然会有极少量的消息可能丢失。通过同步双写技术可以完全避免单点，同步双写势必会影响性能，适合对消息可靠性要求极高的场合，例如与Money相关的应用。</p>
<p>RocketMQ从3.0版本开始支持同步双写。</p>
<h1 id="参考文献">2. 参考文献</h1><ol>
<li><a href="http://jm.taobao.org/2017/01/12/rocketmq-quick-start-in-10-minutes/" target="_blank" rel="external">十分钟入门RocketMQ</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> 中间件比赛 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> openMessaging </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[转化率预估资料]]></title>
      <url>/2017/05/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5-CVR-%E8%BD%AC%E5%8C%96%E7%8E%87%E9%A2%84%E4%BC%B0%E8%B5%84%E6%96%99/</url>
      <content type="html"><![CDATA[<ol>
<li><a href="http://www.flickering.cn/category/ads/" target="_blank" rel="external">火光摇曳</a></li>
<li><a href="http://tech.meituan.com/tag/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0" target="_blank" rel="external">美团点评技术团队</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> 腾讯算法大赛-CVR预估 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CVR预估 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[阿里中间件初赛-李健胜解决方案]]></title>
      <url>/2017/05/14/%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%AF%94%E8%B5%9B-%E6%9D%8E%E5%81%A5%E8%83%9C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      <content type="html"><![CDATA[<h1 id="参考资料">1. 参考资料</h1><ol>
<li><a href="http://blog.jesonlee.me/19/" target="_blank" rel="external">李健胜，阿里中间件大赛初赛解题思路</a></li>
<li><a href="https://github.com/Jesonlee1997/open-message" target="_blank" rel="external">1对应的代码</a></li>
</ol>
<h1 id="题目要求">2. 题目要求</h1><p><strong>主角</strong>：消息中间件<br><strong>目的</strong>：实现消息中间件的推拉模式。即生产者制造消息，使用消息队列储存消息，消费者从消息队列拉取消息。<br><strong>要点</strong>：持久化的消息队列</p>
<h2 id="Producer需要实现">2.1. Producer需要实现</h2><ul>
<li><p>创建一个消息，给消息指定Topic（可以由多个Consumer消费）<br><code>BytesMessage createBytesMessageToTopic(String topic, byte[] body);</code></p>
</li>
<li><p>创建一个消息，给消息指定Queue（只能由一个Consumer消费）<br><code>BytesMessage createBytesMessageToQueue(String queue, byte[] body);</code></p>
</li>
<li><p>发送消息，message中应当包含目的地（Queue，Topic只能选其一），对于发往同一个Topic和Queue的message顺序要保持一致。<br><code>void send(Message message);</code></p>
</li>
</ul>
<h2 id="PullConsumer需要实现">2.2. PullConsumer需要实现</h2><ul>
<li>绑定到一个Queue，并订阅topics，即从这些topic和Queue读取消息。<br><code>void attachQueue(String queueName, Collection topics);</code></li>
<li>规范要求实现阻塞的接口，由properties来设置阻塞时间，但本赛题不需要用到该特性， 请实现一个非阻塞(也即阻塞时间为0)调用, 也即没有消息则返回null<br><code>Message poll();</code></li>
</ul>
<h2 id="测试流程">2.3. 测试流程</h2><ul>
<li>创建<code>Topic</code>，创建<code>Queue</code> 创建<code>Producer</code>，多个<code>Producer</code>创建指定<code>Topic</code>和指定<code>Queue</code>的Message，调用<code>send</code>方法发送</li>
<li>将数据保存到磁盘中</li>
<li><code>kill Producer</code>进程，另取进程进行消费<br>创建<code>PullConsumer</code>线程进行消费，一个<code>Consumer</code>对应一个线程，<code>Consumer</code>连接到一个<code>Queue</code>，可以订阅多个<code>Topic</code>。 </li>
<li>不断的调用poll拉取队列的消息，直到完全读完，读取的消息要相对有序。</li>
</ul>
<p>补充：<br>一个<code>Producer</code>对应一个线程，线程先创建对应的Message，再将Message 发送到对应的队列或<code>topic</code>中，实际情况中会有多个<code>Producer</code>。 一个<code>Consumer</code>对应一个<code>Queue</code>，多个<code>Consumer</code>同时从队列中拉取消息。</p>
<h2 id="技术难点">2.4. 技术难点</h2><ol>
<li>大量的消息产生 </li>
<li>并发写 </li>
<li>并发读 </li>
<li>序列化&amp;反序列化</li>
</ol>
<ol>
<li>大量消息<br>首先根据题目描述，Produce过程会运行5分钟，这个过程中多线程进行消息的发送，然后再考虑将消息持久化。我用自己的程序测试了一下，（不是典型值，只作为参考，在文章的最后我会贴上我的一系列测试结果），多线程发送一亿条消息的时间为27s，而这一亿条消息占据磁盘的大小为将近4G！可以想象在5分钟内会产生多少的消息量，如何将消息存储，如何读取消息都将成为一个非常棘手的问题。</li>
<li>并发写<br>并发写的问题也非常显而易见。我们一般情况下为了实现消息队列会选择使用一个List或数组来存储Producer产生的消息。这就引发了一个问题，怎样保证向同一个队列中发送消息的线程不产生竞争条件。</li>
<li>并发读<br>最麻烦的一个部分，每个线程都需要读取磁盘上的消息内容，每个线程读取的位置又不尽相同，消息数又那么多不可能全部加载到内存中，这个问题曾让我伤透了脑筋，直到我遇到了mmap(后面详细介绍)。</li>
<li>序列化和反序列化的问题<br>大赛刚开始时，我写了一个使用Java自身序列化来实现持久化的版本，这个版本的缺点非常显而易见，就是慢，而这个缺点又是极为致命的。我意识到我需要自己定制一个序列化协议来将消息转化为字节数组，再通过其他方式（如FileOutputStream）写入磁盘，同时再使用这个协议将其从磁盘中恢复。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 中间件比赛 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OpenMessaging </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OpenMessaging源码阅读1]]></title>
      <url>/2017/05/13/%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%AF%94%E8%B5%9B-OpenMessaging%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB1/</url>
      <content type="html"><![CDATA[<p>考虑到自己记性实在太差，还是好好记笔记吧。<br>本节主要看以下几个接口：</p>
<ul>
<li>Meaasage</li>
<li>Producer</li>
<li>PullConsumer</li>
</ul>
<h1 id="Message-java">1. Message.java</h1><p>Message接口是所有OMS消息中的根接口。最常用的消息就是BytesMessage。</p>
<p><strong>标准Message</strong><br>大多消息导向（message-oriented）的中间件（MOM）产品更趋向于将消息认做轻实体，这个轻实体包含一个header和一个body：</p>
<ul>
<li>header:包含用来路由和识别的信息域；</li>
<li>body:包含将会被发送的应用信息；</li>
</ul>
<p><strong>本Message</strong><br>本消息是一个仅包含与具体消息对象相关的property(财产)的轻量级实体。主要包含以下几个方面：</p>
<ul>
<li>Header:所有消息都有同样的header域。header域的值用来给客户端(clients)和提供商（providers）唯一标示消息，以及路由消息。</li>
<li>Properties(财产，特性)：每个消息都有一个消息自有的部分，这部分用来提供“应用定义(application-defined)”的property(财产)值。这一部分为支持“应用定义”消息的过滤提供了很有效的机制。</li>
</ul>
<p><strong>源码解读</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Message</span> </span>&#123;</div><div class="line">     <span class="comment">/*headers()返回Message对象的header域，返回值类型是keyValue。*/</span></div><div class="line">    <span class="function">KeyValue <span class="title">headers</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/*properties()返回消息自有的property域。返回值类型是keyValue。*/</span></div><div class="line">    <span class="function">KeyValue <span class="title">properties</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">     <span class="comment">/*putHeaders(String key, int value)将输入(String key, int value)全部传入header*/</span></div><div class="line">    <span class="comment">/*参数key:headers的关键字*/</span></div><div class="line">    <span class="comment">/*参数values:与key对应的值*/</span></div><div class="line">    <span class="function">Message <span class="title">putHeaders</span><span class="params">(String key, <span class="keyword">int</span> value)</span></span>;</div><div class="line">    <span class="function">Message <span class="title">putHeaders</span><span class="params">(String key, <span class="keyword">long</span> value)</span></span>;</div><div class="line">    <span class="function">Message <span class="title">putHeaders</span><span class="params">(String key, <span class="keyword">double</span> value)</span></span>;</div><div class="line">    <span class="function">Message <span class="title">putHeaders</span><span class="params">(String key, String value)</span></span>;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/*将key和value全部存入header*/</span></div><div class="line">    <span class="comment">/*参数key:headers的关键字*/</span></div><div class="line">    <span class="comment">/*参数values:与key对应的值*/</span></div><div class="line">    <span class="function">Message <span class="title">putProperties</span><span class="params">(String key, <span class="keyword">int</span> value)</span></span>;</div><div class="line">    <span class="function">Message <span class="title">putProperties</span><span class="params">(String key, <span class="keyword">long</span> value)</span></span>;</div><div class="line">    <span class="function">Message <span class="title">putProperties</span><span class="params">(String key, <span class="keyword">double</span> value)</span></span>;</div><div class="line">    <span class="function">Message <span class="title">putProperties</span><span class="params">(String key, String value)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Producer-java">2. Producer.java</h1><p>Producer是一个用来发送消息的简单对象，它是<code>MessagingAccessPoint</code>的一个具体实现。<br><strong>创建Producer对象</strong>：<br><code>Producer</code>的具体实例是通过<code>MessagingAccessPoint#createProducer()</code>方法创建的。<br>这个方法提供了多种定点发送消息的方式，其中，目的地可以是<code>MessageHeader#TOPIC</code>或<code>MessageHeader#QUEUE</code>。</p>
<p><strong>Producer#send(Message)</strong><br>同步定点发送消息方法。<br>当发送请求完成时，线程将会关闭(block)。</p>
<p><strong>Producer#sendAsync(Message)</strong><br>异步定点发送消息方法。<br>当发送请求完成时，线程不会很快关闭，而会立即返回一个<code>Promise</code>作为发送结果。</p>
<p><strong>Producer#sendOneway(Message)</strong><br>one way定点发送消息方法。<br>当发送请求完成时，线程不会很快关闭，而是立即返回。线程发起者不关心发送结果，同时server也对返回值没有责任。</p>
<p><strong>源码解读</strong></p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">MessageFactory</span>, <span class="title">ServiceLifecycle</span> </span>&#123;</div><div class="line">     <span class="comment">/*返回本实例的properties*/</span></div><div class="line">     <span class="comment">/*返回值的变化不会反应在Producer本身上，并且这个变化可以用ResourceManager#setProducerProperties(String, KeyValue)来修改。（Changes to the return &#123;@code KeyValue&#125; are not reflected in physical &#123;@code Producer&#125;,and use &#123;@link ResourceManager#setProducerProperties(String, KeyValue)&#125; to modify.）*/</span></div><div class="line">    <span class="function">KeyValue <span class="title">properties</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/*同步定点发送message方法*/</span></div><div class="line">    <span class="comment">/*发送目的地应该预置在MessageHeader中。当然其它类型的header域也可以*/</span></div><div class="line">    <span class="comment">/*异常OMSRuntimeException：当由于内部原因发送失败时*/</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(Message message)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(Message message, KeyValue properties)</span></span>;<span class="comment">/*properties是属性值*/</span></div><div class="line"></div><div class="line">    <span class="comment">/*异步定点发送消息方法*/</span></div><div class="line">    <span class="comment">/*返回值是Promise类型。同时，登记过的PromiseListener将会被通知*/</span></div><div class="line">    <span class="function">Promise&lt;Void&gt; <span class="title">sendAsync</span><span class="params">(Message message)</span></span>;</div><div class="line">    <span class="function">Promise&lt;Void&gt; <span class="title">sendAsync</span><span class="params">(Message message, KeyValue properties)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/*oneway定点发送消息方法*/</span></div><div class="line">    <span class="comment">/*无返回值，也没有thrown。因为oneway发送不在乎发送结果*/</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendOneway</span><span class="params">(Message message)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendOneway</span><span class="params">(Message message, KeyValue properties)</span></span>;</div><div class="line"></div><div class="line">    <span class="function">BatchToPartition <span class="title">createBatchToPartition</span><span class="params">(String partitionName)</span></span>;</div><div class="line"></div><div class="line">    <span class="function">BatchToPartition <span class="title">createBatchToPartition</span><span class="params">(String partitionName, KeyValue properties)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h1 id="PullConsumer-java">3. PullConsumer.java</h1><p><code>PullConsumer</code>对象能从特定的队列中poll消息。而且支持通过‘ack’方式提交消费结果。</p>
<p><strong>源码分析</strong></p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PullConsumer</span> </span>&#123;</div><div class="line">    <span class="comment">/*返回本PullConsumer实例的properties*/</span></div><div class="line">    <span class="comment">/* Changes to the return &#123;@code KeyValue&#125; are not reflected in physical &#123;@code PullConsumer&#125;,and use &#123;@link ResourceManager#setConsumerProperties(String, KeyValue)&#125; to modify.*/</span></div><div class="line">    <span class="function">KeyValue <span class="title">properties</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 规范要求实现阻塞的接口，由properties来设置阻塞时间，但本赛题不需要用到该特性，请实现一个非阻塞(也即阻塞时间为0)调用, 也即没有消息则返回null</div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="comment">/*抽取下一条为本pullconsumer生产的消息*/</span></div><div class="line">    <span class="comment">/*除非一条消息被产生了，或者本pullConsumer被关闭了，本调用会一直block*/</span></div><div class="line">    <span class="comment">/*返回为本PullConsumer生产的下一条消息；当本PullConsumer被同时关闭时返回null*/</span></div><div class="line">    <span class="comment">/*当本PullConsumer由于一些内部原因而抽取下一条消息失败时，throw OMSRuntimeException*/</span></div><div class="line">    <span class="function">Message <span class="title">poll</span><span class="params">()</span></span>;</div><div class="line">    <span class="function">Message <span class="title">poll</span><span class="params">(<span class="keyword">final</span> KeyValue properties)</span></span>;<span class="comment">/*properties是一些参数*/</span></div><div class="line"></div><div class="line">    <span class="comment">/*用消息id回确认指定的已消费的消息*/</span></div><div class="line">    <span class="comment">/*若某消息已被接收，但还未被回确认，那它可能会被重新投递*/</span></div><div class="line">    <span class="comment">/*有OMSRuntimeException*/</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ack</span><span class="params">(String messageId)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ack</span><span class="params">(String messageId, <span class="keyword">final</span> KeyValue properties)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/* 绑定到一个Queue，并订阅topics，即从这些topic读取消息*/</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">attachQueue</span><span class="params">(String queueName, Collection&lt;String&gt; topics)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre>]]></content>
      
        <categories>
            
            <category> 中间件比赛 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OpenMessaging </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[多线程]]></title>
      <url>/2017/05/12/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p><strong>线程(thread)</strong>：每个任务称为一个线程<br><strong>线程和进程区别</strong>：</p>
<ol>
<li>每个进程有自己独立的变量，而线程则共享数据。</li>
<li>线程是进程的执行单元</li>
<li>线程是进程的组成部分。一个进程可以有多个线程，一个线程必须有一个父进程。</li>
<li>线程可以拥有自己的堆栈、自己的程序计数器和自己的局部变量，但不拥有系统资源（与父进程其它线程共享该进程则资源）</li>
</ol>
<h1 id="线程的创建">1. 线程的创建</h1><p>有以下两种方法：</p>
<ol>
<li>通过继承Thread来创建线程</li>
<li>通过实现Runnable接口创建线程</li>
</ol>
<h2 id="通过继承Thread来创建线程">1.1. 通过继承Thread来创建线程</h2><p>要点：通过继承<code>Thread</code>类创建并启动多线程<br>步骤：</p>
<ol>
<li>定义Thread类的子类，并重写<code>run()</code>方法（线程执行体）</li>
<li>创建<code>Thread</code>子类的实例(创建线程对象)</li>
<li><p>调用<code>start()</code>（启用该线程）</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"run\t"</span>+getName()+<span class="string">"\t"</span>);<span class="comment">//getName()返回thread name</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        <span class="keyword">new</span> FirstThread().start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>以上代码输出：</p>
<pre><code>run  Thread-0
</code></pre><p><strong>一个有意思的现象</strong></p>
<p>运行如下代码时：</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"run\t"</span>+getName()+<span class="string">"\t"</span>);<span class="comment">//getName()返回thread name</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        <span class="comment">//调用currentThread()获取当前线程</span></div><div class="line">        System.out.println(<span class="string">"currentThread : "</span>+Thread.currentThread().getName());</div><div class="line">        <span class="keyword">new</span> FirstThread().start();</div><div class="line">        System.out.println(<span class="string">"currentThread : "</span>+Thread.currentThread().getName());</div><div class="line">        <span class="keyword">new</span> FirstThread().start();</div><div class="line">        System.out.println(<span class="string">"currentThread : "</span>+Thread.currentThread().getName());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><p>按照以前的理解，应该是：</p>
<pre><code>currentThread : main
run Thread-0 
currentThread : main 
run Thread-1    
currentThread : main
</code></pre><p>实际输出：（也有可能是其它顺序）</p>
<pre><code>currentThread : main
currentThread : main
run Thread-0    
run Thread-1    
currentThread : main
</code></pre><p>新发现：其实<code>start</code>一个线程的时候，<code>main</code>线程在继续运行。<code>main</code>线程不会等<code>start</code>完事儿之后再运行下一句！</p>
<h2 id="通过实现Runnable接口创建线程">1.2. 通过实现Runnable接口创建线程</h2><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"run\t"</span>+Thread.currentThread().getName()+<span class="string">"\t"</span>);<span class="comment">//getName()返回thread name</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        SecondThread st = <span class="keyword">new</span> SecondThread();</div><div class="line">        <span class="keyword">new</span> Thread(st,<span class="string">"new_thread_1"</span>).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><p>区别：<br>需要通过<code>Thread.currentThread().getName()</code>来获取getName()<br>main不同</p>
<p><strong>多线程共享变量</strong></p>
<p>以下是一个多线程共享变量<code>i</code>的情况：</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">while</span>(i&lt;<span class="number">5</span>)&#123;</div><div class="line">            System.out.println(<span class="string">"run\t"</span>+Thread.currentThread().getName()+<span class="string">"\t"</span>+i);<span class="comment">//getName()返回thread name</span></div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        SecondThread st = <span class="keyword">new</span> SecondThread();</div><div class="line">        <span class="keyword">new</span> Thread(st,<span class="string">"thread_name_1"</span>).start();</div><div class="line">        <span class="keyword">new</span> Thread(st,<span class="string">"thread_name_2"</span>).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><p>两次运行结果：</p>
<pre><code>run thread_name_1    0
run thread_name_1    1
run thread_name_1    2
run thread_name_1    3
run thread_name_2    3
run thread_name_1    4

run thread_name_1    0
run thread_name_2    0
run thread_name_1    1
run thread_name_2    2
run thread_name_1    3
run thread_name_2    4
</code></pre><p><strong>发现</strong>：</p>
<ol>
<li>两个线程共有变量<code>i</code></li>
<li>线程间抢占资源</li>
</ol>
<h2 id="使用Callable和Future创建线程">1.3. 使用Callable和Future创建线程</h2>]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OpenMessaging简介]]></title>
      <url>/2017/05/11/%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%AF%94%E8%B5%9B-OpenMessaging%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<p>OpenMessaging的主要关系如下图所示：</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-05-12-16-24-52.png" alt=""> </p>
<p>其中，各部分的内容和关系见下述。</p>
<h1 id="Namespace">1. Namespace</h1><p>Namespace就像一个cgroup namespace,是用来创建一个有安全保障的独立的空间。每个namespace都有自己的producer,consumer,topic,queue等等。OpenMessaging用 ​<strong>MessagingAccessPoint</strong>​（消息访问点）来访问/读/写指定namespace的<strong>​资源</strong>​。</p>
<h1 id="Producer">2. Producer</h1><p>Openmessaging定义了两种Producer:<strong>​Producer</strong>​和 <strong>​SequenceProducer</strong>​</p>
<ul>
<li><strong>​Producer</strong>​:提供各种send方法，用来将一个消息送往指定的destination,<strong>Topic</strong>或者<strong>Queue</strong>。支持三种方式：同步、异步、单向(oneway)</li>
<li><strong>SequenceProducer</strong>:重点在于速度，且支持批处理。能发送多个数据并一次提交。</li>
</ul>
<h1 id="Consumer">3. Consumer</h1><p>Openmessaging定义了两种Consumer::<strong>PullConsumer</strong>、<strong>PushConsumer</strong>和<strong>StreamConsumer</strong>.每种Consumer仅支持来自于<strong>Queue</strong>的consume消息。</p>
<ul>
<li><strong>PullConsumer</strong>:从指定队列中pulls消息。支持“submit the consume<br>result by acknowledgement at any time”。每个PullConsumer仅能从固定的队列中pull消息。</li>
<li><strong>PushConsumer</strong>:可从多个队列中接收消息，且这个消息是由MOM server push上去的。PushConsumer可依附于多个独立的、具有不同的MessageListener的队列，并且可以随时通过<strong>ReceivedMessageContext</strong>提交结果。</li>
<li><strong>StreamingConsumer</strong>:一种崭新的consumer类型，是一种面向流的consumer,面向留信息的一体化信息系统。</li>
</ul>
<h1 id="Topic-Queue-and-Routing">4. Topic Queue and Routing</h1><p>这三个概念非常相近。虽然Topic和Queue有不同的用途，但它们总让人迷惑。</p>
<h2 id="Topic">4.1. Topic</h2><p>Topic是原始信息的载体，用来holding消息。消息的分发方式和有序性是没有定义的。</p>
<h2 id="Routing">4.2. Routing</h2><p>Topic中的消息是原始的，是待处理的，一般不易引起consumers的注意。总之，Topic中的数据是producer-orented（导向）的，而不是consumer-oriented。</p>
<p>因此Routing负责加工Topic中的原始消息，并routing去Queue中。每个Routing有一个<strong>操作管线（operator pipeline）</strong>，包含着一系列的操作。消息会通过操作管线从Topic流向Queue。</p>
<p><strong>操作（operator）</strong>是用来处理在Routing流通的消息的。有很多操作，例如expression operator, deduplicator operator, joiner operator, filter operator, rpc<br>operator等等。</p>
<h2 id="Queue-队列">4.3. Queue(队列)</h2><p>现在消息已经被routed到Queue中了。现在消息就可以被consumers使用了。</p>
<p>需要注意的是，一个Queue可能会被分为几部分，消息可能通过MessageHeader#SHARDING_KEY被routed到某个特殊的部分中。</p>
<h2 id="Topic与Queue比较">4.4. Topic与Queue比较</h2><ul>
<li>都是消息的载体</li>
<li>Topic是preducer-oriented的，而Queue是consumer-oriented的</li>
<li>Topic中的消息来自于Producer,而Queue中的消息来自于Topic或者Producer</li>
<li>Queue包含几个部分，而Topic形状未定义</li>
<li>在大多数情况下，Queue是Topic的一个子集</li>
<li>Queue的创建、销毁都很容易，且与producer无关</li>
</ul>
<h1 id="参考文献">5. 参考文献</h1><ol>
<li><a href="openmessaging.github.io">原始文档</a></li>
<li><a href="https://github.com/pugwoo/c/blob/master/linux_ipc/shm/shmqueue.h" target="_blank" rel="external">pugwoo用c写的</a></li>
<li><a href="https://github.com/openmessaging/openmessaging" target="_blank" rel="external">原始文档扒的API</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> 中间件比赛 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OpenMessaging </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[中间件入门]]></title>
      <url>/2017/05/11/%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%AF%94%E8%B5%9B-%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<h1 id="中间件概念">1. 中间件概念</h1><p><strong>中间件</strong>：处于操作系统和应用程序之间的软件。</p>
<p>中间件简单解释，可以理解为面向信息系统交互，集成过程中的通用部分的集合，屏蔽了底层的通讯，交互，连接等复杂又通用化的功能，以产品的形式提供出来，系统在交互时，直接采用中间件进行连接和交互即可，避免了大量的代码开发和人工成本。</p>
<p>其实，理论上来讲，中间件所提供的功能通过代码编写都可以实现，只不过开发的周期和需要考虑的问题太多，逐渐的，这些部分，以中间件产品的形式进行了替代。</p>
<p>比如常见的消息中间件，即系统之间的通讯与交互的专用通道，类似于邮局，系统只需要把传输的消息交给中间件，由中间件负责传递，并保证传输过程中的各类问题，如网络问题，协议问题，两端的开发接口问题等均由消息中间件屏蔽了，出现了网络故障时，消息中间件会负责缓存消息，以避免信息丢失。相当于你想给美国发一个邮包，只需要把邮包交给邮局，填写地址和收件人，至于运送过程中的一系列问题你都不需要关心了。</p>
<h1 id="中间件分类">2. 中间件分类</h1><ol>
<li>消息中间件（MOM：Message-Oriented Middleware）</li>
<li>数据中间件（Database Middleware）</li>
<li>远程过程调用中间件（RPC：Remote Process Call）</li>
<li>对象请求代理中间件（ORB：Object Request Broker）</li>
<li>事务处理中间件（TP Monitor：Transaction Process Monitor）</li>
<li>J2EE中间件</li>
</ol>
<h1 id="Open-Messaging">3. Open-Messaging</h1><p>是一个建立行业内的指引和消息的协议（charter）。它的streaming规范提供了一个可用于电子商务、物联网和大数据的基础框架。它的主要目标是建立一个在分布式异构环境中面向云、简单、灵活和独立于语言的环境。协议的一致性似的它可以跨平台开发异构消息应用程序。</p>
<p><strong>域结构</strong><br><img src="http://om1bxijvl.bkt.clouddn.com/2017-05-11-17-16-52.png" alt=""> </p>
<h1 id="消息中间件-Message-Queue">4. 消息中间件 Message Queue</h1><p>Message Queue是一种应用程序对应用程序的通信方法。程序之间通过在消息中发送数据进行通信，而不是通过直接调用彼此来通信，直接调用通常是用于诸如远程过程调用的技术。排队指的是应用程序通过队列来通信。队列的使用除去了接收和发送应用程序同时执行的要求。</p>
<p>提及消息中间件的时候，还会涉及生产者和消费者两个概念。消息中间件是负责接收来自生产者的消息，并存储并转发给对应的消费者，生产者可以按 topic 发布各样消息，消费者也可以按 topic 订阅各样消息。生产者只管往消息队列里推送消息，不用等待消费者的回应；消费者只管从消息队列中取出数据并处理，可用可靠性等问题都交由消息中间件来负责。<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-05-12-15-43-09.png" alt=""><br>生产者和消费者通常有两种对应关系，一个生产者对应一个消费者，以及一个生产者对应多个消费者。</p>
<h1 id="参考文献">5. 参考文献</h1><p>1.<a href="https://www.zhihu.com/question/19730582/answer/16390709" target="_blank" rel="external">知乎FireJones的回答</a><br>2.<a href="http://wiki.jikexueyuan.com/project/redis/middleware.html" target="_blank" rel="external">极客学院，消息中间件</a></p>
]]></content>
      
        <categories>
            
            <category> 中间件比赛 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OpenMessaging </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[pandas相关技巧]]></title>
      <url>/2017/05/04/Python-pandas%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h1 id="用pandas求差集">1. 用pandas求差集</h1><p>从df1中去除掉df2的内容</p>
<p>data={‘id’:[1,2,3]}<br>data2={‘id’:[3,1,4]}<br>df1=pd.DataFrame(data)<br>df2=pd.DataFrame(data2)<br>print df1<br>print df2<br>df3=df1[~df1[‘id’].isin(df2[‘id’])]<br>print df3</p>
<h1 id="求某个时间区间的数据集">2. 求某个时间区间的数据集</h1><p>tart_t=’2016-04-05 00:00:00’<br>end_t=’2016-04-16 00:00:00’<br>action.time=pd.to_datetime(action.time,format=’%Y-%m-%d %H:%M:%S’)<br>starttime=pd.to_datetime(start_t,format=’%Y-%m-%d %H:%M:%S’)<br>endtime=pd.to_datetime(end_t,format=’%Y-%m-%d %H:%M:%S’)<br>action=action[(action.time<endtime)&(action.time>=starttime)]</endtime)&(action.time></p>
<h1 id="dummies">3. dummies</h1><p>我理解get_dummies是将拥有不同值的变量转换为0/1数值。打个比方，小明有黄、红、蓝三种颜色的帽子，小明今天戴黄色帽子用1表示，红色帽子用2表示，蓝色帽子用3表示。但1、2、3数值大小本身是没有意义的，只是用于区分帽子的颜色，因此在实际分析时，需要将1、2、3转化为0、1，如下代码所示：</p>
<pre><code>import pandas as pd
xiaoming=pd.DataFrame([1,2,3],index=[&apos;yellow&apos;,&apos;red&apos;,&apos;blue&apos;],columns=[&apos;hat&apos;])
print(xiaoming)
hat_ranks=pd.get_dummies(xiaoming[&apos;hat&apos;],prefix=&apos;hat&apos;)
print(hat_ranks.head())

            hat
yellow    1
red       2
blue      3
        hat_1  hat_2  hat_3
yellow      1      0      0
red         0      1      0
blue        0      0      1
</code></pre><h1 id="其它to-DataFrame">4. 其它to DataFrame</h1><h2 id="dict-to-DataFrame">4.1. dict to DataFrame</h2><pre><code>pd.DataFrame(d.items())
</code></pre><h1 id="fillna">5. fillna</h1><h2 id="用同组的均值填补">5.1. 用同组的均值填补</h2><pre><code>&gt;&gt;&gt; df
  name  value
0    A      1
1    A    NaN
2    B    NaN
3    B      2
4    B      3
5    B      1
6    C      3
7    C    NaN
8    C      3
&gt;&gt;&gt; df[&quot;value&quot;] = df.groupby(&quot;name&quot;).transform(lambda x: x.fillna(x.mean()))
&gt;&gt;&gt; df
  name  value
0    A      1
1    A      1
2    B      2
3    B      2
4    B      3
5    B      1
6    C      3
7    C      3
8    C      3
</code></pre><h1 id="ipython运行python">6. ipython运行python</h1><p>启动新的namespace运行： %run main.py</p>
<p>在原有的namespace运行：%run -i main.py</p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[python——os模块]]></title>
      <url>/2017/05/04/Python-os%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<h1 id="os模块">1. os模块</h1><p>os模块的作用：</p>
<p>　　os，语义为操作系统，所以肯定就是操作系统相关的功能了，可以处理文件和目录这些我们日常手动需要做的操作，就比如说：显示当前目录下所有文件/删除某个文件/获取文件大小……</p>
<p>　　另外，os模块不受平台限制，也就是说：当我们要在linux中显示当前命令时就要用到pwd命令，而Windows中cmd命令行下就要用到这个，额…我擦，我还真不知道，（甭管怎么着，肯定不是pwd），这时候我们使用python中os模块的os.path.abspath(name)功能，甭管是linux或者Windows都可以获取当前的绝对路径。</p>
<h1 id="文件夹操作">2. 文件夹操作</h1><h2 id="检验文件夹是否存在">2.1. 检验文件夹是否存在</h2><pre><code>os.path.exists(directory)
</code></pre><h2 id="创建文件夹">2.2. 创建文件夹</h2><pre><code>os.makedirs(directory)
</code></pre><p>实例：<br>检验文件夹是否存在，若不存在，则创建之</p>
<pre><code><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_dir</span><span class="params">(directory)</span>:</span></div><div class="line">    flag=os.path.exists(directory)</div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> flag:</div><div class="line">        os.makedirs(directory)</div></pre></td></tr></table></figure>
</code></pre><h2 id="遍历指定目录名，显示目录下所有文件">2.3. 遍历指定目录名，显示目录下所有文件</h2><pre><code><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pathDir =  os.listdir(filepath)</div><div class="line">    <span class="keyword">for</span> allDir <span class="keyword">in</span> pathDir:</div><div class="line">        <span class="keyword">print</span> allDir</div></pre></td></tr></table></figure>
</code></pre><h1 id="参考文献">3. 参考文献</h1><ol>
<li><a href="http://www.cnblogs.com/MnCu8261/p/5483657.html" target="_blank" rel="external">python基础之模块之os模块</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[java学习笔记3-Object（equal/hashCode/toString）]]></title>
      <url>/2017/05/04/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-Object/</url>
      <content type="html"><![CDATA[<h1 id="Object特性">1. Object特性</h1><ul>
<li>所有类的超类</li>
<li>可以引用任何对象</li>
</ul>
<h1 id="equals方法">2. equals方法</h1><p><code>Object</code>类中的<code>equals</code>方法判断两对象是否有相同的<strong>引用</strong></p>
<h2 id="equals的重写">2.1. equals的重写</h2><p>在实际coding中，一般我们都会对<code>equals</code>方法进行重写，例:</p>
<ol>
<li><p>对于超类<code>Employee</code>：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object otherObject)</span></span>&#123;</div><div class="line">        <span class="comment">//如果otherObject与this是同一个引用</span></div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> == therObject) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"></div><div class="line">        <span class="comment">//如果therObject为空</span></div><div class="line">        <span class="keyword">if</span>(therObject == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        <span class="comment">//如果类型不同</span></div><div class="line">        <span class="keyword">if</span>(getClass() != otherObject.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        <span class="comment">//现在我们已经确认了otherObject是一个非空的Employee对象</span></div><div class="line">        <span class="comment">//为了比较实例域，我们将otherObject转换为Employee类型</span></div><div class="line">        Employee other = (Employee) otherObject</div><div class="line"></div><div class="line">        <span class="comment">//检测实例域是否相等</span></div><div class="line">        <span class="keyword">return</span> name.equals(other.name)</div><div class="line">            &amp;&amp; salary == other.salary</div><div class="line">            &amp;&amp; hireDay.equals(other.hireDay);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 为了防止<code>this.name</code>或<code>this.hireDay</code>可能为<code>null</code>的情况，将最后一句改为：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> Obejcts.equals(name,other.name)</div><div class="line">    &amp;&amp; salary == other.salary</div><div class="line">    &amp;&amp; Objects.equals(hireDay,other.hireDay);</div></pre></td></tr></table></figure>
<p> <strong><code>Obejcts.equals(a,b)</code>运行过程</strong>：</p>
<ul>
<li>如果<code>a</code>和<code>b</code>都为<code>null</code>，则返回true</li>
<li>如果其中一个为<code>null</code>，返回false</li>
<li>如果都不为<code>null</code>，则调用<code>a.equals(b)</code></li>
</ul>
</li>
<li><p>对于<code>Employee</code>的子类<code>Manager</code></p>
</li>
</ol>
<p>在子类中定义<code>euqals</code>方法时，要首先调用超类的euqals，然后比较子类中的实例域。</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span></span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object otherObject)</span></span>&#123;</div><div class="line">        <span class="comment">//先调用超类的equals方法，检验this与otherObject是否属于同一class</span></div><div class="line">        <span class="keyword">if</span>(!<span class="keyword">super</span>.equals(otherObject)) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        Manager other = (Manager) otherObejct;</div><div class="line">        <span class="keyword">return</span> bonus == other.bonus</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h2 id="equals方法的特性">2.2. equals方法的特性</h2><ul>
<li>自反性：若<code>x!=null</code>,则<code>x.equals(x)</code>应返回<code>true</code></li>
<li>对称性：<code>y.equals(x)</code>与<code>x.euqals(y)</code>应返回同样结果</li>
<li>传递性：若<code>x.equals(y)</code>返回<code>true</code>,且<code>y.equals(z)</code>返回<code>true</code>，则<code>x.equals(z)</code>也必须返回<code>true</code></li>
<li>一致性：若x与y的引用对象没有发生变化，则反复调用<code>x.equals(y)</code>应返回同样结果</li>
<li>对任意非空引用x，则<code>x.equals(null)</code>应该返回false</li>
</ul>
<h2 id="相等测试">2.3. 相等测试</h2><p><strong>问题</strong><br>如果隐式（this）和显式（传入的）的参数不属于同一类，equals方法如何处理？</p>
<p><strong>解决方法一</strong><br>在上例中，我们用到了<code>getClass()</code>：</p>
<pre><code>//如果类型不同
      if(getClass() != otherObject.getClass()) return false;
</code></pre><p><strong>解决方法二</strong><br>有的程序员喜欢用<code>instanceof</code>检测：<br>(instanceof 运算符是用来在运行时指出对象是否是特定类的一个实例)</p>
<pre><code>if(!(otherObeject instanceof Employee)) return false;
</code></pre><p><strong>方法一存在的问题</strong><br>若<code>e</code>是一个<code>Employee</code>对象，<code>m</code>是一个<code>Manager</code>对象，且两者具有相同姓名、薪水和雇用日期。</p>
<p>如果<code>Manager</code>没有重新实现<code>equals</code>方法，那么当<code>m1.equals(m2)</code>比较时，就会使用到<code>e.getClass() != m2.getClass()</code>来进行比较，显然结果返回<code>false</code>，因此这不是正确的比较。</p>
<p><strong>方法二存在的问题</strong><br>那么对于<code>e.equals(m)</code>来说，<code>instanceof</code>返回<code>true</code>.（<code>Manager</code>是<code>Employee</code>的一个实例）<br>但对于<code>m.equals(e)</code>来说，<code>instanceof</code>返回<code>false</code></p>
<p>！！！！！违反了对称性！</p>
<p><strong>总结</strong></p>
<ul>
<li>如果子类拥有自己的相等概念，例如若两个<code>Manager</code>对象的姓名、薪水和雇用日期（父类Employee的域）均相等，而奖金（子类Manager的域）不相等，就认为两个<code>Manager</code>不相等。此时可以用<code>getClass</code>检测</li>
<li>如果使用雇员ID(父类Employee的域)来作为相等检测标准，并这个标准适合所有的子类，就可以用<code>instanceof</code>检测，并将<code>Employee</code>的<code>equals</code>申明为<code>final</code></li>
</ul>
<p><strong>完美的equals</strong>：</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object otherObject)</span></span>&#123;</div><div class="line">    <span class="comment">//检测this与otherObject是否引用同一对象</span></div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>==otherObject)<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="comment">//检测otherObject是否为null</span></div><div class="line">    <span class="keyword">if</span>(otherObject == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    <span class="comment">//比较this与Object是否属于同一个类，有以下两种方案：</span></div><div class="line">    <span class="comment">//如果equals的语义在每个子类中都有改变，就用getClass:</span></div><div class="line">    <span class="keyword">if</span>(getClass() != otherObject.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    <span class="comment">//如果所有子类都有统一equals语义，则用instanceof检测：</span></div><div class="line">    <span class="keyword">if</span>(!(otherObject <span class="keyword">instanceof</span> ClassName)) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    <span class="comment">//将otherObject转换为相应的类类型</span></div><div class="line">    ClassName other = (ClassName) otherObject</div><div class="line">    <span class="comment">//对所需要的域进行比较</span></div><div class="line">    <span class="keyword">return</span> field1 == other.field1 </div><div class="line">        &amp;&amp; field2 == other.field2</div><div class="line">        &amp;&amp; Objects.equals(field3,other field3)</div><div class="line">        &amp;&amp; ...;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><p><strong>注意</strong>：如果在子类中重新定义<code>equals</code>，则要在其中包含调用<code>super.equals(other)</code></p>
<h1 id="hashCode方法">3. hashCode方法</h1><p>hashCode : 散列码</p>
<p>使用：</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> hash = <span class="number">0</span></div><div class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; lenth() ; i++ )&#123;</div><div class="line">    hash = <span class="number">31</span> * hash + charAt(i)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><p><strong>注意</strong></p>
<ul>
<li>每个对象都有一个<em>默认的散列码</em>，值为对象的<em>存储地址</em></li>
<li>字符串的散列码是由内容导出的，因此<code>s</code>和<code>t</code>有相同hashcode</li>
<li>如果重新定义了equals方法，就必须重新定义hashCode方法，且通过equal测试的两个对象的hashCode应该也是相等的，以便用户可以将对象插入到散列表中</li>
<li>hashCode方法应该返回一个整型数值，并使得不同对象的hashCode更均匀。</li>
</ul>
<p>例如：</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">7</span> * name.hashCode()</div><div class="line">            + <span class="number">11</span> * <span class="keyword">new</span> Double(salary).hashCode()</div><div class="line">            + <span class="number">13</span> * hireDay.hashCode();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><p>更方便的方法：</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> Objects.hash(name,salary,hireDay);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h1 id="toString方法">4. toString方法</h1><p>用途：返回表示对象值的字符串</p>
<p>例如：</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> getClass().getName()</div><div class="line">        + <span class="string">"[name="</span> + name</div><div class="line">        + <span class="string">",salary="</span> + salary</div><div class="line">        + <span class="string">",hireDay="</span> + hireDay</div><div class="line">        +<span class="string">"]"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><p>特别地：</p>
<ol>
<li>只要对象与一个字符串通过操作符“+”连接起来，或使用System.out.println(x)，Java编译就会自动调用toString方法。</li>
<li>Object类定义了toString方法，用来打印输出对象所属的类名和散列码。</li>
<li>有趣的是，数组继承了object类的toString方法。修正的方法是采用Array.toString.例如<code>String s = Array.toString(luckyNumbers)</code>。多维数组需要调用<code>Array.deepToString</code>方法。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[xgboost参数调节完全指南（Python版）]]></title>
      <url>/2017/04/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6-xgboost%E5%8F%82%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>本文大多来自于参考文献2.的翻译。</p>
<h1 id="Xgboost参数">1. Xgboost参数</h1><p>XGBoost作者将参数分为3类：</p>
<ol>
<li>基本(General)参数：指导整体函数</li>
<li>提升(Booster)参数：在每一步指导每个提升（树或回归）</li>
<li>学习任务(Learning Task Parameters)参数：指导优化模型表现</li>
</ol>
<h2 id="基本参数">1.1. 基本参数</h2><h3 id="booster">1.1.1. booster</h3><ol>
<li>默认值：gbtree</li>
<li>含义：在每次迭代中的模型类型，有两种选择：</li>
</ol>
<ul>
<li>gbtree:树模型</li>
<li>gblinear:线性模型</li>
</ul>
<h3 id="silent">1.1.2. silent</h3><ol>
<li>默认值：0</li>
<li>含义</li>
</ol>
<ul>
<li>0=运行时打印running messages</li>
<li>1=不打running messages</li>
</ul>
<h3 id="nthread">1.1.3. nthread</h3><ol>
<li>运行时的最大线程数</li>
<li>默认值：占当前计算机的最大线程</li>
</ol>
<h2 id="提升参数">1.2. 提升参数</h2><p>这里仅仅介绍树模型（gbtree）的相关参数。</p>
<h3 id="eta">1.2.1. eta</h3><ol>
<li>学习步长</li>
<li>default=0.3</li>
<li>一般调整下限为0.01-0.2</li>
</ol>
<h3 id="min-child-weight">1.2.2. min_child_weight</h3><ol>
<li>表示所有孩子节点(all observations required in a child)的最小权重和</li>
<li>一般都用来控制过拟合。</li>
<li>但如果调得太高就会导致欠拟合。</li>
<li>default=1</li>
</ol>
<h3 id="max-depth">1.2.3. max_depth</h3><ol>
<li>default=6</li>
<li>用来控制过拟合</li>
<li>一般在3-10之间</li>
</ol>
<h3 id="gamma">1.2.4. gamma</h3><ol>
<li>default=0</li>
<li>range: [0,∞]</li>
<li>模型在默认情况下，对于一个节点的划分只有在其损失函数得到结果大于0的情况下才进行，而gamma给定了所需的最低损失函数的值</li>
<li>gamma值使得算法更conservation，且其值依赖于损失函数，在模型中应该进行调参。</li>
</ol>
<h3 id="max-delta-step">1.2.5. max_delta_step</h3><ol>
<li>default=0</li>
<li>在最大化步长的时候，我们允许每个树的权重去估算它。</li>
<li>当max_delta_step=0时，意味着没有误差</li>
<li>当max_delta_step&gt;0时，意味着结果更保守</li>
<li>一般不需要调参。但当类别及不平衡的逻辑回归时可能会用到。</li>
</ol>
<h3 id="subsample-default-1">1.2.6. subsample [default=1]</h3><p>Same as the subsample of GBM. Denotes the fraction of observations to be randomly samples for each tree.<br>Lower values make the algorithm more conservative and prevents overfitting but too small values might lead to under-fitting.<br>Typical values: 0.5-1</p>
<h3 id="colsample-bytree-default-1">1.2.7. colsample_bytree [default=1]</h3><p>Similar to max_features in GBM. Denotes the fraction of columns to be randomly samples for each tree.</p>
<p>Typical values: 0.5-1</p>
<h3 id="colsample-bylevel-default-1">1.2.8. colsample_bylevel [default=1]</h3><p>Denotes the subsample ratio of columns for each split, in each level.<br>I don’t use this often because subsample and colsample_bytree will do the job<br>for you. but you can explore further if you feel so.</p>
<h3 id="lambda-default-1">1.2.9. lambda [default=1]</h3><p>L2 regularization term on weights (analogous to Ridge regression)<br>This used to handle the regularization part of XGBoost. Though many data scientists don’t use it often, it should be explored to reduce overfitting.</p>
<h3 id="alpha-default-0">1.2.10. alpha [default=0]</h3><p>L1 regularization term on weight (analogous to Lasso regression)<br>Can be used in case of very high dimensionality so that the algorithm runs faster when implemented</p>
<h3 id="scale-pos-weight-default-1">1.2.11. scale_pos_weight [default=1]</h3><p>A value greater than 0 should be used in case of high class imbalance as it helps in faster convergence.<br>Control the balance of positive and negative weights, useful for unbalanced classes. A typical value to consider: sum(negative cases) / sum(positive cases) See Parameters Tuning for more discussion. Also see Higgs Kaggle competition demo for examples: R, py1, py2, py3</p>
<p>控制正负样本权重的平衡。一般对非平衡的很有用。一个很特殊的取值是：负样本个数/正样本个数。</p>
<h3 id="不均衡数据在xgboost中的处理">1.2.12. 不均衡数据在xgboost中的处理</h3><p><a href="https://github.com/dmlc/xgboost/blob/master/doc/how_to/param_tuning.md" target="_blank" rel="external">官方文档</a>:</p>
<p>对于一些case，比如：广告点击日志，数据集极不平衡。这会影响xgboost模型的训练，有两个方法来改进它。</p>
<p>如果你关心的预测的ranking order（AUC)： – 通过scale_pos_weight来平衡正负类的权重 – 使用AUC进行评估</p>
<p>如果你关心的是预测的正确率： – 不能再平衡（re-balance）数据集 – 将参数max_delta_step设置到一个有限的数（比如：1）可以获得效果提升.</p>
<h2 id="学习任务参数">1.3. 学习任务参数</h2><h3 id="objective-default-reg-linear">1.3.1. objective [default=reg:linear]</h3><ol>
<li>default=reg:linear</li>
<li>定义学习任务及相应的学习目标，可选的目标函数如下：</li>
</ol>
<ul>
<li>“reg:linear” –线性回归。</li>
<li>“reg:logistic” –逻辑回归。</li>
<li>“binary:logistic” –二分类的逻辑回归问题，输出为概率。</li>
<li>“binary:logitraw” –二分类的逻辑回归问题，输出的结果为wTx。</li>
<li>“count:poisson” –计数问题的poisson回归，输出结果为poisson分布。在poisson回归中，max_delta_step的缺省值为0.7。(used to safeguard optimization)</li>
<li>“multi:softmax” –让XGBoost采用softmax目标函数处理多分类问题，同时需要设置参数num_class（类别个数）</li>
<li>“multi:softprob” –和softmax一样，但是输出的是ndata * nclass的向量，可以将该向量reshape成ndata行nclass列的矩阵。没行数据表示样本所属于每个类别的概率。</li>
<li>“rank:pairwise” –set XGBoost to do ranking task by minimizing the pairwise loss</li>
<li></li>
</ul>
<h3 id="eval-metric">1.3.2. eval_metric</h3><ol>
<li>默认值根据objective参数调整</li>
<li>用来验证数据的参数</li>
<li>几个典型值：</li>
</ol>
<ul>
<li>rmse – root mean square error</li>
<li>mae – mean absolute error</li>
<li>logloss – negative log-likelihood</li>
<li>error – Binary classification error rate (0.5 threshold)</li>
<li>merror – Multiclass classification error rate</li>
<li>mlogloss – Multiclass logloss</li>
<li>auc: Area under the curve</li>
</ul>
<h3 id="seed-default-0">1.3.3. seed [default=0]</h3><p>The random number seed.<br>Can be used for generating reproducible results and also for parameter tuning.</p>
<h1 id="例：CTR问题的正样本过少">2. 例：CTR问题的正样本过少</h1><p>参考文献[xgboost导读和实战]</p>
<p>《xgboost导读和实战》中提到，CTR问题的正样本很稀疏，根据理论推导，会导致叶子节点权重变大，进而导致每一步的估计step过大。</p>
<p>这时可以调节以下参数：</p>
<p><code>min_child_weight</code></p>
<p>默认为1.是每个叶子里h的和至少是多少。对正负样本不均衡时的0-1分类而言，假设h在0.01附近，min_child_weight为1意味着叶子节点中最少需要包含100 个样本。这个参数非常影响结果，控制叶子节点中二阶导的和的最小值，该参数值越小，越容易 overfitting。</p>
<p><code>eta</code><br>shrinkage 参数，用于更新叶子节点权重时，乘以该系数，避免步长过大。参数值越大，越可能无法收敛。把学习率eta设置的小一些，小学习率可以使得后面的学习更加仔细。</p>
<p><code>scale_pos_weight</code><br>如果优化的是仅仅展示排序，就是AUC的话，可以采用平衡正负样本权重的<br>办法调大正样本权重。设置 scale_pos_weight就可以把正样本权重乘这个系数。如果还需要优化回归的性能，还需要在此基础上做下 recalibration。</p>
<p><code>max_delta_step</code><br>如果设立了该值，对叶子节点的权重值做了约束在 [max_delta_step,max_delta_step]。以防在某些 loss 下权重值过大，默认是 0（其实代表 inf)。可以试试把这个参数设置到 1-10 之间的一个值。这样会防止做太大的更新步子，<br>使得更新更加平缓。</p>
<h1 id="交叉验证">3. 交叉验证</h1><p>xgboost自带的交叉验证据说很好用。</p>
<p>下面是参考文献3给出的一个使用案例：</p>
<pre><code>cvresult = xgb.cv(xgb_param, 
                    xgtrain, num_boost_round=alg.get_params()[&apos;n_estimators&apos;],
                    nfold=cv_folds,
                    metrics=&apos;auc&apos;, early_stopping_rounds=early_stopping_rounds, show_progress=False)
</code></pre><p>其中：</p>
<ul>
<li>xgb_params：参数</li>
<li>xgtrain:训练集</li>
<li>num_boost_round：树个数（迭代次数）</li>
<li>nfold:kfold的k</li>
<li>metrics:在CV中的评价度量指标</li>
<li>early_stopping_rounds：Activates early stopping. CV error needs to decrease at least every <early_stopping_rounds> round(s) to continue. Last entry in evaluation history is the one from best iteration.</early_stopping_rounds></li>
</ul>
<h1 id="参考文献">4. 参考文献</h1><ol>
<li>《xgboost导读和实战》</li>
<li><a href="http://wepon.me/2016/05/07/XGBoost%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BA/" target="_blank" rel="external">Xgboost深入浅出</a></li>
<li><a href="https://www.analyticsvidhya.com/blog/2016/03/complete-guide-parameter-tuning-xgboost-with-codes-python/" target="_blank" rel="external">Complete Guide to Parameter Tuning in XGBoost (with codes in Python)</a></li>
<li><a href="http://xgboost.readthedocs.io/en/latest/parameter.html" target="_blank" rel="external">xgboost参数官方文档</a></li>
<li><a href="http://blog.csdn.net/u010657489/article/details/51952785" target="_blank" rel="external">XGBoost参数调优完全指南（附Python代码）</a></li>
<li><a href="http://d0evi1.com/sklearn/imbalanced_classes/" target="_blank" rel="external">如何处理偏斜类(imbalanced classes)</a></li>
<li><a href="https://github.com/dmlc/xgboost/blob/master/doc/parameter.md" target="_blank" rel="external">XGBoost Parameters</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> 机器学习框架 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[特征工程]]></title>
      <url>/2017/04/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5-O2O%E4%BC%98%E6%83%A0%E5%88%B8%E9%A2%84%E6%B5%8B-%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h1 id="特征工程">1. 特征工程</h1><h2 id="别人的例子">1.1. 别人的例子</h2><p><img src="http://om1bxijvl.bkt.clouddn.com/2017-04-25-16-54-35.png" alt=""><br><img src="http://om1bxijvl.bkt.clouddn.com/2017-04-25-16-54-53.png" alt=""> </p>
<h2 id="特征选择">1.2. 特征选择</h2><p>特征选择，就是从多个特征中，挑选出一些对结果预测最有用的特征。因为原始的特征中可能会有冗余和噪声。<br>特征选择和降维有什么区别呢？前者只踢掉原本特征里和结果预测关系不大的， 后者做特征的计算组合构成新特征。</p>
<h3 id="过滤型">1.2.1. 过滤型</h3><ul>
<li>方法：  评估单个特征和结果值之间的相关程度， 排序留下Top相关的特征部分。 </li>
<li>评价方式：Pearson相关系数， 互信息， 距离相关度。 </li>
<li>缺点：只评估了单个特征对结果的影响，没有考虑到特征之间的关联作用， 可能把有用的关联特征误踢掉。因此工业界使用比较少。 </li>
<li>python包：SelectKBest指定过滤个数、SelectPercentile指定过滤百分比。</li>
</ul>
<h3 id="包裹型">1.2.2. 包裹型</h3><ul>
<li>方法：把特征选择看做一个特征子集搜索问题， 筛选各种特<br>征子集， 用模型评估效果。 </li>
<li>典型算法：“递归特征删除算法”。 </li>
<li>应用在逻辑回归的过程：用全量特征跑一个模型；根据线性模型的系数(体现相关性)，删掉5-10%的弱特征，观察准确率/auc的变化；逐步进行， 直至准确率/auc出现大的下滑停止。 </li>
<li>python包：RFE 
　　</li>
</ul>
<h3 id="嵌入型">1.2.3. 嵌入型</h3><ul>
<li>方法：根据模型来分析特征的重要性，最常见的方式为用正则化方式来做特征选择。 </li>
<li>举例：最早在电商用LR做CTR预估， 在3-5亿维的系数特征上用L1正则化的LR模型。上一篇介绍了L1正则化有截断作用，剩余2-3千万的feature， 意味着其他的feature重要度不够。 </li>
<li>python包：feature_selection.SelectFromModel选出权重不为0的特征。</li>
</ul>
<h1 id="参考文献">2. 参考文献</h1><ol>
<li><a href="https://ask.julyedu.com/question/7114" target="_blank" rel="external">四月机器学习算法班—特征工程笔记</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> o2o优惠券使用预测 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 特征工程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux常见命令]]></title>
      <url>/2017/04/14/linux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h1 id="IO">1. IO</h1><h2 id="linux-windows互传">1.1. linux/windows互传</h2><p>需要安装：yum install -y lrzsz</p>
<p>从Windows上传文件<code>[root@localhost src]# rz</code><br>从Linux下载文件<code>sz nginx-1.6.2.tar.gz</code></p>
<h2 id="linux互传">1.2. linux互传</h2><ol>
<li>从服务器下载文件<br> scp username@servername:/path/filename /tmp/local_destination<br> 例如scp codinglog@192.168.0.101:/home/kimi/test.txt  把192.168.0.101上的/home/kimi/test.txt的文件下载到 /tmp/local_destination</li>
<li>上传本地文件到服务器<br> scp /path/local_filename username@servername:/path<br> 例如scp /var/www/test.php  codinglog@192.168.0.101:/var/www/  把本机/var/www/目录下的test.php文件上传到192.168.0.101这台服务器上的/var/www/目录中</li>
<li>从服务器下载整个目录<br> scp -r username@servername:remote_dir/ /tmp/local_dir<br> 例如:scp -r codinglog@192.168.0.101 /home/kimi/test  /tmp/local_dir</li>
<li>上传目录到服务器<br> scp  -r /tmp/local_dir username@servername:remote_dir<br> 例如：scp -r test      codinglog@192.168.0.101:/var/www/把当前目录下的test目录上传到服务器的/var/www/目录</li>
</ol>
<h1 id="文件夹">2. 文件夹</h1><p>新建文件夹<code>mkdir name</code></p>
<h1 id="杂絮">3. 杂絮</h1><p>查看硬盘情况<code>df -h</code><br>合并文件<code>cat *.csv  &gt; full.csv</code><br>查看文件<code>$ ps -ef | grep 关键字</code></p>
<h1 id="解压">4. 解压</h1><h2 id="批量解压-zip">4.1. 批量解压.zip</h2><p>两种方式：（经测试第一种好用）</p>
<pre><code>ls *.zip | xargs -n1 unzip
unzip &quot;*.zip&quot;
</code></pre><h2 id="批量解压-tar-gz">4.2. 批量解压.tar.gz</h2><pre><code>ls *.tar.gz | xargs -n1 tar xzvf    
</code></pre><h1 id="vim">5. vim</h1><p><code>i</code>——进入插入模式<br><code>ESC+:wq!</code>：保存，退出<br><code>ESC+:q!</code>：不保存，退出</p>
<h1 id="VNC-tiger">6. VNC-tiger</h1><p>安装：<br><a href="http://www.jianshu.com/p/35640fc5672b" target="_blank" rel="external">CentOs 7安装配置VNC Server</a><br><a href="https://www.digitalocean.com/community/tutorials/how-to-install-and-configure-vnc-remote-access-for-the-gnome-desktop-on-centos-7" target="_blank" rel="external">digitalOcean,How to install vncserver in centos 7</a></p>
<p>使用：</p>
<p>help:<code>vncserver -help</code><br>开启：<code>vncserver :1</code><br>按照一定比例输出（屏幕旋转）：<code>vncserver 900x1440 :1</code><br>停止：<code>vncserver -kill: 1</code><br>临时文档：<code>/tmp/.X11-unix</code>.</p>
<h1 id="用sublime搭建简单的python">7. 用sublime搭建简单的python</h1><p>安装 Python，安装时选择添加路径到系统中，或者稍后自己添加也可<br>随便写个 demo，Ctrl + B 就可以运行了</p>
<p><a href="http://docs.sublimetext.info/en/latest/getting_started/install.html?highlight=ln" target="_blank" rel="external">sublime官方文档</a><br><a href="https://www.zhihu.com/question/22904994" target="_blank" rel="external">各路方法</a></p>
<p>中文无法输入问题解决<a href="http://www.jianshu.com/p/bf05fb3a4709" target="_blank" rel="external">解决Ubuntu下Sublime Text 3无法输入中文</a><br><a href="http://www.brightempty.com/?p=91" target="_blank" rel="external">装python包</a></p>
<h1 id="nohup">8. nohup</h1><pre><code>nohup command &gt; nohup.out &amp;
</code></pre><p>nohup相关：<br>将nohup后面的<code>command</code>设置成后台运行，并且将标准输出的日志重定向至文件nohup.out。<br>查看运行状态：jobs<br>查看日志内容：tail -f nohup.out (ctrl + c 退出查看)<br>查看进程信息：<br>ps -ef |grep java<br>ps -ef | grep rm<br>停止运行 kill %n<br>很好的参考文献：<a href="http://blog.sina.com.cn/s/blog_90546d6f0101en9y.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_90546d6f0101en9y.html</a></p>
<h1 id="更改某个目录的权限">9. 更改某个目录的权限</h1><pre><code>chown -R -v ubuntu:ubuntu info
</code></pre>]]></content>
      
        <categories>
            
            <category> linux </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[python实现某网站自动打卡]]></title>
      <url>/2017/04/05/Python-python%E5%AE%9E%E7%8E%B0%E6%9F%90%E7%BD%91%E7%AB%99%E8%87%AA%E5%8A%A8%E6%89%93%E5%8D%A1/</url>
      <content type="html"><![CDATA[<p>最近学校出了个科学上网的小网站，但流量有限，可以通过每天打卡来获取几十兆流量。奈何自己记性很差，总忘记打卡。因此决定写一个自动打卡的小程序。</p>
<h1 id="思路总结">1. 思路总结</h1><ol>
<li>用抓包工具仔细分析下登陆以及回帖时post了哪些数据，这些数据从何而来（chrome）</li>
<li>python requests库，用requests.Session().post来登陆和回帖，用get来读取页面内容；</li>
<li>登陆之后，正则找到“签到”或”不能签到”，来进行下一步</li>
<li>若能签到，就发出签到URL的请求（因为链接从原来上来说是一种URL）</li>
<li>记录每次签到的log</li>
<li>最后的最后，使用写个.sh脚本，里面运行这个python程序，配置个相应的plist，每天自动执行（MAC OS）</li>
</ol>
<h1 id="模拟登陆原理">2. 模拟登陆原理</h1><h2 id="浏览器访问服务器的过程">2.1. 浏览器访问服务器的过程</h2><p>一次完整的HTTP请求过程从TCP三次握手建立连接成功后开始。</p>
<ol>
<li>用户发起请求（点击等）</li>
<li>浏览器向WEB服务器发出一个请求<strong>Http Request（请求）</strong></li>
<li>Web服务器发相应<strong>Http Response</strong></li>
<li>浏览器解析</li>
</ol>
<h2 id="HTTP消息">2.2. HTTP消息</h2><p>更多关于HTTP请求过程，见参考资料<a href="https://foofish.net/http-request-process.html" target="_blank" rel="external">一次完整的HTTP请求过程</a></p>
<p>HTTP 是一种无状态的协议,协议本身不保留之前的一切请求信息和响应信息，也就是说，对于一个刚刚发送了 HTTP 请求的客户端再次发起请求时，服务端并不知道之前访问过。这样设计的理由是为了更快地处理大量事务，确保协议的可伸缩性，而特意把 HTTP 协议设计如此简单。<br>但是，无状态导致业务处理就变得棘手了，一个简单的例子就是网上购物的时候，当我在一个页面把商品加入购物车的时候，正当我要跳转到支付页面时，如果没有一种机制来保持我的登录状态，那么之前选的商品全部丢失了。<br>因此，为了在无状态的HTTP协议之上维护会话状态，使服务器可以知道当前是和哪个客户端打交道，于是Cookie技术应运而生，Cookie通俗的理解就是服务端分配给客户端的一个标识。</p>
<h2 id="Cookie原理">2.3. Cookie原理</h2><p>Cookie原理其实也非常简单，总共4个步骤维护HTTP会话。<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-04-05-15-55-17.png" alt=""> </p>
<ol>
<li>浏览器第一次发起HTTP请求时，没有携带任何Cookie信息，服务器收到请求并返回给浏览器的HTTP响应，同时HTTP响应包括了一个响应头Set-Cookie字段，它的值是要设置的Cookie。 </li>
<li>浏览器收到来自服务器的HTTP响应，响应头中发现有Set-Cookie字段，就会将该字段的值保存在内存或者硬盘中。 </li>
<li>浏览器下次给该服务器发送HTTP请求时，会将Cookie信息附加在HTTP请求的头字段Cookie中。 </li>
<li>服务器收到这个HTTP请求，发现请求头中有Cookie字段，便知道之前就和这个用户打过交道了。 </li>
</ol>
<p>理解了Cookie的基本原理之后，我们就可以尝试用Python来实现模拟登录。 </p>
<h1 id="点击登陆后，究竟发生了什么？">3. 点击登陆后，究竟发生了什么？</h1><p>为了看看浏览器究竟做了什么，我们首先进入登录界面，随便输入一个密码，点击登录。打开Chrome开发者工具条(F12)。选择Network下的Headers：<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-04-05-16-12-54.png" alt=""> </p>
<p>从上图我们可以发现以下关键信息：</p>
<ol>
<li>登陆的URL地址是General下面的Request URL的那个。</li>
<li>登录需要提供的表单（Form Data）有三个，email(用户名),passwd（密码）,remember_me(就是那个“记住我”的选项，我们可以从它的html中搜索得出，如下图)。<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-04-05-16-20-21.png" alt=""> </li>
</ol>
<p>到这里，基本上摸清了浏览器登录时所需要的数据是如何获取的了，那么现在就可以开始撸代码用Python模拟浏览器来登录。</p>
<p>由于我今天登陆的网站实在是太简易了，也不需要分析header就可以登陆。所以此处省略header的分析。</p>
<p>我打算基于python的requests库来完成这一过程。</p>
<h1 id="python实现模拟登陆">4. python实现模拟登陆</h1><pre><code><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">email=<span class="string">'jiayi797@163.com'</span></div><div class="line">password=<span class="string">'这里加密了'</span></div><div class="line">loginurl = <span class="string">'https://ssr.0v0.loan/auth/login'</span></div><div class="line"><span class="comment"># 这行代码，是用来维持cookie的，你后续的操作都不用担心cookie，他会自动带上相应的cookie</span></div><div class="line">s = requests.Session()</div><div class="line"><span class="comment"># 我们需要带表单的参数</span></div><div class="line">loginparams=&#123;<span class="string">'email'</span>:email,<span class="string">'passwd'</span>:password,<span class="string">'remember_me'</span>:<span class="string">'ture'</span>&#125;</div><div class="line"><span class="comment"># post 数据实现登录</span></div><div class="line">r = s.post(loginurl,data=loginparams)</div><div class="line"><span class="comment"># 验证是否登陆成功，抓取首页看看内容</span></div><div class="line">r = s.get(loginurl)</div></pre></td></tr></table></figure>
</code></pre><p>运行完这些后，我们发现r已经有内容了。接下来我们进行自动签到。</p>
<h1 id="签到">5. 签到</h1><p>我们查看r._content的内容，是主页的html内容。很长。为了方便分析，我只拿出“签到”标签下的内容：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-6"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box box-primary"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box-header"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-pencil"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">h3</span> <span class="attr">class</span>=<span class="string">"box-title"</span>&gt;</span>签到获取流量<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- /.box-header --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box-body"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span> 每24小时可以签到一次。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>上次签到时间：<span class="tag">&lt;<span class="name">code</span>&gt;</span>2017-04-04 17:11:22<span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"checkin-btn"</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"checkin"</span> <span class="attr">class</span>=<span class="string">"btn btn-success  btn-flat"</span>&gt;</span>签到<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"checkin-msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- /.box-body --&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- /.box --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- /.col (right) --&gt;</span></div></pre></td></tr></table></figure>
<p>需要注意的还有以下这个脚本：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    $(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        $(<span class="string">"#checkin"</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            $.ajax(&#123;</div><div class="line">                <span class="attr">type</span>: <span class="string">"POST"</span>,</div><div class="line">                <span class="attr">url</span>: <span class="string">"/user/checkin"</span>,</div><div class="line">                <span class="attr">dataType</span>: <span class="string">"json"</span>,</div><div class="line">                <span class="attr">success</span>: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">                    $(<span class="string">"#checkin-msg"</span>).html(data.msg);</div><div class="line">                    $(<span class="string">"#checkin-btn"</span>).hide();</div><div class="line">                &#125;,</div><div class="line">                <span class="attr">error</span>: <span class="function"><span class="keyword">function</span> (<span class="params">jqXHR</span>) </span>&#123;</div><div class="line">                    alert(<span class="string">"发生错误："</span> + jqXHR.status);</div><div class="line">                &#125;</div><div class="line">            &#125;)</div><div class="line">        &#125;)</div><div class="line">    &#125;)</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>
<p>从脚本中我们读到，签到的类型是post，url是/user/checkin，<br>因此我们试一下post一个这样的url会有什么后果。</p>
<pre><code><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">checkinUrl=<span class="string">"https://ssr.0v0.loan/user/checkin"</span></div><div class="line">r=s.post(checkinUrl)<span class="comment">#执行签到</span></div><div class="line">r = s.get(loginurl)<span class="comment">#查看签到结果</span></div></pre></td></tr></table></figure>
</code></pre><p>我们发现，签到栏的HTML已经变成了；</p>
<pre><code><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-6"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box box-primary"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box-header"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-pencil"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">h3</span> <span class="attr">class</span>=<span class="string">"box-title"</span>&gt;</span>签到获取流量<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- /.box-header --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box-body"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span> 每24小时可以签到一次。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>上次签到时间：<span class="tag">&lt;<span class="name">code</span>&gt;</span>2017-04-05 14:08:02<span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"btn btn-success btn-flat disabled"</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>不能签到<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"checkin-msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- /.box-body --&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- /.box --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- /.col (right) --&gt;</span></div></pre></td></tr></table></figure>
</code></pre><p>即：</p>
<pre><code>&lt;button id=&quot;checkin&quot; class=&quot;btn btn-success  btn-flat&quot;&gt;签到&lt;/button&gt;
</code></pre><p>变成了：</p>
<pre><code>&lt;a class=&quot;btn btn-success btn-flat disabled&quot; href=&quot;#&quot;&gt;不能签到&lt;/a&gt;
</code></pre><p>大题框架搭完了。接下来要做的就是一些细节。</p>
<h1 id="判断是否已签到">6. 判断是否已签到</h1><p>接下来要做的就是用正则，找到“签到”或者“不能签到”的对应标签，来获得一个当前状态。</p>
<p>首先我想到的是最简单的方式，用python自带的<code>re.search()</code>。</p>
<pre><code><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(str)</span>:</span></div><div class="line">    hasCheckIn=<span class="string">'&lt;button id="checkin" class="btn btn-success  btn-flat"&gt;'</span></div><div class="line">    noChecked=<span class="string">'&lt;a class="btn btn-success btn-flat disabled" href="#"&gt;'</span></div><div class="line">    yes=re.search(hasCheckIn,str)</div><div class="line">    <span class="keyword">if</span> yes==<span class="keyword">None</span>:</div><div class="line">        no=re.search(noChecked,str)</div><div class="line">        <span class="keyword">if</span> no==<span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> <span class="number">-1</span> <span class="comment">#什么都没找到</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span><span class="comment">#找到了“不能签到”</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span><span class="comment">#找到了“签到”</span></div></pre></td></tr></table></figure>
</code></pre><h1 id="获取当前流量">7. 获取当前流量</h1><p>先找到流量的对应标签：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dl</span> <span class="attr">class</span>=<span class="string">"dl-horizontal"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>总流量<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>1.53GB<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>已用流量<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>253.36MB<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>剩余流量<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>1.29GB<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></div></pre></td></tr></table></figure>
<p>想要获取标签内的内容（而不是暴力地匹配字符串），我们就需要用到另一种匹配方式——正则表达式</p>
<p>举个例子，我们想要获取<a href=""></a>之间的内容，那么我们可以这么写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#正则表达式获取&lt;tr&gt;&lt;/tr&gt;之间内容  </span></div><div class="line">res_tr = <span class="string">r'&lt;tr&gt;(.*?)&lt;/tr&gt;'</span>  </div><div class="line">m_tr =  re.findall(res_tr,language,re.S|re.M)  </div><div class="line"><span class="keyword">for</span> line <span class="keyword">in</span> m_tr:  </div><div class="line">    <span class="keyword">print</span> line  </div><div class="line">    <span class="comment">#获取表格第一列th 属性  </span></div><div class="line">    res_th = <span class="string">r'&lt;th&gt;(.*?)&lt;/th&gt;'</span>    </div><div class="line">    m_th = re.findall(res_th,line,re.S|re.M)  </div><div class="line">    <span class="keyword">for</span> mm <span class="keyword">in</span> m_th:  </div><div class="line">        <span class="keyword">print</span> unicode(mm,<span class="string">'utf-8'</span>),  <span class="comment">#unicode防止乱  </span></div><div class="line">    <span class="comment">#获取表格第二列td 属性值  </span></div><div class="line">    res_td = <span class="string">r'&lt;td&gt;(.*?)&lt;/td&gt;'</span>  </div><div class="line">    m_td = re.findall(res_td,line,re.S|re.M)  </div><div class="line">    <span class="keyword">for</span> nn <span class="keyword">in</span> m_td:  </div><div class="line">        <span class="keyword">print</span> unicode(nn,<span class="string">'utf-8'</span>)</div></pre></td></tr></table></figure>
<p>其中，res是匹配模式。<br><code>r’</code>是匹配模式的开头，<br><code>&lt;tr</code>是先匹配字符串<code>&lt;tr</code><br><code>.</code>是匹配任意字符，除了换行符<br><code>*</code>是匹配0个或多个的表达式<br><code>?</code>是匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式<br>依次类推</p>
<p><code>re.S</code>使<code>.</code>匹配包括换行在内的所有字符<br><code>re.M</code>:多行匹配，影响 ^ 和 $</p>
<p>因此，我们的思路是，匹配<code>&lt;dt&gt;总流量&lt;/dt&gt;</code>到<code>&lt;/dd&gt;&lt;/dl&gt;</code>之间的内容。</p>
<p>改写以上匹配式子为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">match_flows</span><span class="params">(str)</span>:</span></div><div class="line">    res = <span class="string">r'&lt;dl class="dl-horizontal"&gt;(.*?)&lt;/dl&gt;'</span></div><div class="line">    mm = re.findall(</div><div class="line">        res, str, re.S | re.M)</div><div class="line">    res=<span class="string">r'&lt;dd&gt;(.*?)&lt;/dd&gt;'</span></div><div class="line">    mm= re.findall(</div><div class="line">        res, mm[<span class="number">0</span>], re.S | re.M)</div><div class="line">    <span class="keyword">return</span> mm</div></pre></td></tr></table></figure>
<h1 id="记录当前操作">8. 记录当前操作</h1><p>首先</p>
<pre><code>import logging
</code></pre><p>然后：</p>
<pre><code># 配置日志文件和日志级别
logging.basicConfig(filename=&apos;logger.log&apos;, level=logging.INFO)

nowtime=time.strftime(&apos;%Y-%m-%d&apos;,time.localtime(time.time()))#获取当前时间
str= nowtime+&apos;,\t总流量：&apos;+lastFlows[0]+&apos;,\t已用流量：&apos;+lastFlows[1]+&apos;,\t剩余流量：&apos;+lastFlows[2]
logging.info(str)#写入日志
</code></pre><h1 id="操作系统定期执行Python脚本">9. 操作系统定期执行Python脚本</h1><p>见参考文献4.</p>
<h1 id="全部代码">10. 全部代码</h1><pre><code><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#! /usr/bin/env python</span></div><div class="line"><span class="comment"># coding:utf-8</span></div><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">import</span> re</div><div class="line"><span class="keyword">import</span> requests</div><div class="line"><span class="keyword">import</span> logging</div><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="comment"># 配置日志文件和日志级别</span></div><div class="line">logging.basicConfig(filename=<span class="string">'logger.log'</span>, level=logging.INFO)</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(str)</span>:</span></div><div class="line">    hasCheckIn=<span class="string">'&lt;button id="checkin" class="btn btn-success  btn-flat"&gt;'</span></div><div class="line">    noChecked=<span class="string">'&lt;a class="btn btn-success btn-flat disabled" href="#"&gt;'</span></div><div class="line">    yes=re.search(hasCheckIn,str)</div><div class="line">    <span class="keyword">if</span> yes==<span class="keyword">None</span>:</div><div class="line">        no=re.search(noChecked,str)</div><div class="line">        <span class="keyword">if</span> no==<span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> <span class="number">-1</span> <span class="comment">#什么都没找到</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span><span class="comment">#找到了“不能签到”</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span><span class="comment">#找到了“签到”</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">match_flows</span><span class="params">(str)</span>:</span></div><div class="line">    res = <span class="string">r'&lt;dl class="dl-horizontal"&gt;(.*?)&lt;/dl&gt;'</span></div><div class="line">    mm = re.findall(</div><div class="line">        res, str, re.S | re.M)</div><div class="line">    res=<span class="string">r'&lt;dd&gt;(.*?)&lt;/dd&gt;'</span></div><div class="line">    mm= re.findall(</div><div class="line">        res, mm[<span class="number">0</span>], re.S | re.M)</div><div class="line">    <span class="keyword">return</span> mm</div><div class="line">    <span class="comment">## 这段代码是用于解决中文报错的问题</span></div><div class="line">reload(sys)</div><div class="line">sys.setdefaultencoding(<span class="string">"utf8"</span>)</div><div class="line">email=<span class="string">'你的账号'</span></div><div class="line">password=<span class="string">'你的密码'</span></div><div class="line">loginurl = <span class="string">'https://ssr.0v0.loan/auth/login'</span></div><div class="line"><span class="comment"># 这行代码，是用来维持cookie的，你后续的操作都不用担心cookie，他会自动带上相应的cookie</span></div><div class="line">s = requests.Session()</div><div class="line"><span class="comment"># 我们需要带表单的参数</span></div><div class="line">loginparams=&#123;<span class="string">'email'</span>:email,<span class="string">'passwd'</span>:password,<span class="string">'remember_me'</span>:<span class="string">'ture'</span>&#125;</div><div class="line"><span class="comment"># post 数据实现登录</span></div><div class="line">r = s.post(loginurl,data=loginparams)</div><div class="line"><span class="comment"># 验证是否登陆成功，抓取首页看看内容</span></div><div class="line">r = s.get(loginurl)</div><div class="line">res=check(r.content)<span class="comment">#0=不能签到;1=可以签到;-1=什么都没找到;</span></div><div class="line"><span class="keyword">if</span>(res==<span class="number">1</span>):<span class="comment">#可以签到</span></div><div class="line">    checkinUrl=<span class="string">"https://ssr.0v0.loan/user/checkin"</span></div><div class="line">    r=s.post(checkinUrl)</div><div class="line">    r = s.get(loginurl)</div><div class="line">lastFlows=match_flows(r.content)</div><div class="line">nowtime=time.strftime(<span class="string">'%Y-%m-%d'</span>,time.localtime(time.time()))<span class="comment">#获取当前时间</span></div><div class="line">str= nowtime+<span class="string">',\t总流量：'</span>+lastFlows[<span class="number">0</span>]+<span class="string">',\t已用流量：'</span>+lastFlows[<span class="number">1</span>]+<span class="string">',\t剩余流量：'</span>+lastFlows[<span class="number">2</span>]</div><div class="line"><span class="keyword">print</span> str</div><div class="line">logging.info(str)</div></pre></td></tr></table></figure>
</code></pre><h1 id="参考文献">11. 参考文献</h1><ol>
<li><a href="http://geek.csdn.net/news/detail/189850" target="_blank" rel="external">微信群分享：用Python模拟知乎自动登录</a></li>
<li><a href="http://www.runoob.com/python/python-reg-expressions.html" target="_blank" rel="external">Python正则表达式</a></li>
<li><a href="http://blog.csdn.net/eastmount/article/details/51082253" target="_blank" rel="external">常用正则表达式爬取网页信息及分析HTML标签总结</a></li>
<li><a href="http://www.cnblogs.com/thingk/p/4309122.html" target="_blank" rel="external">操作系统定期定时执行PYTHON脚本</a></li>
</ol>
<p>签到成功后：</p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[《Improving Regressors Using Boosting Techniques》论文笔记]]></title>
      <url>/2017/04/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6-%E3%80%8AImproving-Regressors-Using-Boosting-Techniques%E3%80%8B%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h1 id="introduction部分">1. introduction部分</h1><p><strong>Bagging和boosting用途</strong></p>
<p>Bagging和boosting主要是用多重预测来解决以下两个问题：</p>
<ol>
<li>在回归问题中获取最小误差；</li>
<li>在分类问题中获取最小错误率。</li>
</ol>
<p><strong>Bagging和Boosting共性</strong><br>都是通过训练不同的数据集来得到回归模型。</p>
<p><strong>不同点</strong></p>
<p><strong>bagging</strong></p>
<ol>
<li>从$N_1$个原始样本中，有放回地抽样(可能overlap)得到$N_1$个样本</li>
<li>独立训练模型</li>
<li>得到不同的预测</li>
<li>求所有预测的平均得到最终结果</li>
</ol>
<p>由于模型之间独立，因此可以对训练过程采取分布式或并行的方式。</p>
<p><strong>boosting</strong></p>
<p>模型是依次训练出来的。</p>
<ol>
<li>从训练集中挑出$N_1$个样本，训练出第一个模型</li>
<li>挑出误差最大的样本</li>
<li>增大这些样本在下次被抽到的概率</li>
<li>再次进行训练，最终得到多个模型</li>
<li>最终对模型进行不同权重的加权，权重公式如下定义：</li>
</ol>
<p>设已知训练集$(y_i,x_i),i=1,…,N_1$。其中，$x$是$M$维的向量，且$(y_i,x_i)$唯一但未知(fixed but unknown)<br>我们将预测函数表示为$y^{(p)}(x)$，则：</p>
<p><strong>sample modeling error</strong>:<br> $$PE=\frac{1}{N_2}\sum_{i=1}^{N_2}[y_i-y_i^{(p)}(x_i)]^2$$<br><strong>prediction error</strong>:<br> $$ME=\frac{1}{N_2}\sum_{i=1}^{N_2}[y_i^{(t)}-y_i^{(p)}(x_i)]^2$$</p>
<p>其中，<br>$y_i^{(p)}(x_i)$表示第$i$个测试集的预测值<br>$y_i$表示第$i$个测试集的观测值<br>$y^{(t)}_i$是实际值<br>$y^{(p)}(x)$的参数p是从$N_2$个测试集的观测值中获得的，但是上面的累加的式子中的$y_i$和$x_i$是从从未被seen过的测试集的观测值$N_2$获得的。</p>
<ol>
<li><p>看到这里突然发现有点跑偏了。决定先暂停这篇论文的研究。</p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 机器学习进阶 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Boosting </tag>
            
            <tag> Bagging </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[2017腾讯题——字符十六进制输出]]></title>
      <url>/2017/04/03/ACM-2017%E8%85%BE%E8%AE%AF%E9%A2%98%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E8%BE%93%E5%87%BA/</url>
      <content type="html"><![CDATA[<h1 id="题目">1. 题目</h1><p>编写代码，接收从屏幕输入的长度为16字节整数倍的字符串。回车后，按实例格式排版输出。</p>
<p>实例：</p>
<p>屏幕输入（均为可见字符）：<br>abcdefghigklmnopqrstuvwxyzabcdefghigklmnopqrstuvwxyzabcdefghigkl</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-04-03-21-24-41.png" alt=""> </p>
<h1 id="代码">2. 代码</h1><pre><code>#include &lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
using namespace std;
int main()
{
    //freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);
    char c[16];
    int count=0;
    int level=0;
    int temp=0;
    char in;
    while(true){
        c[count]=getchar();
        if(c[count]==-1){
            break;
        }
        if(count==16){
            printf(&quot;%08d&quot;,level*10);
            printf(&quot;  &quot;);
            for(int i=0;i&lt;16;i++){
                if(i==8){
                    printf(&quot; &quot;);
                }
                temp=c[i]+16*level;
                printf(&quot;%02X&quot;,c[i]);
                printf(&quot; &quot;);
            }
            printf(&quot; &quot;);
            for(int i=0;i&lt;16;i++){
                std::cout&lt;&lt;c[i];
            }
            printf(&quot;\n&quot;);
            ++level;
            count=0;
        }
        ++count;
    }
    return 0;
}
</code></pre>]]></content>
      
        <categories>
            
            <category> ACM </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[BUPT_ACM_2017_F_Simple_recursion]]></title>
      <url>/2017/04/03/ACM-BUPT-2017-F-Simple-recursion/</url>
      <content type="html"><![CDATA[<p>本文是2017年北京邮电大学第十一届程序设计竞赛网络热身赛的F. Simple recursion题解。</p>
<h1 id="题目">1. 题目</h1><p>题目描述<br>r_clover shows you a BIIIIIIIIIIG water problem:<br>if $f(0)=1,f(1)=1$,$f(n)=2f(n-1)+3f(n-2)$, what is $f(n)mod1000000007$?</p>
<p>输入格式<br>A single integer n(0≤n≤10000000000).</p>
<p>输出格式<br>A single integer, which is the answer for f(n)mod1000000007.</p>
<p>输入样例<br>10<br>输出样例<br>29525</p>
<h1 id="思路">2. 思路</h1><p>一开始想的是用递归。但经测试发现递归的时间、空间复杂度都太高，导致超时。</p>
<p>正确打开方式：求出递推关系，并用快速幂取模方法计算结果。</p>
<h1 id="递推关系求解">3. 递推关系求解</h1><p>《组合数学》内容————常系数线性齐次递推关系的求解。公式见后面的附1。<br>求解题目中所给的递推关系：<br>$$f(n)=2f(n-1)+3f(n-2)$$<br>$$f(0)=1,f(1)=1$$<br>它的特征方程为：<br>$$x^2-2x-3=0$$<br>解方程得：<br>$$x_1=3,x_2=-1$$<br>所以递推关系的通解为：<br>$$f(n)=c_13^n+c_2(-1)^n$$<br>代入初值$f(0)=1,f(1)=1$，得到：<br>$$f(0)=c_1+c_2=1$$<br>$$f(1)=3c_1-c_2=1$$<br>解得:$c_1=c_2=0.5$<br>因此该递推关系的解为$$f(n)=0.5(3)^n+0.5(-1)^n$$</p>
<p>代码实现：</p>
<pre><code><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">long</span> <span class="title">f</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n,<span class="keyword">int</span> modNum)</span></span>&#123;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> a=<span class="number">3</span>;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> b=<span class="number">1</span>;</div><div class="line">    a= quick_algorithm(a,n,modNum);<span class="comment">//(a的n次方)mod(modNum),是快速求幂取模的方法，详细见后面的推导</span></div><div class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">1</span>)&#123;</div><div class="line">        b=<span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    a=<span class="number">0.5</span>*a+<span class="number">0.5</span>*b;</div><div class="line">    <span class="keyword">return</span> a;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h1 id="常系数线性齐次递归关系的求解">4. 常系数线性齐次递归关系的求解</h1><p><strong>递推关系：</strong></p>
<p>$$f(n)=c_1f(n-1)+c_2f(n-2)+…+c_kf(n-k)$$</p>
<p><strong>递推关系的特征方程</strong>：</p>
<p>$$x^k-c_1x^{k-1}-c_2x^{k-2}-…-c_k=0$$</p>
<p><strong>递归关系的特征根：</strong></p>
<p>特征方程的k个根（可能重根）：$$q_1,q_2,…,q_k$$</p>
<p><strong>递归关系的特解：</strong></p>
<p>设q是非零复数，则$f(n)=q^n$是递推关系的解，当且仅当q是它的特征根。</p>
<p><strong>递归关系的通解：</strong></p>
<p>设$q_1,q_2,…,q_k$是递推关系的k个互不相等的特征根，则<br>$$f(n)=b_1q_1^n+b_2q_2^n+b_3q_3^n+…+b_kq_k^n$$是递推关系的通解。</p>
<h1 id="快速大数幂运算">5. 快速大数幂运算</h1><p>这是一种很神奇的方法。</p>
<p>首先引入一些基础知识。</p>
<p><strong>幂取模运算的一个性质</strong></p>
<p>$$(a\times b)mod(c)=(((a)mod(c))\times ((b) mod(c)))mod(c)$$</p>
<p><strong>大数幂运算</strong><br>核心思想：将大数的幂运算拆解成了相对应的乘法运算，利用上面的式子，始终将我们的运算的数据量控制在c的范围以下。</p>
<p>对于目标：<br>$$a^bmodc$$<br>我们将b表示为二进制：<br>$$b=b_0+b_12+b_22^2+…+b_n2^n$$<br>那么，<br>$$a^b=a^b_1\times a^{b_22^2} \times a^{b_32^3} \times … \times a^{b_n2^n}$$<br>其中$b_k$要么为0，要么为1<br>去掉所有的0后，我们得到<br>$$a^b=a^{b_k2^k} \times … \times a^{b_n2^n}$$<br>上式的模可以表示为：<br>$$a^b mod c =a^{b_k2^k} mod c\times … \times a^{b_n2^n}mod c$$<br>易发现：<br>$$A_k=a^{b_k2^k} mod c$$<br>$$…$$<br>$$A_n=a^{b_n2^n} mod c$$</p>
<p>即：$A(n)$是$A(n-1)$的平方倍！</p>
<p>实现：</p>
<pre><code><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">quick</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> ans=<span class="number">1</span>;   <span class="comment">//记录结果</span></div><div class="line">    a=a%c;   <span class="comment">//预处理，使得a处于c的数据范围之下</span></div><div class="line">    <span class="keyword">while</span>(b!=<span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans=(ans*a)%c;   <span class="comment">//如果b的二进制位不是0，那么我们的结果是要参与运算的</span></div><div class="line">        b&gt;&gt;=<span class="number">1</span>;    <span class="comment">//二进制的移位操作，相当于每次除以2，用二进制看，就是我们不断的遍历b的二进制位</span></div><div class="line">        a=(a*a)%c;   <span class="comment">//不断的加倍</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ans;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h1 id="代码">6. 代码</h1><pre><code>#include &lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
#include &lt;math.h&gt;
using namespace std;
long quick_algorithm(long long a,long long n,int modNum){
    a=a%modNum ;
    long long ans=1 ;
    //这里我们不需要考虑b&lt;0，因为分数没有取模运算
    while(n!=0){
        if(n&amp;1)
            ans=(ans*a)%modNum ;
        n&gt;&gt;=1  ;
        a=(a*a)%modNum;
    }
    return ans;
}
long set2(long long n,int modNum){
    long long a=3;
    long long b=1;
    /*for(long long i=0;i&lt;n;i++){
        a=a*3;
        a=a%modNum;
    }*/
    a= quick_algorithm(a,n,modNum);
    if(n%2==1){
        b=-1;
    }
    //a=a;
    a=0.5*a+0.5*b;
    return a;
}

int main()
{
    int modNum=1000000007;
    long long input=999999999;
    scanf(&quot;%lld&quot;,&amp;input);
    if(input==0||input==1){
        printf(&quot;%lld\n&quot;,1);
    }else{
        long long out=set2(input,modNum);
        printf(&quot;%lld\n&quot;,out);
    }
    return 0;
}
</code></pre><h1 id="参考文献">7. 参考文献</h1><ol>
<li>《组合数学引论》</li>
</ol>
<p>附上本题的艰辛史。<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-04-03-13-55-57.png" alt=""> </p>
]]></content>
      
        <categories>
            
            <category> ACM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 递推关系 </tag>
            
            <tag> 快速幂取模 </tag>
            
            <tag> 长整型 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[QR分解]]></title>
      <url>/2017/03/31/%E6%95%B0%E5%AD%A6-QR%E5%88%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h1 id="QR分解">1. QR分解</h1><p><strong>引理</strong>：</p>
<ol>
<li>对于任意的$A\in C^{n\times n}$,若存在$n$阶正交矩阵$Q$和$n$阶上三角矩阵$R$，使得$A=QR$，则称$QR$为$A$的$QR$分解。</li>
<li>若$A\in C^{n\times n}$可逆，则存在正交矩阵$Q$和正对角元的上三角矩阵$R$，使得$A=QR$，且表示式唯一。</li>
</ol>
<p>备注：正交矩阵：$A^{-1}=A^T$<br><strong>QR分解定理</strong>：<img src="http://om1bxijvl.bkt.clouddn.com/2017-03-31-12-06-04.png" alt=""><br>，则A有QR分解：<img src="http://om1bxijvl.bkt.clouddn.com/2017-03-31-12-06-23.png" alt=""><br>Q是m<em>m的正交矩阵<br>R是n</em>n的有非负对角元的上三角阵</p>
<p>当m=n，且A非奇异时，上述分解唯一。</p>
<p><strong>计算QR分解的方法</strong><br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-31-22-28-42.png" alt=""> </p>
<p>备注：<br>计算A(j:m,j:n)=(I(m-j+1)-bvvT)A(j:m,j:n)时，<br>I(m-j+1)-bvvT可以表示为：<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-04-01-21-24-25.png" alt=""> </p>
<p><strong>QR分解的存储方法</strong><br><img src="http://om1bxijvl.bkt.clouddn.com/2017-04-01-21-54-20.png" alt=""> </p>
<p><strong>用QR分解解线性方程组</strong><br>$Ax=b$<br>$QRx=b$<br>$Rx=Q^{-1}b$<br>$x=R^{-1}Q^{-1}b$<br>$x=R^{-1}Q^Tb$</p>
<h1 id="householder方法">2. householder方法</h1><p>利用Householder变换逐步将A化为上三角矩阵。</p>
<p>使用Gauss变换将矩阵化为上三角的理论依据————对于一个给定的向量x，可构造一个初等下三角阵L，使得$Lx=ae_1$，其中$e_1$是I的第一列，a是实数。（I是单位矩阵）</p>
<p>householder变换目的：<br>求一个初等正交矩阵，使其具有矩阵L的功能。</p>
<p>使得：<br>可以通过一系列初等正交变换来完成矩阵的上三角化任务。</p>
<p><strong>Householder变换</strong><br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-31-22-03-16.png" alt=""> </p>
<p>其中：<br>I是单位矩阵<br>w是实的单位列向量（单位正交矩阵），$ww^T=I$</p>
<p>HouseHolder变换可以将一个向量映射到一个超平面上。 </p>
<p><strong>Householder变换的性质</strong></p>
<ol>
<li>对称性。$H^T=H$</li>
<li>正交性。$H^TH=I$</li>
<li>对合性。$H^2=I$</li>
<li>反射性(householder变换的物理意义)：<img src="http://om1bxijvl.bkt.clouddn.com/2017-03-31-22-09-23.png" alt=""><br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-31-22-10-12.png" alt=""> </li>
</ol>
<p><strong>Householder变换的用途</strong></p>
<p>它能如Gauss变换一样，可以通过适当选取单位向量w，把一个给定向量的若干指定的分量变为零。<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-31-22-12-23.png" alt=""><br>由以上定理可知，对于任意的x，都可以构造出Householder矩阵H，使得Hx的后n-1个分量为零。</p>
<p><strong>Householder变换方法</strong><br>计算某一行向量的houser变换：<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-31-22-24-15.png" alt=""><br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-31-22-24-37.png" alt=""><br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-31-22-24-58.png" alt=""> </p>
]]></content>
      
        <categories>
            
            <category> 数学 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[求线代方程的解]]></title>
      <url>/2017/03/30/%E6%95%B0%E5%AD%A6-%E6%B1%82%E7%BA%BF%E4%BB%A3%E6%96%B9%E7%A8%8B%E7%9A%84%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h1 id="LU分解条件">1. LU分解条件</h1><p>如果n阶方阵A的各阶顺序主子式<img src="http://om1bxijvl.bkt.clouddn.com/2017-03-29-19-34-31.png" alt=""> ，即A的各阶顺序主子矩阵Ak都可逆，则存在唯一的单位下三角矩阵L与唯一的非奇异上三角矩阵U，使得A=LU</p>
<p>其中k阶顺序主子式指<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-29-19-36-08.png" alt=""> </p>
<h1 id="LU分解方法">2. LU分解方法</h1><p>由于L存在可逆矩阵L’，即LL’=E<br>则L’A=LL’U=U<br>因此得出一般的分解方法：<br>通过对(A,E)做初等行变换得到(U,L’),再由L’得到L.</p>
<p>其中：</p>
<ol>
<li>L是单位下三角矩阵（对角线上的系数都为1的下三角矩阵）；L’也是单位上三角矩阵；</li>
<li>U是非奇异上三角矩阵；</li>
</ol>
<h1 id="求解方法">3. 求解方法</h1><p>对于一般的线性方程组：<br>$$Ax=b$$<br>如果我们能将A分解成$A=LU$,即一个下三角阵和一个上三角阵U的乘积，那原方程组的解x便可由下面两步得到：</p>
<ol>
<li>用前代法解$Ly=b$的y；<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-30-16-20-29.png" alt=""> </li>
<li>用回代法解$Ux=y$的x.<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-30-16-31-08.png" alt=""> </li>
</ol>
<p>对于列主元消去法，求线性方程组$Ax=b$的计算过程可以按照以下步骤进行：</p>
<ol>
<li>求A的列主元LU分解$PA=LU$</li>
<li>解下三角形方程组$Ly=Pb$</li>
<li>解上三角形方程组$Ux=y$</li>
</ol>
<h1 id="实现">4. 实现</h1><p>前代法：<br>需要注意的是，回代法在计算的过程中需要考虑到主元位置序列，并同时对b进行调整。</p>
<pre><code>double * forwardSub(double *lu,int n,double *b,int *p){
    //double *y=new double[n];
    double temp;
      //按qivot对b行变换，与LU匹配
      for(int i=0; i&lt;n-1; i++)  
      {
            temp = b[p[i]];
            b[p[i]] = b[i];
            b[i]=temp;
      }
    for(int i=0; i&lt;n; i++)
            for(int j=0; j&lt;i; j++)
                b[i]=b[i]-lu[n*i+j]*b[j];
    b[n-1]=b[n-1];
    return b;
}
</code></pre><p>回代法：<br>由于U是上三角矩阵，所以要从x[n-1]开始计算。</p>
<pre><code>double * backSub(double *b,double *lu,int n){
     for(int i=n-1; i&gt;=0; i--)
      {
            for(int j=n-1; j&gt;i; j--)
                b[i]=b[i]-lu[n*i+j]*b[j];
            b[i]=b[i]/lu[n*i+i];
      }
    return b;
}
</code></pre><p>计算：</p>
<pre><code>bool guass(double *lu,int *p,double*b,int n){
    double * y = forwardSub(lu,n,b,p);
    double * x = backSub(y,lu,n);
    std::cout&lt;&lt;endl&lt;&lt;&quot;the sulution is ; &quot;&lt;&lt;endl;
    for(int i=0;i&lt;n;i++){
        std::cout&lt;&lt;x[i]&lt;&lt;&quot;\t&quot;;
    }
    std::cout&lt;&lt;endl;
}
</code></pre><p>输出：<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-31-11-02-01.png" alt=""> </p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;iomanip&gt;
#define LIM -100000000
using namespace std;
double *luReult;
void printmat(double *mat,int n,string s){
    std::cout&lt;&lt;endl&lt;&lt;endl&lt;&lt;s&lt;&lt;endl;
    for(int i=0;i&lt;n;i++){
        for(int j=0;j&lt;n;j++){
            printf(&quot;%.5f\t&quot;,mat[i*n+j]);
        }
        std::cout&lt;&lt;endl;
    }
}
void printarr(int *mat,int n,string s){
    std::cout&lt;&lt;endl&lt;&lt;endl&lt;&lt;s&lt;&lt;endl;
    for(int i=0;i&lt;n;i++){
        std::cout&lt;&lt;mat[i]&lt;&lt;&quot;\t&quot;;
        //printf(&quot;%s\t&quot;,mat[i]);
    }
}
int findMainNumber(double *a,int n,int r){
    float maxa=-99999;
    int maxaIdx=-1;
    //printmat(a,n,&quot;a is now :&quot;);
    for(int i=r;i&lt;n;i++){
        if(a[i*n+r]&gt;maxa){
            maxa=a[i*n+r];
            maxaIdx=i;
        }
    }
    return maxaIdx;
}
void exchange(double *a,int n,int e,int r){
    float temp=0;
    for(int i=0;i&lt;n;i++){
        temp = a[r*n+i];
        a[r*n+i]=a[e*n+i];
        a[e*n+i]=temp;
    }
}
bool lu(double* a, int* pivot, int n)//矩阵LU分解
{
      for(int k=0;k&lt;n;k++){
        //寻找第k列的主元
        int p = findMainNumber(a,n,k);
        exchange(a,n,p,k);//交换k行和p行
        pivot[k]=p;//记录置换矩阵p
        if(a[k*n+k]!=0){
                for(int i=k+1;i&lt;n;i++){//部分下三角L
                    a[i*n+k]=a[i*n+k]/a[k*n+k];
                }
                for(int i=k+1;i&lt;n;i++){//计算上三角U
                    for(int j=k+1;j&lt;n;j++){
                        a[i*n+j]=a[i*n+j]-a[i*n+k]*a[k*n+j];
                    }
                }
        }else{
            return true;//矩阵奇异
        }
      }
      /*
      //计算下三角L
      double temp=0;
       for(int i=0; i&lt;n-2; i++)//i行k列
            for(int k=i+1; k&lt;n-1;k++)
            {
                    temp=a[n*pivot[k] + i];
                    a[n*pivot[k] + i]=a[k*n + i];
                    a[k*n + i]=temp;
            }
        */
      luReult=a;
      printmat(a,n,&quot;lu&quot;);
      return false ;
}
double radio(int a,int b){
    return (double)(a)/(double)(b);
}
void buildHilbert(double *a,double *b,int n){
    for(int r=0;r&lt;n;r++){
        for(int j=0;j&lt;n;j++){
            a[r*n+j]=radio(1,j+r+1);
            b[r]=b[r]+a[r*n+j];
        }
    }
}
void exchangeb(double *b,int n,int r,int e){
    double temp=0;
    temp=b[e];
    b[e]=b[r];
    b[r]=temp;
    /*r(int i=0;i&lt;n;i++){
        temp=b[r*n+i];
        b[r*n+i]=b[e*n+i];
        b[e*n+i]=temp;
    }*/
}
double * forwardSub(double *lu,int n,double *b,int *p){
    //double *y=new double[n];
    double temp;
      //按qivot对b行变换，与LU匹配
      for(int i=0; i&lt;n-1; i++)
      {
            temp = b[p[i]];
            b[p[i]] = b[i];
            b[i]=temp;
      }
    for(int i=0; i&lt;n; i++)
            for(int j=0; j&lt;i; j++)
                b[i]=b[i]-lu[n*i+j]*b[j];
    b[n-1]=b[n-1];
    return b;
}

double * backSub(double *b,double *lu,int n){
     for(int i=n-1; i&gt;=0; i--)
      {
            for(int j=n-1; j&gt;i; j--)
                b[i]=b[i]-lu[n*i+j]*b[j];
            b[i]=b[i]/lu[n*i+i];
      }
    return b;
}

bool guass(double *lu,int *p,double*b,int n){
    double * y = forwardSub(lu,n,b,p);
    double * x = backSub(y,lu,n);
    std::cout&lt;&lt;endl&lt;&lt;&quot;the sulution is ; &quot;&lt;&lt;endl;
    for(int i=0;i&lt;n;i++){
        std::cout&lt;&lt;x[i]&lt;&lt;&quot;\t&quot;;
    }
    std::cout&lt;&lt;endl;
}
int main()
{
    int n=6;//矩阵是n*n的
    double *b=new double[n];
    double *a=new double[n*n];
    /*double input[n*n]={0.001,1.00,1.00,2.00};
    a=input;
    double inputb[n]={1.00,3.00};
    b=inputb;*/
    buildHilbert(a,b,n);
    printmat(a,n,&quot;a:&quot;);
    int *pivot=new int[n*n];
    luReult=new double[n*n];
    lu(a,pivot,n);
    printarr(pivot,n,&quot;p:&quot;);
     guass(luReult,pivot,b,n);
    //cout &lt;&lt; &quot;Hello world!&quot; &lt;&lt; endl;
    return 0;
}
</code></pre>]]></content>
      
        <categories>
            
            <category> 数学 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 矩阵分解 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[矩阵LU分解及其实现]]></title>
      <url>/2017/03/29/%E6%95%B0%E5%AD%A6-%E7%9F%A9%E9%98%B5LU%E5%88%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>LU分解:可以将一个矩阵分解为一个<strong>单位下三角矩阵</strong>和一个<strong>上三角矩阵</strong>的<strong>乘积</strong>（有时是它们和一个置换矩阵的乘积）。LU分解主要应用在数值分析中，用来解线性方程、求反矩阵或计算行列式。</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-29-19-31-33.png" alt=""> </p>
<h1 id="LU分解条件">1. LU分解条件</h1><p>如果n阶方阵A的各阶顺序主子式<img src="http://om1bxijvl.bkt.clouddn.com/2017-03-29-19-34-31.png" alt=""> ，即A的各阶顺序主子矩阵Ak都可逆，则存在唯一的单位下三角矩阵L与唯一的非奇异上三角矩阵U，使得A=LU</p>
<p>其中k阶顺序主子式指<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-29-19-36-08.png" alt=""> </p>
<h1 id="LU分解方法">2. LU分解方法</h1><p>由于L存在可逆矩阵L’，即LL’=E<br>则L’A=LL’U=U<br>因此得出一般的分解方法：<br>通过对(A,E)做初等行变换得到(U,L’),再由L’得到L.</p>
<p>其中：</p>
<ol>
<li>L是单位下三角矩阵（对角线上的系数都为1的下三角矩阵）；L’也是单位上三角矩阵；</li>
<li>U是非奇异上三角矩阵；</li>
</ol>
<h1 id="直接消去法的矩阵解释">3. 直接消去法的矩阵解释</h1><p>计算过程如图所示：<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-29-20-13-15.png" alt=""> </p>
<p><strong>目的</strong>：将[A|E]–&gt;[U|L]形式，其中U是上三角矩阵</p>
<p><strong>过程</strong>：每轮将一列的下三角消为0，就相当于给A左乘一个下三角单位矩阵Lk（对角线为1，保证变换后对角线元素不变）。</p>
<p><strong>第一轮消元</strong>：将第一列的下三角消为0，相当于对A1左乘矩阵L1，即：<img src="http://om1bxijvl.bkt.clouddn.com/2017-03-29-20-54-39.png" alt=""><br>其中，<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-29-20-55-24.png" alt=""><br>我们注意到li1恰好使得第i行的第一列元素变为零，即ai1-li1*a11=0。</p>
<p><strong>第二轮消元</strong>：将第二列的下三角消为0，对应于<img src="http://om1bxijvl.bkt.clouddn.com/2017-03-29-20-57-24.png" alt=""> </p>
<p><strong>第k轮消元</strong>:<img src="http://om1bxijvl.bkt.clouddn.com/2017-03-29-20-57-48.png" alt=""><br>其中，<img src="http://om1bxijvl.bkt.clouddn.com/2017-03-29-20-58-09.png" alt=""> </p>
<p>把k轮消元相乘，即：<br><strong>整个消元过程为</strong>：<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-29-20-59-09.png" alt=""> </p>
<p><strong>总结</strong><br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-29-21-05-36.png" alt=""><br>初始（第一步）：<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-29-21-00-46.png" alt=""> </p>
<p>迭代第r步：<br>即<br>ur=f(u1,u2,…,u(r-1),l1,l2,…,l(r-1)),第r项由前r-1项计算得到<br>lr=g(u1,u2,…,u(r-1),l1,l2,…,l(r-1))<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-29-21-02-44.png" alt=""> </p>
<p>计算顺序：</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-30-10-36-28.png" alt=""> </p>
<p>需要注意的是，我们在计算时需要判断本阶的顺序主子式是否为零。</p>
<p><strong>代码实现</strong><br>备注：其中的piovt暂时没有卵用。</p>
<p>输入矩阵：<img src="http://om1bxijvl.bkt.clouddn.com/2017-03-30-14-16-46.png" alt=""> </p>
<pre><code>bool lu(double *a,int *pivot,int n){//矩阵是n*n的
double test = det(a,r,n);//检验本阶顺序主子式是否为0
 if(test==0){
    return true;
 }
//数组a在内存中按行优先次序存放
//pivot:输出参数
//pivot[0,n)中存放主元的位置排列
//成功时返回false，否则返回ture
//int len = sizeof(a)/sizeof(a[0]);
double *U,*L;
U = new double[n*n];
L = new double[n*n];
set0(U,n);
set0(L,n);
//先算urj(固定r，计算完所有的urj)，再算ljr(固定i，计算完所有的ljr)
for(int r=0;r&lt;n;r++){
    //计算urj(固定r，计算完所有的urj)
    //计算ljr(固定i，计算完所有的ljr)
    for(int j=r;j&lt;n;j++){
        double sum_lu1=0;
        double sum_lu2=0;
        for(int k=0;k&lt;r;k++){
            sum_lu1 = sum_lu1+L[r*n+k]*U[k*n+j];
            sum_lu2 = sum_lu2+L[j*n+k]*U[k*n+r];
        }
        U[r*n+j]=a[r*n+j]-sum_lu1;
        if(j==r){
            L[j*n+r]=1;
        }else{
            L[j*n+r]=a[j*n+r]-sum_lu2;
            L[j*n+r]=L[j*n+r]/U[r*n+r];
        }
    }
}
return false;
}
</code></pre><p>结果：<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-30-14-22-05.png" alt=""> </p>
<p>不知道为什么，我的答案与网上的之前学长做过的这道题的答案统统不一样。仔细检查后还是查不出来。又用Matlab验证了一下LU分解，MATLAB跑的结果为：<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-30-14-39-25.png" alt=""><br>与我自己的L矩阵一致。决定还是相信自己。</p>
<h1 id="列主元高斯消去法">4. 列主元高斯消去法</h1><p>主要思想是在每次计算第r行时，选取当前第r列下的最大的a[i,r]的所在的第i行作为主元，即将第i行与第r行交换，再进行计算。</p>
<p>主要理论见参考文献-北邮理学院数值分析课件chapter5.</p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;iomanip&gt;
#define LIM -100000000
using namespace std;
double *luReult;
void printmat(double *mat,int n,string s){
    std::cout&lt;&lt;endl&lt;&lt;endl&lt;&lt;s&lt;&lt;endl;
    for(int i=0;i&lt;n;i++){
        for(int j=0;j&lt;n;j++){
            printf(&quot;%.5f\t&quot;,mat[i*n+j]);
        }
        std::cout&lt;&lt;endl;
    }
}
void printarr(int *mat,int n,string s){
    std::cout&lt;&lt;endl&lt;&lt;endl&lt;&lt;s&lt;&lt;endl;
    for(int i=0;i&lt;n;i++){
        std::cout&lt;&lt;mat[i]&lt;&lt;&quot;\t&quot;;
        //printf(&quot;%s\t&quot;,mat[i]);
    }
}
int findMainNumber(double *a,int n,int r){
    float maxa=-99999;
    int maxaIdx=-1;
    //printmat(a,n,&quot;a is now :&quot;);
    for(int i=r;i&lt;n;i++){
        if(a[i*n+r]&gt;maxa){
            maxa=a[i*n+r];
            maxaIdx=i;
        }
    }
    return maxaIdx;
}
void exchange(double *a,int n,int e,int r){
    float temp=0;
    for(int i=0;i&lt;n;i++){
        temp = a[r*n+i];
        a[r*n+i]=a[e*n+i];
        a[e*n+i]=temp;
    }
}
bool lu(double* a, int* pivot, int n)//矩阵LU分解
{
      for(int k=0;k&lt;n;k++){
        //寻找第k列的主元
        int p = findMainNumber(a,n,k);
        exchange(a,n,p,k);//交换k行和p行
        pivot[k]=p;//记录置换矩阵p
        if(a[k*n+k]!=0){
                for(int i=k+1;i&lt;n;i++){//部分下三角L
                    a[i*n+k]=a[i*n+k]/a[k*n+k];
                }
                for(int i=k+1;i&lt;n;i++){//计算上三角U
                    for(int j=k+1;j&lt;n;j++){
                        a[i*n+j]=a[i*n+j]-a[i*n+k]*a[k*n+j];
                    }
                }
        }else{
            return true;//矩阵奇异
        }
      }
      /*
      //计算下三角L
      double temp=0;
       for(int i=0; i&lt;n-2; i++)//i行k列
            for(int k=i+1; k&lt;n-1;k++)
            {
                    temp=a[n*pivot[k] + i];
                    a[n*pivot[k] + i]=a[k*n + i];
                    a[k*n + i]=temp;
            }
        */
      luReult=a;
      printmat(a,n,&quot;lu&quot;);
      return false ;
}
double radio(int a,int b){
    return (double)(a)/(double)(b);
}
void buildHilbert(double *a,double *b,int n){
    for(int r=0;r&lt;n;r++){
        for(int j=0;j&lt;n;j++){
            a[r*n+j]=radio(1,j+r+1);
            b[r]=b[r]+a[r*n+j];
        }
    }
}
void exchangeb(double *b,int n,int r,int e){
    double temp=0;
    temp=b[e];
    b[e]=b[r];
    b[r]=temp;
    /*r(int i=0;i&lt;n;i++){
        temp=b[r*n+i];
        b[r*n+i]=b[e*n+i];
        b[e*n+i]=temp;
    }*/
}

int main()
{
    int n=6;//矩阵是n*n的
    double *b=new double[n];
    double *a=new double[n*n];
    /*double input[n*n]={0.001,1.00,1.00,2.00};
    a=input;
    double inputb[n]={1.00,3.00};
    b=inputb;*/
    buildHilbert(a,b,n);
    printmat(a,n,&quot;a:&quot;);
    int *pivot=new int[n*n];
    luReult=new double[n*n];
    lu(a,pivot,n);
    printarr(pivot,n,&quot;p:&quot;);
    //cout &lt;&lt; &quot;Hello world!&quot; &lt;&lt; endl;
    return 0;
}
</code></pre><p>输出：<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-31-11-02-01.png" alt=""> </p>
<h1 id="参考文献">5. 参考文献</h1><ol>
<li><a href="https://ccjou.wordpress.com/2010/09/01/lu-%E5%88%86%E8%A7%A3/" target="_blank" rel="external">LU 分解</a></li>
<li><a href="http://blog.csdn.net/u010945683/article/details/45803141" target="_blank" rel="external">矩阵分析——LU分解</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> 数学 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 矩阵分解 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[最大流]]></title>
      <url>/2017/03/28/%E7%AE%97%E6%B3%95-%E6%9C%80%E5%A4%A7%E6%B5%81/</url>
      <content type="html"><![CDATA[<p>最大流问题：给定流网络、源节点、汇点，找到值最大的一个流。</p>
<h1 id="Ford-Fullkerson方法">1. Ford-Fullkerson方法</h1><p><strong>主要思想</strong>：循环增加流的值。</p>
<h2 id="几个概念">1.1. 几个概念</h2><h3 id="残存网络-G-f">1.1.1. 残存网络$G_f$</h3><p>残存网络简单定义：</p>
<pre><code>残存网络=网络容量Capacity-流量网络flow
</code></pre><p>残存网络形式化定义：</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-28-19-36-03.png" alt=""> </p>
<p>说明：<br>第一项很好理解，就是=网络容量Capacity-流量网络flow</p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[ACM-poj1789-TruckHistory]]></title>
      <url>/2017/03/27/ACM-poj1789-TruckHistory/</url>
      <content type="html"><![CDATA[<h1 id="Description">1. Description</h1><p>Advanced Cargo Movement, Ltd. uses trucks of different types. Some trucks are used for vegetable delivery, other for furniture, or for bricks. The company has its own code describing each type of a truck. The code is simply a string of exactly seven lowercase letters (each letter on each position has a very special meaning but that is unimportant for this task). At the beginning of company’s history, just a single truck type was used but later other types were derived from it, then from the new types another types were derived, and so on. </p>
<p>Movement:运动<br>trucks：卡车<br>exactly seven lowercase letters ：正好七个小写字母<br>derived：派生</p>
<p>Today, ACM is rich enough to pay historians to study its history. One thing historians tried to find out is so called derivation plan – i.e. how the truck types were derived. They defined the distance of truck types as the number of positions with different letters in truck type codes. They also assumed that each truck type was derived from exactly one other truck type (except for the first truck type which was not derived from any other type). The quality of a derivation plan was then defined as<br><code>1/Σ(to,td)d(to,td)</code></p>
<p>quality：质量</p>
<p>where the sum goes over all pairs of types in the derivation plan such that to is the original type and td the type derived from it and d(to,td) is the distance of the types.<br>Since historians failed, you are to write a program to help them. Given the codes of truck types, your program should find the highest possible quality of a derivation plan. </p>
<h1 id="Input">2. Input</h1><p>The input consists of several test cases. Each test case begins with a line containing the number of truck types, N, 2 &lt;= N &lt;= 2 000. Each of the following N lines of input contains one truck type code (a string of seven lowercase letters). You may assume that the codes uniquely describe the trucks, i.e., no two of these N lines are the same. The input is terminated with zero at the place of number of truck types.</p>
<h1 id="Output">3. Output</h1><p>For each test case, your program should output the text “The highest possible quality is 1/Q.”, where 1/Q is the quality of the best derivation plan.<br>Sample Input</p>
<p>4<br>aaaaaaa<br>baaaaaa<br>abaaaaa<br>aabaaaa<br>0</p>
<h1 id="Sample-Output">4. Sample Output</h1><p>The highest possible quality is 1/3.</p>
<h1 id="解决方案">5. 解决方案</h1><p>t:表示卡车的七个字母的字符串<br>d(t0,td)=t0和td两卡车的字符串不相同的个数</p>
<p>每个卡车都是由另一个卡车派生而来。<br>现在给出n种不同型号的truck，问怎样使quality的值最小————即找到一条连接所有truck的最短路径</p>
]]></content>
      
        <categories>
            
            <category> ACM </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[最小生成树算法]]></title>
      <url>/2017/03/26/%E7%AE%97%E6%B3%95-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>带权图分为有向和无向，无向图的最短路径又叫做最小生成树，有prime算法和kruskal算法；有向图的最短路径算法有dijkstra算法和floyd算法。</p>
<p>最小生成树问题：给定一个连通无向图，寻找一颗无环树，使得树上所有边权值之和最小。</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-26-20-15-02.png" alt=""> </p>
<h1 id="最小生成树的贪心策略的通用方法">1. 最小生成树的贪心策略的通用方法</h1><h2 id="问题描述">1.1. 问题描述</h2><p><strong>已知</strong>：连通无向图$G=(V,E)$，权重函数$w:E \rightarrow R$<br><strong>循环不变式</strong>：在每边循环之前，A是某颗最小生成树的一个子集。<br><strong>伪代码</strong></p>
<pre><code>GENERIC-MST(G,w)
A={}
while A does not form a spanning tree // 当A不是一个生成树时
    find an edge(u,v) that is safe for A // 找到一条A的安全边
    A = A ∪ {(u,v)}
return A
</code></pre><p>注：安全边是指加入A后，不会使得A违反循环不变式。即 A ∪ {(u,v)}也是某颗最小生成树的一个子集</p>
<p><strong>问题</strong>：如何寻找安全边</p>
<h2 id="求安全边">1.2. 求安全边</h2><p><strong>定理</strong>：设A是图G的某最小生成树的一个子集。设（S,V-S）是图G中尊重集合A的任意一个切割，又设(u,v)是横跨切割(S,V-S)的一条轻量级边，则边(u,v)对于集合A是安全的。</p>
<p><strong>切割</strong>：图中的线<br><strong>切割尊重集合A</strong>：集合A中不存在横跨切割的边（如图a中的灰粗线构成的集合）<br><strong>轻量级边</strong>：横跨一个切割的所有边中权重最小的边（不唯一）。</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-26-21-11-54.png" alt=""> </p>
<h1 id="Kruskal和Prim关系">2. Kruskal和Prim关系</h1><table>
<thead>
<tr>
<th>term</th>
<th style="text-align:right">集合A</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">共性</th>
</tr>
</thead>
<tbody>
<tr>
<td>Kruskal</td>
<td style="text-align:right">森林</td>
<td style="text-align:center">结点是原图结点，安全边是权重最小的连接两个不同分量的边</td>
<td style="text-align:center">都是用具体的规则来确定安全边的方法</td>
</tr>
<tr>
<td>Prim</td>
<td style="text-align:right">树</td>
<td style="text-align:center">安全边是连接A和A之外某个节点的边中权重最小的边</td>
</tr>
</tbody>
</table>
<h1 id="Kruskal算法">3. Kruskal算法</h1><p><strong>寻找安全边</strong>:在所有连接两个不同树的边里，找到权重最小的边(u,v)</p>
<h2 id="伪代码">3.1. 伪代码</h2><pre><code>MST-KRUSKAL(G,w)
A={}//A是森林
for each vertex v∈G.V
    MAKE-SET(v)//将集合A初始化为空集，并创建M颗子树，每棵树各含一个结点
sort the edges of G.E into nondecreasing order by weight w //对边按照权重排序
for each edge(u,v)∈G.E,taken in nondecreasing order by weight//按权重顺序遍历边
    if FIND-SET(v)!=FIND-SET(u)//(u,v)不在一棵树
        A= A ∪ {(u,v)}
        UNION(u,v)
return A
</code></pre><h2 id="时间复杂度">3.2. 时间复杂度</h2><p>$O(ElgV)$</p>
<h2 id="特点">3.3. 特点</h2><p>图的存贮结构采用边集数组,且权值相等的边在数组中排列次序可以是任意的.该方法对于边相对比较多的不是很实用,浪费时间.</p>
<p>c++实现（写的很好，一定要看）:<a href="http://blog.csdn.net/niushuai666/article/details/6689285" target="_blank" rel="external">Kruskal算法</a></p>
<h1 id="Prim算法">4. Prim算法</h1><p><strong>寻找安全边</strong>:A总是一颗树。从单一顶点开始，逐步扩大树中所含顶点的数目，直到遍及连通图的所有顶点。</p>
<p>为了快速选择新边， 在算法执行的过程中，所有不在树A中的结点都存放在一个基于key属性的<code>最小优先队列Q</code>中。</p>
<p><code>u.key</code> : 连接结点u和<strong>树</strong>中结点的所有边中最小边的权重。<br><code>u.π</code>：u在<strong>树</strong>中的父节点</p>
<h2 id="描述">4.1. 描述</h2><p><strong>输入</strong>:连通图G,边权w,最小生成树的根节点r</p>
<p><strong>初始化</strong>：Vnew = {x}，其中x为集合V中的任一节点（起始点），Enew = {}</p>
<p><strong>循环</strong>：重复以下操作，直到$V_{new}=V$：</p>
<ol>
<li>在集合E中选取权值最小的边（u,v），其中u是集合Vnew中的元素，而v则是V中没有加入Vnew的顶点；</li>
<li>将v加入Vnew中，将(u,v)加入Enew中；</li>
</ol>
<p><strong>输出</strong>：使用集合Vnew和Enew来描述所得到的最小生成树。</p>
<p>图例：</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-27-15-47-24.png" alt=""> </p>
<h2 id="伪代码-1">4.2. 伪代码</h2><pre><code>MST-PRIM(G,w,r)//r是最小生成树的根节点
for each u∈G.V
    u.key=∞ 
    u.π=NIL //u在树中的父节点
r.key=0
Q=G.V
while Q!={}
    u=EXTRACT-MIN(Q)//某条横跨切割(V-Q,Q)的一个轻量级边的端点
    for each v∈G.Adj[u]//遍历u的邻接表
    if v∈Q and w(u,v)&lt;v.key
        v.π=u
        v.key=w(u,v)
</code></pre><h2 id="时间复杂度-1">4.3. 时间复杂度</h2><p><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-27-15-51-25.png" alt=""> </p>
<p>通过邻接矩阵图表示的简易实现中，找到所有最小权边共需O（V2）的运行时间。使用简单的二叉堆与邻接表来表示的话，普里姆算法的运行时间则可缩减为O(E log V)，其中E为连通图的边数，V为顶点数。如果使用较为复杂的斐波那契堆，则可将运行时间进一步缩短为O(E + V log V)，这在连通图足够密集时（当E满足Ω（V log V）条件时），可较显著地提高运行速度</p>
<h1 id="参考文献">5. 参考文献</h1><ol>
<li><a href="https://zh.wikipedia.org/wiki/%E6%99%AE%E6%9E%97%E5%A7%86%E7%AE%97%E6%B3%95" target="_blank" rel="external">维基百科</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[ACM-poj1860-CurrencyExchange]]></title>
      <url>/2017/03/23/ACM-poj1860-CurrencyExchange/</url>
      <content type="html"><![CDATA[<h1 id="Description">1. Description</h1><p>Several currency exchange points are working in our city. Let us suppose that each point specializes in two particular currencies and performs exchange operations only with these currencies. There can be several points specializing in the same pair of currencies. Each point has its own exchange rates, exchange rate of A to B is the quantity of B you get for 1A. Also each exchange point has some commission, the sum you have to pay for your exchange operation. Commission is always collected in source currency.<br>For example, if you want to exchange 100 US Dollars into Russian Rubles at the exchange point, where the exchange rate is 29.75, and the commission is 0.39 you will get (100 - 0.39) * 29.75 = 2963.3975RUR.<br>You surely know that there are N different currencies you can deal with in our city. Let us assign unique integer number from 1 to N to each currency. Then each exchange point can be described with 6 numbers: integer A and B - numbers of currencies it exchanges, and real RAB, CAB, RBA and CBA - exchange rates and commissions when exchanging A to B and B to A respectively.<br>Nick has some money in currency S and wonders if he can somehow, after some exchange operations, increase his capital. Of course, he wants to have his money in currency S in the end. Help him to answer this difficult question. Nick must always have non-negative sum of money while making his operations. </p>
<p> currency exchange points：货币兑换点<br> commission：佣金<br> assign ：分配</p>
<p>每个货币兑换点只能互换两种货币。兑换点可重复。每个点都有自己的兑换率，A to B 的兑换率是指1个A能兑换的B的数量。</p>
<p>兑换时收取一定的佣金，佣金是以来源货币来collect的。例如，如果你想将100dolars兑换成Russian Bules,  兑换点的兑换率是29.75，费用是0.39，，那么你会得到的钱是 (100 - 0.39) * 29.75 = 2963.3975RUR. </p>
<p>假设每种兑换的点数量是1-N，那么每个兑换点可以由6个num来描述：</p>
<p>interger A and B  兑换货币的序号<br>RAB A to B兑换率<br>CAB A to B 的佣金<br>RBA B to A 兑换率<br>CBA B to A 的佣金</p>
<p>Nick有些S货币，他很好奇他能否通过货币兑换的方式对他的资金进行增值。最终他希望他拿到还是S货币。帮他解决这个问题。Nick在这个过程中不能借钱。</p>
<h1 id="Input">2. Input</h1><p>The first line of the input contains four numbers: N - the number of currencies, M - the number of exchange points, S - the number of currency Nick has and V - the quantity of currency units he has. </p>
<p>The following M lines contain 6 numbers each - the description of the corresponding exchange point - in specified above order. Numbers are separated by one or more spaces. </p>
<p>1&lt;=S&lt;=N&lt;=100, 1&lt;=M&lt;=100, V is real number, 0&lt;=V&lt;=103. </p>
<p>For each point exchange rates and commissions are real, given with at most two digits after the decimal point, 10-2&lt;=rate&lt;=102, 0&lt;=commission&lt;=102. </p>
<p>Let us call some sequence of the exchange operations simple if no exchange point is used more than once in this sequence. You may assume that ratio of the numeric values of the sums at the end and at the beginning of any simple sequence of the exchange operations will be less than 104. </p>
<p>corresponding：相应的</p>
<p>第一行包含四个数字：<br>N 货币的种类<br>M 兑换点的数量<br>S Nick的货币的序号<br>V Nick拥有的钱</p>
<p>接下来的M行，每行包含六个数字，描述相应的兑换点的属性。<br>数字由一个或多个空格隔开</p>
<p>1&lt;=S&lt;=N&lt;=100, 1&lt;=M&lt;=100, V is real number, 0&lt;=V&lt;=103. </p>
<p>每个兑换点的兑换率和手续费都是实数，至多精确到两位小数。</p>
<p> 10-2&lt;=rate&lt;=102, 0&lt;=commission&lt;=102</p>
<p>如果在操作序列中不适用多个兑换点，我们可以发起一些简单的兑换操作。你可以假设：（最后的总和/）</p>
<h1 id="输出数据">3. 输出数据</h1><p>如果nick能够实现他的愿望，则输出YES，否则输出NO。</p>
<h1 id="样例输入">4. 样例输入</h1><p>3 2 1 20.0<br>1 2 1.00 1.00 1.00 1.00<br>2 3 1.10 1.00 1.10 1.00</p>
<h1 id="思路">5. 思路</h1><p>将货币看做点，每种兑换规则为边，两点的路径长度为兑换后的钱数。建图之后可以看出题意为求图中是否存在正环，用Bellman-Ford求最长路径，如果存在正环输出YES，不存在输出NO。</p>
]]></content>
      
        <categories>
            
            <category> ACM </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[单源最短路径问题]]></title>
      <url>/2017/03/23/%E7%AE%97%E6%B3%95-%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>单源最短路径问题：给定一个图 $G=(V,E)$ ，我们希望找到从给定源节点$s\in V$到每个节点$v \in V$的最短路径。</p>
<p>先总结：</p>
<p>Bellman-Ford算法：采用动态规划进行设计。<strong>待总结</strong>。简单，还能侦探含源节点的负权重回路。<br>Dijkstra算法：采用贪心算法范式进行设计。复杂度低，但要求权重非负。</p>
<h1 id="最短路径树">1. 最短路径树</h1><p>一颗根节点为s的最短路径树是一个有向子图$G’=(V’,E’)$，这里$V’\in V$,$E’\in E$,满足：</p>
<ol>
<li>$V’$是图G中从源节点s可以到达的所有结点的集合；</li>
<li>$G’$形成一颗根节点为s的树；</li>
<li>对于所有结点$v\in V’$,图$G’$中从结点s到结点v的唯一简单路径是图G中从结点s到结点v的一条最短路径。</li>
</ol>
<h1 id="松弛操作">2. 松弛操作</h1><p>对每个节点v，我们维持一个属性v.d，记录s→v的最短路径估计</p>
<p>松弛操作：比较s→u→v与s→v的d,然后进行更新。</p>
<pre><code>RELEAX(u,v,w)
    if v.d&gt;u.d+w(u,v)
        v.d=u.d+w(u,v)
        v.π=u
</code></pre><h1 id="Bellman-Ford算法">3. Bellman-Ford算法</h1><p><strong>目标</strong>：解决单源最短路径问题<br><strong>条件</strong>：边权重可负<br><strong>输入</strong>：带权有向图$G=(V,E)$和权重函数$w:E→R$<br><strong>输出</strong>：布尔值，是否存在一个从源节点可以到达的负权重回路。若存在，则算法无解。</p>
<p><strong>思路</strong>：Bellman-Ford通过对边进行松弛操作来渐进地降低从源节点s到每个节点v的最短路径估计值v.d，直到该估计值与实际的最短路径权重$δ(s,v)$相同为止。</p>
<p>初始函数：</p>
<pre><code>INITIALIZE-SINGLE-SOURCE(G,s)
    for eahc vertex v∈G.V
        v.d=∞
        v.π=null
    s.d=0
</code></pre><p><strong>算法</strong>：</p>
<pre><code>BELLMAN-FORD(G,w,s)
    INITIALIZE-SINGLE-SOURCE(G,s)//对每个点v.d和v.π初始化
    for i=1 to |G.V|-1 //对每个边处理V-1次
        for each edge(u,v)∈G.E //遍历所有的边
            RELAX(u,v,w)
    for each edge(u,v)∈G.E
        if v.d&gt;u.d+w(u,v)
            return False
        else
            return True
</code></pre><p><strong>复杂度</strong>：$O(VE)$</p>
<p><strong>对每个边处理V-1的原因</strong>：设p是从s到v的最短路径，则p最多包含V-1条边。</p>
<p>如下图所示的极限条件，v0-v5路径应该为<code>&lt;v0,v1,v2,v3,v4,v5&gt;</code></p>
<p>原本v0-v5的路径是灰色的。<br>第一轮松弛后，v0-v5路径变为<code>&lt;v0,v1,v5&gt;</code>，即黑色的<br>同理，第二轮松弛后，v0-v5路径变为<code>&lt;v0,v1,v2,v5&gt;</code><br>因此要松弛V-1次才可以<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-23-17-07-49.png" alt=""> </p>
<h1 id="Dijkstra算法">4. Dijkstra算法</h1><p><strong>条件</strong>：所有边的权重非负<br><strong>思想</strong>：由上述性质可知，如果存在一条从i到j的最短路径(Vi…..Vk,Vj)，Vk是Vj前面的一顶点。那么(Vi…Vk)也必定是从i到k的最短路径。为了求出最短路径，Dijkstra就提出了以最短路径长度递增，逐次生成最短路径的算法。即：每次找到离源点最近的一个顶点，然后以该顶点为中心进行扩展，最终得到源点到其余所有点的最短路径。</p>
<p><strong>Dijkstra算法的关键</strong>：维持一组节点集合S，从s到该集合中的每个节点的最短路径已经被找到。算法重复从V-S中选择最短路径估计最小的节点u，将u加入结合S，然后对所有从u出发的边进行松弛。</p>
<pre><code>DIJKSTRA(G,w,s)
    INITIALIZE-SINGLE-SOURCE(G,s)//对v.d和v.π初始化
    S={}
    Q=G.V
    while Q.length != 0
        u = UXTRACT-MIN(Q)//从V-S中选出最短路径估计最小的节点u
        S=S∪{u}
        for each vertex v∈G.Adj[u]
            RELAX(u,v,w)
</code></pre><p><strong>算法解释</strong><br>二维数组 e 来存储顶点之间边的关系，初始值如下：<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-23-22-23-08.png" alt=""> </p>
<p>我们还需要用一个一维数组 dis 来存储 1 号顶点到其余各个顶点的初始路程，如下。<br>我们将此时 dis 数组中的值称为最短路的“估计值”<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-23-22-23-38.png" alt=""> </p>
<p>图的关系如图所示，1是源点<img src="http://om1bxijvl.bkt.clouddn.com/2017-03-23-22-22-41.png" alt=""> </p>
<p>既然是求 1 号顶点到其余各个顶点的最短路程，那就先找一个离 1 号顶点最近的顶点。通过数组 dis 可知当前离 1 号顶点最近是 2 号顶点。当选择了 2 号顶点后，dis[2]的值就已经从“估计值”变为了“确定值”，即 1 号顶点到 2 号顶点的最短路程就是当前 dis[2]值。<br>原因：目前离 1 号顶点最近的是 2 号顶点，并且这个图所有的边都是正数，那么肯定不可能通过第三个顶点中转，使得 1 号顶点到 2 号顶点的路程进一步缩短了。因为 1 号顶点到其它顶点的路程肯定没有 1 号到 2 号顶点短，</p>
<p>既然选了 2 号顶点，接下来再来看 2 号顶点有哪些出边呢。有 2-&gt;3 和 2-&gt;4 这两条边。先讨论通过 2-&gt;3 这条边能否让 1 号顶点到 3 号顶点的路程变短。也就是说现在来比较 dis[3]和 dis[2]+e[2][3]的大小。其中 dis[3]表示 1 号顶点到 3 号顶点的路程。dis[2]+e[2][3]中 dis[2]表示 1 号顶点到 2 号顶点的路程，e[2][3]表示 2-&gt;3 这条边。所以 dis[2]+e[2][3]就表示从 1 号顶点先到 2 号顶点，再通过 2-&gt;3 这条边，到达 3 号顶点的路程。</p>
<p>我们发现 dis[3]=12，dis[2]+e[2][3]=1+9=10，dis[3]&gt;dis[2]+e[2][3]，因此 dis[3]要更新为 10。这个过程有个专业术语叫做“松弛”。即 1 号顶点到 3 号顶点的路程即 dis[3]，通过 2-&gt;3 这条边松弛成功。这便是 Dijkstra 算法的主要思想：通过“边”来松弛 1 号顶点到其余各个顶点的路程。</p>
<p>同理通过 2-&gt;4（e[2][4]），可以将 dis[4]的值从 ∞ 松弛为 4（dis[4]初始为 ∞，dis[2]+e[2][4]=1+3=4，dis[4]&gt;dis[2]+e[2][4]，因此 dis[4]要更新为 4）。</p>
<p>刚才我们对 2 号顶点所有的出边进行了松弛。松弛完毕之后 dis 数组为：<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-23-22-31-33.png" alt=""> </p>
<p>以此类推，此处不再多加阐述。</p>
<p>参考文献<a href="http://wiki.jikexueyuan.com/project/easy-learn-algorithm/dijkstra.html" target="_blank" rel="external">算法 7：Dijkstra 最短路算法</a></p>
<h1 id="有向无环图的单源最短路径问题">5. 有向无环图的单源最短路径问题</h1><p>来日再填坑。</p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[ACM--Radar Installation]]></title>
      <url>/2017/03/22/ACM-Radar-Installation/</url>
      <content type="html"><![CDATA[<h1 id="题目描述">1. 题目描述</h1><p>Assume the coasting is an infinite straight line. Land is in one side of coasting, sea in the other. Each small island is a point locating in the sea side. And any radar installation, locating on the coasting, can only cover d distance, so an island in the sea can be covered by a radius installation, if the distance between them is at most d. </p>
<p>We use Cartesian coordinate system, defining the coasting is the x-axis. The sea side is above x-axis, and the land side below. Given the position of each island in the sea, and given the distance of the coverage of the radar installation, your task is to write a program to find the minimal number of radar installations to cover all the islands. Note that the position of an island is represented by its x-y coordinates. </p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-22-19-32-14.png" alt=""> </p>
<p>coasting：滑行<br>infinite：无穷的<br>Cartesian coordinate system：笛卡尔坐标系</p>
<p>已知：海岸线是x轴，以上是海，以下是陆地。雷达安装在海岸线上，覆盖半径是d。<br>目标：求能够覆盖所有岛屿的雷达安装数目。<br>需需要注意的是，海岛坐标在x-y坐标系中。</p>
<h1 id="Input">2. Input</h1><p>The input consists of several test cases. The first line of each case contains two integers n (1&lt;=n&lt;=1000) and d, where n is the number of islands in the sea and d is the distance of coverage of the radar installation. This is followed by n lines each containing two integers representing the coordinate of the position of each island. Then a blank line follows to separate the cases. </p>
<p>The input is terminated by a line containing pair of zeros </p>
<p>输入一般包含好几组case测试数据。</p>
<p>每个case的第一行是(n,d)<br>然后是n行岛屿坐标</p>
<p>最后以（0,0）结尾</p>
<h1 id="Output">3. Output</h1><p>For each test case output one line consisting of the test case number followed by the minimal number of radar installations needed. “-1” installation means no solution for that case.</p>
<h1 id="思路">4. 思路</h1><p>这道题问的是怎样放雷达使其放的雷达数目最少而能够探测到所有的岛屿，这里需要转换为求每个岛屿的能放雷达的区间的问题:</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-22-21-06-38.png" alt=""> </p>
<p>抽象问题:每个小岛都对应一个区域,这个区域内的雷达都能探测到这个小岛,把这N个区域求出来,问题现在就变成了,最少放置几个点,能使得每个区域内都至少有一个点.</p>
<p>这道题目的关键之处就是把面的问题转换成线的问题，每一个座海岛在x轴上有一个区间，在这个区间里面的雷达都可以侦测到海岛，区间的范围即是[x-sqrt(dd – yy), x+sqrt(dd+yy)]，然后先以右端点为基进行从小到大排序，然后把第一个雷达默认放在最左端的xmax，接下来的点只要是xmin小于当前xmax就可以不用增加雷达，如果xmax == xmin的话也不用增加雷达。然后如果xmax &lt; xmin的话就加一个雷达，然后以xmin所属区间的xmax为基进行比较。</p>
<h1 id="代码">5. 代码</h1><pre><code>import java.io.PrintWriter;

import java.util.Arrays;
import java.util.Scanner;
public class Main {
    static class Range implements Comparable&lt;Range&gt;{
        double left,right;
        public Range(double left,double right){
            this.left = left;

            this.right = right;
        }
        @Override

        public int compareTo(Range range) {
            if(range.left == left){
                return ((Double)right).compareTo((Double)(range.right));
            }else{
                return ((Double)left).compareTo((Double)(range.left));
            }
        }

        @Override
        public String toString() {
            return &quot;(&quot; + left + &quot;,&quot; + right + &quot;)&quot;;
        }

    }


    public static void main(String[] args) {
        Scanner scn = new Scanner(System.in);

        PrintWriter out = new PrintWriter(System.out);
        int n ,d,x,y,num;
        double dx;
        Range[] ranges;
        int index = 0;
        while(true){
            num = 0;
            n = scn.nextInt();
            d = scn.nextInt();
            if(n == 0){
                break;
            }
            ranges = new Range[n];
            for(int i = 0; i &lt; n; i++){
                x = scn.nextInt();
                y = scn.nextInt();
                if(y &gt; d){
                    num = -1;
                }
                dx = Math.sqrt(d*d - y*y);
                ranges[i] = new Range(x - dx, x + dx);
            }
            Arrays.sort(ranges);//���
            if(num != -1){
                num = calute(ranges);
            }
            out.format(&quot;Case %d: %d\n&quot;,++index,num);
        }
        out.flush();

    }

    private static int calute(Range[] ranges) {
        int num = 1;
        int n = ranges.length;
        Range preRange = ranges[0],range;
        for(int i = 1; i &lt; n; i++){
            range = ranges[i];
            if(range.left &gt;= preRange.left &amp;&amp; range.left &lt;= preRange.right){
                preRange.left = range.left;
                if(range.right &lt; preRange.right){
                    preRange.right = range.right;
                }
            }else{
                num++;
                preRange = range;
            }
        }
        return num;
    }
}
</code></pre>]]></content>
      
        <categories>
            
            <category> ACM </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[numpy笔记]]></title>
      <url>/2017/03/21/Python-numpy%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h1 id="numpy结构数组">1. numpy结构数组</h1><p>在c语言中，我们可以使用关键字struct定义结构类型。和c语言一样，numpy也可以创建结构定义，这样可以很方便的读取二进制的C语言结构数组，将其转换为numpy数组对象，假设我们定义的结构数组如下(C语言描述)：</p>
<pre><code>struct Person{
     char name[30];
     int    age;
     float weight; 
};
</code></pre><p>我们在python中可以自定义类型如下：</p>
<pre><code>persontype = np.dtype({
&apos;names&apos;:[&apos;name&apos;,&apos;age&apos;,&apos;weight&apos;],
&apos;formats&apos;:[&apos;S30&apos;,&apos;i&apos;,&apos;f&apos;]},align = True)
</code></pre><p>参考文献<a href="http://www.cnblogs.com/td15980891505/p/6083083.html" target="_blank" rel="external">numpy中结构数组</a></p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> numpy </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java学习笔记2-继承]]></title>
      <url>/2017/03/16/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-%E7%BB%A7%E6%89%BF/</url>
      <content type="html"><![CDATA[<h1 id="super关键字">1. super关键字</h1><h2 id="子类override-覆盖-父类的函数">1.1. 子类override(覆盖)父类的函数</h2><p>override时，使用<code>super</code>调用父类的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//超类，员工</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;<span class="comment">//薪水</span></div><div class="line">    <span class="keyword">private</span> Date hireDay;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> salary;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//经理</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manage</span> <span class="keyword">extends</span> <span class="title">Employee</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">double</span> bonus;<span class="comment">//奖金</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span></span>&#123;<span class="comment">//对原来的getSalary进行override</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.bonus + <span class="keyword">super</span>.getSalary();<span class="comment">//super调用父类的getSalary()方法</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="super在构造器中的应用">1.2. super在构造器中的应用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Manager</span><span class="params">(String n, <span class="keyword">double</span> s, <span class="keyword">int</span> year, <span class="keyword">int</span> mouth, <span class="keyword">int</span> day)</span></span>&#123;</div><div class="line">    <span class="keyword">super</span>(n,s,year,mouth,day);<span class="comment">//调用超类Employee中对应参数的构造器</span></div><div class="line">    bonus = <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="多态">2. 多态</h1><p>一个对象变量可以指示多种实际类型的现象————多态（polymorphism）<br>在运行时自动选择调用那个方法的现象————动态绑定（dynamic binding）</p>
<p>例如：</p>
<pre><code>Employee e = new Employee();
e = new Manage(); // is ok
</code></pre><p>此时，对象变量<code>e</code>也可以引用<code>Manager</code>的对象。</p>
<pre><code>Manage boss = new Manage(...);
Employee[] staff = new Employee();
</code></pre><h1 id="调用对象方法的执行过程">3. 调用对象方法的执行过程</h1><ol>
<li>编译器查看对象的声明类型和方法名。假设调用<code>x.f(param)</code>，且隐式参数x声明为C类的对象。编译器一一列举所有C类中名为f的方法和其超类中访问属性为public且名为f的方法。</li>
<li>编译器查看调用方法时提供的参数类型。这个过程叫做<strong>重载解析</strong>（overloading resolution）</li>
<li>如果是private方法、static方法、final方法或者构造器，那么编译器会准确地知道应该调用哪个方法（编译器可以在编译阶段就完成绑定），这种调用方式叫<strong>静态绑定</strong>(static binding)。与此对应的是，调用的方法依赖于隐式参数的实际类型（编译器在编译阶段不知道要调用哪个方法，直到运行时才能确定），并在运行时实现<strong>动态绑定</strong>。有一个很好的例子解释这两个概念——<a href="http://blog.csdn.net/lingzhm/article/details/44116091" target="_blank" rel="external">lingzhm-动态绑定</a></li>
<li>程序运行时，若是动态绑定调用方法，那就先从本类中寻找，否则从超类中寻找。（每个类都有一个方法表method table）</li>
</ol>
<h1 id="阻止继承：final类和方法">4. 阻止继承：final类和方法</h1><p>不允许扩展（被继承）的类被称为final类。</p>
<p>例如下例子中的Executive类就不能有子类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Executive</span> <span class="keyword">extends</span> <span class="title">Manager</span></span>&#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>类中的方法也可以final,那么子类就不能覆盖这个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="抽象类，abstract">5. 抽象类，abstract</h1><p>用于表示某种很抽象的、上层的、更通用的类。例如图中的<code>Person</code>类。<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-04-13-10-25-16.png" alt=""> </p>
<ul>
<li>一般来说，包含一个或多个抽象方法的类本身必须被声明为抽象的。</li>
<li>抽象类<strong>不能</strong>被实例化！</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">class</span> <span class="title">Person</span></span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">private</span> String name;<span class="comment">//人类共有的属性,是具体的属性</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String n)</span></span>&#123;<span class="comment">//具体的方法</span></div><div class="line">        name=n;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getDescription</span><span class="params">()</span></span>;<span class="comment">//抽象方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>可以定义抽象类的对象变量，但只能引用非抽象子类的对象：</p>
<p>  Person p = new Student(“Vince Vu”,”Economics”);</p>
</li>
</ul>
<p>照着书上写了abstract的<a href="https://github.com/jiayi797/Java/tree/master/abstactClasses" target="_blank" rel="external">demo</a></p>
<p>输出为：</p>
<pre><code>Harry Hacker,an employee with a salary of 50000.00
Maria Morris,a student majoring in computer science
</code></pre><h1 id="受保护访问，Protected">6. 受保护访问，Protected</h1><p>若超类的某个域被声明为protected,那么子类就可以直接访问这个protected域。</p>
<ul>
<li>private-仅本类可见</li>
<li>public-所有类可见</li>
<li>protected-对本包和所有子类可见</li>
<li>默认-对本包可见</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[GBDT]]></title>
      <url>/2017/03/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-GBDT/</url>
      <content type="html"><![CDATA[<p>之前的AdaBoostDTree的误差函数是指数型的。GBDT的误差函数是任意指定的。<br>GBDT的核心就在于，每一棵树学的是之前所有树结论和的残差，这个残差就是一个加预测值后能得真实值的累加量。</p>
<h1 id="GBDT的误差函数">1. GBDT的误差函数</h1><p><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-15-13-49-01.png" alt=""> </p>
<h1 id="目标">2. 目标</h1><ol>
<li>求函数h(x)的形式</li>
<li>求h(x)的步长η</li>
</ol>
<h1 id="回归问题求解目标">3. 回归问题求解目标</h1><p>对于回归（regression）问题，误差函数一般采用平方误差。即：</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-15-13-55-15.png" alt=""> </p>
<p>为了进一步求解，我们对上式进行taylor展开，即：</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-15-13-58-42.png" alt=""> </p>
<p>其中：</p>
<ul>
<li>左边一项$err(S_n,y_n)$是常量（因为$S_n$、$y_n$都已知）</li>
<li>右边一项应该对s求导，并在sn这点取导数值（$error=(s-y)^2$求导之后得到$2(s-y)$）</li>
</ul>
<p>那么，上式等于：</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-15-14-04-27.png" alt=""> </p>
<h2 id="求h-x">3.1. 求h(x)</h2><p>为了让上式最小化，那么貌似$|h(x)|$无穷大即可实现，这不科学！于是我们要对$h(x)$的大小进行限制（类似归一化）————加入惩罚项$(h(x_n))^2$，即将上式变为：</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-15-14-19-46.png" alt=""> </p>
<p>而上式可变为：</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-15-14-20-27.png" alt=""> </p>
<p>其中的$(s_n-y_n)^2$是常数，记为constant</p>
<p>那么新的目标就变为：用$x_n$和$y_n-s_n$做一个regression即可。即：</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-15-14-27-31.png" alt=""> </p>
<p>经过penalize一番折腾之后，h终于有个像模像样的形式了：即regression with residuals（残差）。</p>
<h2 id="求步长η">3.2. 求步长η</h2><p>需要求得一个η，使得下式最小化：</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-15-15-21-27.png" alt=""> </p>
<p>为了方便计算，我们将平方内的项取负：</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-15-15-22-55.png" alt=""> </p>
<p>上式的$y_n-s_n$即residuals（残差）.这是一个单变量的线性回归问题，其中输入是用gt转换后的数据，输出是残差(residual)。</p>
<h1 id="GBDT算法">4. GBDT算法</h1><p>输出：$\sum_t^T\alpha_t g_t(x)$，即一堆权重$\alpha_t$和一堆决策树$g_t(x)$<br>步骤：<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-15-15-32-42.png" alt=""> </p>
<p>1）利用C&amp;RT去学{x, yn-sn}，保留这一轮学出来的树gt(x)</p>
<p>2）再求{gt(x), residual}线性回归，最小化目标函数求出来ita</p>
<p>3）更新sn</p>
<p>学习足够多次数后，返回组合的GBDT。</p>
]]></content>
      
        <categories>
            
            <category> 机器学习算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 树模型 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[jacman/hexo目录改成浮动]]></title>
      <url>/2017/03/14/blog-jacman-hexo%E7%9B%AE%E5%BD%95%E6%94%B9%E6%88%90%E6%B5%AE%E5%8A%A8/</url>
      <content type="html"><![CDATA[<h1 id="添加样式支持">1. 添加样式支持</h1><p>为了不吧原先的像是文件搞得太乱，这里，添加子集的样式文件。<br>首先，在样式文件的<code>source</code>文件夹下找到<code>css</code>文件夹，打开<code>style.styl</code>文件，在最后添加：</p>
<p><code>@import &quot;_my/mycss&quot;;</code> </p>
<h1 id="新建自定义样式">2. 新建自定义样式</h1><p>找到样式文件夹<code>css</code> 新建<code>_my</code>文件夹，在其中新建<code>mycss.sty</code>l文件，之后就可以按照<code>stylus</code>的格式自定义样式了。</p>
<h1 id="设置toc浮动">3. 设置toc浮动</h1><p>给mycss.sty添加：</p>
<pre><code>#toc
 line-height 1.2em
 font-size 0.8em
 backgroud-color #fff
 float right
 position fixed
 right 30em
 top 20em
</code></pre><h1 id="存在的问题">4. 存在的问题</h1><p>暂不支持自相应。</p>
<h1 id="参考文献">5. 参考文献</h1><ol>
<li><a href="https://segmentfault.com/a/1190000003846777" target="_blank" rel="external">Hexo博客主题NexT使用自定义的CSS样式</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> 瞎折腾 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Java学习笔记1-类与对象]]></title>
      <url>/2017/03/14/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<p>本文主要总结了一些自己不太熟悉的概念。</p>
<h1 id="对象与对象变量">1. 对象与对象变量</h1><pre><code>Date birthday = new Date();
</code></pre><p>对象变量：birthday<br>对象：右边的部分</p>
<p>一个对象变量并没有实际包含一个对象，仅仅是引用一个对象。</p>
<p>可以显示地将对象变量设置为<code>null</code>，表明这个对象变量目前没有引用任何对象：</p>
<pre><code>birthday = null;
</code></pre><h1 id="隐式参数与显式参数">2. 隐式参数与显式参数</h1><p>例，methodName()是类class1的方法，</p>
<pre><code>calss class1{
int a;
    public void methodName(int b){
    this.a = b ;
}
</code></pre><ul>
<li>显式参数(explicit)：括号里面的，例如double pName</li>
<li>隐式参数(implicit)：出现在方法名前的class1类对象<br>– 关键词<code>this</code>表示隐式参数。例如<code>this.a</code></li>
</ul>
<h1 id="封装">3. 封装</h1><p>不能编写返回<code>引用可变对象</code>的访问器方法！例如：</p>
<pre><code>class class1{
    private Date a;
    public Date get(){
        return Date a; //会破坏封装性！
    }
}
</code></pre><p>以上操作破坏了<code>a</code>的私有性。</p>
<p>改正方法：克隆（clone）</p>
<pre><code>class class1{
    private Date a;
    public Date get(){
        return Date a.clone(); //使用clone()
    }
}
</code></pre><h1 id="final实例域">4. final实例域</h1><pre><code>class class1{
    private final String name;
}
</code></pre><p>final域的特征：</p>
<ol>
<li>构造对象时，必须初始化final</li>
<li>后面操作中，不能再改动</li>
<li>但并不等于常量！</li>
<li>属于对象，并不是类！</li>
</ol>
<h1 id="static静态">5. static静态</h1><h2 id="static域">5.1. static域</h2><ol>
<li>每个类只能有一个static域</li>
<li>同一类的所有对象共享一个static域</li>
<li>即使没有对象，static域也存在。它属于类，不属于任何一个对象</li>
</ol>
<pre><code>class Employee{
    private static int nextId = 1;
    private int id;
}
</code></pre><h2 id="static常量">5.2. static常量</h2><ol>
<li>如下例，在程序中，可以使用<code>Math.PI</code>来获取这个常量。</li>
</ol>
<pre><code>public class Math{
    public static final double PI = 3.14;
}
</code></pre><h2 id="static方法">5.3. static方法</h2><pre><code>Math.pow(x,a)
</code></pre><ol>
<li>不使用任何对象；</li>
<li>不能操作实例域（即类内的非static方法和变量），因为它不能操作对象；</li>
<li>可以访问自身类的static域；</li>
<li>对象也可以调用static方法。</li>
</ol>
<p>在下面两种情况使用静态方法：</p>
<ol>
<li>一个方法不需要访问对象；</li>
<li>一个方法只需要访问类的static域。</li>
</ol>
<h2 id="工厂方法">5.4. 工厂方法</h2><p>工厂方法是静态方法的一种常见用途。<br>例如，<code>NumberFormat</code>使用工厂方法(而不是构造器)产生<strong>不同风格</strong>的格式对象。</p>
<pre><code>NumberFormat a = NumberFormat.getSytleA();
NumberFormat b = NumberFormat.getStyleB();
</code></pre><h2 id="main方法">5.5. main方法</h2><pre><code>public class Application{
    public static void main(String[] args){
        // construct objects here
    }
}
</code></pre><ol>
<li>每一个类可以有一个main方法，用来单元测试；</li>
<li>多个类被调用时，只会执行一个main方法；</li>
</ol>
<h1 id="初始化块">6. 初始化块</h1><p>构造对象时，先运行初始化块，才运行构造器主体部分。</p>
<pre><code>class Employee{
    private static int nextId;
    private int id;
    //初始化块
    {
        id=nextId;
    }
}
</code></pre><p>如果对类的静态域进行初始化的代码比较复杂，就可以使用静态的初始化块：</p>
<pre><code>static{
    Random generator = new Random();
    nextId = generator.nextId(10000);
}
</code></pre><p>类（！！！不是对象）第一次加载时，将会进行static域的初始化。</p>
<h1 id="初始化数据域的三种方法">7. 初始化数据域的三种方法</h1><ol>
<li>在构造器中设置值</li>
<li>在声明中赋值</li>
<li>在初始化块中赋值</li>
</ol>
<h1 id="类的初始化顺序">8. 类的初始化顺序</h1><p>对于静态变量、静态初始化块、变量、初始化块、构造器，它们的初始化顺序依次是（静态变量、静态初始化块）&gt;（变量、初始化块）&gt;构造器。</p>
<p>例如，</p>
<pre><code>public class InitialOrderTest {   
    // 静态变量   
    public static String staticField = &quot;静态变量&quot;;   
    // 变量   
    public String field = &quot;变量&quot;;   
    // 静态初始化块   
    static {   
        System.out.println(staticField);   
        System.out.println(&quot;静态初始化块&quot;);   
    }   
    // 初始化块   
    {   
        System.out.println(field);   
        System.out.println(&quot;初始化块&quot;);   
    }   
    // 构造器   
    public InitialOrderTest() {   
        System.out.println(&quot;构造器&quot;);   
    }   
    public static void main(String[] args) {   
        new InitialOrderTest();   
    }   
}  
</code></pre><p>运行以上代码，我们会得到如下的输出结果： </p>
<pre><code>静态变量
静态初始化块
变量
初始化块
构造器
</code></pre><p>对于继承的情况：</p>
<pre><code>class Parent {   
    // 静态变量   
    public static String p_StaticField = &quot;父类--静态变量&quot;;   
    // 变量   
    public String p_Field = &quot;父类--变量&quot;;   

    // 静态初始化块   
    static {   
        System.out.println(p_StaticField);   
        System.out.println(&quot;父类--静态初始化块&quot;);   
    }   

    // 初始化块   
    {   
        System.out.println(p_Field);   
        System.out.println(&quot;父类--初始化块&quot;);   
    }   

    // 构造器   
    public Parent() {   
        System.out.println(&quot;父类--构造器&quot;);   
    }   
}   

public class SubClass extends Parent {   
    // 静态变量   
    public static String s_StaticField = &quot;子类--静态变量&quot;;   
    // 变量   
    public String s_Field = &quot;子类--变量&quot;;   
    // 静态初始化块   
    static {   
        System.out.println(s_StaticField);   
        System.out.println(&quot;子类--静态初始化块&quot;);   
    }   
    // 初始化块   
    {   
        System.out.println(s_Field);   
        System.out.println(&quot;子类--初始化块&quot;);   
    }   

    // 构造器   
    public SubClass() {   
        System.out.println(&quot;子类--构造器&quot;);   
    }   

    // 程序入口   
    public static void main(String[] args) {   
        new SubClass();   
    }   
}  
</code></pre><p>运行一下上面的代码，结果马上呈现在我们的眼前： </p>
<pre><code>父类--静态变量
父类--静态初始化块
子类--静态变量
子类--静态初始化块
父类--变量
父类--初始化块
父类--构造器
子类--变量
子类--初始化块
子类--构造器
</code></pre><p>总得来说，是先静态后变量，先父类后子类</p>
<h1 id="其他重点">9. 其他重点</h1><ol>
<li>基于类的访问权限：一个方法可以访问所属类的所有私有数据。</li>
<li>java的值引用（基本数据类型、对象引用）</li>
<li>如果类中提供了至少一个有参构造器，而没有无参构造器，则在构造无参对象时会出错。</li>
</ol>
<h1 id="Java类库中的GregorianCalendar类-（删除本节）">10. Java类库中的GregorianCalendar类 （删除本节）</h1><h2 id="纪元">10.1. 纪元</h2><p>时间是用距离一个固定时间点的毫秒数表示的，这个点就是纪元(epoch)。</p>
<h2 id="时间与日历">10.2. 时间与日历</h2><p>为了将<strong>时间</strong>与<strong>日历</strong>分开，标准Java类库分别包含两个类：</p>
<ul>
<li>Date类：用来表示时间点的类；</li>
<li>GregorianCalendar类：用来表示公历法的类；（通过它还有一个扩展类——Calendar类，描述了日历的一般属性）</li>
</ul>
<h3 id="Date类">10.2.1. Date类</h3><p>用来表示时间的类；</p>
<p>只有少量的方法，例如比较两个时间点before(),after()：</p>
<pre><code>doday.before(birthday)
</code></pre><h3 id="GregorianCalendar类">10.2.2. GregorianCalendar类</h3><p>常见方法：</p>
<p><code>new GregorianCalendar()</code>，构造新的对象，用于表示对象构造时的日期和时间；</p>
<p>例如:</p>
<pre><code>GregorianCalendar g1 = new GregorianCalendar();
</code></pre><p><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-14-10-47-16.png" alt=""> </p>
<p><code>new GregorianCalendar(1999,11,31)</code>，提供年月日构造一个表示特定日期午夜的日历对象。（月份从0开始计数，11表示12月）</p>
<p><code>new GregorianCalendar(1991,Calendar.DECEMBER,31)</code>,与上等价</p>
<p><code>new GregorianCalendar(1991,Calendar.DECEMBER,31,23,59,59)</code>,设置时间</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[O2O优惠券预测——对第一名的思路源码分析（二）]]></title>
      <url>/2017/03/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5-O2O%E4%BC%98%E6%83%A0%E5%88%B8%E9%A2%84%E6%B5%8B-%E5%AF%B9%E7%AC%AC%E4%B8%80%E5%90%8D%E7%9A%84%E6%80%9D%E8%B7%AF%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>本文主要针对天池大数据竞赛之“O2O优惠券使用预测”的冠军队伍的思路和源码分析。在此感谢无私的前辈(诗人都藏在水底)[<a href="https://github.com/wepe/O2O-Coupon-Usage-Forecast]。" target="_blank" rel="external">https://github.com/wepe/O2O-Coupon-Usage-Forecast]。</a></p>
<p>本文主要对模型训练<code>xgb.py</code> 做一些详细的分析。</p>
<p>文件：O2O-Coupon-Usage-Forecast/code/wepon/season one </p>
<p><code>xgb.py</code> 训练xgboost模型，生成特征重要性文件，生成预测结果。单模型第一赛季A榜AUC得分0.798.</p>
<h1 id="import包">1. import包</h1><p>首先作者import xgboost,因此我们需要安装一下它。</p>
<p>XGBoost是数据挖掘中用到一个新型的数据分析包，相对其它Boosting模型更加高效。</p>
<p>安装教程<a href="http://www.jianshu.com/p/11f9229b0ecd" target="_blank" rel="external">xgboost install on windows</a></p>
<h1 id="导入数据">2. 导入数据</h1><pre><code>#将数据集导入
dataset1 = pd.read_csv(&apos;data/dataset1.csv&apos;)
dataset2 = pd.read_csv(&apos;data/dataset2.csv&apos;)
dataset3 = pd.read_csv(&apos;data/dataset3.csv&apos;)
</code></pre><p><code>dataset1、dataset2</code>有56个特征，图是前十个。</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-12-22-11-30.png" alt=""> </p>
<p><code>dataset3</code>有57个特征</p>
<pre><code>#将dataset1的label列的-1都换成0
dataset1.label.replace(-1,0,inplace=True)
dataset2.label.replace(-1,0,inplace=True)

#删除重复项
dataset1.drop_duplicates(inplace=True)
dataset2.drop_duplicates(inplace=True)
dataset3.drop_duplicates(inplace=True)
</code></pre><p>将dataset1和dataset2连起来</p>
<pre><code>dataset12 = pd.concat([dataset1,dataset2],axis=0)
</code></pre><p>dataset1_y赋值为dataset1的label列</p>
<pre><code>dataset1_y = dataset1.label
</code></pre><p>删除dataset1的’user_id’,’label’,’day_gap_before’,’day_gap_after’字段，赋值给dataset1_x</p>
<pre><code>dataset1_x = dataset1.drop([&apos;user_id&apos;,&apos;label&apos;,&apos;day_gap_before&apos;,&apos;day_gap_after&apos;],axis=1)  # &apos;day_gap_before&apos;,&apos;day_gap_after&apos; cause overfitting, 0.77


dataset2_y = dataset2.label
dataset2_x = dataset2.drop([&apos;user_id&apos;,&apos;label&apos;,&apos;day_gap_before&apos;,&apos;day_gap_after&apos;],axis=1)
dataset12_y = dataset12.label
dataset12_x = dataset12.drop([&apos;user_id&apos;,&apos;label&apos;,&apos;day_gap_before&apos;,&apos;day_gap_after&apos;],axis=1)
dataset3_preds = dataset3[[&apos;user_id&apos;,&apos;coupon_id&apos;,&apos;date_received&apos;]]
dataset3_x = dataset3.drop([&apos;user_id&apos;,&apos;coupon_id&apos;,&apos;date_received&apos;,&apos;day_gap_before&apos;,&apos;day_gap_after&apos;],axis=1)
</code></pre><p>用shape属性来显示数据的格式</p>
<pre><code>print dataset1_x.shape,dataset2_x.shape,dataset3_x.shape
</code></pre><p>若输出：(8618,36) 表示这个表格有8618行和36列的数据，其中dimensions[0]为8618，dimensions[1]为36</p>
<h1 id="加载数据到xgboost">3. 加载数据到xgboost</h1><p>dataset1、dateset2、dateset3 为xgb的DMatrix</p>
<pre><code>dataset1 = xgb.DMatrix(dataset1_x,label=dataset1_y)
dataset2 = xgb.DMatrix(dataset2_x,label=dataset2_y)
dataset12 = xgb.DMatrix(dataset12_x,label=dataset12_y)
dataset3 = xgb.DMatrix(dataset3_x)
</code></pre><p>参考文献<a href="http://blog.csdn.net/sb19931201/article/details/52557382" target="_blank" rel="external">xgboost入门与实战（原理篇）</a></p>
<h1 id="设置参数">4. 设置参数</h1><pre><code>params={&apos;booster&apos;:&apos;gbtree&apos;,
        &apos;objective&apos;: &apos;rank:pairwise&apos;,
        &apos;eval_metric&apos;:&apos;auc&apos;,
        &apos;gamma&apos;:0.1,
        &apos;min_child_weight&apos;:1.1,
        &apos;max_depth&apos;:5,
        &apos;lambda&apos;:10,
        &apos;subsample&apos;:0.7,
        &apos;colsample_bytree&apos;:0.7,
        &apos;colsample_bylevel&apos;:0.7,
        &apos;eta&apos;: 0.01,
        &apos;tree_method&apos;:&apos;exact&apos;,
        &apos;seed&apos;:0,
        &apos;nthread&apos;:12
        }
</code></pre><h1 id="训练模型">5. 训练模型</h1><pre><code>model = xgb.train(params,dataset12,num_boost_round=3500,evals=watchlist)    
</code></pre><h1 id="预测测试集">6. 预测测试集</h1><pre><code>dataset3_preds[&apos;label&apos;] = model.predict(dataset3)
dataset3_preds.label = MinMaxScaler().fit_transform(dataset3_preds.label)
dataset3_preds.sort_values(by=[&apos;coupon_id&apos;,&apos;label&apos;],inplace=True)
dataset3_preds.to_csv(&quot;xgb_preds.csv&quot;,index=None,header=None)
print dataset3_preds.describe()
</code></pre><h1 id="保存特征评分">7. 保存特征评分</h1><pre><code>feature_score = model.get_fscore()
feature_score = sorted(feature_score.items(), key=lambda x:x[1],reverse=True)
fs = []
for (key,value) in feature_score:
    fs.append(&quot;{0},{1}\n&quot;.format(key,value))

with open(&apos;xgb_feature_score.csv&apos;,&apos;w&apos;) as f:
    f.writelines(&quot;feature,score\n&quot;)
    f.writelines(fs)
</code></pre><h1 id="总结">8. 总结</h1><p>这次算是对自己之前的各种理论知识进行了一次梳理，感觉平时过于注重算法的研究，并没有注意到宏观上的操作。以后要多加注意</p>
]]></content>
      
        <categories>
            
            <category> o2o优惠券使用预测 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[O2O优惠券预测——对第一名的思路源码分析（一）]]></title>
      <url>/2017/03/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5-O2O%E4%BC%98%E6%83%A0%E5%88%B8%E9%A2%84%E6%B5%8B-%E5%AF%B9%E7%AC%AC%E4%B8%80%E5%90%8D%E7%9A%84%E6%80%9D%E8%B7%AF%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>感觉自己还是太渣，看了些许算法，并不知道有什么卵用。决定好好分析分析别人的思路，也许能够对我带来些许启发。</p>
<p>本文主要针对天池大数据竞赛之“O2O优惠券使用预测”的冠军队伍的思路和源码分析。在此感谢无私的前辈(诗人都藏在水底)[<a href="https://github.com/wepe/O2O-Coupon-Usage-Forecast]。" target="_blank" rel="external">https://github.com/wepe/O2O-Coupon-Usage-Forecast]。</a></p>
<p>本文主要对数据的抽取<code>extract_feature.py</code>做一些详细的分析。</p>
<h1 id="解决方案概述">1. 解决方案概述</h1><p>本赛题提供了用户线下消费和优惠券领取核销行为的纪录表，用户线上点击/消费和优惠券领取核销行为的纪录表，记录的时间区间是2016.01.01至2016.06.30,需要预测的是2016年7月份用户领取优惠劵后是否核销。根据这两份数据表，我们首先对数据集进行划分，然后提取了用户相关的特征、商家相关的特征，优惠劵相关的特征，用户与商家之间的交互特征，以及利用本赛题的leakage得到的其它特征（这部分特征在实际业务中是不可能获取到的）。最后训练了XGBoost，GBDT，RandomForest进行模型融合。</p>
<p><strong>源码分析</strong></p>
<p>第二赛季暂时没有平台，所以本文只对第一赛季的源码进行分析。</p>
<p>文件：O2O-Coupon-Usage-Forecast/code/wepon/season one </p>
<p>这个文件夹存放第一赛季的代码</p>
<ul>
<li><code>extract_feature.py</code>划分数据集，提取特征，生成训练集（dataset1和dataset2）和预测集（dataset3）。</li>
<li><code>xgb.py</code> 训练xgboost模型，生成特征重要性文件，生成预测结果。单模型第一赛季A榜AUC得分0.798.</li>
</ul>
<h1 id="import概述">2. import概述</h1><p>分析对象：extract_feature.py</p>
<h2 id="import包概述">2.1. import包概述</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date</div></pre></td></tr></table></figure>
<h2 id="pandas">2.2. pandas</h2><p>Pandas 是基于 NumPy (因此还要<code>import numpy</code>) 的一个非常好用的库，正如名字一样，人见人爱。之所以如此，就在于不论是读取、处理数据，用它都非常简单。Pandas提供了很多处理大数据的方法。我想是因为此，原作者才采用了它。</p>
<p>Pandas 有两种自己独有的基本数据结构。<code>Series</code> 和 <code>DataFrame</code>，它们让数据操作更简单了。</p>
<p>两种结构的属性和方法不再多阐述。见两份很好的参考文档：</p>
<ol>
<li><a href="http://wiki.jikexueyuan.com/project/start-learning-python/311.html" target="_blank" rel="external">Pandas 使用</a></li>
<li><a href="http://www.cnblogs.com/chaosimple/p/4153083.html" target="_blank" rel="external">十分钟搞定pandas</a></li>
<li><a href="http://dataunion.org/14261.html" target="_blank" rel="external">在Python中利用Pandas库处理大数据的简单介绍</a></li>
<li><a href="http://pandas.pydata.org/pandas-docs/stable/cookbook.html" target="_blank" rel="external">pandas官方文档</a></li>
<li><a href="http://www.cnblogs.com/pengsixiong/p/5050833.html" target="_blank" rel="external">pandas常见方法，中文</a></li>
</ol>
<p>大概知道了import包的内容后，我们正式开始看源码。</p>
<h2 id="注意">2.3. 注意</h2><ol>
<li>读取之前，请先把数据的表头项删除（也就是第一行的string）</li>
</ol>
<h1 id="读取数据集">3. 读取数据集</h1><p>总结：</p>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:right">name</th>
<th style="text-align:right">content</th>
<th style="text-align:center">varName</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td style="text-align:right">ccf_offline_stage1_train</td>
<td style="text-align:right">用户线下消费和优惠券领取行为</td>
<td style="text-align:center">off_train</td>
</tr>
<tr>
<td>2</td>
<td style="text-align:right">ccf_online_stage1_train</td>
<td style="text-align:right">用户线上点击/消费和优惠券领取行为</td>
<td style="text-align:center">on_train</td>
</tr>
<tr>
<td>3</td>
<td style="text-align:right">offline_stage1_test_revised</td>
<td style="text-align:right">用户O2O线下优惠券使用预测样本</td>
<td style="text-align:center">off_test</td>
</tr>
</tbody>
</table>
<h2 id="源码分析">3.1. 源码分析</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#1754884 record,1053282 with coupon_id,9738 coupon. date_received:20160101~20160615,date:20160101~20160630, 539438 users, 8415 merchants</span></div><div class="line"></div><div class="line">off_train = pd.read_csv(<span class="string">'data/ccf_offline_stage1_train.csv'</span>,header=<span class="keyword">None</span>)</div><div class="line">off_train.columns = [<span class="string">'user_id'</span>,<span class="string">'merchant_id'</span>,<span class="string">'coupon_id'</span>,<span class="string">'discount_rate'</span>,<span class="string">'distance'</span>,<span class="string">'date_received'</span>,<span class="string">'date'</span>]</div><div class="line"></div><div class="line"><span class="comment">#2050 coupon_id. date_received:20160701~20160731, 76309 users(76307 in trainset, 35965 in online_trainset), 1559 merchants(1558 in trainset)</span></div><div class="line"></div><div class="line">off_test = pd.read_csv(<span class="string">'data/ccf_offline_stage1_test_revised.csv'</span>,header=<span class="keyword">None</span>,nrows=<span class="number">3000</span>)</div><div class="line">off_test.columns = [<span class="string">'user_id'</span>,<span class="string">'merchant_id'</span>,<span class="string">'coupon_id'</span>,<span class="string">'discount_rate'</span>,<span class="string">'distance'</span>,<span class="string">'date_received'</span>]</div><div class="line"></div><div class="line"><span class="comment">#11429826 record(872357 with coupon_id),762858 user(267448 in off_train)</span></div><div class="line"></div><div class="line">on_train = pd.read_csv(<span class="string">'data/ccf_online_stage1_train.csv'</span>,header=<span class="keyword">None</span>,nrows=<span class="number">47000</span>)</div><div class="line">on_train.columns = [<span class="string">'user_id'</span>,<span class="string">'merchant_id'</span>,<span class="string">'action'</span>,<span class="string">'coupon_id'</span>,<span class="string">'discount_rate'</span>,<span class="string">'date_received'</span>,<span class="string">'date'</span>]</div></pre></td></tr></table></figure>
<p>读数据主要用了pandas的read_cvs方法. 为了快捷分析，我们限定只读取数据集的前7w、3k、47w行</p>
<h1 id="采集特征">4. 采集特征</h1><h2 id="主要特征">4.1. 主要特征</h2><p>总结：</p>
<table>
<thead>
<tr>
<th>term</th>
<th style="text-align:right">来源</th>
<th style="text-align:center">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>dataset3</td>
<td style="text-align:right">table3,off_test</td>
<td style="text-align:center">off_test数据</td>
</tr>
<tr>
<td>dataset2</td>
<td style="text-align:right">table2,off_train</td>
<td style="text-align:center">领券时期在20160515-20160615之间的</td>
</tr>
<tr>
<td>dataset1</td>
<td style="text-align:right">table2,off_train</td>
<td style="text-align:center">领券日期在20160414-20160514的</td>
</tr>
<tr>
<td>feature3</td>
<td style="text-align:right">table2,off_train</td>
<td style="text-align:center">消费data在20160315-20160630的，或领券日期在20160315-20160630但没有消费的</td>
</tr>
<tr>
<td>feature2</td>
<td style="text-align:right">table2,off_train</td>
<td style="text-align:center">消费日期在20160201-20160514的，或领券日期在20160201-20160514但没有消费的</td>
</tr>
<tr>
<td>feature1</td>
<td style="text-align:right">table2,off_train</td>
<td style="text-align:center">消费日期在20160101-20160413的，或领券日期在20160101-20160413但没有消费的</td>
</tr>
</tbody>
</table>
<p>这是滑窗的方法得到多份训练数据集，特征区间越小，得到的训练数据集越多。划分方式：</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>预测区间（提取label）</th>
<th style="text-align:center">特征区间（提取feature）</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>领券了的</td>
<td style="text-align:center">消费了的+领券了没消费的</td>
</tr>
<tr>
<td>测试集</td>
<td>dataset3</td>
<td style="text-align:center">feature3</td>
</tr>
<tr>
<td>训练集1</td>
<td>dataset2</td>
<td style="text-align:center">feature2</td>
</tr>
<tr>
<td>训练集2</td>
<td>dataset1</td>
<td style="text-align:center">feature1</td>
</tr>
</tbody>
</table>
<p>上面这个表格很清晰地说明了原作者划分数据的方法.</p>
<h3 id="源码分析-1">4.1.1. 源码分析</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#dataset3存放table3 的数据</span></div><div class="line">dataset3 = off_test </div><div class="line"></div><div class="line"><span class="comment">#feature3存放：筛出off_train中，以下四种情况：</span></div><div class="line"><span class="comment">#消费日期data在20160315-20160630的，</span></div><div class="line"><span class="comment">#或消费日期为空且领券日期在20160315-20160630的，</span></div><div class="line">feature3 = off_train[</div><div class="line">((off_train.date&gt;=<span class="string">'20160315'</span>)&amp;(off_train.date&lt;=<span class="string">'20160630'</span>))</div><div class="line">|((off_train.date==<span class="string">'null'</span>)&amp;(off_train.date_received&gt;=<span class="string">'20160315'</span>)&amp;(off_train.date_received&lt;=<span class="string">'20160630'</span>))]</div><div class="line"></div><div class="line"><span class="comment">#dataset2存放：从off_train筛出：领券时期在20160515-20160615之间的</span></div><div class="line">dataset2 = off_train[</div><div class="line">(off_train.date_received&gt;=<span class="string">'20160515'</span>)&amp;off_train.date_received&lt;=<span class="string">'20160615'</span>)]</div><div class="line"></div><div class="line"><span class="comment">#feature2存放：从off_train筛出：</span></div><div class="line"><span class="comment">#消费日期在20160201-20160514的，</span></div><div class="line"><span class="comment">#或领券日期在20160201-20160514但没有消费的</span></div><div class="line">feature2 = off_train[(off_train.date&gt;=<span class="string">'20160201'</span>)&amp;(off_train.date&lt;=<span class="string">'20160514'</span>)|((off_train.date==<span class="string">'null'</span>)&amp;(off_train.date_received&gt;=<span class="string">'20160201'</span>)&amp;(off_train.date_received&lt;=<span class="string">'20160514'</span>))]</div><div class="line"></div><div class="line"><span class="comment">#dataset1存放：从off_train筛出： 领券日期在20160414-20160514的</span></div><div class="line">dataset1 = off_train[(off_train.date_received&gt;=<span class="string">'20160414'</span>)&amp;(off_train.date_received&lt;=<span class="string">'20160514'</span>)]</div><div class="line"></div><div class="line"><span class="comment">#feature1存放：从off_train筛出：</span></div><div class="line"><span class="comment">#消费日期在20160101-20160413的，或</span></div><div class="line"><span class="comment">#领券日期在20160101-20160413但没有消费的</span></div><div class="line">feature1 = off_train[(off_train.date&gt;=<span class="string">'20160101'</span>)&amp;(off_train.date&lt;=<span class="string">'20160413'</span>)|((off_train.date==<span class="string">'null'</span>)&amp;(off_train.date_received&gt;=<span class="string">'20160101'</span>)&amp;(off_train.date_received&lt;=<span class="string">'20160413'</span>))]</div></pre></td></tr></table></figure>
<h2 id="其他特征">4.2. 其他特征</h2><h3 id="other-feature3">4.2.1. other_feature3</h3><table>
<thead>
<tr>
<th></th>
<th style="text-align:right">内容（都是来自测试集dataset3的数据）</th>
</tr>
</thead>
<tbody>
<tr>
<td>t</td>
<td style="text-align:right">每个用户使用优惠券的总次数</td>
</tr>
<tr>
<td>t1</td>
<td style="text-align:right">每个用户使用不同优惠券的次数</td>
</tr>
<tr>
<td>t2</td>
<td style="text-align:right">每个用户使用某张优惠券（使用次数大于1次）的首次和末次使用时间</td>
</tr>
<tr>
<td>t3</td>
<td style="text-align:right">每个用户用优惠券date；本优惠券首、末次间隔；本优惠券首/末次使用date</td>
</tr>
<tr>
<td>t4</td>
<td style="text-align:right">每个用户每天使用优惠券的次数</td>
</tr>
<tr>
<td>t5</td>
<td style="text-align:right">每个用户每天使用每张优惠券的次数</td>
</tr>
<tr>
<td>t6</td>
<td style="text-align:right">用户使用每张优惠券的date，不同date用冒号分隔</td>
</tr>
<tr>
<td>t7</td>
<td style="text-align:right">用户使用每张券的时间，以及和前、后一张券的时间间隔</td>
</tr>
</tbody>
</table>
<p>文件名：data/other_feature3.csv</p>
<p>格式：user_id,coupon_id,this_month_user_receive_same_coupon_count,this_month_user_receive_all_coupon_count,date_received,this_month_user_receive_same_coupon_lastone,this_month_user_receive_same_coupon_firstone,this_day_user_receive_all_coupon_count,this_day_user_receive_same_coupon_count,day_gap_before,day_gap_after</p>
<p>解释：用户id,优惠券id,本月用户使用本券次数，本月用户使用所有券次数，使用时间，本月用户使用本券末次时间、首次时间，本日用户用券总数，本日用户用本券总数，上次用本券间隔，下次用本券间隔</p>
<h4 id="源码分析-2">4.2.1.1. 源码分析</h4><p>t:计算每个用户使用优惠券的总次数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#将测试集dataset3的userid存在t中</span></div><div class="line">t = dataset3[[<span class="string">'user_id'</span>]]</div><div class="line"><span class="comment">#给t添加一个列，列名是this_month_user_receive_all_coupon_count，值都是1</span></div><div class="line">t[<span class="string">'this_month_user_receive_all_coupon_count'</span>] = <span class="number">1</span></div><div class="line"><span class="comment">#按照user_id分组，将user_id重复的项目的this_month_user_receive_all_coupon_count相加，然后进行reset_index</span></div><div class="line"><span class="comment">#其实就是算出每个用户使用优惠券的总次数</span></div><div class="line">t = t.groupby(<span class="string">'user_id'</span>).agg(<span class="string">'sum'</span>).reset_index()</div></pre></td></tr></table></figure>
<p>t1:统计每个用户，使用不同优惠券的次数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">t1 = dataset3[[<span class="string">'user_id'</span>,<span class="string">'coupon_id'</span>]]</div><div class="line">t1[<span class="string">'this_month_user_receive_same_coupon_count'</span>] = <span class="number">1</span></div><div class="line"><span class="comment">#按照user_id和coupon_id进行分组</span></div><div class="line"><span class="comment">#统计每个用户，使用不同优惠券的次数</span></div><div class="line">t1 = t1.groupby([<span class="string">'user_id'</span>,<span class="string">'coupon_id'</span>]).agg(<span class="string">'sum'</span>).reset_index()</div></pre></td></tr></table></figure>
<p>t2:找出每个人，消费每个券的时间，并用冒号分隔例如：<img src="http://om1bxijvl.bkt.clouddn.com/2017-03-09-20-10-27.png" alt=""> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">t2 = dataset3[[<span class="string">'user_id'</span>,<span class="string">'coupon_id'</span>,<span class="string">'date_received'</span>]]</div><div class="line">t2.date_received = t2.date_received.astype(<span class="string">'str'</span>)</div><div class="line"><span class="comment"># 按照user_id','coupon_id排序后，提出来date_received，进行agg运算</span></div><div class="line"><span class="comment"># agg运算：用冒号连接起来</span></div><div class="line">t2 = t2.groupby([<span class="string">'user_id'</span>,<span class="string">'coupon_id'</span>])[<span class="string">'date_received'</span>].agg(<span class="keyword">lambda</span> x:<span class="string">':'</span>.join(x)).reset_index()</div></pre></td></tr></table></figure>
<p>t2:每个用户使用某张优惠券（使用次数大于1次）的首次和末次使用时间</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#apply会返回每个优惠券的使用次数</span></div><div class="line">t2[<span class="string">'receive_number'</span>] = t2.date_received.apply(<span class="keyword">lambda</span> s:len(s.split(<span class="string">':'</span>)))</div><div class="line"><span class="comment">#筛出使用次数大于1次的数据</span></div><div class="line">t2 = t2[t2.receive_number&gt;<span class="number">1</span>]</div><div class="line"><span class="comment">#对max_date_received赋值为最近一次的使用时间</span></div><div class="line">t2[<span class="string">'max_date_received'</span>] = t2.date_received.apply(<span class="keyword">lambda</span> s:max([int(d) <span class="keyword">for</span> d <span class="keyword">in</span> s.split(<span class="string">':'</span>)]))</div><div class="line"><span class="comment">#对min_date_received赋值为最早一次的使用时间</span></div><div class="line">t2[<span class="string">'min_date_received'</span>] = t2.date_received.apply(<span class="keyword">lambda</span> s:min([int(d) <span class="keyword">for</span> d <span class="keyword">in</span> s.split(<span class="string">':'</span>)]))</div><div class="line"><span class="comment"># 重新定义t2为以下项目</span></div><div class="line">t2 = t2[[<span class="string">'user_id'</span>,<span class="string">'coupon_id'</span>,<span class="string">'max_date_received'</span>,<span class="string">'min_date_received'</span>]]</div></pre></td></tr></table></figure>
<p>t3:每个用户使用优惠券的时间、本次优惠券与首次使用的间隔、末次使用的间隔</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">t3 = dataset3[[<span class="string">'user_id'</span>,<span class="string">'coupon_id'</span>,<span class="string">'date_received'</span>]]</div><div class="line"><span class="comment">#merge，将两个数据集合并</span></div><div class="line"><span class="comment">#将t2和t3在['user_id','coupon_id']上进行左帧合并，即根据t3合并t2的user_id','coupon_id</span></div><div class="line"><span class="comment">#t2[['user_id','coupon_id','max_date_received','min_date_received']]</span></div><div class="line"><span class="comment">#t3[['user_id','coupon_id','date_received']]</span></div><div class="line"><span class="comment">#因此合并方式为：找到每个用户每张优惠券的消费时间和对应券的max_date_received与min_date_received</span></div><div class="line">t3 = pd.merge(t3,t2,on=[<span class="string">'user_id'</span>,<span class="string">'coupon_id'</span>],how=<span class="string">'left'</span>)</div><div class="line"><span class="comment">#t3的this_month_user_receive_same_coupon_lastone项目设置为:此用户消费本张优惠券与最近一次消费本张优惠券的间隔</span></div><div class="line"></div><div class="line">t3 = t3.apply(pd.to_numeric, args=(<span class="string">'coerce'</span>,))</div><div class="line">t3[<span class="string">'this_month_user_receive_same_coupon_lastone'</span>] = t3.max_date_received - t3.date_received</div><div class="line"><span class="comment">#此用户消费本张优惠券与第一次消费本张优惠券的间隔</span></div><div class="line">t3[<span class="string">'this_month_user_receive_same_coupon_firstone'</span>] = t3.date_received - t3.min_date_received</div></pre></td></tr></table></figure>
<p>上面跑到<code>t3[&#39;this_month_user_receive_same_coupon_lastone&#39;] = t3.max_date_received - t3.date_received</code>的时候会出现<code>TypeError: unsupported operand type(s) for -: &#39;float&#39; and &#39;str&#39;</code>.</p>
<p>在执行这句话之前，我们看到<code>t3.date_received</code>的类型为<img src="http://om1bxijvl.bkt.clouddn.com/2017-03-09-22-39-21.png" alt=""> </p>
<p>因此我们需要将数据类型先转换为float。在网上查到本方法对本代码有效（暂不知原因）。<a href="http://stackoverflow.com/questions/14450020/unsupported-operand-in-pandas-dataframe-operation" target="_blank" rel="external">参考文献</a></p>
<p><code>t3 = t3.apply(pd.anumeric, args=(&#39;coerce&#39;,))</code></p>
<p>把这句话加上后，我们看到<img src="http://om1bxijvl.bkt.clouddn.com/2017-03-09-22-43-02.png" alt=""> </p>
<p>定义函数is_firstlastone判断优惠券是否是末次使用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_firstlastone</span><span class="params">(x)</span>:</span></div><div class="line">    <span class="keyword">if</span> x==<span class="number">0</span>:</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span></div><div class="line">    <span class="keyword">elif</span> x&gt;<span class="number">0</span>:</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span> <span class="comment">#those only receive once</span></div></pre></td></tr></table></figure>
<p>t3:加上两个数据，…</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">t3.this_month_user_receive_same_coupon_lastone = t3.this_month_user_receive_same_coupon_lastone.apply(is_firstlastone)</div><div class="line">t3.this_month_user_receive_same_coupon_firstone = t3.this_month_user_receive_same_coupon_firstone.apply(is_firstlastone)</div><div class="line">t3 = t3[[<span class="string">'user_id'</span>,<span class="string">'coupon_id'</span>,<span class="string">'date_received'</span>,<span class="string">'this_month_user_receive_same_coupon_lastone'</span>,<span class="string">'this_month_user_receive_same_coupon_firstone'</span>]]</div></pre></td></tr></table></figure>
<p>后面套路差不多，此处不再继续分析。主要结论已经总结在上表中。</p>
<h1 id="合并特征">5. 合并特征</h1><h2 id="生成训练集">5.1. 生成训练集</h2><pre><code>coupon2 = pd.read_csv(&apos;data/coupon2_feature.csv&apos;)
merchant2 = pd.read_csv(&apos;data/merchant2_feature.csv&apos;)
user2 = pd.read_csv(&apos;data/user2_feature.csv&apos;)
user_merchant2 = pd.read_csv(&apos;data/user_merchant2.csv&apos;)
other_feature2 = pd.read_csv(&apos;data/other_feature2.csv&apos;)
#dataset2是根据 优惠券特征 合并商户、用户、用户-商户、其他特征
dataset2 = pd.merge(coupon2,merchant2,on=&apos;merchant_id&apos;,how=&apos;left&apos;)
dataset2 = pd.merge(dataset2,user2,on=&apos;user_id&apos;,how=&apos;left&apos;)
dataset2 = pd.merge(dataset2,user_merchant2,on=[&apos;user_id&apos;,&apos;merchant_id&apos;],how=&apos;left&apos;)
dataset2 = pd.merge(dataset2,other_feature2,on=[&apos;user_id&apos;,&apos;coupon_id&apos;,&apos;date_received&apos;],how=&apos;left&apos;)
dataset2.drop_duplicates(inplace=True)
print dataset2.shape
dataset2.user_merchant_buy_total = dataset2.user_merchant_buy_total.replace(np.nan,0)
dataset2.user_merchant_any = dataset2.user_merchant_any.replace(np.nan,0)
dataset2.user_merchant_received = dataset2.user_merchant_received.replace(np.nan,0)
dataset2[&apos;is_weekend&apos;] = dataset2.day_of_week.apply(lambda x:1 if x in (6,7) else 0)
weekday_dummies = pd.get_dummies(dataset2.day_of_week)
weekday_dummies.columns = [&apos;weekday&apos;+str(i+1) for i in range(weekday_dummies.shape[1])]
dataset2 = pd.concat([dataset2,weekday_dummies],axis=1)
dataset2[&apos;label&apos;] = dataset2.date.astype(&apos;str&apos;) + &apos;:&apos; +  dataset2.date_received.astype(&apos;str&apos;)
dataset2.label = dataset2.label.apply(get_label)
dataset2.drop([&apos;merchant_id&apos;,&apos;day_of_week&apos;,&apos;date&apos;,&apos;date_received&apos;,&apos;coupon_id&apos;,&apos;coupon_count&apos;],axis=1,inplace=True)
dataset2 = dataset2.replace(&apos;null&apos;,np.nan)
dataset2.to_csv(&apos;data/dataset2.csv&apos;,index=None)


coupon1 = pd.read_csv(&apos;data/coupon1_feature.csv&apos;)
merchant1 = pd.read_csv(&apos;data/merchant1_feature.csv&apos;)
user1 = pd.read_csv(&apos;data/user1_feature.csv&apos;)
user_merchant1 = pd.read_csv(&apos;data/user_merchant1.csv&apos;)
other_feature1 = pd.read_csv(&apos;data/other_feature1.csv&apos;)
dataset1 = pd.merge(coupon1,merchant1,on=&apos;merchant_id&apos;,how=&apos;left&apos;)
dataset1 = pd.merge(dataset1,user1,on=&apos;user_id&apos;,how=&apos;left&apos;)
dataset1 = pd.merge(dataset1,user_merchant1,on=[&apos;user_id&apos;,&apos;merchant_id&apos;],how=&apos;left&apos;)
dataset1 = pd.merge(dataset1,other_feature1,on=[&apos;user_id&apos;,&apos;coupon_id&apos;,&apos;date_received&apos;],how=&apos;left&apos;)
dataset1.drop_duplicates(inplace=True)
print dataset1.shape

dataset1.user_merchant_buy_total = dataset1.user_merchant_buy_total.replace(np.nan,0)
dataset1.user_merchant_any = dataset1.user_merchant_any.replace(np.nan,0)
dataset1.user_merchant_received = dataset1.user_merchant_received.replace(np.nan,0)
dataset1[&apos;is_weekend&apos;] = dataset1.day_of_week.apply(lambda x:1 if x in (6,7) else 0)
weekday_dummies = pd.get_dummies(dataset1.day_of_week)
weekday_dummies.columns = [&apos;weekday&apos;+str(i+1) for i in range(weekday_dummies.shape[1])]
dataset1 = pd.concat([dataset1,weekday_dummies],axis=1)
dataset1[&apos;label&apos;] = dataset1.date.astype(&apos;str&apos;) + &apos;:&apos; +  dataset1.date_received.astype(&apos;str&apos;)
dataset1.label = dataset1.label.apply(get_label)
dataset1.drop([&apos;merchant_id&apos;,&apos;day_of_week&apos;,&apos;date&apos;,&apos;date_received&apos;,&apos;coupon_id&apos;,&apos;coupon_count&apos;],axis=1,inplace=True)
dataset1 = dataset1.replace(&apos;null&apos;,np.nan)
dataset1.to_csv(&apos;data/dataset1.csv&apos;,index=None)
</code></pre><h2 id="生成预测集">5.2. 生成预测集</h2><pre><code>coupon3 = pd.read_csv(&apos;data/coupon3_feature.csv&apos;)
merchant3 = pd.read_csv(&apos;data/merchant3_feature.csv&apos;)
user3 = pd.read_csv(&apos;data/user3_feature.csv&apos;)
user_merchant3 = pd.read_csv(&apos;data/user_merchant3.csv&apos;)
other_feature3 = pd.read_csv(&apos;data/other_feature3.csv&apos;)
dataset3 = pd.merge(coupon3,merchant3,on=&apos;merchant_id&apos;,how=&apos;left&apos;)
dataset3 = pd.merge(dataset3,user3,on=&apos;user_id&apos;,how=&apos;left&apos;)
dataset3 = pd.merge(dataset3,user_merchant3,on=[&apos;user_id&apos;,&apos;merchant_id&apos;],how=&apos;left&apos;)
dataset3 = pd.merge(dataset3,other_feature3,on=[&apos;user_id&apos;,&apos;coupon_id&apos;,&apos;date_received&apos;],how=&apos;left&apos;)
dataset3.drop_duplicates(inplace=True)
print dataset3.shape

dataset3.user_merchant_buy_total = dataset3.user_merchant_buy_total.replace(np.nan,0)
dataset3.user_merchant_any = dataset3.user_merchant_any.replace(np.nan,0)
dataset3.user_merchant_received = dataset3.user_merchant_received.replace(np.nan,0)
dataset3[&apos;is_weekend&apos;] = dataset3.day_of_week.apply(lambda x:1 if x in (6,7) else 0)
weekday_dummies = pd.get_dummies(dataset3.day_of_week)
weekday_dummies.columns = [&apos;weekday&apos;+str(i+1) for i in range(weekday_dummies.shape[1])]
dataset3 = pd.concat([dataset3,weekday_dummies],axis=1)
dataset3.drop([&apos;merchant_id&apos;,&apos;day_of_week&apos;,&apos;coupon_count&apos;],axis=1,inplace=True)
dataset3 = dataset3.replace(&apos;null&apos;,np.nan)
dataset3.to_csv(&apos;data/dataset3.csv&apos;,index=None)
</code></pre><h1 id="附录">6. 附录</h1><h2 id="查看dataFrame类型的内容">6.1. 查看dataFrame类型的内容</h2><p>见pandas 文档之 10 minutes to pandas — viewing data</p>
<p>用t.values,t.columns</p>
<h2 id="lambda-functions">6.2. lambda functions</h2><p>源代码中有一行<code>t2.groupby([&#39;user_id&#39;,&#39;coupon_id&#39;])[&#39;date_received&#39;].agg(lambda x:&#39;:&#39;.join(x)).reset_index()</code></p>
<p><a href="http://www.diveintopython.net/power_of_introspection/lambda_functions.html" target="_blank" rel="external">官方文档</a></p>
<p><code>lambda functions</code>是python的一个function.<br>用例：</p>
<pre><code>#函数f(x)
&gt;&gt;&gt; def f(x):
...     return x*2
...
&gt;&gt;&gt; f(3) #输入x=3     
6 #输出6

#f(x)等价于：
&gt;&gt;&gt; g = lambda x: x*2  1
&gt;&gt;&gt; g(3)
6
#f(x)还等价于：
&gt;&gt;&gt; (lambda x: x*2)(3) 2
6
</code></pre><p>作者代码中，有一行<br><code>lambda x:&#39;:&#39;.join(x)</code>即将前后叠加,用<code>:</code>连接<br><code>t2.groupby([&#39;user_id&#39;,&#39;coupon_id&#39;])[&#39;date_received&#39;].agg(lambda x:&#39;:&#39;.join(x)).reset_index()</code>意思是将数据集先按照user_id’,’coupon_id排序，然后对date_received进行用:连接一起来</p>
<p>例如，输入：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">df = pd.DataFrame(&#123;<span class="string">'A'</span> : [<span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'foo'</span>, <span class="string">'bar'</span>,</div><div class="line">                            <span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'foo'</span>, <span class="string">'foo'</span>],</div><div class="line">                            <span class="string">'B'</span> : [<span class="string">'one'</span>, <span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>,</div><div class="line">                             <span class="string">'two'</span>, <span class="string">'two'</span>, <span class="string">'one'</span>, <span class="string">'three'</span>],</div><div class="line">                            <span class="string">'C'</span> : np.random.randn(<span class="number">8</span>),</div><div class="line">                            <span class="string">'D'</span> : np.random.randn(<span class="number">8</span>)&#125;)</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>i</th>
<th style="text-align:right">A</th>
<th style="text-align:right">B</th>
<th style="text-align:right">C</th>
<th style="text-align:right">D</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td style="text-align:right">foo</td>
<td style="text-align:right">one</td>
<td style="text-align:right">0.754147</td>
<td style="text-align:right">0.912176</td>
</tr>
<tr>
<td>1</td>
<td style="text-align:right">bar</td>
<td style="text-align:right">one</td>
<td style="text-align:right">1.414635</td>
<td style="text-align:right">-0.760638</td>
</tr>
<tr>
<td>2</td>
<td style="text-align:right">foo</td>
<td style="text-align:right">two</td>
<td style="text-align:right">-0.142930</td>
<td style="text-align:right">-1.290766</td>
</tr>
<tr>
<td>3</td>
<td style="text-align:right">bar</td>
<td style="text-align:right">three</td>
<td style="text-align:right">1.196999</td>
<td style="text-align:right">1.647513</td>
</tr>
<tr>
<td>4</td>
<td style="text-align:right">foo</td>
<td style="text-align:right">two</td>
<td style="text-align:right">-0.261663</td>
<td style="text-align:right">1.284779</td>
</tr>
<tr>
<td>5</td>
<td style="text-align:right">bar</td>
<td style="text-align:right">two</td>
<td style="text-align:right">1.622070</td>
<td style="text-align:right">1.685648</td>
</tr>
<tr>
<td>6</td>
<td style="text-align:right">foo</td>
<td style="text-align:right">one</td>
<td style="text-align:right">1.478855</td>
<td style="text-align:right">-0.229636</td>
</tr>
</tbody>
</table>
<pre><code>df3 = df.groupby([&apos;A&apos;])[&apos;B&apos;].agg(lambda x:&apos;:&apos;.join(x)).reset_index()
</code></pre><p>输出：</p>
<table>
<thead>
<tr>
<th>i</th>
<th style="text-align:right">A</th>
<th style="text-align:right">B</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td style="text-align:right">bar</td>
<td style="text-align:right"><code>one:three:two</code></td>
</tr>
<tr>
<td>1</td>
<td style="text-align:right">foo</td>
<td style="text-align:right"><code>one:two:two:one:three</code></td>
</tr>
</tbody>
</table>
<h2 id="pandas的merge的how参数">6.3. pandas的merge的how参数</h2><p>原代码出现了<code>t3 = pd.merge(t3,t2,on=[&#39;user_id&#39;,&#39;coupon_id&#39;],how=&#39;left&#39;)</code></p>
<p>how参数主要决定了哪一个keys会被包含在结果表中。它的值有四种可能性：<code>left,right,outer,inner</code>。我们主要看<code>left和right</code></p>
<p>how=’left’:遍历left表，找与right一样的，依次放入行。 如果没有，则设为NAN</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-09-20-34-44.png" alt=""> </p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-09-20-33-13.png" alt=""> </p>
<p>因此<code>t3 = pd.merge(t3,t2,on=[&#39;user_id&#39;,&#39;coupon_id&#39;],how=&#39;left&#39;)</code>的意思是：</p>
<p>根据t3合并t2的user_id’,’coupon_id</p>
]]></content>
      
        <categories>
            
            <category> o2o优惠券使用预测 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[梯度提升决策树 AdaBoost DecisonTree]]></title>
      <url>/2017/03/06/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-%E6%A2%AF%E5%BA%A6%E6%8F%90%E5%8D%87%E5%86%B3%E7%AD%96%E6%A0%91%20AdaBoost%20DecisonTree/</url>
      <content type="html"><![CDATA[<p>上一节中介绍了《随机森林算法》，该算法使用bagging的方式作出一些决策树来，同时在决策树的学习过程中加入了更多的随机因素。该模型可以自动做到验证过程同时还可以进行特征选择。 </p>
<p>本节，我们结合<code>AdaBoost+决策树</code>算法。</p>
<h1 id="AdaBoost决策树算法引入">1. AdaBoost决策树算法引入</h1><p>在AdaBoost中每一轮迭代，都会给数据更新一个权重，利用这个权重，我们学习得到一个g，在这里我们得到一个决策树，最终利用线性组合的方式得到多个决策树组成的G。</p>
<p>=======================================<br><strong>AdaBoost-DTree(DD)</strong><br>对于t=1,2,…,T，循环执行：</p>
<ul>
<li>更新数据的权重$u(t)$；</li>
<li>通过决策树算法$DTree(D,u(t))$得到$g_t$；</li>
<li>计算$g_t$的投票权重$α_t$。</li>
</ul>
<p>返回$G=LinearHypo({(g_t,α_t)})$。</p>
<p>========================================</p>
<p><strong>问题</strong>：如何要在决策树中，加入权重<code>ut</code></p>
<p><strong>解决方案</strong>有两种：</p>
<ul>
<li>一种是通过算法加权，在计算Ein的地方嵌入权重计算，比如AdaBoost采用的最小化加权误差；</li>
<li>另一种方法是将算法当成黑盒不变更，通过数据集加权，根据权重在bootstrap时“复制”数据，也就是加权的重采样。</li>
</ul>
<p>AdaBoost决策树通常用后一种，即：$AdaBoost+sampling∝u^{(t)}+DTree(D_t) $</p>
<h1 id="加权的决策树算法-Weighted-Decision-Tree-Algorithm">2. 加权的决策树算法(Weighted Decision Tree Algorithm)</h1><p> 之前含有权重的算法中，我们在误差估计中加入了权重<code>u</code>：</p>
<p> <img src="http://om1bxijvl.bkt.clouddn.com/2017-03-07-09-46-47.png" alt=""> </p>
<p>为了对决策树中加入权重，且不改变原算法的健壮性，我们设法对输入的<code>数据</code>进行<code>权重加成</code>。而权重等效于数据的重复次数。根据这种方式得到一组新的数据，那么这组新的数据中的比例大概就是和权重的比例呈正比的，也就是说它能够表达权重对于数据的意义。</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-07-09-54-14.png" alt=""> </p>
<p>在AdaBoost-DTree中，为了简单起见，我们不去改变AdaBoost的框架，也不去修改决策树的内部细节，而只是通过基于权重的训练数据的采样来实现。</p>
<p>即如下图所示的：AdaBoost提升决策树=AdaBoost提升+关于权重u的数据抽样+决策树</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-07-09-54-50.png" alt=""> </p>
<h2 id="弱决策树算法">2.1. 弱决策树算法</h2><p>在AdaBoost算法中，我们<strong>通过错误率<code>εt</code>来计算单个的g的权重αt</strong>，那么如果我们使用决策树作为g的时候，g是一个完全长成的树，该树对整个数据集进行细致的切分导致Ein=0，那么这使得εt=0，但计算得到的权重αt会变成无限大。</p>
<p>其意义是，如果使用一个能力很强的树作为g的话，那么该算法会赋予该树无限大的权重或票数，最终得到了一棵“独裁”的树（因为AdaBoost的哲学意义是庶民政治，就是集中多方的意见，及时有的意见可能是错误的），违背了AdaBoost的宗旨。</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-07-09-59-58.png" alt=""> </p>
<p>上面的问题出在使用了所有的数据和让树完全长成这两方面。针对这两个问题，我们要通过<code>剪枝</code>和<code>部分训练数据</code>得到一个弱一点的树。<br>所以实际上，AdaBoost-DTree是通过sampling的方式得到部分训练数据，通过剪枝的方式限制树的高度，得到弱一点的决策树。</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-07-10-19-02.png" alt=""> </p>
<p>下面介绍最弱的决策树。</p>
<h2 id="决策桩，AdaBoost-Stump">2.2. 决策桩，AdaBoost-Stump</h2><p>什么样是树才是弱决策树呢？<br>我们这里限制这棵树只有一层（即它仅基于单个特征来做决策），即决策桩(Decision Stump)。这样我们需要让CART树的不纯度(impurity)尽可能低，学习一个决策桩。</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-07-10-21-14.png" alt=""> </p>
<p>所以，使用决策桩作为弱分类器的AdaBoost称为AdaBoost-Stump，它是一种特殊的AdaBoost-DTree。</p>
<h2 id="决策桩的实现">2.3. 决策桩的实现</h2><p>本节主要参考《机器学习实战》p120</p>
<h3 id="实验数据adaboost-py">2.3.1. 实验数据adaboost.py</h3><pre><code>from numpy import *
def loadSimpData():
    dataMat = matrix([[1.,2.1],[2.,1.1],[1.3,1.],[1.,1.],[2.,1.]])
    classLabels = [1.0,1.0,-1.0,-1.0,1.0]
    return dataMat,classLabels
</code></pre><h3 id="二分类的决策桩实现stump-py">2.3.2. 二分类的决策桩实现stump.py</h3><p>先导入数据</p>
<pre><code>import adaboost
dataMat,classLabels = adaboost.loadSimpData()
</code></pre><p>建立一个<code>buidStump()</code>函数，根据数据集，建立最佳单层决策树（只需要选择一个最好的特征即可）</p>
<pre><code>def buildStump(dataArr,classLabels,D):
    dataMatrix = mat(dataArr)
    labelMat = mat(classLabels).T # T是做转置
</code></pre><p><code>dataMatrix</code>形式为<img src="http://om1bxijvl.bkt.clouddn.com/2017-03-16-16-29-28.png" alt=""><br><code>labelMat</code>形式为<img src="http://om1bxijvl.bkt.clouddn.com/2017-03-16-16-29-39.png" alt=""> </p>
<p>先令一些变量，之后解释。</p>
<pre><code>m,n = shape(dataMatrix)
numSteps = 10.0#步长
bestStup = {}#最佳桩
bestClasEst = mat(zeros((m,1)))#最佳分类est
minError = inf
</code></pre><p>接下来需要对每个特征计算出一个阈值<code>threshVal</code>，根据阈值二分类。</p>
<pre><code>for i in range(n): # 遍历特征个数
    #为了确定threshVal，我们从本特征下的最小值到最大值分10 step进行依次测试
    rangeMin = dataMatrix[:,i].min();rangeMax = dataMatrix[:,i].max();
    stepSize = (rangeMax - rangeMin)/numSteps
    #下面对每个threshVal可能的值进行依次测试
    for j in range(-1,int(numSteps)+1):
        #然后应该开始比较大于阈值和小于阈值怎么怎么滴，为了增加代码的复用性，此处用一个循环来在大于和小于之间切换不等式
        for inequal in [&apos;lt&apos;,&apos;gt&apos;]:#lt=小于等于，gt=大于
            threshVal = (rangeMin + float(j)*stepSize)
            # 开始测试这个特征下这个阈值的二分类器好不好用
            predictedVals = stumpClassify(dataMatrix,i,threshVal,inequal)
            #计算本次分类的err
            errArr = mat(ones((m,1)))
            errArr[predictedVals==labelMat]=0
            #基于权重向量D计算权重
            weightedError = D.T*errArr
            if weightedError &lt; minError :
                minError = weightedError
                bestClasEst = predictedVals.copy()
                bestStump[&apos;dim&apos;] = i
                bestStump[&apos;thresh&apos;] = threshVal
                bestStump[&apos;ineq&apos;] = inequal
</code></pre><p>最后，返回最佳的决策桩，和误差</p>
<pre><code>return bestStump,minError,bestClasEst
</code></pre><h1 id="求解AdaBoost决策树">3. 求解AdaBoost决策树</h1><h2 id="AdaBoost的权重与投票分数的关系">3.1. AdaBoost的权重与投票分数的关系</h2><p>回顾AdaBoost算法：</p>
<p>从权重<code>ut</code>，通过<code>◆t</code>对<code>u(t+1)</code>进行修正，而两个公式可以合成为：<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-07-14-35-34.png" alt=""> </p>
<p>如下图，接着我们将<code>u(t+1)</code>展开(表达为<code>u(1)乘以一坨</code>)，最终可以变成连加；<br>我们发现图中橘色部分<code>∑αt·gt(xn)</code>是G(x)的分数！它现在出现在Adaboost的权重表达式中；<br>我们称橘色<code>∑αt·gt(xn)</code>为<strong>投票分数(voting score)</strong>：<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-07-14-38-40.png" alt=""> </p>
<p><strong>结论</strong>：AdaBoost里面每一个数据的权重，和<code>exp(-yn( 投票分数 on xn))</code>呈正比。即：<img src="http://om1bxijvl.bkt.clouddn.com/2017-03-07-14-41-04.png" alt=""> </p>
<h2 id="投票分数-Voting-Score-和间隔-Margin-的关系">3.2. 投票分数(Voting Score)和间隔(Margin)的关系</h2><p>线性混合(linear blending)等价于将假设看做是特征转换的线性模型：</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-07-19-13-20.png" alt=""> </p>
<p>其中<code>αt·gt(xn)</code>如果换作是<code>wT·φ(xn)</code>可能就更清楚了，这与下面给出的在SVM中的margin表达式对比，我们可以明白投票分数<code>∑αt·gt(xn)</code>的物理意义，即可以看做是没有正规化的边界(margin)。</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-07-19-20-39.png" alt=""> </p>
<p>所以，<code>yn·(voting score)</code>是有符号的、没有正规化的边界距离，从这个角度来说，我们希望<code>yn·(voting score)</code>越大越好，因为这样的泛化能力越强。于是，<code>exp(-yn·(voting score))</code>越小越好，那么<code>un(T+1)</code>越小越好。</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-07-19-21-01.png" alt=""> </p>
<p><strong>结论</strong>：AdaBoost在迭代过程中，是让<code>∑un(t)</code>越来越小的过程，在这个过程中，逐渐达到SVM中最大分类间隔的效果。</p>
<h2 id="AdaBoost误差函数">3.3. AdaBoost误差函数</h2><p>上面解释到了，AdaBoost在迭代学习的过程，就是希望让<code>∑un(t)</code>越来越小的过程，那么我们<strong>新的目标</strong>就是最佳化权重和<code>∑un(T+1)</code>：</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-07-19-58-44.png" alt=""> </p>
<p>我们可以画出<code>0/1错误</code>和<code>AdaBoost误差函数err(s,y) = exp(-ys)</code>的函数曲线，我们发现AdaBoost的误差函数（称为exponential error measure）实际上也是0/1错误函数的上限函数，于是，<strong>我们可以通过最小化该函数来起到最佳化的效果</strong>。</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-07-19-59-15.png" alt=""> </p>
<h2 id="AdaBoost误差函数的梯度下降求解">3.4. AdaBoost误差函数的梯度下降求解</h2><p>本节目的————最小化AdaBoost的误差函数<code>Ein</code>：</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-07-19-58-44.png" alt=""> </p>
<p>这个任务比较麻烦，因为是Σ套着exp再套着Σ，因此需要一些前人的智慧了。</p>
<p>我们可以将<code>Ein</code>函数在所在点的附近做泰勒展开，我们就可以发现在该点的附近可以被梯度所描述，我们希望求一个最好的方向（最大梯度相反的方向），然后在该方向上走一小步，这样我们就可以做到比现在的函数效果好一点点，依次进行梯度下降，最终达到最小化误差函数的效果。</p>
<p>原始的梯度下降法：</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-07-20-02-45.png" alt=""> </p>
<p>为了模仿梯度下降的方法，假设前面已经AdaBoost完t-1轮了，现在要求的是一个函数gt(x)（或者称为h(x)）。</p>
<p>在第t轮，我们沿着函数h(x)的方向走$η$的步长，可以使得目标函数迅速往min的方向走。如下：现在我们把<code>函数gt</code>当做向量，希望去找到这个<code>gt</code>（这里函数方向gt和上面介绍的最大梯度的方向向量没有什么差别，只是表示方式有所不同而已）。</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-07-20-03-24.png" alt=""> </p>
<p>我们解释一下上面的公式：</p>
<ul>
<li>(1、2行)由于前面已经执行完了<code>t-1</code>轮，因此可以把式子化简一下，把一些项目合并成<code>ut</code>的函数形式</li>
<li>(3行左) 将<code>exp(-y·η·h(xn))</code>在原点xn=0点的泰勒展开，进一步化简得到得到<code>(1-yn·η·h(xn))</code>；（这里为什么要用0这个位置的taylor展开呢，可以理解成h(x)只是沿着原来的Σ1,t-1(alphat*g’(xn)这个函数，挪动的了一小步；这一小步，就意味着变化很小，变化很小甚至接近0，因此就可以在0点taylor展开。不晓得这种理解是否正确，意会吧）</li>
<li>(3行右) 然后拆成两部分<code>∑un(t)</code>和<code>η·∑un(t)·yn·h(xn)</code>，第一部分是Ein，第二部分就是要最小化的目标。<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-07-20-04-07.png" alt=""> </li>
</ul>
<p>到此，我们利用前人的智慧已经把目标函数给大大简化了，下面需要要求的东西有俩：</p>
<p>1）<code>h(x)</code>是啥？</p>
<p>2）<code>$η$</code>是啥？</p>
<h3 id="求h-x">3.4.1. 求h(x)</h3><p>我们对<code>∑un(t)·yn·h(xn)</code>整理一下，对于二元分类情形，我们把<code>yn</code>和<code>h(xn)</code>是否同号进行分别讨论：</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-07-20-04-29.png" alt=""> </p>
<p>上面的公式中，我们特意将<code>∑un(t)·yn·h(xn)</code>拆成<code>-∑un(t)</code>和<code>Ein(h)</code>的形式，这里最小化<code>Ein</code>对应于AdaBoost中的A（弱学习算法），好的弱学习算法就是对应于梯度下降的函数方向。</p>
<p><strong>结论</strong>：在AdaBoost的过程中，算法A就是good gt了！</p>
<h3 id="求最佳化步长-η">3.4.2. 求最佳化步长$η$</h3><p>我们要最小化Eada，需要找到好的函数方向gt，但是得打这个gt的代价有些大，梯度下降的过程中，每走一小步，就需要计算得到一个gt。如果转换一下思路，我们现在已经确定了好的gt，我们希望快速找到梯度下降的最低点，那么我们需要找到一个合适的最大步长η。<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-07-20-05-39.png" alt=""> </p>
<p>我们这里使用贪心算法来得到最大步长η，称为steepest decent for optimization。</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-07-20-05-54.png" alt=""> </p>
<p>让Eada对η求偏微分，得到最陡时候的ηt，我们发现这时ηt等于AdaBoost的αt。所以在AdaBoost中αt是在偷偷地做最佳化的工作。</p>
<p>核心在于EADA是怎么变成可对$η$求导的形式的：</p>
<p>EADA = u1t<em>exp(-$η$) + u2t</em>exp($η$)…</p>
<p>EADA1 = u1t<em>exp(-$η$) + ut2t</em>0 … （EADA1只考虑exp(-$η$)的项，其余的补上0）</p>
<p>EADA2 = u1t<em>0 + u2t </em> exp($η$) …（EADA2只考虑exp(+$η$)的项，其余的补上0）</p>
<p>则，EADA = EADA1 + EADA1 = (Σunt) <em> ( (1-epson)exp(-$η$) + epson</em>exp($η$) )</p>
<p>随后的求导步骤就是很自然的了，因此就验证了之前的结论，$η$t = sqrt( (1-epsont)/epsont) )就是最优的。前一次课直接给出了这个结论，并没有说为什么，这次算是给出了一个相对理论些的推导。</p>
<p><strong>结论</strong>：通过求解<img src="http://om1bxijvl.bkt.clouddn.com/2017-03-15-13-25-13.png" alt=""><br>，我们得到最佳的<img src="http://om1bxijvl.bkt.clouddn.com/2017-03-15-13-25-32.png" alt=""> </p>
<h3 id="小结">3.4.3. 小结</h3><p>在第二小节中，我们从另外一个角度介绍了AdaBoost算法，它其实是steepest gradient decent。</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-07-20-06-19.png" alt=""> </p>
<p>上面的式子很清楚了，我们将AdaBoost的误差函数看做是指数误差函数，AdaBoost就是在这个函数上一步一步做最佳化，每一步求得一个h，并将该h当做是gt，决定这个gt上面要走多长的距离ηt，最终得到这个gt的票数αt。</p>
<h1 id="AdaBoost决策树总结">4. AdaBoost决策树总结</h1><ol>
<li>AdaBoost本次的u(t+1)与<code>exp(-yn( 投票分数 on xn))</code>成正比</li>
<li>AdaBoost在迭代过程中，是让<code>∑un(t)</code>越来越小的过程，在这个过程中，逐渐达到SVM中最大分类间隔的效果</li>
<li>上目标与最小化误差函数<code>err(s,y) = exp(-ys)</code>等价</li>
<li>要使得<code>err(s,y)</code>最小，就需要求得<code>h(x)</code>和<code>η</code></li>
</ol>
<h1 id="参考文献">5. 参考文献</h1><ol>
<li><a href="http://qianjiye.de/2015/01/gradient-boosted-decision-tree" target="_blank" rel="external">梯度提升决策树</a></li>
<li><a href="http://www.cnblogs.com/xbf9xbf/p/4706150.html" target="_blank" rel="external">【Gradient Boosted Decision Tree】林轩田机器学习技术</a></li>
<li>《机器学习实战》</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 机器学习算法 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[提升方法 AdaBoost]]></title>
      <url>/2017/03/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-%E6%8F%90%E5%8D%87%E6%96%B9%E6%B3%95%20AdaBoost/</url>
      <content type="html"><![CDATA[<h1 id="Boosting">1. Boosting</h1><p>提升（boosting）：从弱学习算法（正确率低）出发，反复学习，得到一系列弱分类器（基本分类器），然后组合这些弱分类器，构成一个强分类器。（三个臭皮匠顶个诸葛亮）</p>
<p>提升（boosting）方法需要解决的问题：</p>
<ul>
<li>如何获得更多的弱分类器————如何改变训练数据的权值或概率分布————提高被前一轮错误分类样本的权值，降低被正确分类样本的权值。</li>
<li>如何将弱分类器合成一个强分类器————加权多数表决：加大误差小的分类器的权值，减小误差大的分类器的权值。</li>
</ul>
<p>提升方法有很多，最具代表性的就是AdaBoost算法。</p>
<h1 id="AdaBoost算法">2. AdaBoost算法</h1><p>假设给定一个二分类训练数据集$T=\{(x_1,y_1),(x_2,y_2),…,(x_N,y_N)\}$</p>
<p>其中，每个样本点由<code>实例+标记</code>组成</p>
<p>实例：$x_i\in X \subseteq R^n $</p>
<p>标记：$y_i \in Y={-1,+1}$</p>
<p><code>AdaBoost</code>利用以下算法，从训练数据中学习一系列弱分类器或基本分类器，并将这些弱分类器线性组合成一个强分类器</p>
<p><strong>输入</strong>:</p>
<ul>
<li>数据集$T=\{(x_1,y_1),(x_2,y_2),…,(x_N,y_N)\}$</li>
<li>弱学习算法</li>
</ul>
<p><strong>输出</strong>：最终分类器$G(x)$</p>
<p><strong>步骤</strong>：</p>
<ol>
<li>初始化训练数据的权值(每个都设为1/N)：</li>
</ol>
<p>$$D_1=(w_{11},w_{1i},…,w_{1N}),w_{1i}=\frac{1}{N},i=1,2,…,N$$</p>
<ol>
<li>对$m=1,2,…,M$:</li>
</ol>
<ul>
<li>使用带权值$D_m$的训练集学习，得到基本分类器$G_m(x):X\rightarrow \{-1,+1\}$</li>
<li>计算$G_m(x)$在训练集上的分类误差率：$$e_m=P(G_m(x_i)\neq y_i)=\sum_{n=1}^N w_{mi}I(G_m(x_i)\neq y_i)$$</li>
</ul>
<ol>
<li>计算$G_m(x)$的系数：$$\alpha_m=\frac{1}{2}log\frac{1-e_m}{e_m}$$</li>
<li>更新训练集权值：</li>
</ol>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-06-22-49-14.png" alt=""> </p>
<ol>
<li>构建基本分类器的线性组合：</li>
</ol>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-06-22-49-54.png" alt=""> </p>
<h1 id="AdaBoost算法推导">3. AdaBoost算法推导</h1><h2 id="Boot-strapping">3.1. Boot strapping</h2><p>Boot strapping，拔靴法：利用有限的样本资料经由<strong>多次重复抽样</strong>，重新建立起足以代表母体样本分布之新样本。</p>
<p>多次之后，得到一个非线性的结果（黑色线）<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-04-17-37-57.png" alt=""> </p>
<h2 id="基本算法引入权重">3.2. 基本算法引入权重</h2><p>已知：一笔数据$D=\{(x_1,y_1),(x_2,y_2),(x_3,y_3),(x_4,y_4)\}$<br>根据<code>D</code>算出来的输入误差Ein为：<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-04-19-29-41.png" alt=""> </p>
<p>通过Boot strapping，得到新的一笔数据$D_t=\{(x_1,y_1),(x_1,y_1),(x_2,y_2),(x_4,y_4)\}$<br>对应地，根据<code>Dt</code>算出来的Ein为：<br>（增加一个权重u即可）<br><code>u1=2,u2=1,u3=0,u4=1</code><br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-04-19-31-04.png" alt=""> </p>
<p><strong>结论：每一个bootstrapping得到了一个权重<code>u</code></strong></p>
<h2 id="优化权重u">3.3. 优化权重u</h2><h3 id="优化原理">3.3.1. 优化原理</h3><ul>
<li>每一个bootstrapping得到了一个权重`u。</li>
<li>为了综合得到更好的g,则需要抽取的数据集得到的g尽量地不同。</li>
<li>改变<code>u</code>，使得<code>g</code>差异更大，才会更好地改进最终结果</li>
</ul>
<p>得到g差异很大的方法：</p>
<ul>
<li>第一轮$u_n^t$时，得到$g_t$<img src="http://om1bxijvl.bkt.clouddn.com/2017-03-04-19-39-48.png" alt=""> </li>
<li>第二轮，选择一个 在$g_t$ 表现不好的 $u_n^{t+1}$  ，得到 $g_{t+1}$ <img src="http://om1bxijvl.bkt.clouddn.com/2017-03-04-19-41-02.png" alt=""><br>– 表现不好的定义：<br>— 将$u_n^{t+1}$作用在$g_t$上，得到一个归一化的错误率<img src="http://om1bxijvl.bkt.clouddn.com/2017-03-04-19-45-01.png" alt=""><br>— 为了简便，定义橙色方块为所有犯错误的$u_n^{t+1}$的累加，绿色圆形为所有正确的$u_n^{t+1}$累加<br>— 即：<img src="http://om1bxijvl.bkt.clouddn.com/2017-03-04-19-47-12.png" alt=""><br>– 表现不好的选择方法：<br>— 将本次正确的$u_n^t$，除以一个错误的比例（缩小正确），赋给$u_n^{t+1}$<br>— 将本次错误的$u_n^t$，乘以一个正确的比例（放大错误），赋给$u_n^{t+1}$<br>— 这样得到的$u_n^{t+1}$的比率就会为2/1<br>— 即：<img src="http://om1bxijvl.bkt.clouddn.com/2017-03-04-19-51-21.png" alt=""> </li>
</ul>
<h3 id="优化权重u的方法————放缩因子">3.3.2. 优化权重u的方法————放缩因子</h3><p>放缩因子-Adaptive Boosting Algorithm<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-04-20-02-12.png" alt=""> </p>
<ul>
<li>◆t有更清晰的物理意义，通常情况下εt &lt; 1/2（因为是学习之后的结果，错误率应该小于0.5），</li>
<li>◆t将大于1；</li>
<li>那么，犯错的数据将乘上大于1的数，正确数据将除以大于1的数</li>
<li>使得提升了犯错数据的权重(scale up incorrect)，</li>
<li>降低做对数据的权重(scale down correct)</li>
<li>这样使得更加专注在犯了错的地方，来得到不一样的假设(diverse hypotheses)。</li>
</ul>
<h2 id="Linear-Aggregation（聚集）-合成最终的g">3.4. Linear Aggregation（聚集） - 合成最终的g</h2><p>目标：合成最终的的$G(x)=sign(\sum_{t=1}^T\alpha_t g_t(x)$</p>
<ul>
<li>其中 $\alpha_t$是系数</li>
<li>要求好的$g_t$（错误率低），$\alpha_t$应该大一些</li>
<li>坏的$g_t$（错误率高），$\alpha_t$应该小一些</li>
<li>而◆t与错误率成反比</li>
<li>则可令$\alpha_t=ln(\text{◆t})$</li>
</ul>
<p>算法流程：<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-04-20-21-25.png" alt=""> </p>
<p>这里之所以认为αt = ln(◆t)，处于下面的考虑：<br>如果εt = 1/2， 那么◆t = 1，则αt = 0，意思是随机乱猜的情况下（二元分类错误率为0.5），认为是坏的g，则一票不给个，不使用该g<br>如果εt = 0， 那么◆t = ∞，则αt = ∞，意思是正确率为0的情况，给它无限多票数</p>
<h1 id="AdaBoost-自适应优化算法总结">4. AdaBoost 自适应优化算法总结</h1><p>自适应优化算法 = 简单的学习A + 放缩权重 + 合成得到g<br>即：<img src="http://om1bxijvl.bkt.clouddn.com/2017-03-04-20-25-49.png" alt=""> </p>
<p>AdaBoost算法完整流程<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-04-20-26-16.png" alt=""> </p>
<h1 id="AdaBoost理论特性">5. AdaBoost理论特性</h1><p>通过之前的VC Bound，来约束测试误差，其中蓝色的部分是模型的复杂度，O(dvc(H))为g的模型复杂度，而O(dvc(H))·T·logT是模型G的复杂度。原作者证明说，可以用O(logN)次迭代可以将Ein(G)做到很小，并且当数据量N足够多的情况下，又可以使得模型复杂度变得很小，从而使得模型复杂度得到控制。最终预测效果Eout也会很好。<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-04-20-27-24.png" alt=""><br>AdaBoost的保证是让一个很弱的算法不断变强，最终得到一个很强是算法（Ein=0，Eout is small）。<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-04-20-27-48.png" alt=""> </p>
<h1 id="Adaptive-Boosting的实际应用表现">6. Adaptive Boosting的实际应用表现</h1><p>上面的AdaBoost只需要一个很弱的算法就可以使用。<br>一般情况下，可以使用决策桩(Decision Stump)，该模型相当于在某一个维度上的Perceptron模型。<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-04-20-28-27.png" alt=""> </p>
<h1 id="聚合（aggregation）模型总结">7. 聚合（aggregation）模型总结</h1><p>aggregation 模型主要应用在将得到的多个预测函数$g_t$聚合在一起，得到更好的$g_t$（即更好的分类器）的方式</p>
<p>聚合方式主要面向两种情况：</p>
<ul>
<li>blending:已经有了一堆$g_t$在手上（可能是已知的，可能是求得的）。</li>
<li>learning：不已知$g_t$，需要通过一定方式求得很多$g_t$</li>
</ul>
<p>learning的分为三种情况</p>
<ul>
<li>把g看做是同等地位，通过投票或者平均的方式将它们合起来，称为Bagging</li>
<li>g是不平等的，有好有坏，一个可行的做法是把g当成是特征的转换，然后丢进线性模型训练就可以了，这称为AdaBoost</li>
<li>如果是不同的条件下，使用不同的g，那么我们仍然可以将g当做是特征转换，接下来使用一个非线性模型来得到最终的模型参数，这就是下文要介绍的决策树算法</li>
</ul>
<table>
<thead>
<tr>
<th>$g_t$类型</th>
<th style="text-align:right">blending</th>
<th style="text-align:center">learning</th>
</tr>
</thead>
<tbody>
<tr>
<td>各$g_t$等权重型（uniform）</td>
<td style="text-align:right">投票方式/平均方式</td>
<td style="text-align:center">Bagging</td>
</tr>
<tr>
<td>$g_t$权重不等型（non-uniform）</td>
<td style="text-align:right">线性聚合</td>
<td style="text-align:center">AdaBoost</td>
</tr>
<tr>
<td>不同情形用不同$g_t$（conditional）</td>
<td style="text-align:right">stacking</td>
<td style="text-align:center">决策树</td>
</tr>
</tbody>
</table>
<h1 id="AdaBoost思路总结">8. AdaBoost思路总结</h1><ul>
<li>一般，数据量过少时，我们无法得到更好的g.</li>
<li>因此我们采取BootStrapping方法，生成多个数据集，得到多个g</li>
<li>最后合成最好的g</li>
</ul>
<h1 id="AdaBoost伪代码">9. AdaBoost伪代码</h1><pre><code>对每次迭代：
    用buildStump()函数找到最佳单层决策树
    将最佳单层决策树加入到单层决策树数组
    计算alpha
    计算新的权重向量D
    更新累积类别估计值
    如果错误率等于0，则退出循环
</code></pre><p>参考文献</p>
<ol>
<li>《机器学习技法》，林轩田</li>
<li><a href="http://blog.csdn.net/JasonDing1354/article/details/46462711" target="_blank" rel="external">Jason Ding，【机器学习基础】自适应提升</a></li>
<li><a href="http://blog.jasonding.top/2015/07/22/Machine%20Learning/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E3%80%91%E5%86%B3%E7%AD%96%E6%A0%91%E7%AE%97%E6%B3%95/" target="_blank" rel="external">Jason Ding，【机器学习基础】决策树算法</a></li>
</ol>
<p>备注：本节是《机器学习技法》第8章+《统计学习方法》第8章笔记</p>
]]></content>
      
        <categories>
            
            <category> 机器学习算法 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[随机森林算法]]></title>
      <url>/2017/03/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p><strong>引言</strong></p>
<p>回顾之前学习过的两个算法：</p>
<ul>
<li>Bagging<br>– 简要：通过bootstrapping得到不一样的数据，得到不同的g，对g取平均得到G<br>– 特点：通过投票和平均的方式来降低对不同数据的敏感性（variance的效果）</li>
<li>决策树<br>– 简要：通过递归方式建立子树，最终得到完整的树<br>– 特点：对不同数据较敏感（算法的variance很大）</li>
<li>随机森林<br>– 两者的结合</li>
</ul>
<h1 id="随机森林算法">1. 随机森林算法</h1><p>概述：利用随机的方式将许多决策树组合成一个森林,每个决策树$g_t(t)$在分类的时候投票决定测试样本的最终类别。在得到森林之后，当有一个新的输入样本进入的时候，就让森林中的每一棵决策树分别进行一下判断，看看这个样本应该属于哪一类（对于分类算法），然后看看哪一类被选择最多，就预测这个样本为那一类。</p>
<p>详细算法：<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-05-17-09-01.png" alt=""> </p>
<ul>
<li>左边的总算法是Bagging思想–体现随机性</li>
<li><p>其中为每个$g_t(t)$建树时，是决策树的思想–体现森林</p>
</li>
<li><p>并行计算的可能性：随机森林算法从Bagging过程中可以分配到不同的计算机中进行计算，每台计算机可以独立学习一棵树，不同的树之间没有任何依赖关系。这使得Bagging过程很容易实现并行化。</p>
</li>
</ul>
<h1 id="特征投影（Feature-Project">2. 特征投影（Feature Project)</h1><ul>
<li>原来在Bagging中，我们对数据进行抽取，得到不同的数据集，从而产生不同的$g_t$</li>
<li>在随机森林算法中，除了对数据抽取，也可以在<strong>特征</strong>这一角度抽取</li>
<li>例，如果事先我们有100个特征，现在我们可以抽取10个特征<img src="http://om1bxijvl.bkt.clouddn.com/2017-03-05-20-34-44.png" alt=""> </li>
</ul>
<ul>
<li>得到数据集<img src="http://om1bxijvl.bkt.clouddn.com/2017-03-05-20-34-07.png" alt=""> </li>
<li><p>来训练一棵树，这样的方式我们也可以得到很不一样的树，其对于分类的标准显然也很不一样</p>
</li>
<li><p>这等效于一个特征转换，这个过程中，从100维度到10个维度的转换中，相当于作了低维度的投影(Projection)</p>
</li>
<li><p>一般来说，<img src="http://om1bxijvl.bkt.clouddn.com/2017-03-05-20-34-18.png" alt=""> </p>
</li>
</ul>
<ul>
<li>得到的特征实际上是原始特征的随机子集，这使得生成模型过程中的效率也大大提高了</li>
</ul>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-05-17-17-10.png" alt=""> </p>
<h1 id="特征扩展（feature-Expansion）">3. 特征扩展（feature Expansion）</h1><p>每次随机抽取子空间 <code>等效于</code> 对原来的特征向量左乘一个<strong>投影矩阵</strong>$P$,使得$\Phi(X)=P\cdot x$</p>
<p>更加有能力的特征投影就是不再单一选取单一维度的特征，而是将多个维度的特征进行组合(随机的方向)，得到新的一维的特征，这称为<strong>特征扩展</strong>。</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-05-18-43-19.png" alt=""> </p>
<ul>
<li>将多个方向的特征随机合起来(combination)，即对于投影矩阵$P$的每一个方向$p_i$，不再固定方向（row）。即变为$\Phi_i(X)=P_i^T\cdot x$<br>– 一般情况下，会考虑<code>low-dimensional</code>，即投影过去时，一般每次选取少量维度进行投影。即只有$d’’$的<code>非零项</code>被投影过去</li>
<li>这样的方式，包含了随机抽取（random subspace）的思想</li>
<li>一般来说，每次投影都采用新的不一样的投影</li>
</ul>
<h1 id="随机森林的采样过程">4. 随机森林的采样过程</h1><p>在建立森林的每颗决策树$g_t$的过程中，首先需要随机采样数据点。</p>
<p>不是所有数据点都能被采到。以下介绍OOB点</p>
<h2 id="Out-of-bag（OOB）点">4.1. Out-of-bag（OOB）点</h2><p>OOB点：在bootstrapping过程中，有些数据可能没有被选择，这些数据被称为OOB点。例如下表，对于训练每一个决策树$g_t$，其中用*号标注的就是$g_t$的OOB<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-05-19-18-06.png" alt=""> </p>
<h3 id="OOB点个数">4.1.1. OOB点个数</h3><p>假设bootstrapping抽了$N’$次数据，探讨会有多少数据不会被抽到：</p>
<ul>
<li>若$N’=N$，某个数据$(x_n,y_n)$从未被抽到的概率是$(1-\frac{1}{N})^N$<br>$$(1-\frac{1}{N})^N=\frac{1}{\frac{N}{N-1}^N}\approx \frac{1}{e}$$</li>
<li>那么每个决策树$g_t$OOB集合的大小就约为$\frac{1}{e}N\approx 0.3N$</li>
</ul>
<h3 id="OOB用途-验证随机森林的G">4.1.2. OOB用途-验证随机森林的G</h3><p>可以用来做测试集-问题在于————验证<code>g</code>还是<code>G</code>？<br>以数据集$(x_N,y_N)为例$</p>
<ul>
<li>验证$g$的必要性不大</li>
<li>验证$G$不方便</li>
<li>可以用来验证<code>除了g1之外的G</code> = $G_N^-(x)=average(g_2,g_3,g_T)$</li>
<li>总之，用来验证$G$表现是否好的方式：<br>$$E_{oob}(G)=\frac{1}{N}\sum_1^N error(y_n,G_n^-(x_n))$$</li>
</ul>
<h1 id="特征选择（feature-selection）">5. 特征选择（feature selection）</h1><p>目的：自动选择需要的特征，去除冗余、不相关的特征<br>优点：降维，减少复杂度；减少噪声，提高模型泛化能力；物理意义；<br>缺点：计算量大；可能导致过拟合；</p>
<p>下面介绍特征选择的方法。</p>
<h2 id="根据重要性选择（线性的）">5.1. 根据重要性选择（线性的）</h2><ul>
<li>给每个特征算一个权重（分数）</li>
<li>问题：特征选择是线性的，不符合随机森林的非线性特点</li>
</ul>
<h2 id="置换检验（非线性的，Permutation-Test）">5.2. 置换检验（非线性的，Permutation Test）</h2><p>问题：每个特征是有噪音的，由于噪音的存在，导致某些原本很优秀的特征的分数被降低</p>
<p>解决方法：将第i个维度特征的所有数据重新的随机调整位置，然后比较一下原始数据和调整之后的数据表现的差距，来评价这个维度的特征是有多么重要。</p>
<ul>
<li>调整方法1：高斯什么的，但会改变数据原始分布</li>
<li>调整方法2：随机重排，即置换检验。将某一维度的数据随机重排，可以看出来这个维度有多重要。</li>
</ul>
<h2 id="在Out-Of-Bag-Estimate过程中做Permutation-Test">5.3. 在Out-Of-Bag Estimate过程中做Permutation Test</h2><p>在随机森林中可以用OOB代替验证的过程，为了简化Permutation Test带来的重新进行训练的代价，我们在使用OOB Example（bootstrap过程中没有选取的数据）进行验证的过程中做一些修改，即在验证的时候去进行Permutation Test，而非训练时进行。<br>在求Eoob(G)时，我们通过G-(xn)来计算，我们在这里将x(n)修改成x(n,i)，就可以不用对G进行修改了。<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-05-20-17-46.png" alt=""><br>在实际应用中，面对非线性的问题时，可以通过随机森林的方法来进行初步的特征选择。</p>
<p> <img src="http://om1bxijvl.bkt.clouddn.com/2017-03-05-20-16-21.png" alt=""> </p>
<p>参考资料：</p>
<ol>
<li><a href="http://database.51cto.com/art/201407/444788.htm" target="_blank" rel="external">机器学习的算法(1):决策树之随机森林</a></li>
<li>机器学习技法</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 机器学习算法 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[决策树和CART]]></title>
      <url>/2017/03/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8CCART/</url>
      <content type="html"><![CDATA[<h1 id="决策树简介">1. 决策树简介</h1><p>模仿人类决策的过程</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-05-12-43-33.png" alt=""> </p>
<ul>
<li>优点：好理解；简单</li>
<li>缺点：缺少很强的理论支持；树结构不唯一；</li>
</ul>
<h2 id="决策树的表达方式">1.1. 决策树的表达方式</h2><p>如上图所示的决策树，我们用$G(x)$来表达决策树：</p>
<p>$$G(x)=\sum_{t=1}^T q_t(x)\cdot g_t(x) $$</p>
<p>tips:</p>
<ul>
<li>$g(x)$是最终的决策（<code>Y or N</code>），叶子节点</li>
<li>$q_t(x)$是条件，<code>condition</code>。就是橘色箭头的判断过程</li>
<li>内部的决策过程，例如<code>deadline?</code>，内部节点</li>
</ul>
<p>那么决策树的表达就有两种方式：</p>
<ul>
<li><p>路径角度。将每个从根到叶子的路径作为一个假设g，通过不同的条件组合得到最后的G(X)。<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-05-12-53-15.png" alt=""> </p>
</li>
<li><p>递归角度。父树是由子树递归定义的<code>tree=(root,sub-trees)</code><br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-05-12-53-25.png" alt=""> </p>
</li>
</ul>
<h2 id="基本流程">1.2. 基本流程</h2><ol>
<li>如何分支（branching criteria），即如何得到$b(x)$</li>
<li>根据分支，数据如何分块</li>
<li>根据数据，如何学习子树</li>
<li>得到最终的决策树</li>
</ol>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-05-15-33-51.png" alt=""> </p>
<h1 id="CART算法">2. CART算法</h1><ul>
<li>Classification And Regression Tree，分类回归树</li>
<li>二叉树（只有是、否）</li>
<li>输入：随机变量$X$</li>
<li>输出：随机变量$Y$的条件概率分布</li>
<li>$g_t(x)$返回一个常数（根据不同的条件，对数据进行切分，到达叶子节点时，根据剩下的数据进行预测，输出一个常数）</li>
</ul>
<h2 id="纯度">2.1. 纯度</h2><h3 id="纯度的定义">2.1.1. 纯度的定义</h3><ul>
<li>CART算法中每个节点（看做是一个决策桩decision stump）对数据进行切分，如果分出来的数据的y都很接近（回归问题）或者都一样（分类问题），那么我们说这样的数据是“纯的”，这样用标量对数据进行预测可以得到比较小的误差。</li>
</ul>
<p>CART分支$b(x)$为：<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-05-16-03-33.png" alt=""> </p>
<ul>
<li>我们通过上面的公式，来计算对于每一个节点的决策桩来说，分出来的两份数据的纯度是怎样的。</li>
<li>该公式通过计算数据集<code>Di（i=1 or 2）</code>的纯度并根据数据集的数量对其进行加权</li>
<li>其加权的意义是如果数据集的数量比较大的话，那个纯度对其比较重要</li>
<li>反之，就不那么重要。</li>
<li>CART通过分出的两部分数据综合起来的纯度对决策桩进行选择，选择“最纯”的分割方式作为当前的分支。</li>
</ul>
<h3 id="纯度的计算函数">2.1.2. 纯度的计算函数</h3><p>我们可以将分割出来的数据和回传的常数的误差作为评价纯度的方法，利用数据的y和回传的y_ba的均方误差来评价回归问题的纯度；利用0/1误差函数来评价分类问题的纯度。</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-05-16-11-16.png" alt=""> </p>
<p>如果是分类问题，我们还可以使用一个别的方法。通过基尼不纯度来度量分类问题的纯度问题。</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-05-16-11-41.png" alt=""> </p>
<h2 id="终止条件">2.2. 终止条件</h2><p>CART中有两种被迫终止的情况，分别是：</p>
<ul>
<li><code>yn</code>都一样，这时不纯度为0，于是可以得到<code>gt(x)=yn</code>；</li>
<li><code>xn</code>都一样，就没有继续分割的可能了。</li>
<li>CART树长到被迫停下来的情况，称为完全长成的树（fully-grown tree）。</li>
</ul>
<p>下面是CART算法完整流程：</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-05-16-19-09.png" alt=""> </p>
<h2 id="CART剪枝">2.3. CART剪枝</h2><p>预防过拟合</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-05-16-20-48.png" alt=""> </p>
<p>上图告诉我们使用叶子的数目作为正则项（regularizer），最终得到一个正则化的决策树。<br>关于剪枝的具体做法时：</p>
<ul>
<li>首先得到完全长成的树作为<code>G(0)</code>；</li>
<li>然后试图摘掉一片叶子，将所有摘掉一片叶子后的树计算<code>Ein</code>，将最小的那棵摘掉一片叶子的数作为<code>G(1)</code>；</li>
<li>如此这般，得到摘掉两片叶子的最优树<code>G(2)</code>，这样不断剪枝，直到根结点，形成一个子树序列；</li>
<li>最终对这个子树序列使用<code>argmin Ein(G)+λΩ(G)</code>来得到最后的输出。</li>
</ul>
<h1 id="参考资料">3. 参考资料</h1><ol>
<li><a href="http://blog.jasonding.top/2015/07/22/Machine%20Learning/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E3%80%91%E5%86%B3%E7%AD%96%E6%A0%91%E7%AE%97%E6%B3%95/" target="_blank" rel="external">Jason Ding，决策树算法</a></li>
<li>机器学习技法课程，林轩田，台湾大学</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 机器学习算法 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[boosting（混合模型）和bagging（装袋）]]></title>
      <url>/2017/03/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-boosting%EF%BC%88%E6%B7%B7%E5%90%88%E6%A8%A1%E5%9E%8B%EF%BC%89%E5%92%8Cbagging/</url>
      <content type="html"><![CDATA[<p>这位前辈写的很好。今天也没有时间看视频。看看他的博客也就足够了。<a href="http://blog.jasonding.top/2015/06/10/Machine%20Learning/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E3%80%91%E6%B7%B7%E5%90%88%E5%92%8C%E8%A3%85%E8%A2%8B/" target="_blank" rel="external">混合和装袋</a></p>
<h1 id="bagging">1. bagging</h1><p>bagging——基于数据随机重抽样的分类器构建方法。</p>
<h1 id="boosting">2. boosting</h1><p>新的分类器根据已训练出的分类器的性能来进行训练；<br>分类结果基于所有分类器的加权求和得到。</p>
<h1 id="bagging和boosting区别">3. bagging和boosting区别</h1><p>Bagging 是 Bootstrap Aggregating 的简称，意思就是再取样 (Bootstrap) 然后在每个样本上训练出来的模型取平均，所以是降低模型的 variance. Bagging 比如 Random Forest 这种先天并行的算法都有这个效果。</p>
<p>Boosting 则是迭代算法，每一次迭代都根据上一次迭代的预测结果对样本进行加权，所以随着迭代不断进行，误差会越来越小，所以模型的 bias 会不断降低。这种算法无法并行，例子比如 Adaptive Boosting.</p>
<p>作者：匿名用户<br>链接：<a href="https://www.zhihu.com/question/26760839/answer/33963551" target="_blank" rel="external">https://www.zhihu.com/question/26760839/answer/33963551</a><br>来源：知乎<br>著作权归作者所有，转载请联系作者获得授权。</p>
]]></content>
      
        <categories>
            
            <category> 机器学习算法 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[O2O优惠券预测——思路总结]]></title>
      <url>/2017/03/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5-O2O%E4%BC%98%E6%83%A0%E5%88%B8%E9%A2%84%E6%B5%8B-%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>最近看各种机器学习算法，感觉没有实战，总是空空的。刚好这个月没什么事情，趁此机会拿<a href="https://tianchi.shuju.aliyun.com/getStart/information.htm?spm=5176.100067.5678.2.SfEzJi&amp;raceId=231593" target="_blank" rel="external">赛题</a>练习一下。</p>
<h1 id="资料整理">1. 资料整理</h1><ol>
<li><a href="https://github.com/wepe/O2O-Coupon-Usage-Forecast" target="_blank" rel="external">阿里天池O2O优惠券消费行为预测竞赛优胜方案</a>。第一名。北大。解题思路。</li>
<li><a href="http://blog.csdn.net/shine19930820/article/details/53995369" target="_blank" rel="external">O2O优惠券使用预测思路总结</a>。16名。解题思路。</li>
<li><a href="http://blog.csdn.net/bryan__/article/details/53907292" target="_blank" rel="external">O2O优惠券使用预测复赛第三名思路</a>。3名。PPT.</li>
<li><a href="https://www.zhihu.com/question/42154455/answer/124080774" target="_blank" rel="external">各竞赛QQ群</a></li>
<li><a href="http://www.datafountain.cn/data/science/player/competition/detail/description/238" target="_blank" rel="external">竞赛官网</a></li>
<li><a href="https://bbs.aliyun.com/thread/254.html?spm=5176.bbsl254.0.0.sBagXf&amp;type=1214&amp;type=1214#tabA" target="_blank" rel="external">论坛专区</a></li>
<li><a href="https://tianchi.shuju.aliyun.com/getStart/introduction.htm?spm=5176.100066.333.1.osUTZq&amp;raceId=231593" target="_blank" rel="external">天池新人实战赛[o2o优惠券使用预测]</a></li>
<li>也可以去天池官网上，点学习入口，下面的视频，这边也有对这次020比赛的一些视频解说 </li>
<li><a href="https://bbs.aliyun.com/read/273638.html" target="_blank" rel="external">数加平台指南＋文档、视频、FAQ及精华帖干货集锦</a></li>
<li><a href="http://www.jianshu.com/p/00dba98eb1d0" target="_blank" rel="external">数据科学完整学习路径</a></li>
</ol>
<h1 id="赛题背景">2. 赛题背景</h1><ul>
<li>O2O（Online to Offline）消费</li>
<li>O2O：是指将线下的商务机会与互联网结合，让互联网成为线下交易的平台</li>
<li>以优惠券盘活老用户或吸引新客户进店消费是O2O的一种重要营销方式</li>
</ul>
<h1 id="赛题目标">3. 赛题目标</h1><ul>
<li>个性化投放优惠券，提高核销率</li>
<li>通过分析建模，精准预测用户是否会在规定时间内使用相应优惠券</li>
<li>已知：用户在2016年1月1日至2016年6月30日之间真实线上线下消费行为</li>
<li>预测：用户在2016年7月领取优惠券后15天以内的使用情况</li>
<li>评价标准：优惠券核销预测的平均AUC（ROC曲线下面积）。即对每个优惠券coupon_id单独计算核销预测的AUC值，再对所有优惠券的AUC值求平均作为最终的评价标准。 关于AUC的含义与具体计算方法，可参考维基百科</li>
</ul>
<h1 id="数据描述及分析">4. 数据描述及分析</h1><h4 id="数据描述">4.0.0.1. 数据描述</h4><ul>
<li>Table 1: 用户线下消费和优惠券领取行为，ccf_offline_stage1_train.csv</li>
<li>Table 2: 用户线上点击/消费和优惠券领取行为，ccf_online_stage1_train</li>
<li>Table 3：用户O2O线下优惠券使用预测样本，ccf_offline_stage1_test_revised.csv</li>
<li>Table 4：选手提交文件字段，其中user_id,coupon_id和date_received均来自Table 3,而Probability为预测值</li>
</ul>
<p><strong> TABLE 1： 用户线下消费和优惠券领取行为 </strong><br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-03-21-57-25.png" alt=""> </p>
<p><strong> Table 2: 用户线上点击/消费和优惠券领取行为</strong><br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-03-21-58-04.png" alt=""> </p>
<p><strong> Table 3：用户O2O线下优惠券使用预测样本</strong><br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-03-21-58-29.png" alt=""> </p>
<p><strong> Table 4选手提交文件字段</strong><br>其中user_id,coupon_id和date_received均来自Table 3,而Probability为预测值<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-03-21-58-40.png" alt=""> </p>
<h4 id="数据分析">4.0.0.2. 数据分析</h4><h3 id="初步分析">4.0.1. 初步分析</h3><p><strong> TABLE 1 分析 </strong></p>
<ul>
<li>特点：<br>– 标题：用户线下消费和优惠券领取行为<br>– 场景：线下<br>– 行为：消费、优惠券领取<br>– 数据：优惠券领取、使用情况，消费情况，用户常活动地点与最近门店距离</li>
<li>分析1：用户行为有三种情况<br>– 领了优惠券 &amp;&amp; 未消费 = 负样本 （Date=null &amp; Coupon_id != null）<br>– 没领优惠券 &amp;&amp; 已消费（Date!=null &amp; Coupon_id = null）<br>– 领了优惠券 &amp;&amp; 已消费（Date!=null &amp; Coupon_id != null）<br>– 总结：本数据作为刻画用户特点的主要依据较为合理</li>
<li>分析2：优惠率<br>– 总结：有可能用户会根据优惠率来决定是否进行消费</li>
<li>分析3：距离<br>– 离用户近的门店可能会总领取优惠券，但不一定会使用。<br>– 离用户远的门店如果有优惠券，则可能会为了很大的优惠率专程去使用。</li>
<li>总结<br>– 本数据集主要刻画线下用户特征。</li>
</ul>
<p><strong> TABLE 2 分析 </strong></p>
<ul>
<li>特点：<br>– 标题：用户线上点击/消费和优惠券领取行为<br>– 场景：线上<br>– 行为：点击、消费、优惠券领取<br>– 数据：用户是否点击。购买。领取优惠券。</li>
<li>分析1：用户行为有三种情况<br>– 领了优惠券 &amp;&amp; 未消费 = 负样本（Date=null &amp; Coupon_id != null）<br>– 没领优惠券 &amp;&amp; 已消费 （Date!=null &amp; Coupon_id = null）<br>– 领了优惠券 &amp;&amp; 已消费 （Date!=null &amp; Coupon_id != null）</li>
<li>分析2：用户点击、消费、优惠券情况<br>– 用户点击了 &amp;&amp; 没领优惠券 &amp;&amp; 未消费 = 负样本<br>– 用户点击了 &amp;&amp; 领了优惠券 &amp;&amp; 未消费<br>– 用户点击了 &amp;&amp; 领了优惠券 &amp;&amp; 已消费<br>– 用户点击了 &amp;&amp; 没领优惠券 &amp;&amp; 已消费<br>– 用户没点击 </li>
<li>总结<br>– 本数据集主要刻画线上用户特征。</li>
</ul>
<p><strong> Table 3：用户O2O线下优惠券使用预测样本 </strong></p>
<ul>
<li>测试集</li>
</ul>
<h3 id="认识数据">4.0.2. 认识数据</h3><p>感谢wepon的<a href="https://tianchi.shuju.aliyun.com/video.htm?spm=5176.100258.100258.3.1O7LLR" target="_blank" rel="external">无私奉献</a></p>
<p>对提供的数据做一些基本的统计，有助于对赛题的理解，可以熟悉业务逻辑，也方便后面的特征工程。</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-12-21-38-50.png" alt=""> </p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-12-21-39-13.png" alt=""> </p>
<h1 id="特征提取">5. 特征提取</h1><ul>
<li>特征提取：将原始特征转换为一组具有明显物理意义（Gabor、几何特征[角点、不变量]、纹理[LBP HOG]）或者统计意义或核的特征</li>
<li>经验上来说，这些特征提取的越多越好，并不用担心特征过多，因为推荐系统的数据量都比较大，并且基于一些规则可以很好的筛选特征。</li>
<li>第一次做特征提取，很多东西想得不够周到。参考了很多第一名的思想。</li>
</ul>
<h4 id="用户特征">5.0.0.1. 用户特征</h4><p>用途：描述用户消费偏好</p>
<p>线下：</p>
<ol>
<li>领取优惠券率（领取次数/总次数）</li>
<li>优惠券核销率（优惠券使用次数/优惠券领取次数）</li>
<li>消费率（消费次数/总次数）</li>
<li>核销时的优惠率</li>
<li>领取、使用优惠券间隔</li>
<li>user经常活动的地点离平均/最大/最小用户-商家的最近门店距离</li>
<li>消费频数</li>
<li>优惠券领取频数</li>
<li>优惠券使用频数</li>
<li>用户满减优惠券核销率（满减优惠券使用次数/优惠券领取次数）</li>
<li>用户满减优惠券核销比重（满减优惠券使用次数/优惠券使用次数）</li>
<li>核销优惠券的平均/最低/最高消费打率</li>
<li>核销过的商户数量，以及不同商家的比重</li>
<li>核销过的不同优惠券数量，以及其与优惠券种类数的比重</li>
<li>平均每个商家核销多少张优惠券</li>
</ol>
<p>线上：</p>
<ol>
<li>优惠券领取率（领取/总）</li>
<li>点击频数</li>
<li>优惠券领取频数</li>
<li>优惠券使用频数</li>
<li>优惠券核销率（使用/领取）</li>
<li>消费频数</li>
<li>消费率（消费次数/总）</li>
<li>核销时的优惠率</li>
<li>领取、使用优惠券间隔</li>
<li>用户线上不消费次数</li>
<li>用户线下不消费次数占线上线下总的不消费次数的比重</li>
<li>用户线下的优惠券核销次数占线上线下总的优惠券核销次数的比重</li>
</ol>
<h4 id="线下消费的优惠券特征">5.0.0.2. 线下消费的优惠券特征</h4><ol>
<li>优惠率</li>
<li>优惠券被领取次数</li>
<li>优惠券核销率</li>
<li>领取、使用优惠券间隔</li>
</ol>
<h4 id="线上商户特征">5.0.0.3. 线上商户特征</h4><ol>
<li>点击频数</li>
<li>购买频数</li>
<li>优惠券被领取频数</li>
<li>优惠券被使用频数</li>
<li>消费率（购买/总）</li>
<li>优惠券领取率（领取/总）</li>
<li>优惠券核销率（使用/领取）</li>
<li>优惠率</li>
<li>领取、使用优惠券间隔</li>
</ol>
<p>现在遇到了一些瓶颈。参考了前人的教程<a href="http://www.jianshu.com/p/00dba98eb1d0" target="_blank" rel="external">数据科学完整学习路径</a>，发现自己基础还是不够扎实。决定先看看机器学习技法教程，再进行下一步。</p>
<p>=======2017.3.1======</p>
<p>看了一下GBDT，发现我的疑问还是不能解决。</p>
<ul>
<li>多类特征，怎么处理？</li>
<li>处理的流程究竟是怎样的？</li>
</ul>
<p>为了解决上述问题，我决定开始深入分析第一名的队伍的<a href="https://github.com/wepe/O2O-Coupon-Usage-Forecast" target="_blank" rel="external">阿里天池O2O优惠券消费行为预测竞赛优胜方案</a>源码。</p>
<p>=======2017.3.8======</p>
<p>算是大致看完了前辈的代码。见本博客文章“O2O优惠券预测——对第一名的思路源码分析”</p>
<p>这其中的奥妙深不可测。</p>
<p>知识累积不是一蹴而就的。加油吧。</p>
<p>=======2017.3.12======</p>
]]></content>
      
        <categories>
            
            <category> o2o优惠券使用预测 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[SVM]]></title>
      <url>/2017/03/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-SVM/</url>
      <content type="html"><![CDATA[<h1 id="SVM简介">1. SVM简介</h1><p>SVM - Support Vector Machines, 支持向量机。是二分类模型。</p>
<h1 id="线性可分SVM">2. 线性可分SVM</h1><h2 id="概念复习">2.1. 概念复习</h2><p><a href="http://blog.csdn.net/kaka19880812/article/details/46419269" target="_blank" rel="external">参考文献</a></p>
<p><em>输入空间</em>：输入所有可能的取值的集合</p>
<p><em>特征向量</em>：每个具体的输入</p>
<p><em>特征空间</em>：所有特征向量存在的空间。特征空间可以是输入空间，也可以由输入空间映射得到。模型定义在特征空间上。</p>
<p><em>输出空间</em>：输出所有可能的取值的集合</p>
<h2 id="线性可分SVM学习目标">2.2. 线性可分SVM学习目标</h2><p>在特征空间找到一个分离超平面 $wx+b=0$，并且间隔最大。</p>
<h2 id="SVM与PLA区别">2.3. SVM与PLA区别</h2><p>PLA:误分类最小策略，求得分离超平面。解不唯一。<br>线性可分SVM:间隔最大化，求得分离超平面。解唯一。</p>
<h2 id="函数间隔和几何间隔">2.4. 函数间隔和几何间隔</h2><p><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-03-13-44-02.png" alt=""> </p>
<ul>
<li>一个点距离分离超平面的远近<code>|wx+b|</code> 是 分类预测的<strong>确信程度</strong>。例如将A分为0的确信度很高，而将C分为0的确信度较低</li>
<li><code>wx+b</code>与<code>y</code>的符号一致，则分类正确</li>
<li><strong>函数间隔</strong>：<code>y(wx+b)</code>，表示分类的正确性及确信度</li>
<li><strong>超平面的函数间隔*</strong>：<code>min{y(wx+b)}</code></li>
<li><strong>几何间隔</strong>：规范化<code>||w||=1</code>，即为$y(\frac{w}{||w||}\cdot x + \frac{b}{||w||})$，使得间隔固定。（因为w和b成比例增加时，超平面不会改变，但函数间隔会变大）</li>
</ul>
<h1 id="SVM基本算法">3. SVM基本算法</h1><h2 id="标准问题">3.1. 标准问题</h2><p><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-03-14-56-13.png" alt=""> </p>
<h2 id="算法的推导">3.2. 算法的推导</h2><ul>
<li>一开始的目标是：<br>– 目标：求得一个x，使得margin最大<br>– 条件：<br>— 每个点都被正确分类（<code>b</code>被塞入了<code>w</code>矩阵里）<br>— magin是最近的点的距离<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-04-16-22-00.png" alt=""> </li>
</ul>
<ul>
<li><p>从距离的理解入手，如图所示<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-04-16-07-16.png" alt=""> </p>
</li>
<li><p><code>w</code>的理解<br>– 灰色是分割平面<br>– $x’$和$x’’$是平面上的两个点，则它俩满足$w^T X’ = -b$，$w^T x’’ = -b$<br>– 两式相减，得到 $w^T(x’’ - x’)=0$<br>– 则<strong><code>w</code>垂直于平面</strong>，即w是平面的法向量<br>– 那么dist是向量$x’ x’’$在<code>w</code>上的投影</p>
</li>
</ul>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-04-16-15-32.png" alt=""> </p>
<ul>
<li><p>而<code>y(wx+b)&gt;0</code>，则距离可以表示为：<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-04-16-18-42.png" alt=""> </p>
</li>
<li><p>因此，新的算法目标为<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-04-16-19-57.png" alt=""> </p>
</li>
<li><p>归一化条件：<code>margin=y(wx+b)=1</code>,得到新目标<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-04-16-29-24.png" alt=""> </p>
</li>
<li><p>对目标进行放缩，方便解<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-04-16-31-16.png" alt=""> </p>
</li>
<li><p>再将最大化变为最小化，也拿走||w||的根号<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-04-16-33-31.png" alt=""> </p>
</li>
</ul>
<h3 id="支持向量">3.2.1. 支持向量</h3><ul>
<li>在线性可分的情况下，训练数据集的样本点中与分离超平面距离最近的样本点的实例，叫做<strong>支持向量</strong>（support vector）</li>
<li>支持向量是使得约束条件等号成立的点</li>
<li>决定分离超平面时，只有支持向量起作用，而其他点不起作用</li>
<li>在H1，H2上的点就是支撑向量（很少，但很重要的点）</li>
</ul>
<h3 id="间隔-margin">3.2.2. 间隔 margin</h3><p>H1，H2之间，$margin=\frac{2}{||w||}$</p>
<h3 id="间隔边界">3.2.3. 间隔边界</h3><p>H1，H2<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-03-15-06-02.png" alt=""> </p>
<h3 id="标准问题的求解">3.2.4. 标准问题的求解</h3><ul>
<li>目标是二次的，条件是线性的</li>
<li><p>则这是一个二次规划问题，有固定的解</p>
</li>
<li><p>我们的标准问题：<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-04-16-47-03.png" alt=""> </p>
</li>
<li><p>标准二次规划问题：<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-04-16-47-26.png" alt=""> </p>
</li>
<li><p>系数代入：<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-04-16-47-47.png" alt=""> </p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 机器学习算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 线性模型 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LR]]></title>
      <url>/2017/03/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-LR/</url>
      <content type="html"><![CDATA[<p>在说LR之前，我们先回顾一下logistic分布。</p>
<h1 id="logistic分布">1. logistic分布</h1><p>如果连续随机变量$X$服从logistic分布，则$X$具有下列<strong>分布函数和密度函数</strong>：</p>
<p>$$<br>F(x)=P(X&lt;=x)=\frac{1}{1+e^{-(x-u)/r}}<br>$$</p>
<p>$$<br>f(x)=F’(x)=\frac{e^{-(x-u)/r}}{r(1+e^{-(x-u)/r})^2}<br>$$</p>
<p>其中</p>
<p>$u$为位置参数</p>
<p>$r&gt;0$为形状参数</p>
<p>其中，密度函数与分布函数的形状如图所示<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-02-20-46-41.png" alt=""> </p>
<p><strong>备注：分布密度函数与分布函数</strong></p>
<p>概率密度函数$f(x)$：表示瞬时值落在某区间的概率，是幅值的概率。++用来描述连续型随机变量取值的密集程度的。++$f(x)$表示X=x的概率是$\int_0^1f(x)$。</p>
<p>$P(X=x|x \in (0,1))=\int_0^1f(x)$</p>
<p>分布函数$F(x)$：描述随机变量落在任一区间的概率。</p>
<p>$F(x)=P(X&lt;=x)$</p>
<p>关系：</p>
<p>分布函数$F(x)$是概率密度函数$f(x)$从负无穷到正无穷上的积分；</p>
<p>在坐标轴上，概率密度函数的函数值y表示落在x点上的概率为y；分布函数的函数值y则表示x落在区间(-∞上的概率。</p>
<h1 id="二项logistic回归模型">2. 二项logistic回归模型</h1><p><strong>用途：估计某个值的为哪一类的概率</strong></p>
<p>logistic回归是分类问题。前面我们讲的分类问题的输出都是 “yes”或者“no”。但是在现实生活中，我们并不是总是希望结果那么肯定，而是概率（发生的可能性）。比如，我们希望知道这个房子在第三个星期被卖出去的概率。那么以前的分类算法就无法使用了，这时logistic 回归就派上了用场。 </p>
<p><strong>定义</strong></p>
<p>二项logistic回归模型是如下的条件概率分布：</p>
<p>$$<br>P(Y=1|x)=\frac{exp(wx+b)}{1+exp(wx+b)}<br>$$</p>
<p>$$<br>P(Y=0|x)=\frac{1}{1+exp(wx+b)}<br>$$</p>
<p>其中：<br>$x \in R^n$ ：输入</p>
<p>$Y \in (0,1)$ ：输出</p>
<p>给定$x$，可以求得$P(Y=1|x)$和$P(Y=0|x)$</p>
<p><strong>logistic回归模型的特点</strong></p>
<p>几率（odds）= 该事件发生的概率/该事件不该发生的概率，则对数几率：</p>
<p>$$<br>log(odds)=log(\frac{p}{1-p})=log(\frac{P(Y=1|x)}{1-P(Y=1|x)})=wx<br>$$</p>
<p>则：输出Y=1的对数几率=输入x的线性函数</p>
<h1 id="模型参数估计">3. 模型参数估计</h1><p>输入： 一堆（x,y）</p>
<p>目标：估计参数w,b</p>
<p>方法：极大似然法</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-02-21-35-03.png" alt=""> </p>
<h1 id="总结">4. 总结</h1><ol>
<li>逻辑回归是一种预测y的各类别的概率的模型，即计算P(Y=1|x)或者P(Y=0|x)</li>
<li>与机器学习过程类似，即 通过已知的大量（x,y），拟合计算参数w,b；再用y=wx+b来计算新的x下的y；把y输入sigmoid函数中，得到y为1的概率。</li>
</ol>
<h1 id="LR推导（sigmoid，损失函数，梯度，参数更新公式）">5. LR推导（sigmoid，损失函数，梯度，参数更新公式）</h1><p>这篇文章非常详细地介绍了逻辑回归的推导。非常有用。我在此处进行了转载。</p>
<h2 id="声明">5.1. 声明</h2><ol>
<li>$ x(1),x(2),…,x(m) $ 表示 n 维空间的一个样本，$x(i)$ 表示第i个样本，$x(i)_j$ 表示第i个样本的第j维的数据（因为$x$是一个n维向量）。</li>
<li>$y(1),y(2),…,y(m)$ 表示 k 维空间的一个观测结果，记k从1,2,…,k变化，即分类问题中的k个类别，也可以0为下标开始，不影响推导。</li>
<li>$\pi()$是我们学习到的概率函数，实现样本数据到预测结果的映射：$R^n\rightarrow R^k$，（其实就是样本经过函数 $\pi()$计算后得到各个类别的预测概率，即一个k维向量），<br>$\pi(x)_u​$表示数据样本x属于类别u的概率，我们希望$\pi()​$具有如下性质：</li>
</ol>
<blockquote>
<ol>
<li>$\pi(x)_v&gt;0$  (样本x属于类别v的概率大于0，显然概率必须大于0)</li>
<li>$\sum_{v=1}^k\pi(x)_v = 1$,样本x属于各个类别的概率和为1</li>
<li>$\pi(x(i))_{y(i)}在所有类别概率中最大$</li>
</ol>
</blockquote>
<ol>
<li>$A(u,v)$是一个指示函数，$当u=v时A(u,v)=1，当u\neq v时A(u,v)=0，如A(u,y(i))$表示第i个观测结果是否为u</li>
</ol>
<h2 id="逻辑回归求解分类问题过程">5.2. 逻辑回归求解分类问题过程</h2><p>对于二分类问题有k=2，对线性回归函数$\lambda x$进行非线性映射得到：</p>
<p>$$ \pi(x)_1 = \frac{\rm e^{\lambda \cdot x}}{\rm e^{\lambda \cdot x}+1}\tag{1} $$<br> $$ \pi(x)_2 = 1-\pi(x)_1= \frac{1}{\rm e^{\lambda \cdot x}+1}\tag{2} $$<br>对于多分类问题有：<br> $$ \pi(x) = \frac{\rm e^{\lambda _v\cdot x}}{\sum_{u=1}^m\rm e^{\lambda_u \cdot x}}\tag{3} $$<br>对$\lambda$求偏导可得：</p>
<p>$$ \begin{aligned}<br>u = v 时，<br>\frac {\partial\,\pi (x)_v}{\lambda_{v,j}} &amp;= \frac{x_j\rm e^{\lambda _{v,j}\cdot x}\cdot \sum_{u=1}^m\rm e^{\lambda_{u,j} \cdot x}-x_j\rm e^{\lambda _{v,j}\cdot x}\rm e^{\lambda _{v,j}\cdot x}}{(\sum_{u=1}^m\rm e^{\lambda_{u,j} \cdot x})^2}\\<br>&amp; = \frac{x_j\rm e^{\lambda _{v,j}\cdot x}}{\sum_{u=1}^m\rm e^{\lambda_{u,j} \cdot x}} \cdot \frac{\sum_{u=1}^m\rm e^{\lambda_{u,j} \cdot x}-\rm e^{\lambda_{v,j}\cdot x}}{\sum_{u=1}^m\rm e^{\lambda_{u,j} \cdot x}}\\&amp; = x_j \pi(x)_v(1-\pi(x)_v)\end{aligned}\tag{4} $$ </p>
<p>$$<br>\begin{aligned}<br>u \neq v 时<br>\frac {\partial\,\pi (x)_v}{\lambda_{u,j}}&amp;=-\frac{\rm e^{\lambda_{v,j} \cdot x} \cdot (x_j\rm e^{\lambda_{u,j} \cdot x})}{(\sum_{u=1}^m\rm e^{\lambda_{u,j} \cdot x})^2} \\<br>&amp;= -x_j \pi(x)_v\pi(x)_u, u\neq v时<br>\end{aligned}<br>\tag{5}<br>$$<br>该分类问题的最大似然函数为：<br> $$ L(\lambda)=\prod_{i=1}^m \pi(x(i))_{y(i)}\tag{6} $$<br>取对数得：<br> $$ f(\lambda)=\log L(\lambda)=\sum_{i=1}^m \log(\pi(x(i))_{y(i)})\tag{7} $$<br>求似然函数最大值，令：<br>$$<br>\begin{aligned}<br>\frac{\partial\,f(\lambda)}{\partial \,\lambda_{u,j}} &amp;=\frac{\partial}{\partial \,\lambda_{u,j}}\sum_{i=1}^m \log(\pi(x(i))_{y(i)}) \\<br>&amp;= \sum_{i=1}^m \frac{1}{\pi(x(i))_{y(i)}}\frac{\partial}{\partial \,\lambda_{u,j}}\pi(x(i))_{y(i)} \\<br>&amp;= \sum_{\begin{array}{c}i=1,\\y(i)=u\end{array}}^m \frac{1}{\pi(x(i))_{y(i)}}\frac{\partial}{\partial \,\lambda_{u,j}}\pi(x(i))_{u} + \sum_{\begin{array}{c}i=1,\\y(i)\neq u\end{array}}^m \frac{1}{\pi(x(i))_{y(i)}}\frac{\partial}{\partial \,\lambda_{u,j}}\pi(x(i))_{y(i)}\\<br>&amp;= \sum_{\begin{array}{c}i=1,\\y(i)=u\end{array}}^m \frac{1}{\pi(x(i))_{y(i)}}x(i)_j\pi(x(i))_u(1-\pi(x(i))_u) \\<br>&amp;\quad - \sum_{\begin{array}{c}i=1,\\y(i)\neq u\end{array}}^m \frac{1}{\pi(x(i))_{y(i)}}x(i)_j\pi(x(i))_{y(i)} \pi(x(i))_u\\<br>&amp;= \sum_{\begin{array}{c}i=1,\\y(i)=u\end{array}}^m x(i)_j(1-\pi(x(i))_u)-\sum_{\begin{array}{c}i=1,\\y(i)\neq u\end{array}}^m x(i)_j \pi(x(i))_u \\<br>&amp;= \sum_{\begin{array}{c}i=1,\\y(i)=u\end{array}}^m x(i)_j - \sum_{i=1}^m x(i)_j\pi(x(i))_u \\<br>&amp;= 0<br>\end{aligned}<br>\tag{8}<br>$$<br>得：<br> $$ \sum_{\begin{array}{c}i=1,\\y(i)=u\end{array}}^m x(i)_j = \sum_{i=1}^m x(i)_j\pi(x(i))_u\tag{9} $$<br>代入$A(u,y(i))=1$得：<br> $$ \sum_{i=1}^m x(i)_j\pi(x(i))_u = \sum_{i=1}^m x(i)_jA(u,y(i))\tag{10} $$<br>综上有：<br> $$ \frac{\partial\,f(\lambda)}{\partial \,\lambda_{u,j}}=\sum_{i=1}^m x(i)_j(A(u,y(i))-\pi(x(i))_u)\tag{11} $$<br>则参数更新公式为：</p>
<p>$$ \begin{aligned}\lambda_{u,j} &amp;= \lambda_{u,j} - \alpha \cdot \frac{\partial\,f(\lambda)}{\partial \,\lambda_{u,j}} \\&amp;= \lambda_{u,j} - \alpha \cdot \sum_{i=1}^m x(i)_j(A(u,y(i))-\pi(x(i))_u)\end{aligned}\tag{12} $$ </p>
<h2 id="sigmoid函数的由来（最大熵）">5.3. sigmoid函数的由来（最大熵）</h2><p>由上文已知$\pi()$具应有如下性质：</p>
<blockquote>
<ol>
<li>样本x属于类别v的概率大于0，显然概率必须大于0$\pi(x)_v&gt;0\tag{13}$ </li>
<li>样本x属于各个类别的概率和为1 $\sum_{v=1}^k\pi(x)_v = 1\tag{14}$</li>
<li>$\pi(x(i))_{y(i)}在所有类别概率中最大$</li>
</ol>
</blockquote>
<p>其中对最后一个条件等价于尽可能的让$\pi(x(i))\rightarrow y(i)$ 即 $\pi(x(i))\rightarrow A(u,y(i))$，理想情况为$\pi(x(i))= A(u,y(i))$固有：<br> $$ \sum_{i=1}^m x(i)_j\pi(x(i))_u = \sum_{i=1}^m x(i)_jA(u,y(i))\tag{15}，对所有的u，j都成立 $$ </p>
<p>对所有类别及所有样本取$\pi()$的熵，得：<br> $$ f(v,i)=-\sum_{v=1}^k\sum_{i=1}^m\pi(x(i))_v \log(\pi(x(i))_v)\tag{16} $$<br>得到一个优化问题：</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-11-06-23-03-41.png" alt=""> </p>
<p>$$\left{<br>\begin{aligned}<br>max f(v,i)=max (-\sum_{v=1}^k \sum_{i=1}^m pi(x(i))_v log(π(x(i))_v))\\<br>\pi(x)_v&gt;0\\<br>\sum_{v=1}^k π(x)_v = 1\\<br>\sum_{i=1}^m x(i)_j π(x(i))_u = \sum_{i=1}^m x(i)_j A(u,y(i))<br>\end{aligned}<br>\right.<br>\tag{17}$$<br>利用拉格朗日对偶性求这个优化问题的对偶问题，首先引入拉格朗日函数：</p>
<p>$$ \begin{aligned}L &amp;= \sum_{j=1}^n\sum_{v=1}^k\lambda_{v,j} \left( \sum_{i=1}^m\pi(x(i))_vx(i)_j-A(v,y(i))x(i)_j \right)\\&amp;+ \sum_{v=1}^k\sum_{i=1}^m\beta_i(\pi(x(i))_v-1)\\&amp;- \sum_{v=1}^k\sum_{i=1}^m\pi(x(i))_v\log(\pi(x(i))_v)\end{aligned}\tag{18} $$<br>其中 $$ \beta&lt;0 $$ ,由KKT条件有：<br>$$ \frac{\partial\,L}{\partial \,\pi(x(i))_u} = \lambda_u\cdot x(i)+\beta_i-\log(\pi(x(i))_u) - 1 = 0  \quad对所有i,u \tag{19}$$</p>
<p>$$则：\pi(x(i))_u = e^{\lambda_u \cdot x(i)+\beta_i-1} \tag{20}$$ </p>
<p>则： $$\pi(x(i))_u = e^{\lambda_u \cdot x(i)+\beta_i-1} \tag{20}$$<br>由（14）式得到：<br> $$  \sum_{v=1}^k e^{\lambda_u \cdot x(i)+\beta_i-1} = 1\ $$<br>即： $$e^\beta=\frac{1}{\sum_{v=1}^ke^{\lambda_u \cdot x(i)-1}} \tag{21} $$<br>代入（21）式消去常数项得：<br> $$ \pi(x(i))_u=\frac{e^{\lambda_u \cdot x}}{\sum_{v=1}^ke^{\lambda_u \cdot x}}\tag{22} $$<br>即多分类问题对应的sigmoid函数</p>
<h1 id="其它文献">6. 其它文献</h1><ol>
<li><a href="http://blog.csdn.net/cyh_24/article/details/50359055" target="_blank" rel="external">Logistic Regression 的前世今生（理论篇）</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> 机器学习算法 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[SQL游标]]></title>
      <url>/2017/03/02/SQL-SQL%E6%B8%B8%E6%A0%87/</url>
      <content type="html"><![CDATA[<h1 id="简介">1. 简介</h1><h3 id="场景">1.0.1. 场景</h3><p>从某一结果集中地逐一读记录</p>
<h3 id="游标本质">1.0.2. 游标本质</h3><p>能从包括多条数据记录的结果集中每次提取一条记录的机制。</p>
<p>我们知道关系数据库管理系统实质是面向集合的，在MS SQL SERVER 中并没有一种描述表中单一记录的表达形式，除非使用where 子句来限制只有一条记录被选中。因此我们必须借助于游标来进行面向单条记录的数据处理。</p>
<h3 id="游标种类">1.0.3. 游标种类</h3><ul>
<li>Transact_SQL 游标</li>
<li>API 游标</li>
<li>客户游标</li>
</ul>
<h1 id="游标操作">2. 游标操作</h1><p>使用游标有四种基本的步骤:声明游标、打开游标、提取数据、关闭游标。</p>
<h3 id="声明游标">2.0.1. 声明游标</h3><p>游标的声明包括两个部分:游标的名称 + 这个游标所用到的SQL语句。</p>
<p>例：要声明一个叫作Cus-tomerCursor的游标用以查询地址在北京的客户的姓名、帐号及其余额: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">DECLARE CustomerCursor CURSOR FOR </div><div class="line">SELECT acct_no,name,balance </div><div class="line">FROM customer </div><div class="line">WHERE province=&quot;北京&quot;;</div></pre></td></tr></table></figure>
<p>TIPS:</p>
<ul>
<li>声明游标的这一段代码行是不执行的,不能将debug时的断点设在这一代码行上,也不能用IF语句来声明两个同名的游标,如下列的代码就是错误的。 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">IF Is_prov=&quot;北京&quot;THEN </div><div class="line">DECLARE CustomerCursor CURSOR FOR </div><div class="line">SELECT acct_no,name,balance </div><div class="line">FROM customer </div><div class="line">WHERE province=&quot;北京&quot;; </div><div class="line">ELSE </div><div class="line">DECLARE CustomerCursor CURSOR FOR </div><div class="line">SELECT acct_no,name,balance </div><div class="line">FROM customer </div><div class="line">WHERE province〈〉&quot;北京&quot;; </div><div class="line">END IF</div></pre></td></tr></table></figure>
<h3 id="打开游标">2.0.2. 打开游标</h3><p>打开游标是执行与其相关的一段SQL语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OPEN CustomerCursor;</div></pre></td></tr></table></figure>
<h3 id="提取数据">2.0.3. 提取数据</h3><p>必须用FETCH语句来取得数据。</p>
<p>一条FETCH语句一次可以将一条记录放入程序员指定的变量中。</p>
<p>事实上,++FETCH语句是游标使用的核心++。</p>
<h4 id="用游标提取一条数据">2.0.3.1. 用游标提取一条数据:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">FETCH CustmerCur-sor </div><div class="line">INTO:ls_acct_no, </div><div class="line">    :ls_name, </div><div class="line">    :ll_balance;</div></pre></td></tr></table></figure>
<h4 id="用游标遍历很多条数据：">2.0.3.2. 用游标遍历很多条数据：</h4><p>而在多数情况下,我们所想要作的是在数据库中从第一条记录开始提取,一直到结束。所以我们一般要将游标提取数据的语句放在一个循环体内,直至将结果集中的全部数据提取后,跳出循环圈。</p>
<p><strong>通过检测SQLCA.SQL-CODE的值,可以得知最后一条FETCH语句是否成功。</strong></p>
<p>一般,当SQLCODE值为0时表明一切正常,100表示已经取到了结果集的末尾,而其它值均表明操作出了问题,这样我们可以编写以下的代码: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">lb_continue=True </div><div class="line">ll_total=0 </div><div class="line">DO WHILE lb_continue </div><div class="line">    FETCH CustomerCur-sor </div><div class="line">    INTO:ls_acct_no, </div><div class="line">        :ls_name, </div><div class="line">        :ll_balance; </div><div class="line">    If sqlca.sqlcode=0 Then  #如果SQLCA.SQL-CODE==0，则一切正常</div><div class="line">        ll_total+=ll_balance </div><div class="line">    Else #跳出循环</div><div class="line">        lb_continue=False </div><div class="line">    End If </div><div class="line">LOOP</div></pre></td></tr></table></figure>
<h3 id="关闭游标">2.0.4. 关闭游标</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CLOSE CustomerCursor;</div></pre></td></tr></table></figure>
<h3 id="使用Where子句子">2.0.5. 使用Where子句子</h3><p>我们可以动态地定义游标中的Where子句的参数,例如在本例中我们是直接定义了查询省份是北京的记录,但也许在应用中我们要使用一个下拉式列表框,由用户来选择要查询的省份,我们该怎样做呢?<br>我们在前面曾经提到过,DECLARE语句的作用只是定义一个游标,在OPEN语句中这个游标才会真正地被执行。了解了这些,我们就可以很方便地实现这样的功能,在DECLARE的Where子句中加入变量作参数,如下所示: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">DECLARE CustomerCursor CURSOR FOR </div><div class="line">SELCECT acct_no,name,balance </div><div class="line">FROM customer </div><div class="line">WHERE province=:ls_province; </div><div class="line">∥定义ls_province的值 </div><div class="line">OPEN CustomerCursor;</div></pre></td></tr></table></figure>
<h3 id="游标的类型">2.0.6. 游标的类型</h3><p>同其它变量一样,我们也可以定义游标的访问类型:全局、共享、实例或局部,游标变量的命名规范建议也同其它变量一样。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">--声明游标</div><div class="line">declare my_cursor cursor keyset for select * from info</div><div class="line">--删除游标资源</div><div class="line">deallocate my_cursor</div><div class="line">--打开游标,在游标关闭或删除前都有效</div><div class="line">open my_cursor</div><div class="line">--关闭游标</div><div class="line">close my_cursor</div><div class="line">--声明局部变量</div><div class="line">declare @id int,@name varchar(20),@address varchar(20)</div><div class="line">--定位到指定位置的记录</div><div class="line">fetch absolute 56488 from my_cursor into @id,@name,@address</div><div class="line">select @id as id,@name as name,@address as address</div><div class="line">--定位到当前记录相对位置记录</div><div class="line">fetch relative -88 from my_cursor into @id,@name,@address</div><div class="line">select @id as id,@name as name,@address as address</div><div class="line">--定位到当前记录前一条</div><div class="line">fetch prior from my_cursor into @id,@name,@address</div><div class="line">select @id as id,@name as name,@address as address</div><div class="line">--定位到当前记录后一条</div><div class="line">fetch next from my_cursor into @id,@name,@address</div><div class="line">select @id as id,@name as name,@address as address</div><div class="line">--定位到首记录</div><div class="line">fetch first from my_cursor into @id,@name,@address</div><div class="line">select @id as id,@name as name,@address as address</div><div class="line">--定位到尾记录</div><div class="line">fetch last from my_cursor into @id,@name,@address</div><div class="line">select @id as id,@name as name,@address as address</div></pre></td></tr></table></figure>
<p>实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">use database1</div><div class="line">declare my_cursor cursor scroll dynamic</div><div class="line"> /**//*scroll表示可随意移动游标指针（否则只能向前），dynamic表示可以读写游标（否则游标只读）*/</div><div class="line">for</div><div class="line">select productname from  product</div><div class="line">open my_cursor</div><div class="line">declare @pname sysname</div><div class="line">fetch next from my_cursor into @pname</div><div class="line">while(@@fetch_status=0)</div><div class="line">  begin</div><div class="line">    print &apos;Product Name: &apos; + @pname</div><div class="line">    fetch next from my_cursor into @pname</div><div class="line">  end</div><div class="line">fetch first from my_cursor into @pname</div><div class="line">print @pname</div><div class="line">/**//*update product set productname=&apos;zzg&apos; where current of my_cursor */</div><div class="line">/**//*delete from product where current of my_cursor */</div><div class="line">close my_cursor</div><div class="line">deallocate my_cursor</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> SQL </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[从出租车行驶数据筛选出OD点数据]]></title>
      <url>/2017/03/02/%E4%BB%8E%E5%87%BA%E7%A7%9F%E8%BD%A6%E8%A1%8C%E9%A9%B6%E6%95%B0%E6%8D%AE%E7%AD%9B%E9%80%89%E5%87%BAOD%E7%82%B9%E6%95%B0%E6%8D%AE/</url>
      <content type="html"><![CDATA[<p>动手前先动脑，这句话献给自己。</p>
<h2 id="目标">0.1. 目标</h2><p>从出租车行驶数据中，筛选出OD点。</p>
<h2 id="数据集">0.2. 数据集</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">名称：2012年11月1日 北京市出租车GPS数据</div><div class="line"></div><div class="line">格式：txt文本文件</div><div class="line"></div><div class="line">数据项及顺序：车辆标识,触发事件,运营状态,GPS时间,GPS经度,GPS纬度,GPS速度,GPS方向,GPS状态</div><div class="line">车辆标识：6个字符</div><div class="line">触发事件：0=变空车，1=变载客，2=设防，3=撤防，4=其它</div><div class="line">运营状态：0=空车，1=载客，2=驻车，3=停运，4=其它</div><div class="line">GPS时间</div><div class="line">GPS经度</div><div class="line">GPS纬度</div><div class="line">GPS速度：取值000-255内整数，以公里/小时为单位</div><div class="line">GPS方位：取值000-360内整数，以度为单位</div><div class="line">GPS状态：0=无效，1=有效</div><div class="line">结束串：回车符+换行符</div><div class="line"></div><div class="line">数据示例:</div><div class="line">123456,0,0,20110414160613,116.4078674,40.2220650,21,274,1</div></pre></td></tr></table></figure>
<h2 id="思路">0.3. 思路</h2><ol>
<li>将数据点按照“车牌号、运营时间、运营状态”依次从小到大排序</li>
<li>筛出同一车牌号的运营状态变化的时刻的数据</li>
</ol>
<h2 id="方法">0.4. 方法</h2><ul>
<li><p>方法一：导入数据库，再写脚本操作数据。可能是我对数据库实在没缘分，这个方法没有成功。</p>
</li>
<li><p>方法二：将车牌号分段后，在每段上进行如上思路所示的操作。</p>
</li>
</ul>
<p>为了更好地分段，我们先对车牌号段进行分析。</p>
<h3 id="车牌号段分析">0.4.1. 车牌号段分析</h3><p>查询车的数目：12409个</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT COUNT(DISTINCT id) FROM SET1</div></pre></td></tr></table></figure>
<p>脚本名：data1IDcount.py</p>
<p>地址：81服务器上，D:\jiayi\wxt</p>
<p>听说数据集有三千多万，所以我决定每一千个数据取一条进行粗略分析。</p>
<p>车牌号分布：<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-01-15-01-24.png" alt=""> </p>
<p>结果：</p>
<ol>
<li>车牌号分布在1-800000之间</li>
<li>100000-200000的车最多</li>
<li>一共有32885600条数据</li>
</ol>
<h3 id="分段">0.4.2. 分段</h3><p>脚本名：data2cut.py</p>
<p>分段法：将车牌号分为10段，其中100000-200000为三段，其余段均分。 <del>简单起见，还是将车牌号均分为十段了(ERROR:Errcode: 28 - No space left on device))</del></p>
<p>还是采用了数据库。是福不是祸，是祸躲不过呀。<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-01-19-49-25.png" alt=""> </p>
<h3 id="伪代码">0.4.3. 伪代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">for i = 0:10000:800000</div><div class="line">    # 为本区间数据建立新表，并插入数据</div><div class="line">    CREATE TABLE to this range</div><div class="line">    INSERT data </div><div class="line">    #将本区间数据排序</div><div class="line">    ORDER BY id,timen,opevent</div><div class="line">    #遍历，筛出本段的OD点</div><div class="line">    for line in this range table</div><div class="line">    </div><div class="line">        #如果本条数据是跳跃点，则插入到OD表中</div><div class="line">        #vehicle:上一条数据的车牌号</div><div class="line">        #pre:上一条数据的opevent</div><div class="line">        </div><div class="line">        #第一条数据</div><div class="line">        if vehicle==&quot;&quot;:</div><div class="line">            vehicle = row[0]</div><div class="line">            pre=row[2]</div><div class="line">        else:#从第二条记录开始</div><div class="line">            # 如果与上一条是一个车</div><div class="line">            if vehicle==row[0]:</div><div class="line">                #如果与上一条记录是同一个车，且event有变化</div><div class="line">                if pre!=row[2]:</div><div class="line">                    INSERT to OD_table</div><div class="line">                    pre=row[2]</div><div class="line">                    vehicle=row[0]</div><div class="line">                else:</div><div class="line">                    continue</div><div class="line">            #如果与上一条不是同一个车</div><div class="line">            else:</div><div class="line">                vehicle=row[0]</div><div class="line">                pre=row[2]</div></pre></td></tr></table></figure>
<h3 id="结果">0.4.4. 结果</h3><p>原始数据：data.set1，32885600个</p>
<p>OD点：data.set1_od ,645271个</p>
]]></content>
      
        
        <tags>
            
            <tag> 数据预处理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ROC和AUC]]></title>
      <url>/2017/03/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5-O2O%E4%BC%98%E6%83%A0%E5%88%B8%E9%A2%84%E6%B5%8B-ROC%E5%92%8CAUC/</url>
      <content type="html"><![CDATA[<h3 id="AUC定义">0.0.1. AUC定义</h3><p>用途：用来度量分类模型好坏的一个标准<br>背景：</p>
<ul>
<li>有些时候，仅仅依靠正确率是不妥当的。</li>
<li>能客观反映对正样本、负样本综合预测的能力，还要考虑消除样本倾斜的影响。</li>
</ul>
<h3 id="ROC">0.0.2. ROC</h3><ul>
<li>ROC:Receiver Operating Characteristic</li>
<li>ROC曲线：横坐标是false positive rate(FPR)，纵坐标是true positive rate(TPR)。</li>
<li>对某个分类器而言，我们可以根据其在测试样本上的表现得到一个TPR和FPR点对。这样，此分类器就可以映射成ROC平面上的一个点。</li>
<li>调整这个分类器分类时候使用的阈值，我们就可以得到一个经过(0, 0)，(1, 1)的曲线，这就是此分类器的ROC曲线。</li>
</ul>
<p>tip：FPR和TPR<br>先来看一个普遍的二分类问题的结果，预测值和实际值有4种组合情况，看下面的表格：<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-03-22-18-05.png" alt=""><br>我们定义<br>$$ TruePositiveRate(TPR) = \frac{TP}{TP+FN=P} = \frac{正确预测1}{正确预测1+错误预测1=1的数量}=实际正样本正确预测的比例$$<br>$$ FalsePositiveRate(FPR) = \frac{FP}{FP+TN=N} = \frac{错误预测0}{错误预测0+正确预测0=0的数量}=实际负样本错误预测的比例$$</p>
<h4 id="如何一个分类器的画ROC曲线">0.0.2.1. 如何一个分类器的画ROC曲线</h4><p>概率输出：即表示分类器认为某个样本具有多大的概率属于正样本（或负样本），来动态调整一个样本是否属于正负样本<br>例：</p>
<ul>
<li>图中共有20个测试样本</li>
<li>“Class”一栏表示每个测试样本真正的标签（p表示正样本，n表示负样本）</li>
<li>“Score”表示每个测试样本属于正样本的概率。<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-03-22-38-47.png" alt=""><br>步骤：</li>
<li>从高到低，依次将“Score”值作为阈值，当测试样本属于正样本的概率大于或等于这个阈值时，我们认为它为正样本，否则为负样本。</li>
<li>举例来说，对于图中的第4个样本，其“Score”值为0.6，那么样本1，2，3，4都被认为是正样本，因为它们的“Score”值都大于等于0.6，而其他样本则都认为是负样本。</li>
<li>每次选取一个不同的阈值，我们就可以得到一组FPR和TPR，即ROC曲线上的一点。这样一来，我们一共得到了20组FPR和TPR的值，将它们画在ROC曲线的结果如下图：<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-03-22-39-56.png" alt=""> </li>
<li>当我们将阈值设置为1和0时，分别可以得到ROC曲线上的(0,0)和(1,1)两个点。将这些(FPR,TPR)对连接起来，就得到了ROC曲线。</li>
<li>当阈值取值越多，ROC曲线越平滑。</li>
</ul>
<h3 id="AUC">0.0.3. AUC</h3><ul>
<li>AUC的值就是处于ROC curve下方的那部分面积的大小</li>
<li>通常，AUC的值介于0.5到1.0之间</li>
<li>较大的AUC代表了较好的performance</li>
</ul>
<h4 id="计算AUC的方法">0.0.3.1. 计算AUC的方法</h4><ul>
<li>直接计算AUC是很麻烦的，所以就使用了AUC的一个性质（它和Wilcoxon-Mann-Witney Test是等价的）来进行计算。</li>
<li>Wilcoxon-Mann-Witney Test就是测试任意给一个正类样本和一个负类样本，正类样本的score有多大的概率大于负类样本的score。</li>
<li>有了这个定义，我们就得到了另外一中计算AUC的办法：得到这个概率。</li>
</ul>
<h5 id="方法一">0.0.3.1.1. 方法一</h5><p>统计一下所有的 M×N(M为正类样本的数目，N为负类样本的数目)个正负样本对中，有多少个组中的正样本的score大于负样本的score。当二元组中正负样本的 score相等的时候，按照0.5计算。然后除以MN。实现这个方法的复杂度为O(n^2)。n为样本数（即n=M+N）。<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-03-22-43-59.png" alt=""> </p>
<h5 id="方法二">0.0.3.1.2. 方法二</h5><p>第二种方法实际上和上述方法是一样的，但是复杂度减小了。</p>
<ul>
<li>首先对score从大到小排序</li>
<li>然后令最大score对应的sample 的rank为n，第二大score对应sample的rank为n-1，以此类推</li>
<li>然后把所有的正类样本的rank相加，再减去正类样本的score为最小的那M个值的情况。</li>
<li>得到的就是所有的样本中有多少对正类样本的score大于负类样本的score。</li>
<li>然后再除以M×N。即<br><code>AUC=((所有的正例位置相加)-M*(M+1))/(M*N)</code></li>
</ul>
<p>另外，特别需要注意的是，再存在score相等的情况时，对相等score的样本，需要 赋予相同的rank(无论这个相等的score是出现在同类样本还是不同类的样本之间，都需要这样处理)。具体操作就是再把所有这些score相等的样本 的rank取平均。然后再使用上述公式。</p>
<h3 id="参考文献">0.0.4. 参考文献</h3><ol>
<li><a href="https://www.zybuluo.com/frank-shaw/note/152851" target="_blank" rel="external">评价分类器性能指标之AUC、ROC</a></li>
<li><a href="http://www.cnblogs.com/lixiaolun/p/4053499.html" target="_blank" rel="external">AUC(Area Under roc Curve)学习笔记</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> o2o优惠券使用预测 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[PLA-线性感知机]]></title>
      <url>/2017/02/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-PLA-%E7%BA%BF%E6%80%A7%E6%84%9F%E7%9F%A5%E6%9C%BA/</url>
      <content type="html"><![CDATA[<p>感觉自己记性越来越差。寒假前看的东西，回来忘得一干二净。从此认真做笔记，不能再重蹈覆辙。——题记<br>（第一次使用markdown，不太习惯，后面的公式没有继续打。现在去学习一下好用一些的公式编辑方法）</p>
<h1 id="简介">1. 简介</h1><p>定义：感知机是二类分类的线性模型。</p>
<p>输入：实例的特征向量</p>
<p>输出：实例的类别（±1）</p>
<h1 id="感知机模型">2. 感知机模型</h1><p>感知机——由输入空间到输出空间的函数：</p>
<p>$$<br>f(x)=sign(wx+b)<br>$$</p>
<p>###Tips:<br>$ w \in R^n $：权值，weight<br>$ b \in R $：偏值，bias<br>输入空间（特征空间）：$ X \in R^n $<br>输出空间：$ y={+1,-1} $<br>输入：$ x \in X $表示实例的特征向量，对应于输入空间的点<br>输出：$ y \in Y $，表示实例的类别</p>
<h1 id="感知机学习策略">3. 感知机学习策略</h1><ol>
<li>感知机学习目标：求得一个能将训练集正实例点和负实例点完全正确分开的分离超平面 = 确定模型参数w,b。</li>
<li>感知机学习策略：定义（经验）损失函数并将损失函数极小化。</li>
<li>损失函数的选择：</li>
</ol>
<ul>
<li>《统计学习方法》中介绍到的损失函数：所有误分类点到超平面S的总距离：<img src="http://om1bxijvl.bkt.clouddn.com/2017-02-27-22-03-00.png" alt=""><br>一般不考虑w,即损失函数为：<img src="http://om1bxijvl.bkt.clouddn.com/2017-02-27-22-05-23.png" alt=""><br>M:误分类点的个数</li>
<li>《西瓜书》里提到的误差是均方误差：<img src="https://ooo.0o0.ooo/2017/07/11/59648c8143357.png" alt=""><br>然后用最小二乘法求解w,b。</li>
</ul>
<ol>
<li>误分类点越少，损失函数越小。</li>
</ol>
<p><strong>将感知机学习问题转化为求解损失函数最优化问题</strong></p>
<h1 id="感知机学习算法">4. 感知机学习算法</h1><h2 id="感知机学习算法的原始形式">4.1. 感知机学习算法的原始形式</h2><p><img src="http://om1bxijvl.bkt.clouddn.com/2017-02-27-22-06-33.png" alt=""> </p>
<h2 id="算法的收敛性">4.2. 算法的收敛性</h2>]]></content>
      
        <categories>
            
            <category> 机器学习算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 线性模型 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[布置完毕]]></title>
      <url>/2017/02/28/blog-%E5%B8%83%E7%BD%AE%E5%AE%8C%E6%AF%95/</url>
      <content type="html"><![CDATA[<p>可算是把博客布置得差不多了。还有很多功能待完善，先记下来，日后再说。</p>
<p>1.RSS订阅功能</p>
<p>2.新浪微博圈</p>
<p>3.搜索功能</p>
<p>4.评论功能</p>
<p>5.访问量统计</p>
<p>6.数学公式支持。已解决。<a href="https://weylmann.github.io/2017/02/21/%E7%94%A8github-hexo-mathjax-%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" target="_blank" rel="external">参考文献，程数的博客</a></p>
<p>7.图片一键上传到图床，已解决。<a href="https://github.com/kingname/MarkdownPicPicker" target="_blank" rel="external">参考文献MarkdownPicPicker-master</a></p>
<p>8.sublime text<a href="http://jingyan.baidu.com/article/f006222838bac2fbd2f0c87d.html" target="_blank" rel="external">编辑md</a>。<a href="http://www.cnblogs.com/Richard-Core/p/Sublime-MarkDown.html" target="_blank" rel="external">WEB实时刷新</a>。<a href="https://packagecontrol.io/packages/auto-save" target="_blank" rel="external">sublime实时保存</a></p>
<ol>
<li><a href="https://github.com/HarleyWang93/blog/issues/26" target="_blank" rel="external">站长统计</a></li>
<li><a href="https://zetaoyang.github.io/post/2016/07/08/hexo-localsearch.html" target="_blank" rel="external">搜索引擎</a></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">9.一键发布功能[已解决](http://blog.csdn.net/anonymalias/article/details/50528946)</div><div class="line"></div><div class="line">10.[为Hexo博客标题自动添加序号：hexo-heading-index](http://www.qingpingshan.com/jianzhan/cms/212734.html)</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 瞎折腾 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[机器学习简介]]></title>
      <url>/2017/02/27/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<p>很多东西看了就忘。一定要好好做笔记。</p>
<p>本节主要记录《机器学习基石》的常见符号。</p>
<h1 id="基础符号">1. 基础符号</h1><p>输入： $ x \in X $<br>输出： $y \in Y $<br>目标函数： $f:X\rightarrow Y $ （理想中的，实际得不到）<br>假设函数：$g:X\rightarrow Y $ ，又称为<code>hypothesis</code>（学习到的g，希望跟f越像越好）<br>$g \in H $<br>假设函数集合：$H = \{h_k\} $ <code>hypothesis set</code><br>训练集：$D=\{(x_1,y_1),…,(x_N,y_N)\}$<br>机器学习演算法：$A$</p>
<h1 id="机器学习流程">2. 机器学习流程</h1><ul>
<li>从数据集D出发</li>
<li>通过演算法A，来计算出一个g，使得g很接近f<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-04-19-09-29.png" alt=""> </li>
</ul>
<h1 id="误差E">3. 误差E</h1><p>不知道为什么公式显示不出来，只好手动展图了<br>输入误差：<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-04-20-44-49.png" alt=""> </p>
<p>$$E_{in}(h)=\frac{1}{N} \sum_{n=1}^N(h(x_n)-y_n)^2$$</p>
<ul>
<li>样本（训练集）中出现的错误率</li>
</ul>
<p>输出误差：<br><img src="http://om1bxijvl.bkt.clouddn.com/2017-03-04-20-45-03.png" alt=""> </p>
<p>$$E_{out}(h)=\mathcal{E}_{(x,y)\text~P}(w^Tx-y)^2$$</p>
<ul>
<li>总体（测试集+训练集）中出现的错误率</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 机器学习算法 </category>
            
        </categories>
        
        
    </entry>
    
  
  
</search>
