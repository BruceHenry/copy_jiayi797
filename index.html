<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="jiayi797的专栏">
<meta property="og:url" content="http://yoursite.com/child/index.html">
<meta property="og:site_name" content="jiayi797的专栏">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="jiayi797的专栏">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/child/"/>





  <title>jiayi797的专栏</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">jiayi797的专栏</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/child/2017/05/24/特征选择/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jiayi797">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jiayi797的专栏">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/24/特征选择/" itemprop="url">特征选择</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-24T14:40:33+08:00">
                2017-05-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/机器学习/" itemprop="url" rel="index">
                    <span itemprop="name">机器学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>特征选择：很重要</p>
<p><strong>tip:冗余特征(redundant feature)</strong>：</p>
<ul>
<li>本特征能被其它特征中推演出来。它不一定有坏处，但也不一定有好处。例如：考虑立方体对象，若已有特征“长”、“宽”，则“底面积”是冗余特征。</li>
<li>冗余特征在很多时候不起作用，会增加学习过程的负担。</li>
<li>但如果学习目标是估算立方体体积，则“底面积”特征会对学习更好。</li>
</ul>
<p>结论：如果某冗余特征恰好对应完成学习任务所需的“中间概念”，则该冗余特征是有益的。</p>
<h1 id="子集搜索与评价">1. 子集搜索与评价</h1><p>特征选取时，若没有任何领域知识进行先验假设，只能遍历所有可能子集。–&gt;不可取！</p>
<p><strong>可行做法</strong>:<br>产生个“候选子集”，评价它的好坏，基于评价结果产生下一个候选子集。</p>
<h2 id="问题一，如何评价结果获取下一个候选特征子集？">1.1. 问题一，如何评价结果获取下一个候选特征子集？</h2><p><strong>子集搜索</strong></p>
<ol>
<li>前向搜索</li>
</ol>
<ul>
<li>给定特征集合${a_1,a_2,…,a_d}$,将每个特征看做一个候选子集。对d个候选单特征子集进行评价，假定${a_2}$最优，将${a_2}$做为第一轮选定集；</li>
<li>加入一个新特征，构成包含两个特征的候选子集，假定在这$d-1$个候选两特征子集中${a_2,a_4}$最优，则将${a_2,a_4}$作为本轮选定集；</li>
<li>…</li>
<li>k+1轮时，不再更好，停止迭代</li>
</ul>
<ol>
<li>后向搜索<br>每次都删除掉一个特征</li>
</ol>
<h2 id="问题二，如何评价候选特征子集？">1.2. 问题二，如何评价候选特征子集？</h2><p><strong>信息增益</strong></p>
<ul>
<li>给定数据集$D$,假定$D$中第$i$类样本所占的比例为$p_i(i=1,2,…,|Y|)$.</li>
<li>假定所有样本属性均为离散型</li>
<li>对属性子集$A$,假定根据其取值将$D$分成了$V$个子集${D^1,D^2,…,D^V}$,每个子集中的样本在A上取值相同，则属性子集$A$的信息增益为：</li>
</ul>
<p>$$Gain(A)=Ent(D)-\sum_{v=1}^V\frac{|D^v|}{|D|}Ent(D^v)$$</p>
<p>其中信息熵定义为：</p>
<p>$$Ent(D)=-\sum_{k=1}^{|y|}p_klog_2p_k$$</p>
<p>信息增益$Gain(A)$越大，特征子集A包含的有助于分类的信息越多。</p>
<h2 id="总结">1.3. 总结</h2><p>特征选择方法=子集搜索+子集评价</p>
<p>常见特征选择方法：</p>
<ul>
<li>过滤式(filter)</li>
<li>包裹式(wrapper)</li>
<li>嵌入式(embedding)</li>
</ul>
<h1 id="过滤式选择-filter">2. 过滤式选择(filter)</h1><p>概念：先特征选择，再训练模型</p>
<p>特点：特征选择与模型学习无关</p>
<p>===来日填坑===</p>
<h1 id="包裹式选择">3. 包裹式选择</h1><p>概念：把最终将要使用的学习器的性能作为特征子集的评价准则</p>
<p>特点：需要多次训练学习器</p>
<p>===来日填坑===</p>
<h1 id="嵌入式选择与L1正则化">4. 嵌入式选择与L1正则化</h1>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/child/2017/05/22/java-Buffer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jiayi797">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jiayi797的专栏">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/22/java-Buffer/" itemprop="url">java-Buffer</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-22T20:17:39+08:00">
                2017-05-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>引言</strong></p>
<p>说到缓冲区，不得不提Java NIO。</p>
<p>Java NIO(New IO)是一个可以替代标准Java IO API的IO API（从Java 1.4开始)，Java NIO提供了与标准IO不同的IO工作方式。</p>
<p>Java NIO: Channels and Buffers（通道和缓冲区）</p>
<h1 id="什么是缓冲区">1. 什么是缓冲区</h1><p><strong>Buffer定义</strong></p>
<p>代码的角度来讲（可以查看JDK中Buffer、ByteBuffer、DoubleBuffer等的源码），Buffer类内部其实就是一个基本数据类型的数组，以及对这个缓冲数组的各种操作；</p>
<p>常见的缓冲区如ByteBuffer、IntBuffer、DoubleBuffer…内部对应的数组依次是byte、int、double…</p>
<p><strong>Buffer与通道的关系</strong></p>
<p>标准的IO基于字节流和字符流进行操作的，而NIO是基于通道（Channel）和缓冲区（Buffer）进行操作，数据总是<em>从通道读取到缓冲区中</em>，或者<em>从缓冲区写入到通道中</em>。</p>
<p><strong>继承结构</strong></p>
<p>以ByteBuffer为例：</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-05-22-20-31-24.png" alt=""> </p>
<p>Buffer是顶层抽象类，ByteBuffer继承Buffer，也是抽象类，ByteBuffer最常见的两个具体实现类如下：</p>
<p>DirectByteBuffer（JVM堆外部、通过unsafe.allocateMemory实现）、HeapByteBuffer（JVM堆）</p>
<p><strong>缓冲区用途</strong></p>
<p>写，然后读出</p>
<h1 id="缓冲区的四个属性">2. 缓冲区的四个属性</h1><ul>
<li><p>容量(capacity)<br>capacity指的是缓冲区能够容纳元素的最大数量，这个值在缓冲区创建时被设定，而且不能够改变，如下，我们创建了一个最大容量为10的字节缓冲区；</p>
<pre><code>ByteBuffer bf = ByteBuffer.allocate(10);
</code></pre></li>
<li><p>上界（limit）<br>limit指的是缓冲区中第一个不能读写的元素的数组下标索引，也可以认为是缓冲区中实际元素的数量；</p>
</li>
<li><p>位置（position）<br>position指的是下一个要被读写的元素的数组下标索引，该值会随get()和put()的调用自动更新；</p>
</li>
<li><p>标记（mark）<br>一个备忘位置，调用mark()方法的话，mark值将存储当前position的值，等下次调用reset()方法时，会设定position的值为之前的标记值；</p>
</li>
<li><p>四个属性值之间的关系<br>根据以上四个属性的定义，我们可以总结出它们之间的关系如下：<br>0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity</p>
</li>
</ul>
<h1 id="缓冲区调用一般步骤">3. 缓冲区调用一般步骤</h1><ol>
<li>写入数据到 Buffer</li>
<li>调用flip()方法</li>
<li>从 Buffer 中get()数据</li>
<li>调用clear()方法或者compact()方法</li>
</ol>
<h1 id="参考文献">4. 参考文献</h1><ol>
<li><a href="http://www.cnblogs.com/chenpi/p/6475510.html" target="_blank" rel="external">Java NIO中的缓冲区Buffer（一）缓冲区基础</a></li>
<li>[Java编程思想2]</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/child/2017/05/21/内存映射文件/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jiayi797">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jiayi797的专栏">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/21/内存映射文件/" itemprop="url">内存映射文件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-21T14:55:49+08:00">
                2017-05-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>内存映射文件：利用虚拟内存实现将文件“映射”到内存中。文件对应于内存中的一个字节数组，对文件的操作变为对这个字节数组的操作，而字节数组的操作直接映射到文件上。这样这个文件就可以当做是一个内存数组一样的访问，这比传统的文件操作要快得多。</p>
<p>映射：<strong>硬盘上文件</strong>的位置与进程<strong>逻辑地址空间</strong>中一块大小相同的区域之间的一一对应</p>
<p>不过，这种映射是操作系统提供的一种假象，文件一般不会马上加载到内存，操作系统只是记录下了这回事，当实际发生读写时，才会按需加载。</p>
<p>这种按需加载的方式，使得内存映射文件可以方便处理非常大的文件，内存放不下整个文件也不要紧，操作系统会自动进行处理，将需要的内容读到内存，将修改的内容保存到硬盘，将不再使用的内存释放。</p>
<p>内存映射文件也有局限性，比如，它不太适合处理小文件，它是按页分配内存的，对于小文件，会浪费空间，另外，映射文件要消耗一定的操作系统资源，初始化比较慢。</p>
<h1 id="java使用内存映射">1. java使用内存映射</h1><h2 id="步骤">1.1. 步骤</h2><ul>
<li>引入java.nio包</li>
<li><p>从文件中获得一个通道(channel)。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FileChannel channel = FileChanne.open(path,options)</div></pre></td></tr></table></figure>
</li>
<li><p>通过调用FileChannel类的map方法从这个通道中获得一个ByteBuffer,它代表内存中的字节数组。其中，映射文件区域与映射模式支持三种方式：</p>
<h2 id="–-FileChannel-MapMode-READ-ONLY-缓冲区只读">1.2. – FileChannel.MapMode.READ_ONLY:缓冲区只读</h2><p>FileChannel.MapMode.READ_WRITE：可读写。任何缓冲区的修改都会写回文件（非立即）<br>– FileChannel.MapMode.PRIVATE：缓冲区可写，但修改不会传播到文件中</p>
</li>
</ul>
<p>映射完成后，文件就可以关闭了，后续对文件的读写可以通过MappedByteBuffer。</p>
<p>例：以读写模式映射文件”abc.dat”，代码可以为：</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(<span class="string">"abc.dat"</span>,<span class="string">"rw"</span>);</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    MappedByteBuffer buf = file.getChannel().map(MapMode.READ_WRITE, <span class="number">0</span>, file.length());</div><div class="line">    <span class="comment">//使用buf...</span></div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125;<span class="keyword">finally</span>&#123;</div><div class="line">    file.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><p>##　</p>
<h1 id="参考文献">2. 参考文献</h1><p>1.<a href="https://juejin.im/post/58626ac361ff4b006cf14faf" target="_blank" rel="external">计算机程序的思维逻辑 (61) - 内存映射文件及其应用 - 实现一个简单的消息队列</a><br>2.<a href="http://blog.csdn.net/king_is_everyone/article/details/28096583" target="_blank" rel="external">java流的性能优化2-内存映射文件</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/child/2017/05/19/OpenMessaging源码阅读2-demo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jiayi797">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jiayi797的专栏">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/19/OpenMessaging源码阅读2-demo/" itemprop="url">OpenMessaging源码阅读2-demo</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-19T16:32:48+08:00">
                2017-05-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/中间件/" itemprop="url" rel="index">
                    <span itemprop="name">中间件</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="producer操作">1. producer操作</h1><p>tips:以下涉及到的代码是关键步骤代码。</p>
<ol>
<li><p>====================构造n个<strong>Topic</strong>和n个<strong>Queue</strong>====================</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">String topic1 = <span class="string">"TOPIC1"</span>; <span class="comment">//实际测试时大概会有100个Topic左右</span></div><div class="line">String queue2 = <span class="string">"QUEUE2"</span>; <span class="comment">//实际测试时，queue数目与消费线程数目相同</span></div><div class="line">List&lt;Message&gt; messagesForTopic1 = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">1024</span>);</div><div class="line">List&lt;Message&gt; messagesForQueue1 = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">1024</span>);</div></pre></td></tr></table></figure>
</li>
<li><p>====================向Topic和Queue中<strong>create</strong>数据====================</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">messagesForTopic1.add(producer.createBytesMessageToTopic(topic1,  (topic1 + i).getBytes()));</div></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>调用<code>producer</code>的<code>producer.createBytesMessageToTopic()</code>方法来创建<code>BytesMessage</code></li>
<li>将上一步产生的标准消息扔进messagesForTopic1中，即调用了每个<code>messagesForTopic1.add()</code>来向这个<code>Topic</code>中添加消息</li>
</ul>
<p>需要注意的是：</p>
<ul>
<li>messageFactory,而createBytesMessageToTopic()正是通过messageFactory.createBytesMessageToTopic(topic, body);来创建消息；</li>
<li>messageFactory.createBytesMessageToTopic(topic, body);仅仅只是将消息的body和header放入了一个defaultBytesMessage类型的消息中，并返回</li>
<li>每个producer对应一个messageStore<br><strong>总结：这一步将producer产生的数据放入消息列表messagesForTopic/Queue中</strong></li>
</ul>
<p>3.====================<strong>send</strong>数据====================</p>
<p>方式：</p>
<pre><code>producer.send(messagesForTopic1.get(i));
</code></pre><p>然后<code>send()</code>内部是：</p>
<pre><code>String topic = message.headers().getString(MessageHeader.TOPIC);
messageStore.putMessage(topic或queue, message);
</code></pre><p>需要注意的是：</p>
<ul>
<li>每个producer有一个messageStore，通过调用它的putMessage()来进行发送消息（将消息存储在硬盘中）</li>
<li>MessageStore类有一个成员变量<code>Map &lt;String, ArrayList&lt;Message&gt;&gt; messageBuckets</code>用来装消息，其中键是topic或queue的名字，值是new ArrayList&lt;&gt;(1024)(这里有一点疑问？)</li>
</ul>
<p>而putMessage：</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">putMessage</span><span class="params">(String bucket, Message message)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!messageBuckets.containsKey(bucket)) &#123;</div><div class="line">        messageBuckets.put(bucket, <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">1024</span>));</div><div class="line">    &#125;</div><div class="line">    ArrayList&lt;Message&gt; bucketList = messageBuckets.get(bucket);</div><div class="line">    bucketList.add(message);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><ul>
<li>如果本messageStore的messageBuckets没有本bucket(Topic或Queue)，则将这个buket加入到messageBuckets中,并使得其键值为new ArrayList&lt;&gt;(1024)</li>
<li>从本messageBuckets拿出(get)本bucket，放入消息列表bucketList中</li>
<li>再将本message加入消息列表bucketList</li>
</ul>
<p><strong>总结：将Topic或Queue放入MessageStore的messageBuckets中，将消息体放入bMessageStore的ucketList中</strong></p>
<h1 id="consumer操作">2. consumer操作</h1><ol>
<li>====================进行消息订阅<strong>attach</strong>====================</li>
</ol>
<p>操作：</p>
<pre><code>consumer1.attachQueue(queue1, Collections.singletonList(topic1));
</code></pre><p>备注：</p>
<ul>
<li>singletonList(T) 方法用于返回一个只包含指定对象的不可变列表</li>
</ul>
<p>然后DefaultPullConsumer的attachQueue如下：</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">attachQueue</span><span class="params">(String queueName, Collection&lt;String&gt; topics)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (queue != <span class="keyword">null</span> &amp;&amp; !queue.equals(queueName)) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClientOMSException(<span class="string">"You have alreadly attached to a queue "</span> + queue);</div><div class="line">    &#125;</div><div class="line">    queue = queueName;</div><div class="line">    buckets.add(queueName);</div><div class="line">    buckets.addAll(topics);</div><div class="line">    bucketList.clear();</div><div class="line">    bucketList.addAll(buckets);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><ul>
<li>buckets是DefaultPullConsumer的一个成员变量：private Set<string> buckets = new HashSet&lt;&gt;();</string></li>
<li>bucketList是DefaultPullConsumer的一个成员变量：private List<string> bucketList = new ArrayList&lt;&gt;();</string></li>
<li>将本queue以及其下的所有topic都加入到buckets中</li>
<li>将bukets都加入到bucketList中</li>
</ul>
<p>2.====================进行消息拉取<strong>pull</strong>====================</p>
<p>操作：</p>
<p>Message message = consumer1.poll();</p>
<p>其中，poll为：</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Message <span class="title">poll</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (buckets.size() == <span class="number">0</span> || queue == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//use Round Robin</span></div><div class="line">    <span class="keyword">int</span> checkNum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (++checkNum &lt;= bucketList.size()) &#123;</div><div class="line">        String bucket = bucketList.get((++lastIndex) % (bucketList.size()));</div><div class="line">        Message message = messageStore.pullMessage(queue, bucket);</div><div class="line">        <span class="keyword">if</span> (message != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> message;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><ul>
<li>遍历每个bucketList（bucketList装的是本consumer订阅的topics以及对应的queue）</li>
<li>对遍历到的每个bucket，从messageStore拉取消息</li>
</ul>
<p>而 messageStore.pullMessage为：</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Message <span class="title">pullMessage</span><span class="params">(String queue, String bucket)</span> </span>&#123;</div><div class="line">    ArrayList&lt;Message&gt; bucketList = messageBuckets.get(bucket);</div><div class="line">    <span class="keyword">if</span> (bucketList == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    HashMap&lt;String, Integer&gt; offsetMap = queueOffsets.get(queue);</div><div class="line">    <span class="keyword">if</span> (offsetMap == <span class="keyword">null</span>) &#123;</div><div class="line">        offsetMap = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        queueOffsets.put(queue, offsetMap);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> offset = offsetMap.getOrDefault(bucket, <span class="number">0</span>);</div><div class="line">    <span class="keyword">if</span> (offset &gt;= bucketList.size()) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    Message message = bucketList.get(offset);</div><div class="line">    offsetMap.put(bucket, ++offset);</div><div class="line">    <span class="keyword">return</span> message;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><ul>
<li>先从messageStore的messageBuckets中get到本bucket的bucketList</li>
<li>将这个consumer绑定的queue放入本messageStore的queueOffsets中</li>
<li>然后我就有点疑惑了？？</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/child/2017/05/17/RocketMQ简介/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jiayi797">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jiayi797的专栏">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/17/RocketMQ简介/" itemprop="url">RocketMQ简介</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-17T10:49:03+08:00">
                2017-05-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/中间件/" itemprop="url" rel="index">
                    <span itemprop="name">中间件</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>RocketMQ:分布式开放消息系统</p>
<h1 id="消息中间件需要解决哪些问题？">1. 消息中间件需要解决哪些问题？</h1><h2 id="发布订阅（Publish-Subscribe）">1.1. 发布订阅（Publish/Subscribe）</h2><p>发布订阅是消息中间件的最基本功能，也是相对于传统RPC通信而言。在此不再详述。</p>
<h2 id="消息优先级（Message-Priority）">1.2. 消息优先级（Message Priority）</h2><p>两种方式：</p>
<ol>
<li>严格优先级，例如0-65535。开销大，精准，但可能没有必要。</li>
<li>档位优先级。高、中、低，或其他。每个优先级可以用不同的topic表示，发消息时，指定不同的topic来表示优先级。精确性低。</li>
</ol>
<h2 id="消息有序性（Message-Order）">1.3. 消息有序性（Message Order）</h2><ol>
<li>一个订单的发出的消息顺序不能变</li>
<li>订单之间是可以并行消费</li>
</ol>
<h2 id="消息过滤（Message-Filter）">1.4. 消息过滤（Message Filter）</h2><h3 id="消息协商器（Broker端）消息过滤">1.4.1. 消息协商器（Broker端）消息过滤</h3><p>在Broker中，按照Consumer的要求做过滤</p>
<ol>
<li>优点是减少了对于Consumer无用消息的网络传输。</li>
<li>缺点是增加了Broker的负担，实现相对复杂。</li>
</ol>
<p>淘宝Notify支持多种过滤方式：<br>包含直接按照消息类型过滤，灵活的语法表达式过滤，几乎可以满足最苛刻的过滤需求。</p>
<p>淘宝RocketMQ支持按照简单的Message Tag过滤，也支持按照Message Header、body进行过滤。</p>
<p>CORBA Notification规范中也支持灵活的语法表达式过滤。</p>
<h3 id="Consumer端消息过滤">1.4.2. Consumer端消息过滤</h3><p>这种过滤方式可由应用完全自定义实现，但是缺点是很多无用的消息要传输到Consumer端。</p>
<h3 id="消息持久化（Message-Persistence）">1.4.3. 消息持久化（Message Persistence）</h3><p>持久化（Persistence）：即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的主要应用是将内存中的对象存储在数据库中，或者存储在磁盘文件中、XML数据文件中等等。</p>
<p>消息中间件通常采用的几种持久化方式：</p>
<ol>
<li>持久化到数据库，例如Mysql。</li>
<li>持久化到KV存储，例如levelDB、伯克利DB等KV存储系统。</li>
<li>文件记录形式持久化，例如Kafka，RocketMQ</li>
<li>对内存数据做一个持久化镜像，例如beanstalkd，VisiNotify</li>
<li>(1)、(2)、(3)三种持久化方式都具有将内存队列Buffer进行扩展的能力，(4)只是一个内存的镜像，作用是当Broker挂掉重启后仍然能将之前内存的数据恢复出来。</li>
</ol>
<p>JMS与CORBA Notification规范没有明确说明如何持久化，但是持久化部分的性能直接决定了整个消息中间件的性能。</p>
<p>RocketMQ充分利用Linux文件系统内存cache来提高性能。</p>
<h3 id="消息可靠性（Message-Reliablity）">1.4.4. 消息可靠性（Message Reliablity）</h3><p>响消息可靠性的几种情况：</p>
<ol>
<li>Broker正常关闭</li>
<li>Broker异常Crash</li>
<li>OS Crash</li>
<li>机器掉电，但是能立即恢复供电情况。</li>
<li>机器无法开机（可能是cpu、主板、内存等关键设备损坏）</li>
<li>磁盘设备损坏</li>
</ol>
<p>(1)、(2)、(3)、(4)四种情况都属于硬件资源可立即恢复情况，RocketMQ在这四种情况下能保证消息不丢，或者丢失少量数据（依赖刷盘方式是同步还是异步）。</p>
<p>(5)、(6)属于单点故障，且无法恢复，一旦发生，在此单点上的消息全部丢失。RocketMQ在这两种情况下，通过异步复制，可保证99%的消息不丢，但是仍然会有极少量的消息可能丢失。通过同步双写技术可以完全避免单点，同步双写势必会影响性能，适合对消息可靠性要求极高的场合，例如与Money相关的应用。</p>
<p>RocketMQ从3.0版本开始支持同步双写。</p>
<h1 id="参考文献">2. 参考文献</h1><ol>
<li><a href="http://jm.taobao.org/2017/01/12/rocketmq-quick-start-in-10-minutes/" target="_blank" rel="external">十分钟入门RocketMQ</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/child/2017/05/16/转化率预估资料/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jiayi797">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jiayi797的专栏">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/16/转化率预估资料/" itemprop="url">转化率预估资料</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-16T13:36:42+08:00">
                2017-05-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/机器学习/" itemprop="url" rel="index">
                    <span itemprop="name">机器学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li><a href="http://www.flickering.cn/category/ads/" target="_blank" rel="external">火光摇曳</a></li>
<li><a href="http://tech.meituan.com/tag/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0" target="_blank" rel="external">美团点评技术团队</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/child/2017/05/14/阿里中间件初赛-李健胜解决方案/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jiayi797">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jiayi797的专栏">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/14/阿里中间件初赛-李健胜解决方案/" itemprop="url">阿里中间件初赛-李健胜解决方案</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-14T14:19:14+08:00">
                2017-05-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/中间件/" itemprop="url" rel="index">
                    <span itemprop="name">中间件</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="参考资料">1. 参考资料</h1><ol>
<li><a href="http://blog.jesonlee.me/19/" target="_blank" rel="external">李健胜，阿里中间件大赛初赛解题思路</a></li>
<li><a href="https://github.com/Jesonlee1997/open-message" target="_blank" rel="external">1对应的代码</a></li>
</ol>
<h1 id="题目要求">2. 题目要求</h1><p><strong>主角</strong>：消息中间件<br><strong>目的</strong>：实现消息中间件的推拉模式。即生产者制造消息，使用消息队列储存消息，消费者从消息队列拉取消息。<br><strong>要点</strong>：持久化的消息队列</p>
<h2 id="Producer需要实现">2.1. Producer需要实现</h2><ul>
<li><p>创建一个消息，给消息指定Topic（可以由多个Consumer消费）<br><code>BytesMessage createBytesMessageToTopic(String topic, byte[] body);</code></p>
</li>
<li><p>创建一个消息，给消息指定Queue（只能由一个Consumer消费）<br><code>BytesMessage createBytesMessageToQueue(String queue, byte[] body);</code></p>
</li>
<li><p>发送消息，message中应当包含目的地（Queue，Topic只能选其一），对于发往同一个Topic和Queue的message顺序要保持一致。<br><code>void send(Message message);</code></p>
</li>
</ul>
<h2 id="PullConsumer需要实现">2.2. PullConsumer需要实现</h2><ul>
<li>绑定到一个Queue，并订阅topics，即从这些topic和Queue读取消息。<br><code>void attachQueue(String queueName, Collection topics);</code></li>
<li>规范要求实现阻塞的接口，由properties来设置阻塞时间，但本赛题不需要用到该特性， 请实现一个非阻塞(也即阻塞时间为0)调用, 也即没有消息则返回null<br><code>Message poll();</code></li>
</ul>
<h2 id="测试流程">2.3. 测试流程</h2><ul>
<li>创建<code>Topic</code>，创建<code>Queue</code> 创建<code>Producer</code>，多个<code>Producer</code>创建指定<code>Topic</code>和指定<code>Queue</code>的Message，调用<code>send</code>方法发送</li>
<li>将数据保存到磁盘中</li>
<li><code>kill Producer</code>进程，另取进程进行消费<br>创建<code>PullConsumer</code>线程进行消费，一个<code>Consumer</code>对应一个线程，<code>Consumer</code>连接到一个<code>Queue</code>，可以订阅多个<code>Topic</code>。 </li>
<li>不断的调用poll拉取队列的消息，直到完全读完，读取的消息要相对有序。</li>
</ul>
<p>补充：<br>一个<code>Producer</code>对应一个线程，线程先创建对应的Message，再将Message 发送到对应的队列或<code>topic</code>中，实际情况中会有多个<code>Producer</code>。 一个<code>Consumer</code>对应一个<code>Queue</code>，多个<code>Consumer</code>同时从队列中拉取消息。</p>
<h2 id="技术难点">2.4. 技术难点</h2><ol>
<li>大量的消息产生 </li>
<li>并发写 </li>
<li>并发读 </li>
<li>序列化&amp;反序列化</li>
</ol>
<ol>
<li>大量消息<br>首先根据题目描述，Produce过程会运行5分钟，这个过程中多线程进行消息的发送，然后再考虑将消息持久化。我用自己的程序测试了一下，（不是典型值，只作为参考，在文章的最后我会贴上我的一系列测试结果），多线程发送一亿条消息的时间为27s，而这一亿条消息占据磁盘的大小为将近4G！可以想象在5分钟内会产生多少的消息量，如何将消息存储，如何读取消息都将成为一个非常棘手的问题。</li>
<li>并发写<br>并发写的问题也非常显而易见。我们一般情况下为了实现消息队列会选择使用一个List或数组来存储Producer产生的消息。这就引发了一个问题，怎样保证向同一个队列中发送消息的线程不产生竞争条件。</li>
<li>并发读<br>最麻烦的一个部分，每个线程都需要读取磁盘上的消息内容，每个线程读取的位置又不尽相同，消息数又那么多不可能全部加载到内存中，这个问题曾让我伤透了脑筋，直到我遇到了mmap(后面详细介绍)。</li>
<li>序列化和反序列化的问题<br>大赛刚开始时，我写了一个使用Java自身序列化来实现持久化的版本，这个版本的缺点非常显而易见，就是慢，而这个缺点又是极为致命的。我意识到我需要自己定制一个序列化协议来将消息转化为字节数组，再通过其他方式（如FileOutputStream）写入磁盘，同时再使用这个协议将其从磁盘中恢复。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/child/2017/05/13/OpenMessaging源码阅读1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jiayi797">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jiayi797的专栏">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/13/OpenMessaging源码阅读1/" itemprop="url">OpenMessaging源码阅读1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-13T15:29:31+08:00">
                2017-05-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/中间件/" itemprop="url" rel="index">
                    <span itemprop="name">中间件</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>考虑到自己记性实在太差，还是好好记笔记吧。<br>本节主要看以下几个接口：</p>
<ul>
<li>Meaasage</li>
<li>Producer</li>
<li>PullConsumer</li>
</ul>
<h1 id="Message-java">1. Message.java</h1><p>Message接口是所有OMS消息中的根接口。最常用的消息就是BytesMessage。</p>
<p><strong>标准Message</strong><br>大多消息导向（message-oriented）的中间件（MOM）产品更趋向于将消息认做轻实体，这个轻实体包含一个header和一个body：</p>
<ul>
<li>header:包含用来路由和识别的信息域；</li>
<li>body:包含将会被发送的应用信息；</li>
</ul>
<p><strong>本Message</strong><br>本消息是一个仅包含与具体消息对象相关的property(财产)的轻量级实体。主要包含以下几个方面：</p>
<ul>
<li>Header:所有消息都有同样的header域。header域的值用来给客户端(clients)和提供商（providers）唯一标示消息，以及路由消息。</li>
<li>Properties(财产，特性)：每个消息都有一个消息自有的部分，这部分用来提供“应用定义(application-defined)”的property(财产)值。这一部分为支持“应用定义”消息的过滤提供了很有效的机制。</li>
</ul>
<p><strong>源码解读</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Message</span> </span>&#123;</div><div class="line">     <span class="comment">/*headers()返回Message对象的header域，返回值类型是keyValue。*/</span></div><div class="line">    <span class="function">KeyValue <span class="title">headers</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/*properties()返回消息自有的property域。返回值类型是keyValue。*/</span></div><div class="line">    <span class="function">KeyValue <span class="title">properties</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">     <span class="comment">/*putHeaders(String key, int value)将输入(String key, int value)全部传入header*/</span></div><div class="line">    <span class="comment">/*参数key:headers的关键字*/</span></div><div class="line">    <span class="comment">/*参数values:与key对应的值*/</span></div><div class="line">    <span class="function">Message <span class="title">putHeaders</span><span class="params">(String key, <span class="keyword">int</span> value)</span></span>;</div><div class="line">    <span class="function">Message <span class="title">putHeaders</span><span class="params">(String key, <span class="keyword">long</span> value)</span></span>;</div><div class="line">    <span class="function">Message <span class="title">putHeaders</span><span class="params">(String key, <span class="keyword">double</span> value)</span></span>;</div><div class="line">    <span class="function">Message <span class="title">putHeaders</span><span class="params">(String key, String value)</span></span>;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/*将key和value全部存入header*/</span></div><div class="line">    <span class="comment">/*参数key:headers的关键字*/</span></div><div class="line">    <span class="comment">/*参数values:与key对应的值*/</span></div><div class="line">    <span class="function">Message <span class="title">putProperties</span><span class="params">(String key, <span class="keyword">int</span> value)</span></span>;</div><div class="line">    <span class="function">Message <span class="title">putProperties</span><span class="params">(String key, <span class="keyword">long</span> value)</span></span>;</div><div class="line">    <span class="function">Message <span class="title">putProperties</span><span class="params">(String key, <span class="keyword">double</span> value)</span></span>;</div><div class="line">    <span class="function">Message <span class="title">putProperties</span><span class="params">(String key, String value)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Producer-java">2. Producer.java</h1><p>Producer是一个用来发送消息的简单对象，它是<code>MessagingAccessPoint</code>的一个具体实现。<br><strong>创建Producer对象</strong>：<br><code>Producer</code>的具体实例是通过<code>MessagingAccessPoint#createProducer()</code>方法创建的。<br>这个方法提供了多种定点发送消息的方式，其中，目的地可以是<code>MessageHeader#TOPIC</code>或<code>MessageHeader#QUEUE</code>。</p>
<p><strong>Producer#send(Message)</strong><br>同步定点发送消息方法。<br>当发送请求完成时，线程将会关闭(block)。</p>
<p><strong>Producer#sendAsync(Message)</strong><br>异步定点发送消息方法。<br>当发送请求完成时，线程不会很快关闭，而会立即返回一个<code>Promise</code>作为发送结果。</p>
<p><strong>Producer#sendOneway(Message)</strong><br>one way定点发送消息方法。<br>当发送请求完成时，线程不会很快关闭，而是立即返回。线程发起者不关心发送结果，同时server也对返回值没有责任。</p>
<p><strong>源码解读</strong></p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">MessageFactory</span>, <span class="title">ServiceLifecycle</span> </span>&#123;</div><div class="line">     <span class="comment">/*返回本实例的properties*/</span></div><div class="line">     <span class="comment">/*返回值的变化不会反应在Producer本身上，并且这个变化可以用ResourceManager#setProducerProperties(String, KeyValue)来修改。（Changes to the return &#123;@code KeyValue&#125; are not reflected in physical &#123;@code Producer&#125;,and use &#123;@link ResourceManager#setProducerProperties(String, KeyValue)&#125; to modify.）*/</span></div><div class="line">    <span class="function">KeyValue <span class="title">properties</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/*同步定点发送message方法*/</span></div><div class="line">    <span class="comment">/*发送目的地应该预置在MessageHeader中。当然其它类型的header域也可以*/</span></div><div class="line">    <span class="comment">/*异常OMSRuntimeException：当由于内部原因发送失败时*/</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(Message message)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(Message message, KeyValue properties)</span></span>;<span class="comment">/*properties是属性值*/</span></div><div class="line"></div><div class="line">    <span class="comment">/*异步定点发送消息方法*/</span></div><div class="line">    <span class="comment">/*返回值是Promise类型。同时，登记过的PromiseListener将会被通知*/</span></div><div class="line">    <span class="function">Promise&lt;Void&gt; <span class="title">sendAsync</span><span class="params">(Message message)</span></span>;</div><div class="line">    <span class="function">Promise&lt;Void&gt; <span class="title">sendAsync</span><span class="params">(Message message, KeyValue properties)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/*oneway定点发送消息方法*/</span></div><div class="line">    <span class="comment">/*无返回值，也没有thrown。因为oneway发送不在乎发送结果*/</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendOneway</span><span class="params">(Message message)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendOneway</span><span class="params">(Message message, KeyValue properties)</span></span>;</div><div class="line"></div><div class="line">    <span class="function">BatchToPartition <span class="title">createBatchToPartition</span><span class="params">(String partitionName)</span></span>;</div><div class="line"></div><div class="line">    <span class="function">BatchToPartition <span class="title">createBatchToPartition</span><span class="params">(String partitionName, KeyValue properties)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h1 id="PullConsumer-java">3. PullConsumer.java</h1><p><code>PullConsumer</code>对象能从特定的队列中poll消息。而且支持通过‘ack’方式提交消费结果。</p>
<p><strong>源码分析</strong></p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PullConsumer</span> </span>&#123;</div><div class="line">    <span class="comment">/*返回本PullConsumer实例的properties*/</span></div><div class="line">    <span class="comment">/* Changes to the return &#123;@code KeyValue&#125; are not reflected in physical &#123;@code PullConsumer&#125;,and use &#123;@link ResourceManager#setConsumerProperties(String, KeyValue)&#125; to modify.*/</span></div><div class="line">    <span class="function">KeyValue <span class="title">properties</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 规范要求实现阻塞的接口，由properties来设置阻塞时间，但本赛题不需要用到该特性，请实现一个非阻塞(也即阻塞时间为0)调用, 也即没有消息则返回null</div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="comment">/*抽取下一条为本pullconsumer生产的消息*/</span></div><div class="line">    <span class="comment">/*除非一条消息被产生了，或者本pullConsumer被关闭了，本调用会一直block*/</span></div><div class="line">    <span class="comment">/*返回为本PullConsumer生产的下一条消息；当本PullConsumer被同时关闭时返回null*/</span></div><div class="line">    <span class="comment">/*当本PullConsumer由于一些内部原因而抽取下一条消息失败时，throw OMSRuntimeException*/</span></div><div class="line">    <span class="function">Message <span class="title">poll</span><span class="params">()</span></span>;</div><div class="line">    <span class="function">Message <span class="title">poll</span><span class="params">(<span class="keyword">final</span> KeyValue properties)</span></span>;<span class="comment">/*properties是一些参数*/</span></div><div class="line"></div><div class="line">    <span class="comment">/*用消息id回确认指定的已消费的消息*/</span></div><div class="line">    <span class="comment">/*若某消息已被接收，但还未被回确认，那它可能会被重新投递*/</span></div><div class="line">    <span class="comment">/*有OMSRuntimeException*/</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ack</span><span class="params">(String messageId)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ack</span><span class="params">(String messageId, <span class="keyword">final</span> KeyValue properties)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/* 绑定到一个Queue，并订阅topics，即从这些topic读取消息*/</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">attachQueue</span><span class="params">(String queueName, Collection&lt;String&gt; topics)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/child/2017/05/12/多线程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jiayi797">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jiayi797的专栏">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/12/多线程/" itemprop="url">多线程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-12T13:51:34+08:00">
                2017-05-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>线程(thread)</strong>：每个任务称为一个线程<br><strong>线程和进程区别</strong>：</p>
<ol>
<li>每个进程有自己独立的变量，而线程则共享数据。</li>
<li>线程是进程的执行单元</li>
<li>线程是进程的组成部分。一个进程可以有多个线程，一个线程必须有一个父进程。</li>
<li>线程可以拥有自己的堆栈、自己的程序计数器和自己的局部变量，但不拥有系统资源（与父进程其它线程共享该进程则资源）</li>
</ol>
<h1 id="线程的创建">1. 线程的创建</h1><p>有以下两种方法：</p>
<ol>
<li>通过继承Thread来创建线程</li>
<li>通过实现Runnable接口创建线程</li>
</ol>
<h2 id="通过继承Thread来创建线程">1.1. 通过继承Thread来创建线程</h2><p>要点：通过继承<code>Thread</code>类创建并启动多线程<br>步骤：</p>
<ol>
<li>定义Thread类的子类，并重写<code>run()</code>方法（线程执行体）</li>
<li>创建<code>Thread</code>子类的实例(创建线程对象)</li>
<li><p>调用<code>start()</code>（启用该线程）</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"run\t"</span>+getName()+<span class="string">"\t"</span>);<span class="comment">//getName()返回thread name</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        <span class="keyword">new</span> FirstThread().start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>以上代码输出：</p>
<pre><code>run  Thread-0
</code></pre><p><strong>一个有意思的现象</strong></p>
<p>运行如下代码时：</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"run\t"</span>+getName()+<span class="string">"\t"</span>);<span class="comment">//getName()返回thread name</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        <span class="comment">//调用currentThread()获取当前线程</span></div><div class="line">        System.out.println(<span class="string">"currentThread : "</span>+Thread.currentThread().getName());</div><div class="line">        <span class="keyword">new</span> FirstThread().start();</div><div class="line">        System.out.println(<span class="string">"currentThread : "</span>+Thread.currentThread().getName());</div><div class="line">        <span class="keyword">new</span> FirstThread().start();</div><div class="line">        System.out.println(<span class="string">"currentThread : "</span>+Thread.currentThread().getName());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><p>按照以前的理解，应该是：</p>
<pre><code>currentThread : main
run Thread-0 
currentThread : main 
run Thread-1    
currentThread : main
</code></pre><p>实际输出：（也有可能是其它顺序）</p>
<pre><code>currentThread : main
currentThread : main
run Thread-0    
run Thread-1    
currentThread : main
</code></pre><p>新发现：其实<code>start</code>一个线程的时候，<code>main</code>线程在继续运行。<code>main</code>线程不会等<code>start</code>完事儿之后再运行下一句！</p>
<h2 id="通过实现Runnable接口创建线程">1.2. 通过实现Runnable接口创建线程</h2><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"run\t"</span>+Thread.currentThread().getName()+<span class="string">"\t"</span>);<span class="comment">//getName()返回thread name</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        SecondThread st = <span class="keyword">new</span> SecondThread();</div><div class="line">        <span class="keyword">new</span> Thread(st,<span class="string">"new_thread_1"</span>).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><p>区别：<br>需要通过<code>Thread.currentThread().getName()</code>来获取getName()<br>main不同</p>
<p><strong>多线程共享变量</strong></p>
<p>以下是一个多线程共享变量<code>i</code>的情况：</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">while</span>(i&lt;<span class="number">5</span>)&#123;</div><div class="line">            System.out.println(<span class="string">"run\t"</span>+Thread.currentThread().getName()+<span class="string">"\t"</span>+i);<span class="comment">//getName()返回thread name</span></div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        SecondThread st = <span class="keyword">new</span> SecondThread();</div><div class="line">        <span class="keyword">new</span> Thread(st,<span class="string">"thread_name_1"</span>).start();</div><div class="line">        <span class="keyword">new</span> Thread(st,<span class="string">"thread_name_2"</span>).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><p>两次运行结果：</p>
<pre><code>run thread_name_1    0
run thread_name_1    1
run thread_name_1    2
run thread_name_1    3
run thread_name_2    3
run thread_name_1    4

run thread_name_1    0
run thread_name_2    0
run thread_name_1    1
run thread_name_2    2
run thread_name_1    3
run thread_name_2    4
</code></pre><p><strong>发现</strong>：</p>
<ol>
<li>两个线程共有变量<code>i</code></li>
<li>线程间抢占资源</li>
</ol>
<h2 id="使用Callable和Future创建线程">1.3. 使用Callable和Future创建线程</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/child/2017/05/11/OpenMessaging简介/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jiayi797">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jiayi797的专栏">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/11/OpenMessaging简介/" itemprop="url">OpenMessaging简介</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-11T22:58:55+08:00">
                2017-05-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/中间件/" itemprop="url" rel="index">
                    <span itemprop="name">中间件</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>OpenMessaging的主要关系如下图所示：</p>
<p><img src="http://om1bxijvl.bkt.clouddn.com/2017-05-12-16-24-52.png" alt=""> </p>
<p>其中，各部分的内容和关系见下述。</p>
<h1 id="Namespace">1. Namespace</h1><p>Namespace就像一个cgroup namespace,是用来创建一个有安全保障的独立的空间。每个namespace都有自己的producer,consumer,topic,queue等等。OpenMessaging用 ​<strong>MessagingAccessPoint</strong>​（消息访问点）来访问/读/写指定namespace的<strong>​资源</strong>​。</p>
<h1 id="Producer">2. Producer</h1><p>Openmessaging定义了两种Producer:<strong>​Producer</strong>​和 <strong>​SequenceProducer</strong>​</p>
<ul>
<li><strong>​Producer</strong>​:提供各种send方法，用来将一个消息送往指定的destination,<strong>Topic</strong>或者<strong>Queue</strong>。支持三种方式：同步、异步、单向(oneway)</li>
<li><strong>SequenceProducer</strong>:重点在于速度，且支持批处理。能发送多个数据并一次提交。</li>
</ul>
<h1 id="Consumer">3. Consumer</h1><p>Openmessaging定义了两种Consumer::<strong>PullConsumer</strong>、<strong>PushConsumer</strong>和<strong>StreamConsumer</strong>.每种Consumer仅支持来自于<strong>Queue</strong>的consume消息。</p>
<ul>
<li><strong>PullConsumer</strong>:从指定队列中pulls消息。支持“submit the consume<br>result by acknowledgement at any time”。每个PullConsumer仅能从固定的队列中pull消息。</li>
<li><strong>PushConsumer</strong>:可从多个队列中接收消息，且这个消息是由MOM server push上去的。PushConsumer可依附于多个独立的、具有不同的MessageListener的队列，并且可以随时通过<strong>ReceivedMessageContext</strong>提交结果。</li>
<li><strong>StreamingConsumer</strong>:一种崭新的consumer类型，是一种面向流的consumer,面向留信息的一体化信息系统。</li>
</ul>
<h1 id="Topic-Queue-and-Routing">4. Topic Queue and Routing</h1><p>这三个概念非常相近。虽然Topic和Queue有不同的用途，但它们总让人迷惑。</p>
<h2 id="Topic">4.1. Topic</h2><p>Topic是原始信息的载体，用来holding消息。消息的分发方式和有序性是没有定义的。</p>
<h2 id="Routing">4.2. Routing</h2><p>Topic中的消息是原始的，是待处理的，一般不易引起consumers的注意。总之，Topic中的数据是producer-orented（导向）的，而不是consumer-oriented。</p>
<p>因此Routing负责加工Topic中的原始消息，并routing去Queue中。每个Routing有一个<strong>操作管线（operator pipeline）</strong>，包含着一系列的操作。消息会通过操作管线从Topic流向Queue。</p>
<p><strong>操作（operator）</strong>是用来处理在Routing流通的消息的。有很多操作，例如expression operator, deduplicator operator, joiner operator, filter operator, rpc<br>operator等等。</p>
<h2 id="Queue-队列">4.3. Queue(队列)</h2><p>现在消息已经被routed到Queue中了。现在消息就可以被consumers使用了。</p>
<p>需要注意的是，一个Queue可能会被分为几部分，消息可能通过MessageHeader#SHARDING_KEY被routed到某个特殊的部分中。</p>
<h2 id="Topic与Queue比较">4.4. Topic与Queue比较</h2><ul>
<li>都是消息的载体</li>
<li>Topic是preducer-oriented的，而Queue是consumer-oriented的</li>
<li>Topic中的消息来自于Producer,而Queue中的消息来自于Topic或者Producer</li>
<li>Queue包含几个部分，而Topic形状未定义</li>
<li>在大多数情况下，Queue是Topic的一个子集</li>
<li>Queue的创建、销毁都很容易，且与producer无关</li>
</ul>
<h1 id="参考文献">5. 参考文献</h1><ol>
<li><a href="openmessaging.github.io">原始文档</a></li>
<li><a href="https://github.com/pugwoo/c/blob/master/linux_ipc/shm/shmqueue.h" target="_blank" rel="external">pugwoo用c写的</a></li>
<li><a href="https://github.com/openmessaging/openmessaging" target="_blank" rel="external">原始文档扒的API</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="jiayi797" />
          <p class="site-author-name" itemprop="name">jiayi797</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">51</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">17</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jiayi797</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"displayMath":[["$$","$$"]]}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
